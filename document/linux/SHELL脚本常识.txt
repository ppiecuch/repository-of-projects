2008112314137
     
    
Shell脚本常识--（条件判断）
文章整理: 文章来源: 网络 
一、if 条件语句　 
格式： 
if 条件表达式 
then #当条件为真时执行以下语句 
命令列表 
else #为假时执行以下语句 
命令列表 
fi 
if　语句也可以嵌套使用 
if 条件表达式1 
then 
if 条件表达式2 
then 
命令列表 
else 
if 条件表达式3 
then 
命令列表 
else 
命令列表 
fi 
fi 
else 
命令列表 
fi 
你可以进行多层嵌套　一个if语句一定要跟一个fi　表示该层条件结束　　否则会造成语法错误 
结合前面讲的　举例如下： 
这里先讲一个条件语句中用到的命令test　表示测试test后面的条件是否为真 
if test -f "$1" 
then 
lpr $1 
else 
if test -d "$1" 
then 
cd $1 
lpr $1 
else 
echo "$1不是文件或目录" 
fi 
fi 
以上的例子还可以改成如下所示 
if test -f "$1" 
then 
lpr $1 
elif test -d "$1" #elif　同else if 
then 
(cd $1;lpr $1) 
else 
echo "$1不是文件或目录" 
fi 
以上的例子不知您是否看懂是什么意思吗？ 
假如我们现在将这个例子保存为prfile 
chmod +x prfile 
执行刚才的程序 
./prfile aaa 
这个例子是检查你的输入的参数是否是一个文件　如果是就打印　如果是一个目录　先转目录再打印　如果即不是文件也不是目录给出提示 
二、多重条件测试语句case 
格式： 
case 字串　in 
模式) 命令列表;; 
模式) 命令列表;; 
.... 
esac 
多重条件语句是以case 开始以esac结束　中间可以有多个条件列表　功能是测试字串和和里面的模式有没有匹配的,有就执行里面的命令列表　模式也可以是*号　表示任意字串，每个模式里面的最后要心;;双引号结束，否则会发生语法错误。 
现举例如下： 
case $1 in 
*.c) 
cc $1 
;; 
*.txt) 
lpr $1 
;; 
*) 
echo "未知的类型" 
esac 
假如将以上内容保存在文件abc中 
chmod +x abc 
执行　./abc a.c 　 将会对文件a.c进行编译 
执行 ./abc readme.txt　将会把文件通过打印机 
假如我将以上内容改一下，你是否会知道它的执行结果？ 
case $1 in 
*) 
cc $1 
;; 
*.txt) 
lpr $1 
;; 
*.c) 
echo "未知的类型" 
esac  
[]     
    
Shell脚本常识--（循环控制）
文章整理: 文章来源: 网络 
一. while 循环 
while 命令格式 
while 条件表 
do 
命令表 
done 
执行过程 
shell首先执行条件表,如果条件表的最后一条语句的退出状态为零,则执行盾环体内的命令 
表,执行完后,再检查条件表,如果退出状态为零将继续执行,如此循环往复直到条件表的 
最后一条语句的退出状态非零. 退出状态为零就是条件为真True. 
举例说明 假如shell文件的内容如下: 
Sum=0 
i=0 
while true #true是系统的关键词 表示真 
do 
i=`expr $i + 1` 
Sum=`expr $Sum + $i` 
if [ $i = "100" ] 
then 
break; 
fi 
done 
echo $i $Sum 
最后这个程序显示的是 100 5050 
这个程序的运算就是将1到100加起来 
下面将这个程序再改动一下 
Sum=0 
i=0 
while [ $i != "100" ] 
do 
i=`expr $i + 1` 
Sum=`expr $Sum + $i` 
done 
echo $i $Sum 
改动后的程序运算结果和上面是一样 但程序比上面的要简练 
在这个循环中还可以以until做为测试条件 它正好与while测试的条件相反,也就是当条件为假时将继续执行循环体内的语句,否则就退出循环体,下面还用这个例子. 
Sum=0 
i=0 
until [ $i = "100" ] 
do 
i=`expr $i + 1` 
Sum=`expr $Sum + $i` 
done 
echo $i $Sum 
当i不等于100时循环 就是当条件为假时循环,否则就退出,而第一个例子是当i不等于100 
时循环,也就是测试条件为真时循环. 
二.for 循环 
命令格式: 
for 变量 in 名字列表 
do 
命令列表 
done 
这里的名字列表是一个由空格分隔的字符串列表,shell在执行for循环时每次依次从名字表 
中取出一个字符串赋给循环变量作为变量的值. 
在写for语句时,也可以省略in 名字列表部分,这表示用当前的位置参数来代替这时的名 
字列表. 
下面举个例子 
比如在你的电脑中有两个目录,一个是aa,一个是bb在这两个目录中有5个相同的文件,但其 
中一个目录中的一个或多个文件刚刚修改过,现在我忘记刚才改的是那几个文件 了,那么我靠梢员冉弦幌抡饬礁瞿柯嫉奈募就知道?程序如下: 
for File in a1 a2 a3 a4 a5 
do 
diff aa/$File bb/$File 
done 
下面再举一个不带名字列表的例子 
for File 
do 
echo $Filw 
done 
文件内容保存在a.sh中 并可执行 
我们在执行这个shell程序时命令行如下: 
a.sh a1 a2 a3 a4 a5 
执行结果如下: 
a1 
a2 
a3 
a4 
a5 
大家从这个例子中可以看到命令行的参数被逐一读入一次 
三.循环控制语句 
break 命令不执行当前循环体内break下面的语句从当前循环退出. 
continue 命令是程序在本循体内忽略下面的语句,从循环头开始执行. 
一,命令组合:圆括号和花括号 
shell中有两种方法将命令组合在一起:圆括号和花括号.圆括号使shell创建一个子shell 
来读取并执行括起来的名命令.左括号和右括号不论出现在命令行中的什么位置,shell都会 
认为它们具有特殊的组合意义的.只有用双引号将它们括起来引用,才表示圆括号或花括号 
的原义.例如: 
echo a(b) 
将出现语法上的错误,要想输出a(b)字符串 只能括起来 
echo "a(b)" 
或echo a"("b"" 
这样才能被shell正确解释. 
利用组合命令有什么作用呢? 
一,用圆括号组合命令 
圆括号的组合命令可以创建子进程运行组合程序,建立子进程的功能是很有用的,因为 
子shell在组合命令中的种种操作都不会影响到当前shell的各变量的值. 
例如: 
子进程在执行组合命令时改变了工作目录,并在新的工作目录下执行一系例命令,执行 
完后它可以不必返回原工作目录,因为子进程工作目录的改变不会影响到当前工作目录. 
创建子进程后将当前的环境也同样传给子shell,当前shell中用export输出到环境中的 
各变量在子shell中同样有效. 
花括号也可以将命令组合在一起.左 右花括号只有作为一条命令的第一个字出现时, 
shell才它们含有特殊含义. 
与圆括号不同的是花括号并不创建子shell,只是由当前的shell来读取并执行括起来的 
命令.有时用户希望使用一组命令的顺序输出作为另一组命令的输入,此时用花括号是很方 
便的. 
不论是用圆括号不是花括号,退出状态都是等于最后一条括起来的命令的退出状态. 
二,可以在当前shell中执行的命令 
用户在使用shell时一定要了解那些是可以在当前shell中执行的命令 那些不可以 
可以在当前shell中执行的命令有: 
break case cd continue 
echo eval exec exit 
export for if read 
readonly return set shift 
test times trap umask 
until wait while 
: {} 
[]     
    
Solaris SysAdmin Commands
文章整理: 文章来源: 网络 
Debugging
truss executable
/* Trace doing of given command ( useful debugging ) */
truss -f -p <pid of a shell>
/* Using multiple windows, this can be used to trace setuid/setgid programs */
Arp, ethernet trouble shooting
arp -a .
/* Shows the ethernet address arp table */
arp -d myhost
/* Delete a stale ethernet entry for host myhost */
Disk Commands
du -k .
/* Reports disk space used in Kilobytes */
du -sk .
/* Reports only total disk space used in Kilobytes */
du -sk *|sort -k1,1n
/* Reports total disk space used in Kilobytes in present directory */
du -ad /var | sort -nr
/* Tells you how big the /var files are in reverse order */
fdformat -d -U
/* Format diskette */
/usr/bin/iostat -E
/* Command to display drives statistics */
/bin/mount -F hsfs -o ro /dev/sr0 /cdrom
/* Mount an ISO 9660 CDROM */
newfs -Nv /dev/rdsk/c0t0d0s1
/* To view the superfblocks available */
prtvtoc /dev/rdsk/c0t0d0s2
/* Disk geometry and partitioning info */
quot -af
/* How much space is used by users in kilobytes */
Driver Parameters
ndd /dev/ip \?
/* Shows IP variables in the kernel */
ndd /dev/ip ip_forwarding
/* Tells you if forwarding is on (=1) */
ndd -set /dev/ip ip_forwarding 1
/* Enables IP forwarding between interfaces */
File Manipulation
dos2unix | -ascii <filename>
/* Converts DOS file formats to Unix */
split
/* Split files into pieces */
[vi] : %s/existing/new/g
/* Search and Replace text in vi */
[vi] :set nu
/* Set line numbers in vi */
[vi] :set ts=[num]
/* Set tab stops in vi */
File System
cat /dev/null > filename
/* Zero's out the file without breaking pipe */
dd if=/dev/rdsk/... of=/dev/rdsk/... bs=4096
/* Make a mirror image of your boot disk */
df -k | grep dg| awk '{print $6}' |xargs -n 1 umount
/* Unmount all file systems in disk group dg */
fsck -F ufs /dev/rdsk/c0t0d0s0
/* Check a UFS filesystem on c0t0d0s0 */
fsck -F ufs -y /dev/rdsk/c0t0d0s0
/* Check answering yes to all questions */
fsck -F ufs -o b=97472 /dev/rdsk/c0t0d0s0
/* Check using an alternate super block */
gzip -dc file1.tar.gz | tar xf -
/* Unpack .tar.gz files in place */
gzip -d -c tarball.tgz | (cd /[dir];tar xf - ) &
/* Unpacking tarballs to diff location */
ln [-fhns] <source file> <destination file>
/* Creating hard links and soft links */
ls -la | awk '{ print $5," ",$9 }' | sort -rn
/* File sizes of current directory */
mount -f pcfs /dev/dsk/c0d0p1 /export/dos
/* Mount DOS fdisk partition from Solaris */
mount -F ufs -o rw,remount /
/* Used to remount root to make it writeable */
mount -o remount,logging /spare
/* Re-mount the ro file system rw and turn on ufs logging */
pax -rw . /newdir
/* Efficient alternative for copying directories */
prtvtoc /dev/rdsk/c0t0d0s2 | fmthard -s - /dev/rdsk/c0t1d0s2
/* Cloning Partitiontables */
tar cvf filename.tar
/* Create a tape (tar) archive */
tar xvf filename.tar
/* Extract a tape (tar) archive */
tar cf - . | (cd /newdir ; tar xf -)
/* Recursively copy files and their permissions */
/sbin/uadmin x x
/* Syncs File Systems and Reboots systems fast */
zcat [cpio file] | cpio -itmv
/* Show the contents of a compressed cpio */
zcat <patch_file.tar.Z | tar xvf -
/* Extract the patch_file that is a compressed tar file */
File Transfer
get filename.suffix |"tar xf -"
/* Undocumented Feature of FTP */
put "| tar cf - ." filename.tar
/* Undocumented Feature of FTP */
find . -depth | cpio -pdmv /path/tobe/copied/to
/* Fast alternative to cp -pr */
sendport
/* Transferring large numbers of files within the same ftp control session */
General
/usr/bin/catman -w
/* Create windex databases for man page directories */
FQ_FILENAME=<fully_qualified_file_name>; echo ${FQ_FILENAME%/*}
/* Extract directory from fully-qualified file name. */
mailx -H -u <username>
/* List out mail headers for specified user */
set filec
/* Set file-completion for csh */
uuencode [filename] [filename] | mailx -s "Subject" [user to mail]
/* Send files as attachments */
Hardware
cfgadm
/* Verify reconfigurable hardware resources */
m64config -prconf
/* Print M64 hardware configuration */
m64config -depth 8|24
/* Sets the screen depth of your M64 graphics accelerator */
m64config -res 'video_mode'
/* Change the resolution of your M64 graphics accelerator */
Kernel
/usr/sbin/modinfo
/* Display kernel module information */
/usr/sbin/modload <module>
/* Load a kernel module */
/usr/sbin/modunload -i <module id>
/* Unload a kernel module */
nm -x /dev/ksyms | grep OBJ | more
/* Tuneable kernel parameters */
/usr/sbin/sysdef
/* Show system kernal tunable details */
Memory
prtconf | grep Mem
/* Display Memory Size */
Network Information
ndd /dev/arp arp_cache_report
/* Prints ARP table in cache with IP and MAC address */
netstat -a | grep EST | wc -l
/* Displays number active established connections to the localhost */
netstat -k hme0
/* Undocumented netstat command */
netstat -i
/* Show the TCP/IP network interfaces */
netstat -np
/* Similar to arp -a without name resolution */
netstat -r
/* Show network route table */
netstat -rn
/* Displays routing information but bypasses hostname lookup. */
netstat -a | more
/* Show the state of all sockets */
traceroute <ipaddress>
/* Follow the route to the ipaddress */
Network/Tuning
ifconfig eth0 mtu 1500
/* Change MTU of interface */
ifconfig eth0 10.1.1.1 netmask 255.255.255.255
/* Add an Interface */
/sbin/ifconfig hme0:1 inet 10.210.xx.xxx netmask 255.255.0.0 broadcast 10.210.xxx.xxx
/* Virtual Interfaces */
/sbin/ifconfig hme0:1 up
/* Bring virtual interface up */
/usr/sbin/ndd -set /dev/hme adv_100fdx_cap 1
/* Nailling to 100Mbps */
ndd -set /dev/ip ip_addrs_per_if 1-8192
/* To set more than 256 virtual ip addresses. */
ndd -set /dev/tcp tcp_xmit_hiwat 65535
/* Increase TCP-transmitbuffers */
ndd -set /dev/tcp tcp_recv_hiwat 65535
/* Increase TCP-receivebuffers */
Processes
fuser -uc /var
/* Processes that are running from /var */
kill -HUP `ps -ef | grep [p]roccess | awk '{print $2}'`
/* HUP any related process in one step */
lsof -i TCP:25
/* Mapping port with process */
pfiles <pid>
/* Shows processes' current open files */
pkill -n <name>
/* Kill a process by name */
kill `ps -ef | grep program_name | grep -v grep | cut -f8 -d ' '`
/* pkill for solaris 2.6 */
prstat -a
/* An alternative for top command */
/usr/ucb/ps -aux | more
/* Displays CPU % usage for each process in ascending order */
/usr/ucb/ps -auxww | grep <process name>
/* Gives the full listing of the process (long listing) */
ps -ef | grep -i <string> | awk '{ print $2 }'
/* Creates list of running PID by */
ps -ef | grep -v "0:00" | more
/* Gives you a list of any process with CPU time more than 0:00 */
ps -ef | more
/* Show all processes running */
ps -eo pid,args
/* List processes in simplified format */
ps -fu oracle|grep pmon
/* See which instances of Oracle are running */
/usr/proc/bin/ptree <pid>
/* Print the parent/child process 'tree' of a process */
/usr/proc/bin/pwdx <pid>
/* Print the working directory of a process */
top -b 1
/* Returns the process utilizing the most cpu and quits */
Resource Management
/usr/bin/ldd [filename]
/* List the dynamic dependencies of executable files */
/usr/proc/bin/pmap pid
/* Report address space map a process occupies */
Route Configuration
route add net 128.50.0.0 128.50.1.6 1
/* Adds route to 128.50 network via 128.50.1.6 */
route change 128.50.0.0 128.50.1.5
/* Changes the destination address for a route */
route delete net 128.50.0.0 128.50.1.6
/* Deletes route to 128.50 network */
route get [hostname]
/* Which interface will be used to contact hostname */
route monitor
/* Monitors traffic to the routes */
route flush
/* Removes all entries in the route table */
Searching Items
egrep "patterna|patternb" <filename>
/* Search for multiple patterns within the same file */
find . -exec egrep -li "str" {} \;
/* Find a string in files starting cwd */
find / -fstype nfs -prune -o fstype autofs -prune -o -name filename -print
/* Find without traversing NFS mounted file systems */
find . -mtime -1 -type f
/* Find recently modified files */
find / -mtime <# of days>
/* Find files modified during the past # of days */
find . ! -mtime -<days> | /usr/bin/xargs rm -rf
/* Finds and removes files older than <days> specified */
find . -type f -exec grep "<sub-string>" {} \; -print
/* Find files (and content) containing <sub-string> within directory tree */
find . -type f -exec grep -l "<sub-string>" {} \;
/* Find filenames containing <sub-string> within directory tree */
find . -type f -print | xargs grep -i [PATTERN]
/* Recursive grep on files */
find / -user <username>
/* Find all files owned by <username> */
find / | grep [file mask]
/* Fast way to search for files */
find <start_path> -name "<file_name>" -exec rm -rf {} \;
/* Recursively finds files by name and automatically removes them */
find /proc/*/fd -links 0 -type f -size +2000 -ls
/* Find large files held open by a process */
ls -lR | grep <sub_string>
/* Fast alternative to find */
Security
echo 'Please go away' > /etc/nologin
/* Stops users logging in */
find / -perm -0777 -type d -ls
/* Find all your writable directories */
find / -type f -perm -2000 -print
/* Find all SGID files */
find / -type f -perm -4000 -print
/* find all SUID files */
Set Terminal Options
stty erase ^H
/* Sets the Backspace Key to erase */
stty erase ^?
/* Sets the Delete Key to erase */
stty sane
/* Rreset terminal after viewing a binary file. */
tput rmacs
/* Reset to standard char set */
Snoop Your Network
snoop -d pcelx0
/* Watch all network packets on device pcelx0 */
snoop -o /tmp/mylog pcelx0
/* Saves packets from device pcelx0 to a file */
snoop -i /tmp/mylog host1 host2
/* View packets from logfile between host1 & host2 */
snoop -i /tmp/mylog -v -p101
/* Show all info on packet number 101 from a logfile */
snoop -i /tmp/mylog -o /tmp/newlog host1
/* Write a new logfile with all host1 packets */
snoop -s 120
/* Return the first 120 bytes in the packet header */
snoop -v arp
/* Capture arp broadcasts on your network */
Swap File
mkfile -v 10m /export/disk1/myswap
/* Makes a 10 Megabyte swapfile in /export/disk */
mkfile -nv 10m /export/disk1/myswap
/* Makes an empty 10 Megabyte swapfile */
Swap Space
swap -s
/* List the amount of swap space available, also see mkfile */
swap -a /export/disk1/swapfile
/* Add a swapfile */
swap -d /dev/dsk/c0t0d0s4
/* Deletes a swap device */
swap -l
/* List the current swap devices */
System Configuration
drvconfig ; disks
/* Adding hot-plug disks to system */
/usr/sbin/eeprom auto-boot? false
/* Changes eeprom autoboot? setting without going to Ok prompt */
/usr/sbin/eeprom diag-switch? true
/* Set the system to perform diagnostics on the next reboot. */
/usr/sbin/eeprom local-mac-address?=true
/* Multiple Port Network Card Setting */
/usr/sbin/grpck
/* Check /etc/group file syntax */
/usr/sbin/pwck
/* Check /etc/passwd file syntax */
/usr/sbin/sys-unconfig
/* Clear host specific network configuration information */
System Information and Monitoring
coreadm -e log
/* Report global core */
/bin/echo "0t${stamp}>Y\n<Y=Y" | adb
/* Convert UNIX timestamp to something human-readable */
/usr/sbin/eeprom
/* Show eeprom parameters */
grep "\-root" /var/adm/sulog | grep -v \+ | tail -25
/* List most recent attempts to switch to superuser account. */
isainfo -bv
/* Quickly checkout if machine is in 32 or 64 bit mode */
last
/* Tells who was or still is on the system */
logger -i
/* Log the process ID */
psradm -f [processor id]
/* Take processor offline */
/usr/sbin/prtconf -vp
/* Show system configuration details */
/usr/platform/`/bin/uname -i`/sbin/prtdiag -v
/* System Diagnostics */
prtconf -pv | grep banner-name |awk -F\' ' { print $2 } ' | head -1
/* Show actual model name of machine */
psrinfo | wc -l
/* Display number of processors */
sar -A <time in sec>
/* Provides cumulative system report. */
sar -a <time in sec>
/* Report use of file access system routines. */
sar -u
/* Report CPU Utilization */
telnet <remote machine> 13 | grep ':'
/* Get the time on remote Unix machine */
uname -a
/* Displays system information */
vmstat 10
/* Displays summary of what the system is doing every 10 seconds */
who -b
/* Displays the date of the last system reboot. */
ypcat hosts | sort -n -t. +0 -1 +1 -2 +2 -3 +3 -4
/* Take the input of "ypcat hosts" or "cat /etc/inet/hosts" and sort by IP. */ 
[]     
    
eval $() ``三者的异同点
文章整理: 文章来源: 网络 
   eval命令将会首先扫描命令行进行所有的置换，然后再执行该命令。该命令适用于那些一次扫描无法实现其功能的变量。该命令对变量进行两次扫描。
   eval命令在一个语句中，是按次序执行的，只不过再执行之前，先进行置换。(eval后的语句必须是一个命令，若不是则出错)
$HU="hu file"
$eval $HU
bash :hu: 找不到命令
而 $HU="echo file"
   $eval $HU
   file
   $()和``在一个语句中，不管其在什么位置，都是先执行其内部的命令，然后在执行整条语句。
   echo -n "$(eval echo \$$flag) "
语句执行时，先执行eval echo \$$flag，并且将$flag（若＝2）代入，echo $2（若$2=abcde），则最后执行 echo -n "abcde".
   $()与``的区别：
在$()内部的反斜杠(\)可以被转义，而在``中的不能。
echo -n $(eval echo \$$flag)与echo -n `eval echo \$$flag`，前者正常执行，而后者会先代入$$
（其为PID码）然后再执行。
[]     
    
awk总结－－从基础到高级实例分析(转)
文章整理: 文章来源: 网络 
awk的三种调用方式： ?
QUOTE:
awk ‘pattern{action}’ filename1，filename2
awk Cf myscript.awk filename1，filename2
#!/bin/nawk Cf … … 执行：myscript.awk filename
特别注意事项：
QUOTE:
A．从window拷贝语法句到Unix中，行结尾可能有不识别的字符会导致语法错误
B．写script文件时，BEGIN或END后必须紧跟{
C．所有action语句必须放在{ }中，否则提示语法错误。例如不可直接写print
D．单独的赋值或pattern条件句没有{ }则默认print $0；例如{ }外面的i＝1
E．if条件块必须放在action中，也就是必须要有{ }来包含
F．条件的判断“相等”须用= =，而不是=（赋值）；例如，if($1= =100)
G．输出多列须用“，”（逗号）隔开；for循环中间隔符为“；”而不是“，”
关于-F和BEGIN内的FS定义特别注意如下：
QUOTE:
A．-F参数后紧跟单个分隔符，则用双引号“”，例如 CF”+”
B．-F参数后紧跟多个分隔符，则用单引号‘ ’并用[ ]，中间顺序无所谓，例如-F’[+$]’
C．BEGIN中的FS无论是单个还是多个分隔，均用双引号“”，多个则需加[ ]
     例如：nawk ‘BEGIN{FS=”[\t+$]”}{print $6,$8,$9}’data.txt
D．BEGIN中若同时有FS和OFS，则建议中间用分号“；”来分隔开，否则提示出错
    例如：nawk ‘BEGIN{FS=”[\t+$]”;OFS=”%”}{print $6,$7,$8,$9}’ data.txt
E．半方括号[ ]也可以作为分隔符，顺序无所谓。例如：-F‘[[]]’ 或 CF‘[][]’
F．在用多个分隔符的时候，为避免语法错误或想得到正确的结果，最好用nawk
NR与FNR：
QUOTE:
A．awk对多输入文件的执行顺序是，先将代码作用于第一个文件（一行行读入），然后该重复的代码又作用于第二个文件，再作用于第三个文件。
B．awk对多输入文件的执行顺序产生了行序号的问题。当第一个文件执行完，下次读入第二个文件，那么第二个文件的第一行怎么算呢？如果又计为1的话，那不就两个1了么？（因为第一个文件也有第一行）。这就是NR和FNR的问题。
   NR ：全局行数（第二个文件的第一行接着第一个文件尾行数顺序计数）
   FNR：当前文件自身的行数（不考虑前几个输入文件的自身行数及总数）
         例如：data1.txt中有40行，data2.txt中有50行，那么awk ‘{}’ data1.txt data2.txt
                  NR  的值依次为：1，2……40，41，42……90
                   FNR的值依次为：1，2……40， 1， 2……50 
getline函数说明：
QUOTE:
A．getline从整体上来说，应这么理解它的用法：
            当其左右无重定向符 | 或 < 时，getline作用于当前文件，读入当前文件的第一行给其后跟的变量 
            var 或$0（无变量）；应该注意到，由于awk在处理getline之前已经读入了一行，所以getline得到
            的返回结果是隔行的。
            当其左右有重定向符 | 或 < 时，getline则作用于定向输入文件，由于该文件是刚打开，并没有被
            awk读入一行，只是getline读入，那么getline返回的是该文件的第一行，而不是隔行。
B．getline用法大致可分为三大类（每大类又分两小类），即总共有6种用法。代码如下：
QUOTE:
nawk ‘BEGIN{“cat data.txt”|getline d; print d}’ data2.txt 
nawk ‘BEGIN{“cat data.txt”|getline; print $0}’ data2.txt
nawk ‘BEGIN{getline d < “data.txt”; print d}’ data2.txt 
nawk ‘BEGIN{getline < “data.txt”; print $0}’ data2.txt
      以上四行代码均实现“只打印data.txt文件的第一行”（若打印全部行，用循环）
eg. nawk ‘BEGIN{FS=”:”;while(getline<”/etc/passwd”>0){print $1}}’ data.txt
QUOTE:
nawk ‘{getline d; print d”#”$3}’ data.txt
              awk首先读入第一行，接着处理getline函数，然后把下一行指定给变量d，再先打印d，由于d后面有换行符，所以后面紧跟的＃会覆盖d，后面的$3同样也会覆盖d。
QUOTE:
nawk ‘{getline; print $0”#”$3}’ data.txt
               awk首先读入第一行接着处理getline函数，然后把下一行指定给$0，现在的$0已经是下一行内容，后面的#和$3（从$0中取）会覆盖$0的内容。
文件:ABS_Guide_cn.pdf
[]     
    
托福gmat代考女枪手 qq79674554
文章整理: 文章来源: 网络 
女  研究生， 专业8级   替考代考枪手 非中介 诚信服务 英语枪手
新托福ibt从未低过100分，gre 1400. gmat700，bec，sat，自考，专8专业8级 替考代考
 
加 qq 79674554  ，进qq相册查看成绩单
邮箱+msn: cream329@hotmail.com
手机：13061931484
[]     
    
自动telnet
文章整理: 文章来源: 网络 
(sleep 2;echo user;sleep 2;echo password;while read cmd;do echo $cmd;done)|telnet 10.2.2.2|cat
[]     
    
shell 简介 编程 应用
文章整理: 文章来源: 网络 
什么是SHELL
SHELL为我们在用户和linux系统之间提供了一个交互界面。它读取我们的输入然后执行特定的程序。当程序执行的时候它还显示命令输出。因此SHELL被称作linux系统的命令解析器。shell的作用就是遵循一定的语法将输入的命令加以解释并传给系统。它是用户使用linux的桥梁。
登录Linux 系统时，将会看到像这样的提示符：#或$
您所看到的特殊的提示符可能看起来很不一样。它可能包含系统的主机名、当前的工作目录名，或者两者都有。但是不管这个特殊的提示符看起来像什么，有一件事是肯定的。打印出这个提示符的程序叫“shell”，极有可能您的特殊的shell 是一个叫bash 的程序。
几种流行的SHELL：
ash、bash、ksh、csh、zsh
[root@localhost ~ ]#echo $SHELL 显示系统当前使用的SHELL
[root@localhost ~ ]# chsh－l 列出系统所支持的shell
Bash 是“Bourne-again shell”的首字母缩写，它是大多数Linux 系统缺省的shell。shell 的任务是执行您的命令，使您能够与Linux 系统进行交互。当您输完命令，您可以通知shell 执行exit 或logout 命令，在此您将返回到登录提示符。
[root@localhost ~ ]# csh //直接进入csh中，这个shell被称为子shell
[root@localhost ~ ]# exit //退出这个shell
LINUX系统的组成
LINUX系统主要由两部分组成：工具 内核
工具就是能够被执行的程序，如who、date，工具指的是一个程序名字，而命令则是指程序和为了改变程序的行为而指定的参数。有时工具也叫作命令。
内核是linux系统的核心部分，它提供了访问计算机硬件的功能，同时进行系统调度和执行命令。当计算机断电的时候，内核和工具（程序）被存储在硬件存储介质上。
当计算机启动的时候，内核就从磁盘被加载到内存里，并且一直驻留在内存里，直到关机的时候。工具是以文件的形式存储在磁盘上的，只有在被请求的时候才加载到内存。例如执行“who”命令时内核就加载磁盘里存储的who命令到内存里。然后开始执行它。
Shell和命令who一样，也是存储在磁盘上的程序。他们之间的主要区别是，shell在你登录系统的时候就加载了，然后一直驻留在内存里，直到你退出系统。
看一个简单的shell程序
#Program date
#usageto ::show the date in this way (注释)
echo “Mr.$USER,Today is:”
echo date “+%B%d%A”
Shell特殊字符
Shell变量的名称中只能包含字母（a到z、A到Z），数字（0到9）和下划线（_）。此外变量名只能以字母或下划线开始。
Shell中引号分为三种：单引号，双引号和反引号
特殊字符用单引号括起来以后，会失去原来的意义，而只作为普通字符解释。
例：
[root@localhost ~ ]# echo ‘$binnary’
Shell特殊字符：
由双引号括起来的字符，除 $、\、`、“ 这几个字符仍是特殊字符并保留其特殊功能外，
其余字符仍作为普通字符对待。
$字符：就是用其后指定的变量的值来代替这个变量和$
例：
[root@localhost ~ ]# echo $PATH
\符号：是转义字符，它告诉shell不要对其后面的那个字符进行特殊处理，只当作普通字符。
例：
[root@localhost ~ ]# echo it’s good
[root@localhost ~ ]# echo it\’s good
`符号：叫做反引号，反引号括起来的字符串被shell解释为命令行，在执行时，shell首先执行该命令行，并以它的标准输出结果取代整个反引号。
[root@localhost ~ ]# echo `date`
输入/输出重定向和管道
[root@localhost ~ ]# ls *.doc >> d.doc
和程序的标准输出重定向一样，程序的错误输出也可以重新定向。使用符号2>（或追加符号2>>）表示对错误输出设备重定向。
[root@localhost ~ ]# ls /usr/tmp 2> err.file
还可以使用另一个输出重定向操作符（&>）将标准输出和错误输出同时送到同一文件中。
例：
[root@localhost ~ ]# ls/usr/tmp &> output.file
命令执行顺序
命令间隔符说明
； 用；间隔的各命令按顺序依次执行。
&& 前后命令的执行存在“逻辑与”关系，只有&&前面的命令执行成功后，它后面的命令才被执行。
|| 前后命令的执行存在“逻辑或”关系，只有||前面的命令执行失败后，它后面的命令才被执行。
Shell的执行方式
Shell的执行方式可以选择使用下面三种方法：
1、改文件的权限。
[root@localhost ~ ]# chmod 755 filename.sh
[root@localhost ~ ]#./filename.sh
2、直接使用sh命令
[root@localhost ~ ]# sh filename.sh
3、使用bash命令
[root@localhost ~ ]# bash filename.sh
[root@localhost ~ ]#vi hello.sh
#!/bin/bash
hello=“Hello! How are you?”
echo $hello
[root@localhost ~ ]# sh hello.sh
Hello ! How are you ?
declare
declare [-afir]
参数说明：
-a ：定义为数组array
-f ：定义为函数function
-i ：定义为整数integer
-r ：定义为只读
例：
[root@lcoalhost ~ ]# vi declare.sh
declare -i a=3
declare -i b=5
declare -i c=$a*$b
echo $c
[root@lcoalhost ~ ]#sh declare.sh
read
read:的功能就是读取键盘输入的值，并赋给变量
[root @test test]#vi read.sh
#!/bin/bash
read name
echo $name
[root @test test]# sh read.sh
test 这是键盘输入的内容
test 这是输出的内容
shell参数
1、 位置参数
由系统提供的参数称为位置参数。位置参数的值可以用$N得到，N是一个数字，如果为1，即$1.类似C语言中的数组，Linux会把输入的命令字符串分段并给每段进行标号，标号从0开始。第0号为程序名字，从1开始就表示传递给程序的参数。如$0表示程序的名字，$1表示传递给程序的第一个参数，以此类推。
例：
[root@localhost ~ ]# vi example.sh
echo $0
echo $1
echo $2
echo $3
[root@localhost ~ ]#sh example.sh a b c
example.sh
a
b
c
2、 内部参数
上述过程中的$0是一个内部变量，它是必须的，而$1则可有可无。和$0一样的内部变量还有以下几个。
$# ----传递给程序的总的参数数目
$? ----上一个代码或者shell程序在shell中退出的情况，如果正常退出则返回0，反之为非0值。
$* ----传递给程序的所有参数组成的字符串。
$@----程序的所有参数
变量表达式
test 表达式
表达式所代表的操作符有字符串操作符、数字操作符、逻辑操作符以及文件操作符。其中文件操作符是一种shell独特的操作符，因为shell里的变量都是字符串，为了达到对文件进行操作的目的，于是才提供了这样的一种操作符。
1、 字符串比较
作用：测试字符串是否相等、长度是否为零，字符串是否为NULL(注：bash区分零长度字符串和空字符串)
常用的字符穿操作符有：
= 比较两个字符串是否相同，同则为“是”!= 比较两个字符串是否相同，不同则为“是”
-n 比较字符串长度是否大于零，如果大于零则为“是”
-z 比较字符串的穿度是否等于零，如果等于则为“是”
2、 数字比较
这里区别于其他编程语言，test语句不使用>?类似的符号来表达大小的比较，而是用整数式来表示这些。
-eq 相等
-ge 大于等于
-le 小于等于
-ne 不等于
-gt 大于
-lt 小于
3、 逻辑操作! 反：与一个逻辑值相反的逻辑值
-a 与(and)：两个逻辑值为“是”返回值才为“是”，反之为“否”
-o 或(or)：两个逻辑值有一个为“是”，返回值就为“是”
4、 文件操作
文件测试表达式通常是为了测试文件的信息，一般由脚本来决定文件是否应该备份、复制或删除。由于test关于文件的操作符有很多，我们只列举一些常用的。
-d 对象存在且为目录返回值为“是”
-f 对象存在且为文件返回值为“是”
-L 对象存在且为符号连接返回值为“是”
-r 对象存在且可读则返回值为“是”
-s 对象存在且长度非零则返回值为“是”
-w 对象存在且可写则返回值为“是”
-x 对象存在且可执行则返回值为“是”
下面我们利用内部变量和位置参数编写一个名为del的简单删除程序：
if test $# -eq 0
then
echo “Please specify a file!”
else
gzip $1 //先对文件进行压缩
mv $1.gz $HOME/dustbin //移动到回收站
echo “File $1 is deleted !”
fi
算式运算
$((exp))
exp：表达式，可以使用如下运算符：
/ ：除，并返回结果
* :乘
-：减
+ :加
() :圆括号里的运算符优先于其他预算符
[root@localhost ~ ]# echo $((5*6))
[root@localhost ~ ]# echo $((((5+3*2)-4)/2))
除时，如果结果有小数，则截取小数部分
expr
expr是用来加减变量$x
expr的操作符
＋：加
－：减
\*：乘
/：除
％：取余（取模）
注意：操作符两边有空格
expr 1 + 6 / 5
流控制
在一个shell脚本中的命令执行顺序称作脚本的流。大多数脚本会根据一个或多个条件来改变它们的流。
流控制命令：能让脚本的流根据条件而改变的命令称为条件流控制命令。
Shell语句中两种主要的流控制语句:
If语句
Case语句
if语句
if语句根据给出的条件是否为真来执行相应的动作。代码返回0表示真，非0为假。
if语句语法如下：
if list1
then
list2
elif list3
then
list4
else
list5
fi
if示例
条件判断一：if then fi的方式
执行脚本if.sh，当输入y是输出“script is running”，当输入除y以外的任何字符时输出“STOP!”
・[root@localhost ~ ]# vi iftest.sh
echo "Press y to continue"
read yn
if [ "$yn" = "y" ]; then
echo "script is running..."
else
echo "STOP!"
fi
[root@localhost ~ ]#sh iftest.sh
if练习
编写脚本port.sh，执行脚本后显示系统的www、ftp、ssh这些服务是否开启。
提示：在脚本中使用nmap、grep命令。
case语句
case语句是shell中流控制的第二种方式，语法如下：
case word in
pattern1）
list1;;
pattern2）
list2 ;;
…
patternN)
listN;;
esac
;;类似C语言中的break指令
字符串变量word与从pattern1到patternN的所有模式一一比较。当找到一个匹配模式后就执行跟在匹配模式后的list
当一个list执行完了，专用命令;;表明流应该跳转到case语句的最后。;;类似C语言中的break指令。如果找不到匹配的模式，case语句就不做任何动作。
case练习
建立脚本case.sh，当执行时，要求我们在键盘输入适当的值，当输入正确时并打印出，当输入错误时会提示你，应该输入哪些值。
[root@localhost ~ ]# vi case.sh
#!/bin/bash
echo "press your chioceone,two,three"
read number
case $number in
one)
echo "your choice is one";;
two)
echo "your choice is two";;
three)
echo "your choice is three";;
*)
echo "Usage {one|two|three}"
esac
[root@localhost ~ ]# sh case.sh
for循环
for循环使你对列表中的每一项重复执行一系列命令。
语法格式：
for name in word1 world2 …worldN
do
list
done
name 是变量名，word1到wordN是一系列由空格分隔的字符序列（单词）。每次执行for循环时，变量name的值就被设为单词列表（word1到wordN）中的一个单词。for循环执行的次数取决于指定的word的个数。
在for循环的每次反复中，都会执行list中指定的命令。
也可以写成如下格式：
for name in word1 wrold2 …wordN; do list ;done
for循环练习
自己看一下下面的例子，会出现什么样的效果：
[root@localhost ~ ]# vi fortest.sh
#!/bin/bash
LIST="Tom Jony Mary Geoge"
for i in $LIST
do
echo $i
done
[root@localhost ~ ]# sh fortest.sh
while循环
while循环使你能够重复执行一系列的命令，直到某种条件发生。
基本语法：
while cmd
do
list
done
cmd是一个单一的命令，list是一个或多个命令的列表。
1.执行cmd
2.如果cmd的退出状态为非0，则退出循环
3.如果cmd的退出状态为0，则执行list
4.当list结束时，回到第一步
可以写成：
while cmd ；do list ；done
while循环练习
输出10以内的数字
[root@localhost ~ ]#vi whiletest.sh
x=0
while [ $x Clt10 ]
do
echo $x
x=`expr $x + 1`
done
[root@localhost ~ ]#sh whiletest.sh
嵌套while循环
x=0
while [ “$x” Clt 10 ];
do
y=“$x”
while [ “$y” Cge 0 ];
do
printf“$y”
y=`expr $y C 1`
done
echo
x=`expr $x + 1`
done
批量添加用户
#!/bin/bash
sum=0
while [ $sum Clt 10 ]
do
sum=`expr $sum + 1`
useradd user $sum
echo “123456" | passwd Cstdin user$sum
done
练习
请按上面的例子写一个添加指定数目，指定用户的程序。
until循环
while循环适合于当某种条件为真时执行一系列命令，而until循环执行一系列命令,直到条件为真时才退出循环。
语法如下：
until cmd
do
list
done
cmd是一条单独指令，而list是一条或多条命令的集合。Until的执行流程和while类似。
1.执行cmd
2.如果cmd的退出状态为非0，则退出until循环
3.如果cmd的退出状态为0，则执行list
4.当list执行完毕，返回步骤1
select循环
select循环提供了一种简单的方式来创建一种用户可选择的有限菜单。当你需要用户从一个选项列表中选择一项或多项时非常有用。
语法：
select name in word1 word2 …wordN
do
list
done
name是变量名
执行流程：
1.list1中的每一项都跟随着一个数字一起显示
2.显示一个命令提示符，通常是#?
3.当用户输入一个值时，$REPLY被设置那个值
4.进行了有效的选择后，执行list2
5.如果list2没有使用循环控制机制（例如break）来退出select循环，过程重新从步骤1开
始。
select练习
#!/bin/bash
select program in ‘lsCF’ ‘pwd’ ‘date’ ‘dfCv’
do
$program
done
函数
[function]函数名( )
{
命令表
}
其中，关键字function可以缺省。
函数应先定义，后使用。调用函数时，直接利用函数名，如showfile，不必带圆括号，就像一般命令那样使用。Shell脚本与函数间的参数传递可利用位置参数和变量直接传递。变量的值可以由Shell脚本传递给被调用的函数，而函数中所用的位置参数$1、$2，等对应于函数调用语句中的实参，这一点是与普通命令不同的。
函数的示例
#func is a function name
# it echos the values of variables and arguments
func( )
{
echo "Let's begin now. "
echo $a $b $c
echo $1 $2 $3
echo "The end. "
}
a=" Working directory "
b="is"
c=`pwd`
func Welcome You Byby
echo "Today is ` date ` "
Shell中的函数把若干命令集合在一起，通过一个函数名加以调用。如果需要，还可被多次调用。执行函数并不创建新的进程，是通过Shell进程执行。
通常，函数中的最后一个命令执行之后，就退出被调函数。也可利用return命令立即退出函数，其语法格式是：
return [ n ]
其中，n值是退出函数时的退出值（退出状态），即$?的值。当n值缺省时，则退出值是最后一个命令执行后的退回值。 
[]     
    
百度面试题(1)--shell编程
文章整理: 文章来源: 网络 
1. 从a.log文件中提取包含"WARNING"或"FATAL"，同时不包含"IGNOR"的行，然后提取以":"分割的第 5个字段
2. 编写一个脚本，只想简单的减法运算，要求提示输入变量
3. Shell脚本阅读（解释下面执行的功能），请挑出下面程序或脚本中的错误，并说明错在哪里。 
#!/bin/bash 
#监控cpuser的point端口是否正常 
logname="/home/forum/log/lpointlog.wf" 
flagfile="/home/forum/log/lognum.txt" 
lodnum=sed -n "1,1 p"$flagfile 
newnum=wc -l ${logname} 
echo $newnum >$flagfile 
totalnum=expr $newnum -$oldnum 
tail -n $totalnum $logname |grep "POINT_THREAD WARNING" 
if [$?==0] 
then 
   mail -s "cpuser point "端口异常,请处理!" test@aa.com</dev/null 
fi>
参考答案：
1。
grep -E 'warning|fatal' file | grep -v ignor | awk -F ":" '{print $5}'
[]     
    
shell 编程常用工具
文章整理: 文章来源: 网络 
awk 是一种方便的面向行的文本处理语言。 
cat 将指定为参数的文件内容打印到终端。作为管道的第一个命令，这是很方便的，例如，cat foo.txt | blah。 
cut 从输入文件或流的每个行上抽取出由字符限定的字段。 
expand 将输入制表符转换为空格。使用 -t 选项来指定制表符停止位。 
fmt 对段落重新格式化以便在其边缘处进行换行。这个能力被构建到大多数文本编辑器中，但是应知道它仍是一个好工具。 
head 打印出文件或流的前十行。使用 -n 选项来指定应显示的行数。 
join 与 paste 类似，但它在每个输入行中使用一个字段（缺省情况下是第一个字段）来匹配一在单行上合并的字段。 
nl 将行号添加到输入的每个行上。这对于打印输出很有用。 
od 将输入流转换为八进制或十六进制的“转储”格式。 
paste 获取两个或更多文件作为输入，连接输入文件上的每个后续行，并输出结果行。它对于创建文本的表或列是很有用的。 
pr 将文件分解为多个页面的输出；通常用于打印。 
sed 是一个功能强大的面向流的文本编辑器。 
sort 按字母次序打印在命令行上指定的文件内容。当然，sort 也接受用管道传送的输入。输入 man sort 来熟悉控制排序行为的各种选项。 
split 将较大的文件拆分成许多较小、更易处理的块。 
tac 与 cat 类似，但它以逆向顺序打印所有行，换句话说，先打印最后一行。 
tail 打印出文件或流的最后十行。使用 -n 选项来指定应显示的行数。 
tee 将它的输入打印到文件和屏幕。当您想创建某些日志记录，但还想在屏幕上看时，这很有用。 
tr 是字符转换工具；它用来将输入流中的某些字符映射成输出流中的某些其它字符。 
unexpand 将输入空格转换为制表符。使用 -t 选项来指定制表符停止位。 
uniq 获取已排序的文件或数据流（通过管道）并除去重复行。 
wc 打印出指定文件或输入流（来自管道）中的行、字和字节的数量。输入 man wc 来学习如何精调显示的内容。 
comm 比较两个排好序的文件 
csplit 也是拆分文件，和split不同的是，新文件的名字可以用pattern来控制 
fold 按指定的宽度把文本文件换行 
basename 去处前导的目录后的文件或目录名 
echo 打印字符串 
env 打印环境变量 
expr 数学表达式计算 
false 设置返回值为1 
true 设置返回值为0 
pwd 打印当前目录名 
seq 打印指定步进值的数字序列，整数浮点数都可以 
sleep 让当前进程休息一会儿  
uname 打印一些重要的内核信息 
yes 不停打印指定字符串，缺省为y 
加两个比较文件的命令： 
1. cmp -- 判断两个文件内容是否一样。 
2. diff -- 详细输出两个不同文件的差别。 
很有教益的电子文档： 
《LINUX与UNIX SHELL编程指南》(中文PDF文件下载，推荐阅读！) 
Unix Shell 介绍，mhss翻译的文章，shell入门的好教材，推荐阅读！ 
使用 Shell，xgwu翻译的Mandrake文档，可以看看。 
[]     
    
百度文件数统计
文章整理: 文章来源: 网络 
一个文本文件有多行，每行为一个URL。请编写代码，统计出URL中的文件名及出现次数。
　　a) 文件名不包括域名、路径和URL参数，例如http://www.ourday.cn/bbs/forumdisplay.php?fid=18中的文件名是forumdisplay.php.
　　b) 部分URL可能没有文件名，例如http://www.ourday.cn/，这类统计为“空文件名”。
　　c) 出现在不同URL中的相同文件名视为同一文件名，例如http://www.ourday.cn/index.php和ftp://ftp.ourday.cn/index.php为同一文件名
　　文件内容示例如下：
　　http://www.ourday.cn/bbs/index.php
　　http://www.ourday.cn/index.php
　　ftp://ftp.ourday.cn/index.html
　　http://www.ourday.cn/bbs/index.php?k=8
　　http://www.ourday.cn/bbs/forumdisplay.php?fid=16
　　http://www.ourday.cn/bbs/viewthread.php?extra=page
　　http://www.ourday.cn/
      http://www.ourday.com.cn/
以上url地址经修改，不影响试题内容。
 sed实现:sed -e 's/\?.*//g' -e 's/.*\///g' url | sort | uniq -c
 awk实现: awk '{sub(/.*\//,"");sub(/\?.*/,"");a[$0]++;}END{for(n in a)print n,a[n];}' url
感觉c的字符串处理以及文本处理根本不能与shell想题并论
[]     
    
shell之sed命令全解
文章整理: 文章来源: 网络 
先来看看下面的网页吧：
http://blog.csdn.net/jinyonghe/archive/2007/08/20/1751513.aspx
sed手册：（详细）
sed手册 - 1. Introduction 
http://phi.sinica.edu.tw aspac@phi.sinica.edu.tw (2001-07-29 08:05:00) 
1.Introduction 
Sed(Stream EDitor)为 UNIX 系统上提供将编辑工作自动化的编辑器 , 使用者无需直接编辑资料。使用者可利用 sed 所提供 20 多种不同的函数参数 , 组合(解 [1])它们完成不同的编辑动作。此外 , 由於sed 都 以行为单位编辑文件 , 故其亦是行编辑器(line editor)。 
一般 sed 最常用在编辑那些需要不断重覆某些编辑动作的文件上 , 例如将文件中的某个字串替换成另一个字串等等。这些相较於一般 UNIX 编辑器(交谈式的, 如 vi、emacs)用手动的方式修改文件 , sed 用起来较省力。 
下面几节将分别介绍: 
何时使用 sed 
何处获得 sed 
sed 能做那些编辑动作 
sed 如何工作 
1.1 何时使用 sed 
在修改文件时 , 如果不断地重覆某些编辑动作 , 则可用 sed 自动一次执行这些编辑动作。例如要使 received 
档内 1000 封电子信件内的发信人属名 "Tom" 改成 "John" , 此时只要在命令列上执行一简单的 sed 命令就可把档内所有的 "Tom" 字串替换成 "John"。 
再者 , 当文件需要许多不同编辑动作时 , 则 sed 一次可执行那些不同的编辑动作。例如 sed 能一次执行完将 文件中所有空白行删除、替换字串、并将使用者输入的文字添加在文件的第六行等等不同的编辑动作。 
1.2 何处获得 sed 
一般的 UNIX 系统 , 本身即附有 sed。不同的 UNIX 系统所附的 sed 版本亦不尽相同。若读者所使用的 UNIX 系统上未附有 sed , 则可透过 anonymous ftp 到下列地方去取得 : 
phi.sinica.edu.tw:/pub/GNU/gnu 
gete.sinica.edu.tw:/unix/gnu 
ftp.edu.tw:/UNIX/gnu 
ftp.csie.nctu.edu.tw:/pub/Unix/GNU 
ftp.fcu.edu.tw: /pub3/UNIX/gnu 
axp350.ncu.edu.tw:/Packages/gnu 
leica.ccu.edu.tw :/pub2/gnu 
mail.ncku.edu.tw :/pub/unix/gnu 
bbs.ccit.edu.tw :/pub1/UNIX/gnu 
prep.ai.mit.edu.tw:/pub/gnu 
1.3 sed 能做那些编辑动作 
sed 可删除(delete)、改变(change)、添加(append)、插入(insert)、合、交换文件中的资料行 , 或读入其它 
档的资料到文件中 , 也可替换(substuite)它们其中的字串、或转换(tranfer)其中的字母等等。例如将文件中的 连续空白行删成一行、 "local" 字串替换成 "remote" 、"t" 字母转换成 "T"、将第 10 行资料与第 11 资料合等。 
1.4 sed 如何工作 
如同其它 UNIX 命令 , sed 由标准输入读入编辑文件并由标准输出送出结果。下图表示 sed 将资料行 "Unix" 替换成 "UNIX" , 
在图中 , 上方 standard input 为标准输入 , 是读取资料之处 ; standard output 为标准输出 , 是送出结果之处 ; 
中间 sed 方块的下面两个虚线方块表示 sed 的工作流程。其中 , 左边虚线方块表示 sed 将标准输入资料置入 
pattern space , 右边虚线方块表示 sed 将 pattern space 中编辑完毕後的资料送到标准输出。 
在虚线方块中 , 两个实线方块分别表示 pattern space 与 sed script。其中 , pattern space 为一缓区 , 它是 sed 工作场所 ; 而 sed script 则表示一组执行的编辑指令。 
在图中, 左边虚线方块 "Unix" 由标准输入置入 pattern space ; 接着 , 在右边虚线方块中 , sed 执行 sed script 
中的编辑指令 s/Unix/UNIX/ (解 [2]) , 结果 "Unix" 被替换成 "UNIX" , 之後 , "UNIX" pattern space 送到标准输出。 
总合上述所言 , 当 sed 由标准输入读入一行资料并放入 pattern space 时 , sed 依照 sed script 的编辑指令逐 一对 pattern space 内的资料执行编辑 , 之後 , 再由 pattern space 内的结果送到标准输出 , 接着再将下一行资料读入。如此重执行上述动作 , 直至读完所有资料行为止。 
SED 手册 - 2. 使用 sed 
http://phi.sinica.edu.tw aspac@phi.sinica.edu.tw (2001-07-29 09:05:00) 
Sed 命令列可分成编辑指令与文件档部份。其中 , 编辑指令负责控制所有的编辑工作 ; 文件档表示所处理的档案。 
sed 的编辑指令均由位址(address)与函数(function)两部份组成 , 其中 , 在执行时 , sed 利用它的位址参数来 
决定编辑的对象;而用它的函数参数(解[3])编辑。 
此外 , sed 编辑指令 , 除了可在命令列上执行 , 也可在档案内执行。其中差别只是在命令列上执行时 , 其前必 
须加上选项 -e ; 而在档案(解[4])内时 , 则只需在其档名前加上选项 -f。另外 , sed 执行编辑指令是依照它 
们在命令列上或档内的次序。 
下面各节 , 将介绍执行命令列上的编辑指令 、sed 编辑指令、执行档案内的编辑指令、执行多个档案的编辑、及 
执行 sed 输出控制。 
2.1 执行命令列上的编辑指令 
2.2 sed 编辑指令 
2.3 执行档案内的编辑指令 
2.4 执行多个档案的编辑 
2.5 执行 sed 输出控制 
2.1.执行命令列上的编辑指令 
当编辑指令(参照[section 2.2])在命令列上执行时 , 其前必须加上选项 -e 。其命令格式如下 : 
sed -e '编辑指令1' -e '编辑指令2' ... 文件档 
其中 , 所有编辑指令都紧接在选项 -e 之後 , 并置於两个 " ' " 特殊字元间。另外 , 命令上编辑指令的执行是由 
左而右。 
一般编辑指令不多时 , 使用者通常直接在命令上执行它们。例如 , 删除 yel.dat 内 1 至 10 行资料 , 并将其 
馀文字中的 "yellow" 字串改成 "black" 字串。此时 , 可将编辑指令直接在命令上执行 , 其命令如下 : 
sed -e '1,10d' -e 's/yellow/black/g' yel.dat 
在命令中 , 编辑指令 '1,10d'(解[5])执行删除 1 至 10 行资料 ; 编辑指令 's/yellow/black/g'(解[6]) , 
"yellow" 字串替换(substuite)成 "black" 字串。 
2.2 sed 的编辑指令 
sed 编辑指令的格式如下 : 
[address1[,address2]]function[argument] 
其中 , 位址参数 address1 、address2 为行数或 regular expression 字串 , 表示所执行编辑的资料行 ; 函数参 
数 function[argument] 为 sed 的内定函数 , 表示执行的编辑动作。 
下面两小节 , 将仔细介绍位址参数的表示法与有哪些函数参数供选择。 
2.2.1 位址(address)参数的表示法 
实际上 , 位址参数表示法只是将要编辑的资料行 , 用它们的行数或其中的字串来代替表示它们。下面举几个例子 
说明(指令都以函数参数 d(参照[section4.2]) 为例) : 
删除档内第 10 行资料 , 则指令为 10d。 
删除含有 "man" 字串的资料行时 , 则指令为 /man/d。 
删除档内第 10 行到第 200 行资料, 则指令为 10,200d。 
删除档内第 10 行到含 "man" 字串的资料行 , 则指令为 10,/man/d。 
接下来 , 以位址参数的内容与其个数两点 , 完整说明指令中位址参数的表示法(同样也以函数参数 d 为例)。 
位址参数的内容: 
位址为十进位数字 : 此数字表示行数。当指令执行时 , 将对符合此行数的资料执行函数参数指示的编辑动作。例如 , 
删除资料档中的第 15 行资料 , 则指令为 15d(参照[section4.2])。其馀类推 ,如删除资料档中的第 m 行资料 , 则 
指令为 md 。 
位址为 regular expression(参照[附录 A]): 
当资料行中有符合 regular expression 所表示的字串时 , 则执行函数参数指示的编辑动作。另外 , 在 
regular expression 前後必须加上 "/"。例如指令为 /t.*t/d , 表示删除所有含两 "t" 字母的资料行。其中 , "." 
表示任意字元; "*" 表示其前字元可重任意次 , 它们结合 ".*" 表示两 "t" 字母间的任意字串。 
位址参数的个数 : 在指令中 , 当没有位址参数时 , 表示全部资料行执行函数参数所指示的编辑动作; 当只有一位址 
参数时 , 表示只有符合位址的资料行才编辑 ; 当有两个位址参数 , 如 address1,address2 时 , 表示对资料区执行 
编辑 , address1 代表起始资料行 , address2 代表结束资料行。对於上述内容 , 以下面例子做具说明。 
例如指令为 
d 
其表示删除档内所有资料行。 
例如指令为 
5d 
其表示删除档内第五行资料。 
例如指令为 
1,/apple/d 
其表示删除资料区 , 由档内第一行至内有 "apple" 字串的资料行。 
例如指令为 
/apple/,/orange/d 
其表示删除资料区 , 由档内含有 "apple" 字串至含有 "orange" 字串的资料行 
2.2.2 有那些函数(function)参数 
下页表中介绍所有 sed 的函数参数(参照[chapter 4])的功能。 
函数参数 功能 
: label 建立 script file 内指令互相参考的位置。 
# 建立解 
{ } 集合有相同位址参数的指令。 
! 不执行函数参数。 
= 印出资料行数( line number )。 
a 添加使用者输入的资料。 
b label 将执行的指令跳至由 : 建立的参考位置。 
c 以使用者输入的资料取代资料。 
d 删除资料。 
D 删除 pattern space 内第一个 newline 字母 前的资料。 
g 拷贝资料从 hold space。 
G 添加资料从 hold space 至 pattern space 。 
h 拷贝资料从 pattern space 至 hold space 。 
H 添加资料从 pattern space 至 hold space 。 
l 印出 l 资料中的 nonprinting character 用 ASCII 码。 
i 插入添加使用者输入的资料行。 
n 读入下一笔资料。 
N 添加下一笔资料到 pattern space。 
p 印出资料。 
P 印出 pattern space 内第一个 newline 字母 前的资料。 
q 跳出 sed 编辑。 
r 读入它档内容。 
s 替换字串。 
t label 先执行一替换的编辑指令 , 如果替换成牛p>则将编辑指令跳至 : label 处执行。 
w 写资料到它档内。 
x 交换 hold space 与 pattern space 内容。 
y 转换(transform)字元。 
虽然 , sed 只有上表所述几个拥有基本编辑功能的函数 , 但由指令中位址参数和指令与指令间的配合 , 也能使 
sed 完成大部份的编辑任务。 
2.3 执行档案内的编辑指令 
当执行的指令太多 , 在命令列上撰写起来十分混乱 , 此时 , 可将这些指令整理储存在档案 
(譬如档名为 script_file )内 , 用选项 -f script_file , 则让 sed 执行 script_file 内的编辑指令。其命 
令的格示如下 : 
sed -f script_file 文件档 
其中 , 执行 script_file 内编辑指令的顺序是由上而下。例如上一节的例子 , 其可改成如下命令: 
sed -f ysb.scr yel.dat 
其中 , ysb.scr 档的内容如下 : 
1,10d 
s/yellow/black/g 
另外 , 在命令列上可混合使用选项 -e 与 -f , sed 执行指令顺序依然是由命令列的左到右, 如执行至 -f 後 
档案内的指令 , 则由上而下执行。 
2.4 执行多个文件档的编辑 
在 sed 命令列上 , 一次可执行编辑多个文件档 , 它们跟在编辑指令之後。例如 , 替换 
white.dat、red.dat、black.dat 档内的 "yellow" 字串成 "blue" , 其命令如下: 
sed -e 's/yellow/blue/g' white.dat red.dat black.dat 
上述命令执行时 , sed 依 white.dat、red.dat、black.dat 顺序 , 执行编辑指令 s/yellow/blue/(请参照[section 4.1] , 
进行字串的替换。 
2.5.执行输出的控制 
在命令列上的选项 -n (解[7]) 表示输出由编辑指令控制。由前章内容得知 , sed 会 "自动的" 将资料由 
pattern space 输送到标准输出档。但藉着选项 -n , 可将 sed 这 "自动的" 的动作改成 "被动的" 由它所执行的 
编辑指令(解[8])来决定结果是否输出。 
由上述可知 , 选项 -n 必须与编辑指令一起配合 , 否则无法获得结果。例如 , 印出 white.dat 档内含有 "white" 
字串的资料行 , 其命令如下: 
sed -n -e '/white/p' white.dat 
上面命令中 , 选项 -n 与编辑指令 /white/p (参照[section4.6]) 一起配合控制输出。其中 , 选项 -n 将输出控制权 
移给编辑指令;/white/p 将资料行中含有 "white" 字串印出萤幕。 
SED 手册 - 3.例 
http://phi.sinica.edu.tw aspac@phi.sinica.edu.tw (2001-07-29 13:05:00) 
一般在实际使用编辑器的过程中 , 常需要执行替换文件中的字串、搬移、删除、与搜寻资料行等等动作。 
当然 , 一般交谈式编辑器(如 vi、emacs)都能做得到上述功能 , 但文件一旦有大量上述编辑需求时 , 则 
用它们编辑十分没有效率。本章将用举例的方式说明如何用 sed 自动执行这些编辑功能。此外 , 在本章 
例中 , 均以下述方式描述文件的需求 : 
将文件中...资料 , 执行...(动作) 
如此 , 目的是为了能将它们迅速的转成编辑指令。其中 , " ...资料" 部份 , 转成指令中的位址参数表示 ; 
"执行...动作" 部份 , 则转成函数参数表示 。另外 , 当 "执行...动作" 要由数个函数参数表示时 , 则可利 
用 "{ "与 " }" 集合这些函数参数(解[9]) , 其指令形式如下 : 
位址参数{ 
函数参数1 
函数参数2 
函数参数3 
. 
: 
} 
上述指令表示 , 将对符合位址参数的资料 , 依次执行函数参数1、函数参数2、函数参数3 ... 表示的动作。 
下面各节 , 分别举例说明 sed 替换资料、移动、删除资料、及搜寻资料的命令。 
3.1 替换文件中的资料 
3.2 搬动文件中的资料 
3.3 删除文件中的资料 
3.4 搜寻文件中的资料 
3.1 替换文件中的资料 
Sed 可替换文件中的字串、资料行、甚至资料区。其中 , 表示替换字串的指令中的函数参数为 s(参照[section4.1]); 
表示替换资料行、或资料区的指令中的函数参数为 c(参照[section4.5])。上述情况以下面三个例子说明。上述情况 
以下面三个例子说明。 
例一. 将文件中含 "machine" 字串的资料行中的 "phi" 字串 , 替换成为 "beta" 字串。其命令列如下 : 
sed -e '/machine/s/phi/beta/g' input.dat(以後文件档都以 input.dat 代表) 
例二. 将文件中第 5 行资料 , 替换成句子 "Those who in quarrels interpose, must often wipe a bloody nose."。 
其命令列如下 
sed -e '5c 
Those must often wipe a bloody nose. 
' input.dat 
例三. 将文件中 1 至 100 行的资料区 , 替换成如下两行资料 : 
How are you? 
data be deleted! 
则其命令列如下 
sed -e '1,100c 
How are you? 
data be deleted! 
' input.dat 
3.2 搬动文件中的资料 
使用者可用 sed 中的 hold space 暂存编辑中的资料、用函数参数 w(参照[section4.9])将文件资料搬动到它档内储存、 
或用函数参数 r(参照[section4.8])将它档内容搬到文件内。Hold space 是 sed 用来暂存 pattern space 内资料的暂 
存器 , 当 sed 执行函数参数 h、H(参照[section4.19])时 , 会将 pattern space 资料暂存到 hold space;当执行函 
数参数 x、g、G(参照[section4.22])时 , 会将暂存的资料取到 pattern space 。下面举三个例子说明。 
例一. 将文件中的前 100 资料 , 搬到文件中第 300 後输出。其命令列如下 : 
sed -f mov.scr 文件档 
mov.scr 档的内容为 
1,100{ 
H 
d 
} 
300G 
其中 , 
1,100{ 
H 
d 
} 
它表示将文件中的前 100 资料 , 先储存(参照[section4.19])在 hold space 之後删除 ;指令 300G (参照[section4.22]) 
表示 , 将 hold space 内的资料 , 添加在文件中的第 300 资料後输出。 
例二. 将文件中含 "phi" 字串的资料行 , 搬至 mach.inf 档中储存。其命令列如下 : 
sed -e '/phi/w mach.inf' 文件档 
例三. 将 mach.inf 档内容 , 搬至文件中含 "beta" 字串的资料行。其命令列如下 : 
sed -e '/beta/r mach.inf' 文件档 
另外 , 由於 sed 是一 stream(参照[section1.4])编辑器 , 故理论上输出後的文件资料不可能再搬回来编辑。 
3.3 删除文件中的资料 
因为 sed 是一行编辑器 , 所以 sed 很容易删除个别资料行或整个资料区。一般用函数参数 d(参照[section4.2])或 
D(参照[section4.17]) 来表示。下面举两个例子说明。 
将文件内所有空白行全部删除。其命令列为 
sed -e '/^$/d' 文件档 
regular expression(解[附录 A]) , ^$ 表示空白行。 其中 , ^ 限制其後字串必须在行首; $ 限制其前字串必须在行尾。 
将文件内连续的空白行 , 删除它们成为一行。其命令列为 
sed -e '/^$/{ 
N 
/^$/D 
}' 文件档 
其中 , 函数参数 N(参照[section4.16])表示 , 将空白行的下一行资料添加至 pattern space 内。函数参数 /^$/D 表示 , 
当添加的是空白行时 , 删除第一行空白行 , 而且剩下的空白行则再重新执行指令一次。指令重新执行一次 , 删除一行空白行 , 
如此反覆直至空白行後添加的为非空白行为止 , 故连续的空白行最後只剩一空白行被输出。 
3.4 搜寻文件中的资料 
Sed 可以执行类似 UNIX 命令 grep 的功能。理论上 , 可用 regular expression(参照[附录 A])。例如 , 将文件中含 
有 "gamma" 字串的资料行输出。则其命令列如下: 
sed -n -e '/gamma/p' 文件档 
但是 , sed 是行编辑器 , 它的搜寻基本上是以一行为单位。因此 , 当一些字串因换行而被拆成两部份时 , 一般的方法 
即不可行。此时 , 就必须以合两行的方式来搜寻这些资料。其情况如下面例子: 
例. 将文件中含 "omega" 字串的资料输出。其命令列如下 
sed -f gp.scr 文件档 
gp.scr 档的内容如下 : 
/omega/b 
N 
h 
s/.* // 
/omega/b 
g 
D 
在上述 sed script(解[10]), 因藉着函数参数 b 形成类似 C 语言中的 case statement 结构 , 使得 sed 可分别处理当 
资料内含 "omega" 字串 ; 当 "omega" 字串被拆成两行 ; 以及资料内没有"omega" 字串的情况。接下来就依上述的三种情 
况 , 将 sed script 分成下面三部份来讨论。 
当资料内含 "omega" , 则执行编辑指令 
/omega/b 
它表示当资料内含 "omega" 字串时 , sed 不用再对它执行後面的指令 , 而直接将它输出。 
当资料内没有"omega" , 则执行编辑指令如下 
N 
h 
s/.* // 
/omega/b 
其中 , 函数参数 N(参照[section 4.16]) , 它表示将下一行资料读入使得 pattern space 内含前後两行资料 。函数参 
数 h(参照[section 4.19]) , 它表示将 pattern space 内的前後两行资料存入 hold space 。函数参数 s/.* // , 它 
表示将 pattern space 内的前後两行资料合(解[11])成一行。/omega/b , 它表示如果合後的资料内含 "omega" 字 
串 , 则不用再执行它之後的指令 , 而将此资料自动输出 ; 
当合後的资料依旧不含 "omega" , 则执行编辑指令如下 
g 
D 
其中 , 函数参数 g(参照[section4.21]) , 它表示将 hold space 内合前的两行资料放回 pattern space。 函数参数 
D(参照[section4.17]) , 它表示删除两行资料中的第一行资料 , 并让剩下的那行资料 , 重新执行 sed script。如此 , 
无论的资料行内或行间的字串才可搜寻完全。 
SED 手册 - 4.介绍函数参数 
http://phi.sinica.edu.tw aspac@phi.sinica.edu.tw (2001-07-30 07:00:00) 
本章将以一节一个函数参数的方式 ,介绍所有 sed 提供的函数参数 , 其中有 
| s | d | a | i | c | p | l | r | w | y | ! | n | q | = | # | N | D | P | h | H | g | G | x | b | t | 
另外 , 在各节中 , 首先简单介绍函数参数功能 , 接着说明函数参数与位址参数配合的格式 , 而其中也一描述 
sed 执行此函数参数的工作情形。 
4.1 s 
函数参数 s 表示替换(substitute)文件内字串。其指令格式如下 : 
[address1[ ,address2]] s/pattern/replacemen/[flag] 
对上述格式有下面几点说明 : 
函数参数 s 最多与两个位址参数配合。 
关於 "s/pattern/replacement/[flag]"(解[12]) 有下面几点说明: 
pattern : 它为 reguler expression 字串。它表示文件中要被替换的字串。 
replacement : 它为一般字串。但其内出现下列字元有特别意义 : 
& : 代表其前 pattern 字串。例如 
sed -e 's/test/& my car/' 资料档名 
指令中 , & 代表 pattern 字串 "test"。故执行後 , 资料档的 "test" 被替换成 "test my car"。 
: 代表 pattern 中被第 n 个 ( 、)(参照[附录 A]) 所括起来的字串。例如 
sed -e 's/(test) (my) (car)/[2 3 1]/' 资料档名 
指令中 , 1 表示 "test"、2 表示 "my"、1 表示 "car" 字串。故执行後 , 资料档的 "test my car" 被替换 
成 "[my car test]"。 
: 可用它来还原一些特殊符号(如上述的 & 与 )本身字面上的意义 , 或用它来代表换行。 
flag : 主要用它来控制一些替换情况 : 
当 flag 为 g 时 , 代表替换所有符合(match)的字串 。 
当 flag 为十进位数字 m 时 , 代表替换行内第 m 个符合的字串。 
当 flag 为 p 时 , 代表替换第一个符合 pattern 的字串後 , 将资料输出标准输出档。 
当 flag 为 w wfile 时 , 代表替换第一个符合 pattern 的字串後 , 输出到 wfile 档内(如果 wfile 不存在 , 则会 
重新开启名为 wfile 的档案)。 
当没有 flag 时 , 则将资料行内第一个符合 pattern 的字串以 replacement 字串来替换 。 
delimiter : 在 "/pattern/replace/[flag] " 中 "/" 被当成一 delimiter。除了空白(blank)、换行(newline) 之外 , 
使用者可用任何字元作为 delimiter。例如下述编辑指令 
s#/usr#/usr1#g 
上述命令中 verb|#| 为 delimiter。如果用 "/" 做 delimiter , 则 sed 会将 pattern 与 replacement 中的 "/" 
当成 delimiter 而发生错误。 
例: 
题目 : 替换 input.dat 档(後面如果没有特别指定 , 均假设文件档名为 input.dat)内 "1996" 字串成 "1997" , 同时 
将这些资料行存入 year97.dat 档内。 
说明 : 用函数参数 s 指示 sed 将 "1996" 字串替换成 "1997" , 另外用 s argument 中的 flag w 指示 sed 将替换 
过的资料行存入 year97.dat 档内。 
sed 命令列: 
sed -e 's/1996/1997/w year97.dat' input.dat 
4.2 d 
函数参数 d 表示删除资料行 , 其指令格式如下: 
[address1[ ,address2]] d 
对上述格式有下面几点说明: 
函数参数 d 最多与两个位址参数配合。 
sed 执行删除动作情况如下 : 
将 pattern space 内符合位址参数的资料删除。 
将下一笔资料读进 pattern space 。 
重新执行 sed script。 
例 : 可参考 section 3.3。 
4.3 a 
函数参数 a 表示将资料添加到文件中。其指令格式如下: 
[address1] a 使用者所输入的资料 
对上述格式有下面几点说明: 
函数参数 a 最多与一个位址参数配合。 
函数参数 a 紧接着 "" 字元用来表示此行结束 , 使用者所输入的资料必须从下一行输入。如果资料超过一行 , 则须在 
每行的结尾加入""。 
sed 执行添加动作情况如下 : 当 pattern space 内资料输出後 , sed 跟着输出使用者所输入的资料。 
例 : 
题目: 添加 "多工作业系统" 在含 "UNIX" 字串的资料行後。假设 input.dat 档的内容如下 : 
UNIX 
说明: 用函数参数 a 将所输入的资料添加在含 "UNIX" 字串的资料行後。 
sed 命令列如下 : 
sed -e '/UNIX/a 
多工作业系统 
' input.dat 
执行上述命令後 , 其输出结果如下 : 
UNIX 
多工作业系统 
4.4 i 
函数参数 i 表示将资料插入文件中。其指令格式如下: 
[address1] i 使用者所输入的资料 
对上述格式有下面几点说明: 
函数参数 i 最多与一个位址参数配合。 
函数参数 i 紧接着 "" 字元用来表示此行结束 , 使用者所输入的资料必须从下一行输入。如果资料超过一行 , 则须在 
每行的结尾加入""。 
sed 执行插入动作的情况如下 : 在 pattern space 内资料输出前 , sed 先输出使用者所输入的资料。 
例 : 
题目: 将 "文章版权属於中央研究院" 插在 input.dat 档中含 "院长 : 李远哲" 的资料行之前。假设 input.dat 档内 
容如下 : 
院长 : 李远哲 
说明: 用函数参数 i 将资料行 "文章版权属於中央研究院" 插在含 "院长 : 李远哲" 的资料行之前。 
sed 命令列如下: 
sed -e '/院长 : 李远哲/i 
文章版权属於中央研究院 
' input.dat 
执行上述命令後的输出如下 : 
文章版权属於中央研究院 
院长 : 李远哲 
4.5 c 
函数参数 c 表示改变文件中的资料。其格式如下: 
[address1[ ,address2]]c 使用者所输入的资料 
对上述格式有下面几点说明: 
函数参数 c 最多与两个位址参数配合。 
函数参数 c 紧接着 "" 字元用来表示此行结束 , 使用者所输入的资料必须从下一行输入。如果资料超过一行 , 则须在 
每行的结尾加入""。 
sed 执行改变动作的情况 : 在 pattern space 内资料输出时 , sed 改变它成为使用者所输入的资料。 
例 : 参考 section 3.1 之例二、三。 
4.6 p 
函数参数 p 表示印出资料。其指令格式如下 : 
[address1[ , address2]] p 
对於上述格式有下面几点说明 : 
函数参数 p 最多与两个位址参数配合。 
sed 执行印出动作的情况如下 : sed 拷备一份 pattern space 内容至标准输出档。 
例 : 参考 section 3.4 开头的内容。 
4.7 l 
函数参数 l , 除可将资料中的 nonprinting character 以 ASCII码列出外 , 其於均与函数参数 p 相同。例如 , 将下 
面 input.dat 档中的 ^[ 以 ASCII 码印出 
The Great ^[ is a movie starring Steve McQueen. 
执行命令 sed -e 'l' input.dat 後 , 则输出结果如下 : 
The Great 
shell实例： 
通用线程 -- sed 实例，第 1 部分
在本文章系列中，Daniel Robbins 将为您演示如何使用功能十分强大（但常被遗忘）的 UNIX 流编辑器 sed。sed 是用批处理方式编辑文件或以十分有效的方式创建 shell 脚本以修改现有文件的理想工具。
挑选编辑器
在 UNIX 世界中有很多文本编辑器可供我们选择。思考一下 -- vi、emacs 和 jed 以及很多其它工具都会浮现在脑海中。我们都有自己已逐渐了解并且喜爱的编辑器（以及我们喜爱的组合键）。有了可信赖的编辑器，我们可以轻松处理任何数量与 UNIX 有关的管理或编程任务。
虽然交互式编辑器很棒，但却有其限制。尽管其交互式特性可以成为强项，但也有其不足之处。考虑一下需要对一组文件执行类似更改的情形。您可能会本能地运行自己所喜爱的编辑器，然后手工执行一组烦琐、重复和耗时的编辑任务。然而，有一种更好的方法。
进入 sed
如果可以使编辑文件的过程自动化，以便用“批处理”方式编辑文件，甚至编写可以对现有文件进行复杂更改的脚本，那将太好了。幸运的是，对于这种情况，有一种更好的方法 -- 这种更好的方法称为 "sed"。
sed 是一种几乎包括在所有 UNIX 平台（包括 Linux）的轻量级流编辑器。sed 有许多很好的特性。首先，它相当小巧，通常要比您所喜爱的脚本语言小很多倍。其次，因为 sed 是一种流编辑器，所以，它可以对从如管道这样的标准输入接收的数据进行编辑。因此，无需将要编辑的数据存储在磁盘上的文件中。因为可以轻易将数据管道输出到 sed，所以，将 sed 用作强大的 shell 脚本中长而复杂的管道很容易。试一下用您所喜爱的编辑器去那样做。
GNU sed
对 Linux 用户来说幸运的是，最好的 sed 版本之一恰好是 GNU sed，其当前版本是 3.02。每一个 Linux 发行版都有（或至少应该有）GNU sed。GNU sed 之所以流行不仅因为可以自由分发其源代码，还因为它恰巧有许多对 POSIX sed 标准便利、省时的扩展。另外，GNU 没有 sed 早期专门版本的很多限制，如行长度限制 -- GNU 可以轻松处理任意长度的行。
最新的 GNU sed
在研究这篇文章之时我注意到：几个在线 sed 爱好者提到 GNU sed 3.02a。奇怪的是，在ftp.gnu.org（有关这些链接，请参阅参考资料）上找不到 sed 3.02a，所以，我只得在别处寻找。我在alpha.gnu.org 的 /pub/sed 中找到了它。于是我高兴地将其下载、编译然后安装，而几分钟后我发现最新的 sed 版本却是 3.02.80 -- 可在alpha.gnu.org 上 3.02a 源代码旁边找到其源代码。安装完 GNU sed 3.02.80 之后，我就完全准备好了。
alpha.gnu.org
alpha.gnu.org（请参阅参考资料）是新的和实验性 GNU 源代码的所在地。然而，您还会在那里发现许多优秀、稳定的源代码。出于某种原因，不是许多 GNU 开发人员忘记将稳定的源代码移至 ftp.gnu.org，就是它们的 "beta" 期间格外长（2 年！）。例如，sed 3.02a 已有两年，甚至 3.02.80 也有一年，但它们仍不能（在 2000 年 8 月写本文章时）在 ftp.gnu.org 上获得。
正确的 sed
在本系列中，将使用 GNU sed 3.02.80。在即将出现的本系列后续文章中，某些（但非常少）最高级的示例将不能在 GNU sed 3.02 或 3.02a 中使用。如果您使用的不是 GNU sed，那么结果可能会不同。现在为什么不花些时间安装 GNU sed 3.02.80 呢？那样，不仅可以为本系列的余下部分作好准备，而且还可以使用可能是目前最好的 sed。
sed 示例
sed 通过对输入数据执行任意数量用户指定的编辑操作（“命令”）来工作。sed 是基于行的，因此按顺序对每一行执行命令。然后，sed 将其结果写入标准输出 (stdout)，它不修改任何输入文件。
让我们看一些示例。头几个会有些奇怪，因为我要用它们演示 sed 如何工作，而不是执行任何有用的任务。然而，如果您是 sed 新手，那么理解它们是十分重要的。下面是第一个示例：
$ sed -e 'd' /etc/services
如果输入该命令，将得不到任何输出。那么，发生了什么？在该例中，用一个编辑命令 'd' 调用 sed。sed 打开 /etc/services 文件，将一行读入其模式缓冲区，执行编辑命令（“删除行”），然后打印模式缓冲区（缓冲区已为空）。然后，它对后面的每一行重复这些步骤。这不会产生输出，因为 "d" 命令除去了模式缓冲区中的每一行！
在该例中，还有几件事要注意。首先，根本没有修改 /etc/services。这还是因为 sed 只读取在命令行指定的文件，将其用作输入 -- 它不试图修改该文件。第二件要注意的事是 sed 是面向行的。'd' 命令不是简单地告诉 sed 一下子删除所有输入数据。相反，sed 逐行将 /etc/services 的每一行读入其称为模式缓冲区的内部缓冲区。一旦将一行读入模式缓冲区，它就执行 'd' 命令，然后打印模式缓冲区的内容（在本例中没有内容）。我将在后面为您演示如何使用地址范围来控制将命令应用到哪些行 -- 但是，如果不使用地址，命令将应用到所有行。
第三件要注意的事是括起 'd' 命令的单引号的用法。养成使用单引号来括起 sed 命令的习惯是个好注意，这样可以禁用 shell 扩展。
另一个 sed 示例
下面是使用 sed 从输出流除去 /etc/services 文件第一行的示例：
$ sed -e '1d' /etc/services | more
如您所见，除了前面有 '1' 之外，该命令与第一个 'd' 命令十分类似。如果您猜到 '1' 指的是第一行，那您就猜对了。与第一个示例中只使用 'd' 不同的是，这一次使用的 'd' 前面有一个可选的数字地址。通过使用地址，可以告诉 sed 只对某一或某些特定行进行编辑。
地址范围
现在，让我们看一下如何指定地址范围。在本例中，sed 将删除输出的第 1 到 10 行：
$ sed -e '1,10d' /etc/services | more
当用逗号将两个地址分开时，sed 将把后面的命令应用到从第一个地址开始、到第二个地址结束的范围。在本例中，将 'd' 命令应用到第 1 到 10 行（包括这两行）。所有其它行都被忽略。
带规则表达式的地址
现在演示一个更有用的示例。假设要查看 /etc/services 文件的内容，但是对查看其中包括的注释部分不感兴趣。如您所知，可以通过以 '#' 字符开头的行在 /etc/services 文件中放置注释。为了避免注释，我们希望 sed 删除以 '#' 开始的行。以下是具体做法：
$ sed -e '/^#/d' /etc/services | more
试一下该例，看看发生了什么。您将注意到，sed 成功完成了预期任务。现在，让我们分析发生的情况。
要理解 '/^#/d' 命令，首先需要对其剖析。首先，让我们除去 'd' -- 这是我们前面所使用的同一个删除行命令。新增加的是 '/^#/' 部分，它是一种新的规则表达式地址。规则表达式地址总是由斜杠括起。它们指定一种 模式，紧跟在规则表达式地址之后的命令将仅适用于正好与该特定模式匹配的行。
因此，'/^#/' 是一个规则表达式。但是，它做些什么呢？很明显，现在该复习规则表达式了。
规则表达式复习
可以使用规则表达式来表示可能会在文本中发现的模式。您在 shell 命令行中用过 '*' 字符吗？这种用法与规则表达式类似，但并不相同。下面是可以在规则表达式中使用的特殊字符：
字符 描述 
与行首匹配 
与行末尾匹配 
与任一个字符匹配 
将与前一个字符的零或多个出现匹配 
[ ] 与 [ ] 之内的所有字符匹配 
感受规则表达式的最好方法可能是看几个示例。所有这些示例都将被 sed 作为合法地址接受，这些地址出现在命令的左边。下面是几个示例：
规则
表达式 描述 
/./ 将与包含至少一个字符的任何行匹配 
/../ 将与包含至少两个字符的任何行匹配 
/^#/ 将与以 '#' 开始的任何行匹配 
/^$/ 将与所有空行匹配 
/}^/ 将与以 '}'（无空格）结束的任何行匹配 
/} *^/ 将与以 '}' 后面跟有零或多个空格结束的任何行匹配 
/[abc]/ 将与包含小写 'a'、'b' 或 'c' 的任何行匹配 
/^[abc]/ 将与以 'a'、'b' 或 'c'开始的任何行匹配 
在这些示例中，鼓励您尝试几个。花一些时间熟悉规则表达式，然后尝试几个自己创建的规则表达式。可以如下使用 regexp：
$ sed -e '/regexp/d' /path/to/my/test/file | more
这将导致 sed 删除任何匹配的行。然而，通过告诉 sed打印 regexp 匹配并删除不匹配的内容，而不是与之相反的方法，会更有利于熟悉规则表达式。可以用以下命令这样做：
$ sed -n -e '/regexp/p' /path/to/my/test/file | more
请注意新的 '-n' 选项，该选项告诉 sed 除非明确要求打印模式空间，否则不这样做。您还会注意到，我们用 'p' 命令替换了 'd' 命令，如您所猜想的那样，这明确要求 sed 打印模式空间。就这样，将只打印匹配部分。
有关地址的更多内容
目前为止，我们已经看到了行地址、行范围地址和 regexp 地址。但是，还有更多的可能。我们可以指定两个用逗号分开的规则表达式，sed 将与所有从匹配第一个规则表达式的第一行开始，到匹配第二个规则表达式的行结束（包括该行）的所有行匹配。例如，以下命令将打印从包含 "BEGIN" 的行开始，并且以包含 "END" 的行结束的文本块：
$ sed -n -e '/BEGIN/,/END/p' /my/test/file | more
如果没发现 "BEGIN"，那么将不打印数据。如果发现了 "BEGIN"，但是在这之后的所有行中都没发现 "END"，那么将打印所有后续行。发生这种情况是因为 sed 面向流的特性 -- 它不知道是否会出现 "END"。
C 源代码示例
如果只要打印 C 源文件中的 main() 函数，可输入：
$ sed -n -e '/main[[:space:]]*(/,/^}/p' sourcefile.c | more
该命令有两个规则表达式 '/main[[:space:]]*(/' 和 '/^}/'，以及一个命令 'p'。第一个规则表达式将与后面依次跟有任意数量的空格或制表键以及开始圆括号的字符串 "main" 匹配。这应该与一般 ANSI C main() 声明的开始匹配。
在这个特别的规则表达式中，出现了 '[[:space:]]' 字符类。这只是一个特殊的关键字，它告诉 sed 与 TAB 或空格匹配。如果愿意的话，可以不输入 '[[:space:]]'，而输入 '['，然后是空格字母，然后是 -V，然后再输入制表键字母和 ']' -- Control-V 告诉 bash 要插入“真正”的制表键，而不是执行命令扩展。使用 '[[:space:]]' 命令类（特别是在脚本中）会更清楚。
好，现在看一下第二个 regexp。'/^}' 将与任何出现在新行行首的 '}' 字符匹配。如果代码的格式很好，那么这将与 main() 函数的结束花括号匹配。如果格式不好，则不会正确匹配 -- 这是执行模式匹配任务的一件棘手之事。
因为是处于 '-n' 安静方式，所以 'p' 命令还是完成其惯有任务，即明确告诉 sed 打印该行。试着对 C 源文件运行该命令 -- 它应该输出整个 main() { } 块，包括开始的 "main()" 和结束的 '}'。
下一篇
既然已经触及了基本知识，我们将在后两篇文章中加快步伐。如果想看一些更丰富的 sed 资料，请耐心一些 -- 马上就有！同时，您可能想查看下列 sed 和规则表达式资源。
sed 是十分强大和小巧的文本流编辑器。在本文章系列的第二篇中，Daniel Robbins 为您演示如何使用 sed 来执行字符串替换、创建更大的 sed 脚本以及如何使用 sed 的附加、插入和更改行命令。
sed 是很有用（但常被遗忘）的 UNIX 流编辑器。在以批处理方式编辑文件或以有效方式创建 shell 脚本来修改现有文件方面，它是十分理想的工具。本文是前一篇介绍 sed 文章的续篇。
替换！
让我们看一下 sed 最有用的命令之一，替换命令。使用该命令，可以将特定字符串或匹配的规则表达式用另一个字符串替换。下面是该命令最基本用法的示例：
$ sed -e 's/foo/bar/' myfile.txt 
上面的命令将 myfile.txt 中每行第一次出现的 'foo'（如果有的话）用字符串 'bar' 替换，然后将该文件内容输出到标准输出。请注意，我说的是每行第一次出现，尽管这通常不是您想要的。在进行字符串替换时，通常想执行全局替换。也就是说，要替换每行中的所有出现，如下所示： 
$ sed -e 's/foo/bar/g' myfile.txt 
在最后一个斜杠之后附加的 'g' 选项告诉 sed 执行全局替换。
关于 's///' 替换命令，还有其它几件要了解的事。首先，它是一个命令，并且只是一个命令，在所有上例中都没有指定地址。这意味着，'s///' 还可以与地址一起使用来控制要将命令应用到哪些行，如下所示：
$ sed -e '1,10s/enchantment/entrapment/g' myfile2.txt 
上例将导致用短语 'entrapment' 替换所有出现的短语 'enchantment'，但是只在第一到第十行（包括这两行）上这样做。
$ sed -e '/^$/,/^END/s/hills/mountains/g' myfile3.txt 
该例将用 'mountains' 替换 'hills'，但是，只从空行开始，到以三个字符 'END' 开始的行结束（包括这两行）的文本块上这样做。
关于 's///' 命令的另一个妙处是 '/' 分隔符有许多替换选项。如果正在执行字符串替换，并且规则表达式或替换字符串中有许多斜杠，则可以通过在 's' 之后指定一个不同的字符来更改分隔符。例如，下例将把所有出现的 /usr/local 替换成 /usr：
$ sed -e 's:/usr/local:/usr:g' mylist.txt 
在该例中，使用冒号作为分隔符。如果需要在规则表达式中指定分隔符字符，可以在它前面加入反斜杠。
规则表达式混乱
目前为止，我们只执行了简单的字符串替换。虽然这很方便，但是我们还可以匹配规则表达式。例如，以下 sed 命令将匹配从 '<' 开始、到 '>' 结束、并且在其中包含任意数量字符的短语。下例将删除该短语（用空字符串替换）：
$ sed -e 's/<.*>//g' myfile.html 
这是要从文件除去 HTML 标记的第一个很好的 sed 脚本尝试，但是由于规则表达式的特有规则，它不会很好地工作。原因何在？当 sed 试图在行中匹配规则表达式时，它要在行中查找最长的匹配。在我的前一篇 sed 文章中，这不成问题，因为我们使用的是 'd' 和 'p' 命令，这些命令总要删除或打印整行。但是，在使用 's///' 命令时，确实有很大不同，因为规则表达式匹配的整个部分将被目标字符串替换，或者，在本例中，被删除。这意味着，上例将把下行：
<b>This</b> is what <b>I</b> meant. 
变成：
meant. 
我们要的不是这个，而是：
This is what I meant. 
幸运的是，有一种简便方法来纠正该问题。我们不输入“'<' 字符后面跟有一些字符并以 '>' 字符结束”的规则表达式，而只需输入一个“'<' 字符后面跟有任意数量非 '>' 字符并以 '>' 字符结束”的规则表达式。这将与最短、而不是最长的可能性匹配。新命令如下：
$ sed -e 's/<[^>]*>//g' myfile.html 
在上例中，'[^>]' 指定“非 '>'”字符，其后的 '*' 完成该表达式以表示“零或多个非 '>' 字符”。对几个 html 文件测试该命令，将它们管道输出到 "more"，然后仔细查看其结果。
更多字符匹配
'[ ]' 规则表达式语法还有一些附加选项。要指定字符范围，只要字符不在第一个或最后一个位置，就可以使用 '-'，如下所示：
'[a-x]*' 
这将匹配零或多个全部为 'a'、'b'、'c'...'v'、'w'、'x' 的字符。另外，可以使用 '[:space:]' 字符类来匹配空格。以下是可用字符类的相当完整的列表：
字符类 描述 
[:alnum:] 字母数字 [a-z A-Z 0-9] 
[:alpha:] 字母 [a-z A-Z] 
[:blank:] 空格或制表键 
[:cntrl:] 任何控制字符 
[:digit:] 数字 [0-9] 
[:graph:] 任何可视字符（无空格） 
[:lower:] 小写 [a-z] 
[:print:] 非控制字符 
[:punct:] 标点字符 
[:space:] 空格 
[:upper:] 大写 [A-Z] 
[:xdigit:] 十六进制数字 [0-9 a-f A-F] 
尽可能使用字符类是很有利的，因为它们可以更好地适应非英语 locale（包括某些必需的重音字符等等）.
高级替换功能
我们已经看到如何执行简单甚至有些复杂的直接替换，但是 sed 还可以做更多的事。实际上可以引用匹配规则表达式的部分或全部，并使用这些部分来构造替换字符串。作为示例，假设您正在回复一条消息。下例将在每一行前面加上短语 "ralph said: "：
$ sed -e 's/.*/ralph said: &/' origmsg.txt 
输出如下： 
ralph said: Hiya Jim, ralph said: ralph said: 
I sure like this sed stuff! ralph said: 
该例的替换字符串中使用了 '&' 字符，该字符告诉 sed 插入整个匹配的规则表达式。因此，可以将与 '.*' 匹配的任何内容（行中的零或多个字符的最大组或整行）插入到替换字符串中的任何位置，甚至多次插入。这非常好，但 sed 甚至更强大。
那些极好的带反斜杠的圆括号
's///' 命令甚至比 '&' 更好，它允许我们在规则表达式中定义区域，然后可以在替换字符串中引用这些特定区域。作为示例，假设有一个包含以下文本的文件：
foo bar oni eeny meeny miny larry curly moe jimmy the weasel 
现在假设要编写一个 sed 脚本，该脚本将把 "eeny meeny miny" 替换成 "Victor eeny-meeny Von miny" 等等。要这样做，首先要编写一个由空格分隔并与三个字符串匹配的规则表达式。
'.* .* .*' 
现在，将在其中每个感兴趣的区域两边插入带反斜杠的圆括号来定义区域：
'(.*) (.*) (.*)' 
除了要定义三个可在替换字符串中引用的逻辑区域以外，该规则表达式的工作原理将与第一个规则表达式相同。下面是最终脚本：
$ sed -e 's/(.*) (.*) (.*)/Victor 1-2 Von 3/' myfile.txt 
如您所见，通过输入 'x'（其中，x 是从 1 开始的区域号）来引用每个由圆括号定界的区域。输入如下：
Victor foo-bar Von oni Victor eeny-meeny Von miny Victor larry-curly Von moe Victor jimmy-the Von weasel 
随着对 sed 越来越熟悉，您可以花最小力气来进行相当强大的文本处理。您可能想如何使用熟悉的脚本语言来处理这种问题 -- 能用一行代码轻易实现这样的解决方案吗？
组合使用
在开始创建更复杂的 sed 脚本时，需要有输入多个命令的能力。有几种方法这样做。首先，可以在命令之间使用分号。例如，以下命令系列使用 '=' 命令和 'p' 命令，'=' 命令告诉 sed 打印行号，'p' 命令明确告诉 sed 打印该行（因为处于 '-n' 模式）。
$ sed -n -e '=;p' myfile.txt 
无论什么时候指定了两个或更多命令，都按顺序将每个命令应用到文件的每一行。在上例中，首先将 '=' 命令应用到第 1 行，然后应用 'p' 命令。接着，sed 继续处理第 2 行，并重复该过程。虽然分号很方便，但是在某些场合下，它不能正常工作。另一种替换方法是使用两个 -e 选项来指定两个不同的命令：
$ sed -n -e '=' -e 'p' myfile.txt 
然而，在使用更为复杂的附加和插入命令时，甚至多个 '-e' 选项也不能帮我们的忙。对于复杂的多行脚本，最好的方法是将命令放入一个单独的文件中。然后，用 -f 选项引用该脚本文件：
$ sed -n -f mycommands.sed myfile.txt 
这种方法虽然可能不太方便，但总是管用。
一个地址的多个命令
有时，可能要指定应用到一个地址的多个命令。这在执行许多 's///' 以变换源文件中的字和语法时特别方便。要对一个地址执行多个命令，可在文件中输入 sed 命令，然后使用 '{ }' 字符将这些命令分组，如下所示：
1,20{ s/[Ll]inux/GNU/Linux/g s/samba/Samba/g s/posix/POSIX/g } 
上例将把三个替换命令应用到第 1 行到第 20 行（包括这两行）。还可以使用规则表达式地址或者二者的组合：
1,/^END/{ s/[Ll]inux/GNU/Linux/g s/samba/Samba/g s/posix/POSIX/g p } 
该例将把 '{ }' 之间的所有命令应用到从第 1 行开始，到以字母 "END" 开始的行结束（如果在源文件中没发现 "END"，则到文件结束）的所有行。
附加、插入和更改行
既然在单独的文件中编写 sed 脚本，我们可以利用附加、插入和更改行命令。这些命令将在当前行之后插入一行，在当前行之前插入一行，或者替换模式空间中的当前行。它们也可以用来将多行插入到输出。插入行命令用法如下：
i This line will be inserted before each line 
如果不为该命令指定地址，那么它将应用到每一行，并产生如下的输出：
This line will be inserted before each line line 1 here 
This line will be inserted before each line line 2 here 
This line will be inserted before each line line 3 here 
This line will be inserted before each line line 4 here 
如果要在当前行之前插入多行，可以通过在前一行之后附加一个反斜杠来添加附加行，如下所示：
i insert this line and this one and this one and, uh, this one too. 
附加命令的用法与之类似，但是它将把一行或多行插入到模式空间中的当前行之后。其用法如下：
a insert this line after each line. Thanks! :) 
另一方面，“更改行”命令将实际替换模式空间中的当前行，其用法如下：
c You're history, original line! Muhahaha! 
因为附加、插入和更改行命令需要在多行输入，所以将把它们输入到一个文本 sed 脚本中，然后通过使用 '-f' 选项告诉 sed 执行它们。使用其它方法将命令传递给 sed 会出现问题。
下一篇
在下一篇、也是本 sed 系列的最后一篇文章中，我将为您演示许多使用 sed 来完成不同类型任务的极佳实例。我将不仅为您显示脚本做些什么，还显示为什么那样做。完成之后，您将掌握更多有关如何在不同项目中使用 sed 的极佳知识。到时候见！
在这篇 sed 系列的总结性文章中，Daniel Robbins 带您体验 sed 的真正力量。在介绍完几个重要的 sed 脚本之后，他将通过将一个 Quicken .QIF 文件转换成可读文本格式来演示一些基本 sed 脚本的编写。该转换脚本不仅实用，而且还是展现 sed 脚本编写能力的极佳示例。
强健的 sed
在第二篇 sed 文章中，我提供了一些示例来演示 sed 的工作原理，但是它们当中很少有示例能实际做特别有用的事。在这篇 sed 系列的最后文章中，我要改变那种方式，并使用 sed 来做实际的事。我将为您显示几个示例，它们不仅演示 sed 的能力，而且还做一些真正巧妙（和方便）的事。例如，在本文的后半部，将为您演示如何设计一个 sed 脚本来将 .QIF 文件从 Intuit 的 Quicken 金融程序转换成具有良好格式的文本文件。在那样做之前，我们将看一下不怎么复杂但却很有用的 sed 脚本。
文本转换
第一个实际脚本将 UNIX 风格的文本转换成 DOS/Windows 格式。您可能知道，基于 DOS/Windows 的文本文件在每一行末尾有一个 CR（回车）和 LF（换行），而 UNIX 文本只有一个换行。有时可能需要将某些 UNIX 文本移至 Windows 系统，该脚本将为您执行必需的格式转换。
$ sed -e 's/$/ /' myunix.txt > mydos.txt 
在该脚本中，'$' 规则表达式将与行的末尾匹配，而 ' ' 告诉 sed 在其之前插入一个回车。在换行之前插入回车，立即，每一行就以 CR/LF 结束。请注意，仅当使用 GNU sed 3.02.80 或以后的版本时，才会用 CR 替换 ' '。如果还没有安装 GNU sed 3.02.80，请在我的第一篇 sed 文章中查看如何这样做的说明。
我已记不清有多少次在下载一些示例脚本或 C 代码之后，却发现它是 DOS/Windows 格式。虽然很多程序不在乎 DOS/Windows 格式的 CR/LF 文本文件，但是有几个程序却在乎 -- 最著名的是 bash，只要一遇到回车，它就会出问题。以下 sed 调用将把 DOS/Windows 格式的文本转换成可信赖的 UNIX 格式：
$ sed -e 's/.$//' mydos.txt > myunix.txt 
该脚本的工作原理很简单：替代规则表达式与一行的最末字符匹配，而该字符恰好就是回车。我们用空字符替换它，从而将其从输出中彻底删除。如果使用该脚本并注意到已经删除了输出中每行的最末字符，那么，您就指定了已经是 UNIX 格式的文本文件。也就没必要那样做了！
反转行
下面是另一个方便的小脚本。与大多数 Linux 发行版中包括的 "tac" 命令一样，该脚本将反转文件中行的次序。"tac" 这个名称可能会给人以误导，因为 "tac" 不反转行中字符的位置（左和右），而是反转文件中行的位置（上和下）。用 "tac" 处理以下文件：
foo bar oni 
....将产生以下输出：
oni bar foo 
可以用以下 sed 脚本达到相同目的： 
$ sed -e '1!G;h;$!d' forward.txt > backward.txt 
如果登录到恰巧没有 "tac" 命令的 FreeBSD 系统，将发现该 sed 脚本很有用。虽然方便，但最好还是知道该脚本为什么那样做。让我们对它进行讨论。
反转解释
首先，该脚本包含三个由分号隔开的单独 sed 命令：'1!G'、'h' 和 '$!d'。现在，需要好好理解用于第一个和第三个命令的地址。如果第一个命令是 '1G'，则 'G' 命令将只应用第一行。然而，还有一个 '!' 字符 -- 该 '!' 字符忽略该地址，即，'G' 命令将应用到除第一行之外的所有行。'$!d' 命令与之类似。如果命令是 '$d'，则将只把 'd' 命令应用到文件中的最后一行（'$' 地址是指定最后一行的简单方式）。然而，有了 '!' 之后，'$!d' 将把 'd' 命令应用到除最后一行之外的所有行。现在，我们所要理解的是这些命令本身做什么。
当对上面的文本文件执行反转脚本时，首先执行的命令是 'h'。该命令告诉 sed 将模式空间（保存正在处理的当前行的缓冲区）的内容复制到保留空间（临时缓冲区）。然后，执行 'd' 命令，该命令从模式空间中删除 "foo"，以便在对这一行执行完所有命令之后不打印它。
现在，第二行。在将 "bar" 读入模式空间之后，执行 'G' 命令，该命令将保留空间的内容 ("foo ") 附加到模式空间 ("bar ")，使模式空间的内容为 "bar foo "。'h' 命令将该内容放回保留空间保护起来，然后，'d' 从模式空间删除该行，以便不打印它。
对于最后的 "oni" 行，除了不删除模式空间的内容（由于 'd' 之前的 '$!'）以及将模式空间的内容（三行）打印到标准输出之外，重复同样的步骤。
现在，要用 sed 执行一些强大的数据转换。
sed QIF 魔法
过去几个星期，我一直想买一份 Quicken 来结算我的银行帐户。Quicken 是一个非常好的金融程序，当然会成功地完成这项工作。但是，经过考虑之后，我觉得自己可以轻易编写某个软件来结算我的支票簿。我想，毕竟，我是个软件开发人员！
我开发了一个很好的小型支票簿结算程序（使用 awk），它通过分析包含我的所有交易的文本文件的语法来计算余额。略微调整之后，我将其改进，以便可以象 Quicken 那样跟踪不同的贷款和借款类别。但是，我还要添加一个特性。最近，我将帐户转移到一家有联机 Web 帐户界面的银行。有一天，我注意到，这家银行的 Web 站点允许以 Quicken 的 .QIF 格式下载我的帐户信息。我马上觉得，如果可以将该信息转换成文本格式，那就太棒了。
两种格式的故事
在查看 QIF 格式之前，先看一下我的 checkbook.txt 格式：
28 Aug 2000 food - - Y Supermarket 30.94 25 Aug 2000 watr - 103 Y Check 103 52.86 
在我的文件中，所有字段都由一个或多个制表符分开，每个交易占据一行。日期之后的下一个字段列出支出类型（如果是收入项，则为 "-"）。第三个字段列出收入类型（如果是支出项，则为 "-"）。然后，是一个支票号字段（如果为空，则还是 "-"），一个交易完成字段（"Y" 或 "N"），一个注释和一个美元金额字段。现在，让我们看一下 QIF 格式。当用文本查看器查看下载的 QIF 文件时，它看起来如下：
!Type:Bank D08/28/2000 T-8.15 N PCHECKCARD SUPERMARKET ^ D08/28/2000 T-8.25 N PCHECKCARD PUNJAB RESTAURANT ^ D08/28/2000 T-17.17 N PCHECKCARD SUPERMARKET 
浏览过文件之后，不难猜出其格式 -- 忽略第一行，其余的格式如下： 
D<数据> 
T<交易量> 
N<支票号> 
P<描述> 
^ （这是字段分隔符） 
开始处理
在处理象这样重要的 sed 项目时，不要气馁 -- sed 允许您将数据逐渐修改成最终形式。在进行当中，可以继续细化 sed 脚本，直到输出与预期的完全一样为止。无需在试第一次时就保证其完全正确。
要开始，首先创建一个名为 "qiftrans.sed" 的文件，然后开始修改数据： 
1d /^^/d s/[[:cntrl:]]//g 
第一个 '1d' 命令删除第一行，第二个命令从输出除去那些讨厌的 '^' 字符。最后一行除去文件中可能存在的任何控制字符。既然在处理外来文件格式，我想消除在中途遇到任何控制字符的风险。到目前为止，一切顺利。现在，要向该基本脚本中添加一些处理功能：
1d /^^/d s/[[:cntrl:]]//g /^D/ { 
s/^D(.*)/1 OUTY INNY / 
s/^01/Jan/ s/^02/Feb/
s/^03/Mar/ s/^04/Apr/
s/^05/May/ s/^06/Jun/ 
s/^07/Jul/ s/^08/Aug/ 
s/^09/Sep/ s/^10/Oct/
s/^11/Nov/ s/^12/Dec/ 
s:^(.*)/(.*)/(.*):2 1 3: } 
首先，添加一个 '/^D/' 地址，以便 sed 只在遇到 QIF 数据字段的第一个字符 'D' 时才开始处理。当 sed 将这样一行读入其模式空间时，将按顺序执行花括号中的所有命令。
花括号中的第一个命令将把如下行：
D08/28/2000 
变换成： 
08/28/2000 OUTY INNY 
当然，现在的格式还不完美，但没关系。我们将在进行过程中逐渐细化模式空间的内容。后面 12 行的最后效果是将数据变换成三个字母的格式，最后一行从数据中除去三个斜杠。最后得到这一行：
Aug 28 2000 OUTY INNY 
OUTY 和 INNY 字段是占位符，以后将被替换。现在还不能确定它们，因为如果美元金额为负，将把 OUTY 和 INNY 设置成 "misc" 和 "-"，但是，如果美元金额为正，将分别把它们更改成 "-" 和 "inco"。既然还没有读入美元金额，所以，需要暂时使用占位符。
细化
现在进一步细化： 
1d /^^/d s/[[:cntrl:]]//g /^D/ {
s/^D(.*)/1 OUTY INNY / 
s/^01/Jan/ s/^02/Feb/
s/^03/Mar/ s/^04/Apr/
s/^05/May/ s/^06/Jun/
s/^07/Jul/ s/^08/Aug/
s/^09/Sep/ s/^10/Oct/
s/^11/Nov/ s/^12/Dec/
s:^(.*)/(.*)/(.*):2 1 3:
N N N 
s/ T(.*) N(.*) P(.*)/NUM2NUM Y 3 AMT1AMT/
s/NUMNUM/-/ s/NUM([0-9]*)NUM/1/
s/([0-9]),/1/ } 
后七行有些复杂，所以将详细讨论它们。首先，连续使用三个 'N' 命令。'N' 命令告诉 sed 将下一行读入输入中，然后将其附加到当前模式空间。这三个 'N' 命令导致将下三行附加到当前模式空间缓冲区，现在这一行看起来如下：
28 Aug 2000 OUTY INNY T-8.15 N PCHECKCARD SUPERMARKET 
sed 的模式空间变得很难看 -- 需要除去额外的新行，并执行某些附加的格式化。要这样做，将使用替代命令。要匹配的模式为：
' T.* N.* P.*' 
这将与后面依次跟有 'T'、零或多个字符、新行、'N'、任何数量的字符、新行、'P'、以及任何数量字符的新行匹配。呀！这个规则表达式将与刚刚附加到模式空间的三行的全部内容匹配。但我们要重新格式化该区域，而不是整个替换它。美元金额、支票号（如果有的话）和描述需要出现在替换字符串中。要这样做，我们用带有反斜杠的圆括号括起那些“感兴趣部分”，以便可以在替换字符串中引用它们（使用 '1'、'2 和 '3' 来告诉 sed 将它们插入到何处）。以下是最后的命令：
s/ T(.*) N(.*) P(.*)/NUM2NUM Y 3 AMT1AMT/ 
该命令将我们的行变换成： 
28 Aug 2000 OUTY INNY NUMNUM Y CHECKCARD SUPERMARKET AMT-8.15AMT 
虽然该行正变得好一些，但是，有几件事一看就有点...啊...有趣。首先是那个愚蠢的 "NUMNUM" 字符串 -- 其目的何在？如果查看 sed 脚本的后两行，就会发现其目的，后两行将把 "NUMNUM" 替换成 "-"，而把 "NUM"<number>"NUM" 替换成 <number>。如您所见，用愚蠢的标记括起支票号允许我们在该字段为空时方便地插入一个 "-"。
结束尝试
最后一行除去数字后的逗号。它把如 "3,231.00" 这样的美元金额转换成我使用的格式 "3231.00"。现在，让我们看一下最终脚本：
最终的“QIF 到文本”脚本 1d /^^/d s/[[:cntrl:]]//g /^D/ { s/^D(.*)/1 OUTY INNY / 
s/^01/Jan/ s/^02/Feb/ s/^03/Mar/ s/^04/Apr/ s/^05/May/ 
s/^06/Jun/ s/^07/Jul/ s/^08/Aug/ s/^09/Sep/ s/^10/Oct/ 
s/^11/Nov/ s/^12/Dec/ s:^(.*)/(.*)/(.*):2 1 3: 
N N N s/ T(.*) N(.*) P(.*)/NUM2NUM Y 3 AMT1AMT/ 
s/NUMNUM/-/ s/NUM([0-9]*)NUM/1/ s/([0-9]),/1/ 
/AMT-[0-9]*.[0-9]*AMT/b fixnegs 
s/AMT(.*)AMT/1/ s/OUTY/-/ s/INNY/inco/ 
b done :fixnegs s/AMT-(.*)AMT/1/ s/OUTY/misc/ 
s/INNY/-/ :done } 
附加的十一行使用替代和一些分支功能来美化输出。首先看一下这行： 
/AMT-[0-9]*.[0-9]*AMT/b fixnegs 
该行包含一个格式为 "/regexp/b label" 的分支命令。如果模式空间与规则表达式匹配，sed 将分支到 fixnegs 标号。您应该可以轻易找到该标号，它在代码中为 ":fixnegs"。如果规则表达式不匹配，则以常规方式继续处理下一个命令。
既然您理解该命令本身的工作原理，让我们看一下分支。如果看一下分支规则表达式，将看到它与后面依次跟有 '-'、任意数量的数字、一个 '.'、任意数量的数字和 'AMT' 的字符串 'AMT' 匹配。就象我确信您已猜到一样，该规则表达式专门处理负的美元金额。在这之前，用 'ATM' 括起美元金额，以便以后可以轻易找到它。因为规则表达式只与以 '-' 开始的美元金额匹配，所以，该分支只在恰巧处理借款时才发生。如果正处理贷款，应该将 OUTY 设置成 'misc'，将 INNY 设置成 '-'，并且应该除去贷款数量前面的负号。如果跟踪代码的流程，将看到实际情况正是这样。如果不执行分支，则用 '-' 替换 OUTY，用 'inco' 替换 INNY。完成了！现在输出行是完美的：
28 Aug 2000 misc - - Y CHECKCARD SUPERMARKET -8.15 
别犯糊涂
如您所见，只要循序渐进地解决问题，使用 sed 转换数据就没有那么难。不要试图使用一个 sed 命令或一下子解决所有问题。相反，要朝着目标逐步进行，并不断改进 sed 脚本，直到其输出正如您希望那样为止。sed 有许多功能，希望您已非常熟悉其内部工作原理并继续努力以进一步掌握它！ 
[]     
    
几个shell程序设计小知识(shell常识部分)
文章整理: 文章来源: 网络 
一、用户登陆进入系统后的系统环境变量： 
$HOME 使用者自己的目录 
$PATH 执行命令时所搜寻的目录 
$TZ 时区 
$MAILCHECK 每隔多少秒检查是否有新的信件 
$PS1 在命令列时的提示号 
$PS2 当命令尚未打完时，Shell 要求再输入时的提示号 
$MANPATH man 指令的搜寻路径 
二、特殊变量： 
$0 这个程序的执行名字 
$n 这个程序的第n个参数值，n=1..9 
$* 这个程序的所有参数 
$# 这个程序的参数个数 
$$ 这个程序的PID 
$! 执行上一个指令的PID 
$? 执行上一个指令的返回值 
三、shell中的变元： 
* 任意字符串 
? 一个任意字符 
[abc] a, b, c三者中之一 
[a-n] 从a到n的任一字符 
四、几个特殊字符表示 
\b 退回 
\c 打印一行时没有换行符 这个我们经常会用到 
\f 换页 
\r 回车 
\t 制表 
\v 垂直制表 
\\ 反斜线本身 
五、判断文件的属性 
格式：-操作符 filename 
-e 文件存在返回1， 否则返回0 
-r 文件可读返回1,否则返回0 
-w 文件可写返回1,否则返回0 
-x 文件可执行返回1,否则返回0 
-o 文件属于用户本人返回1, 否则返回0 
-z 文件长度为0返回1, 否则返回0. 
-f 文件为普通文件返回1, 否则返回0 
-d 文件为目录文件时返回1, 否则返回0 
六、测试字符串 
字符串1 = 字符串2　当两个字串相等时为真 
字符串1 != 字符串2 当两个字串不等时为真 
-n 字符串　 　　　 当字符串的长度大于0时为真 
-z 字符串　　　　　 当字符串的长度为0时为真 
字符串　　　　　　 当串字符串为非空时为真 
七、测试两个整数关系 
数字1 -eq 数字2　　　　 两数相等为真 
数字1 -ne 数字2　　　　 两数不等为真 
数字1 -gt 数字2　　　　 数字1大于数字2为真 
数字1 -ge 数字2 　　　 数字1大于等于数字2为真 
数字1 -lt 数字2　　　　 数字1小于数字2为真 
数字1 -le 数字2　　　　 数字1小于等于数字2为真 
八、逻辑测试 
-a 　 　　　　　 与 
-o　　　　　　　 或 
!　　　　　　　　非 
今天介绍shell特殊字符的引用 
=============================== 
shell中的特殊字符有 
1、$ 美元符 
2、\ 反斜杠 
3、` 反引号 
4、"　双引号 
5、< ,>,*,?,[,] 
下面我一一举列说明 
一、$符号 
1、echo $? 显示的是上一条指令退出状态 
2、echo "$?" 效果同上 
3、echo '$?' 显示的是$? 
4、echo \$? 显示的是$? 
5、echo "\$?" 显示的是$? 
　　大家可能已经看出　$符号在双引号中具有特殊意义　双引号对$符号不起作用 
而单引号可以将特殊字符的的特殊意义屏蔽掉，使其能显示为字符本身，反斜 
杠也可以将特殊字符的特殊含义屏蔽掉，使特殊字符失去特殊含义。 
二、\　反斜杠 
　　反斜杠的作用是将特殊符号字符的特殊含义屏蔽掉，使其还是原字符 
A＝1234 
echo \$A 显示为$A 如果不加\将显示为1234 
echo \` 显示为` 
echo \" 显示为双引号 
echo \\ 显示为\ 
三、` 反引号 
　　反引号的功能是命令替换，将反引号中的字符串做为命令来执行，我们在用shell编程时经常用的到　将系统命令的执行结果赋给一个变量 
A=`date` 
echo $A 显示的不是date而是当时的时间串 
比如有一文件A的内容如下　 
ABCDEFG 
1234456 
abcdefg 
B=`cat A|grep 234` # 检索文件A中含有字符串234的行 
echo $B 将显示为1234456 
echo "$B" 将显示为什么？ 
echo "\$B" 将显示为什么？读者自己试试 
四、" 双引号 
　　在系统中有些特殊字符，为避免引用这些特殊字符　往往用双引号或单引号将这些特殊字符引起来，使其不具有特殊含义。 
　　但有一部分特殊字符在引号中还是具有特殊含义，用双引号引起来是不起作用的。本文中所列的前四个特殊字符在双引号中还是特殊字符。为了使其不具有特殊含义一是用单引号引进来二是用\反斜线使其失去作用。 
　　比如我们想原样输出这些特殊字符 
echo """ 
echo "$" 
echo "\" 
echo "`" 
　　　以上不是你所期望的结果，因为双引号对它们不起作用，你只能这样才能输出这些特殊字符的原形 
echo '"' 
echo '$' 
echo '\' 
echo '`' 
或 
echo "\"" 
echo "\$" 
echo "\\" 
echo "\`" 
将分别显示为　" $ \ ` 
五、其它特殊字符 
　　大家注意到　除了前四个特殊字符外　我将其它的特殊字符都放在一块，这是因为前四个特殊字符在双引号中还是具有特殊含义，所以单独拿出来讲，除此以外的特殊字符如果你要输出这些特殊字符的原形，你就可以用双引号或单引号引起来使其失去特殊含义。 
< ,>,*,?,[,]对shell有特殊含义　但你可以用双引号引起来输入这些原形 
　　讲了这么多大家是不是已经注意到所有的特殊字符在单引号中失去特殊含义，如果你要输出特殊字符原形但又记不清那些特殊字符在双引号中不能输出原形，建议你干脆用单引号引起来。
今天介绍条件测试语句 
一、if 条件语句　 
格式： 
if 条件表达式 
then #当条件为真时执行以下语句 
命令列表 
else #为假时执行以下语句 
命令列表 
fi 
if　语句也可以嵌套使用 
if 条件表达式1 
then 
if 条件表达式2 
then 
命令列表 
else 
if 条件表达式3 
then 
命令列表 
else 
命令列表 
fi 
fi 
else 
命令列表 
fi 
你可以进行多层嵌套　一个if语句一定要跟一个fi　表示该层条件结束　　否则会造成语法错误 
结合前面讲的　举例如下： 
这里先讲一个条件语句中用到的命令test　表示测试test后面的条件是否为真 
if test -f "$1" 
then 
lpr $1 
else 
if test -d "$1" 
then 
cd $1 
lpr $1 
else 
echo "$1不是文件或目录" 
fi 
fi 
以上的例子还可以改成如下所示 
if test -f "$1" 
then 
lpr $1 
elif test -d "$1" #elif　同else if 
then 
(cd $1;lpr $1) 
else 
echo "$1不是文件或目录" 
fi 
以上的例子不知您是否看懂是什么意思吗？ 
假如我们现在将这个例子保存为prfile 
chmod +x prfile 
执行刚才的程序 
./prfile aaa 
这个例子是检查你的输入的参数是否是一个文件　如果是就打印　如果是一个目录　先转目录再打印　如果即不是文件也不是目录给出提示 
二、多重条件测试语句case 
格式： 
case 字串　in 
模式) 命令列表;; 
模式) 命令列表;; 
.... 
esac 
多重条件语句是以case 开始以esac结束　中间可以有多个条件列表　功能是测试字串和和里面的模式有没有匹配的,有就执行里面的命令列表　模式也可以是*号　表示任意字串，每个模式里面的最后要心;;双引号结束，否则会发生语法错误。 
现举例如下： 
case $1 in 
*.c) 
cc $1 
;; 
*.txt) 
lpr $1 
;; 
*) 
echo "未知的类型" 
esac 
假如将以上内容保存在文件abc中 
chmod +x abc 
执行　./abc a.c 　 将会对文件a.c进行编译 
执行 ./abc readme.txt　将会把文件通过打印机 
假如我将以上内容改一下，你是否会知道它的执行结果？ 
case $1 in 
*) 
cc $1 
;; 
*.txt) 
lpr $1 
;; 
*.c) 
echo "未知的类型" 
esac 
今天介绍循环语句 
一. while 循环 
while 命令格式 
while 条件表 
do 
命令表 
done 
执行过程 
shell首先执行条件表,如果条件表的最后一条语句的退出状态为零,则执行盾环体内的命令 
表,执行完后,再检查条件表,如果退出状态为零将继续执行,如此循环往复直到条件表的 
最后一条语句的退出状态非零. 退出状态为零就是条件为真True. 
举例说明 假如shell文件的内容如下: 
Sum=0 
i=0 
while true #true是系统的关键词 表示真 
do 
i=`expr $i + 1` 
Sum=`expr $Sum + $i` 
if [ $i = "100" ] 
then 
break; 
fi 
done 
echo $i $Sum 
最后这个程序显示的是 100 5050 
这个程序的运算就是将1到100加起来 
下面将这个程序再改动一下 
Sum=0 
i=0 
while [ $i != "100" ] 
do 
i=`expr $i + 1` 
Sum=`expr $Sum + $i` 
done 
echo $i $Sum 
改动后的程序运算结果和上面是一样 但程序比上面的要简练 
在这个循环中还可以以until做为测试条件 它正好与while测试的条件相反,也就是当条件为假时将继续执行循环体内的语句,否则就退出循环体,下面还用这个例子. 
Sum=0 
i=0 
until [ $i = "100" ] 
do 
i=`expr $i + 1` 
Sum=`expr $Sum + $i` 
done 
echo $i $Sum 
当i不等于100时循环 就是当条件为假时循环,否则就退出,而第一个例子是当i不等于100 
时循环,也就是测试条件为真时循环. 
二.for 循环 
命令格式: 
for 变量 in 名字列表 
do 
命令列表 
done 
这里的名字列表是一个由空格分隔的字符串列表,shell在执行for循环时每次依次从名字表 
中取出一个字符串赋给循环变量作为变量的值. 
在写for语句时,也可以省略in 名字列表部分,这表示用当前的位置参数来代替这时的名 
字列表. 
下面举个例子 
比如在你的电脑中有两个目录,一个是aa,一个是bb在这两个目录中有5个相同的文件,但其 
中一个目录中的一个或多个文件刚刚修改过,现在我忘记刚才改的是那几个文件 了,那么我靠梢员冉弦幌抡饬礁瞿柯嫉奈募就知道?程序如下: 
for File in a1 a2 a3 a4 a5 
do 
diff aa/$File bb/$File 
done 
下面再举一个不带名字列表的例子 
for File 
do 
echo $Filw 
done 
文件内容保存在a.sh中 并可执行 
我们在执行这个shell程序时命令行如下: 
a.sh a1 a2 a3 a4 a5 
执行结果如下: 
a1 
a2 
a3 
a4 
a5 
大家从这个例子中可以看到命令行的参数被逐一读入一次 
三.循环控制语句 
break 命令不执行当前循环体内break下面的语句从当前循环退出. 
continue 命令是程序在本循体内忽略下面的语句,从循环头开始执行. 
一,命令组合:圆括号和花括号 
shell中有两种方法将命令组合在一起:圆括号和花括号.圆括号使shell创建一个子shell 
来读取并执行括起来的名命令.左括号和右括号不论出现在命令行中的什么位置,shell都会 
认为它们具有特殊的组合意义的.只有用双引号将它们括起来引用,才表示圆括号或花括号 
的原义.例如: 
echo a(b) 
将出现语法上的错误,要想输出a(b)字符串 只能括起来 
echo "a(b)" 
或echo a"("b")" 
这样才能被shell正确解释. 
利用组合命令有什么作用呢? 
一,用圆括号组合命令 
圆括号的组合命令可以创建子进程运行组合程序,建立子进程的功能是很有用的,因为 
子shell在组合命令中的种种操作都不会影响到当前shell的各变量的值. 
例如: 
子进程在执行组合命令时改变了工作目录,并在新的工作目录下执行一系例命令,执行 
完后它可以不必返回原工作目录,因为子进程工作目录的改变不会影响到当前工作目录. 
创建子进程后将当前的环境也同样传给子shell,当前shell中用export输出到环境中的 
各变量在子shell中同样有效. 
花括号也可以将命令组合在一起.左 右花括号只有作为一条命令的第一个字出现时, 
shell才它们含有特殊含义. 
与圆括号不同的是花括号并不创建子shell,只是由当前的shell来读取并执行括起来的 
命令.有时用户希望使用一组命令的顺序输出作为另一组命令的输入,此时用花括号是很方 
便的. 
不论是用圆括号不是花括号,退出状态都是等于最后一条括起来的命令的退出状态. 
二,可以在当前shell中执行的命令 
用户在使用shell时一定要了解那些是可以在当前shell中执行的命令 那些不可以 
可以在当前shell中执行的命令有: 
break case cd continue 
echo eval exec exit 
export for if read 
readonly return set shift 
test times trap umask 
until wait while 
: {} 
[]     
    
linux和unix的shell实例
文章整理: 文章来源: 网络 
文件:UNIXshell.zip
大小:72KB
下载:下载
[]     
    
shell版俄罗斯方块
文章整理: 文章来源: 网络 
把注释加进去了，可能不是很详尽，
只希望能把问题表现的清楚一点
感谢各位兄弟的捧场，
属于旧瓶装新酒了，呵呵
如果你的终端可以显示出颜色，效果会好点
运行于GNU bash, version 2.05a.0(1)-release (i686-pc-linux-gnu)
---------------------------------------------------
果然在新的ubuntu下不能运行了，需要将类似\33的地方改成\033,
感谢网友thinux和guotao_buaa帮忙修改，已经将新的代码补入。 
[code]#!/bin/bash
# Tetris Game
# 10.21.2003 xhchen<[email]xhchen@winbond.com.tw[/email]>
#APP declaration
APP_NAME="${0##*[\\/]}"
APP_VERSION="1.0"
#颜色定义
cRed=1
cGreen=2
cYellow=3
cBlue=4
cFuchsia=5
cCyan=6
cWhite=7
colorTable=($cRed $cGreen $cYellow $cBlue $cFuchsia $cCyan $cWhite)
#位置和大小
iLeft=3
iTop=2
((iTrayLeft = iLeft + 2))
((iTrayTop = iTop + 1))
((iTrayWidth = 10))
((iTrayHeight = 15))
#颜色设置
cBorder=$cGreen
cScore=$cFuchsia
cScoreValue=$cCyan
#控制信号
#改游戏使用两个进程，一个用于接收输入，一个用于游戏流程和显示界面;
#当前者接收到上下左右等按键时，通过向后者发送signal的方式通知后者。
sigRotate=25
sigLeft=26
sigRight=27
sigDown=28
sigAllDown=29
sigExit=30
#七中不同的方块的定义
#通过旋转，每种方块的显示的样式可能有几种
box0=(0 0 0 1 1 0 1 1)
box1=(0 2 1 2 2 2 3 2 1 0 1 1 1 2 1 3)
box2=(0 0 0 1 1 1 1 2 0 1 1 0 1 1 2 0)
box3=(0 1 0 2 1 0 1 1 0 0 1 0 1 1 2 1)
box4=(0 1 0 2 1 1 2 1 1 0 1 1 1 2 2 2 0 1 1 1 2 0 2 1 0 0 1 0 1 1 1 2)
box5=(0 1 1 1 2 1 2 2 1 0 1 1 1 2 2 0 0 0 0 1 1 1 2 1 0 2 1 0 1 1 1 2)
box6=(0 1 1 1 1 2 2 1 1 0 1 1 1 2 2 1 0 1 1 0 1 1 2 1 0 1 1 0 1 1 1 2)
#所有其中方块的定义都放到box变量中
box=(${box0[@]} ${box1[@]} ${box2[@]} ${box3[@]} ${box4[@]} ${box5[@]} ${box6[@]})
#各种方块旋转后可能的样式数目
countBox=(1 2 2 2 4 4 4)
#各种方块再box数组中的偏移
offsetBox=(0 1 3 5 7 11 15)
#每提高一个速度级需要积累的分数
iScoreEachLevel=50 #be greater than 7
#运行时数据
sig=0 #接收到的signal
iScore=0 #总分
iLevel=0 #速度级
boxNew=() #新下落的方块的位置定义
cBoxNew=0 #新下落的方块的颜色
iBoxNewType=0 #新下落的方块的种类
iBoxNewRotate=0 #新下落的方块的旋转角度
boxCur=() #当前方块的位置定义
cBoxCur=0 #当前方块的颜色
iBoxCurType=0 #当前方块的种类
iBoxCurRotate=0 #当前方块的旋转角度
boxCurX=-1 #当前方块的x坐标位置
boxCurY=-1 #当前方块的y坐标位置
iMap=() #背景方块图表
#初始化所有背景方块为-1, 表示没有方块
for ((i = 0; i < iTrayHeight * iTrayWidth; i++)); do iMap[$i]=-1; done
#接收输入的进程的主函数
function RunAsKeyReceiver()
{
local pidDisplayer key aKey sig cESC sTTY
pidDisplayer=$1
aKey=(0 0 0)
cESC=`echo -ne "\033"`
cSpace=`echo -ne "\040"`
#保存终端属性。在read -s读取终端键时，终端的属性会被暂时改变。
#如果在read -s时程序被不幸杀掉，可能会导致终端混乱，
#需要在程序退出时恢复终端属性。
sTTY=`stty -g`
#捕捉退出信号
trap "MyExit;" INT TERM
trap "MyExitNoSub;" $sigExit
#隐藏光标
echo -ne "\033[?25l"
while :
do
#读取输入。注-s不回显，-n读到一个字符立即返回
read -s -n 1 key
aKey[0]=${aKey[1]}
aKey[1]=${aKey[2]}
aKey[2]=$key
sig=0
#判断输入了何种键
if [[ $key == $cESC && ${aKey[1]} == $cESC ]]
then
#ESC键
MyExit
elif [[ ${aKey[0]} == $cESC && ${aKey[1]} == "[" ]]
then
if [[ $key == "A" ]]; then sig=$sigRotate #<向上键>
elif [[ $key == "B" ]]; then sig=$sigDown #<向下键>
elif [[ $key == "D" ]]; then sig=$sigLeft #<向左键>
elif [[ $key == "C" ]]; then sig=$sigRight #<向右键>
fi
elif [[ $key == "W" || $key == "w" ]]; then sig=$sigRotate #W, w
elif [[ $key == "S" || $key == "s" ]]; then sig=$sigDown #S, s
elif [[ $key == "A" || $key == "a" ]]; then sig=$sigLeft #A, a
elif [[ $key == "D" || $key == "d" ]]; then sig=$sigRight #D, d
elif [[ "[$key]" == "[]" ]]; then sig=$sigAllDown #空格键
elif [[ $key == "Q" || $key == "q" ]] #Q, q
then
MyExit
fi
if [[ $sig != 0 ]]
then
#向另一进程发送消息
kill -$sig $pidDisplayer
fi
done
}
#退出前的恢复
function MyExitNoSub()
{
local y
#恢复终端属性
stty $sTTY
((y = iTop + iTrayHeight + 4))
#显示光标
echo -e "\033[?25h\033[${y};0H"
exit
}
function MyExit()
{
#通知显示进程需要退出
kill -$sigExit $pidDisplayer
MyExitNoSub
}
#处理显示和游戏流程的主函数
function RunAsDisplayer()
{
local sigThis
InitDraw
#挂载各种信号的处理函数
trap "sig=$sigRotate;" $sigRotate
trap "sig=$sigLeft;" $sigLeft
trap "sig=$sigRight;" $sigRight
trap "sig=$sigDown;" $sigDown
trap "sig=$sigAllDown;" $sigAllDown
trap "ShowExit;" $sigExit
while :
do
#根据当前的速度级iLevel不同，设定相应的循环的次数
for ((i = 0; i < 21 - iLevel; i++))
do
sleep 0.02
sigThis=$sig
sig=0
#根据sig变量判断是否接受到相应的信号
if ((sigThis == sigRotate)); then BoxRotate; #旋转
elif ((sigThis == sigLeft)); then BoxLeft; #左移一列
elif ((sigThis == sigRight)); then BoxRight; #右移一列
elif ((sigThis == sigDown)); then BoxDown; #下落一行
elif ((sigThis == sigAllDown)); then BoxAllDown; #下落到底
fi
done
#kill -$sigDown $$
BoxDown #下落一行
done
}
#BoxMove(y, x), 测试是否可以把移动中的方块移到(x, y)的位置, 返回0则可以, 1不可以
function BoxMove()
{
local j i x y xTest yTest
yTest=$1
xTest=$2
for ((j = 0; j < 8; j += 2))
do
((i = j + 1))
((y = ${boxCur[$j]} + yTest))
((x = ${boxCur[$i]} + xTest))
if (( y < 0 || y >= iTrayHeight || x < 0 || x >= iTrayWidth))
then
#撞到墙壁了
return 1
fi
if ((${iMap[y * iTrayWidth + x]} != -1 ))
then
#撞到其他已经存在的方块了
return 1
fi
done
return 0;
}
#将当前移动中的方块放到背景方块中去,
#并计算新的分数和速度级。(即一次方块落到底部)
function Box2Map()
{
local j i x y xp yp line
#将当前移动中的方块放到背景方块中去
for ((j = 0; j < 8; j += 2))
do
((i = j + 1))
((y = ${boxCur[$j]} + boxCurY))
((x = ${boxCur[$i]} + boxCurX))
((i = y * iTrayWidth + x))
iMap[$i]=$cBoxCur
done
#消去可被消去的行
line=0
for ((j = 0; j < iTrayWidth * iTrayHeight; j += iTrayWidth))
do
for ((i = j + iTrayWidth - 1; i >= j; i--))
do
if ((${iMap[$i]} == -1)); then break; fi
done
if ((i >= j)); then continue; fi
((line++))
for ((i = j - 1; i >= 0; i--))
do
((x = i + iTrayWidth))
iMap[$x]=${iMap[$i]}
done
for ((i = 0; i < iTrayWidth; i++))
do
iMap[$i]=-1
done
done
if ((line == 0)); then return; fi
#根据消去的行数line计算分数和速度级
((x = iLeft + iTrayWidth * 2 + 7))
((y = iTop + 11))
((iScore += line * 2 - 1))
#显示新的分数
echo -ne "\033[1m\033[3${cScoreValue}m\033[${y};${x}H${iScore} "
if ((iScore % iScoreEachLevel < line * 2 - 1))
then
if ((iLevel < 20))
then
((iLevel++))
((y = iTop + 14))
#显示新的速度级
echo -ne "\033[3${cScoreValue}m\033[${y};${x}H${iLevel} "
fi
fi
echo -ne "\033[0m"
#重新显示背景方块
for ((y = 0; y < iTrayHeight; y++))
do
((yp = y + iTrayTop + 1))
((xp = iTrayLeft + 1))
((i = y * iTrayWidth))
echo -ne "\033[${yp};${xp}H"
for ((x = 0; x < iTrayWidth; x++))
do
((j = i + x))
if ((${iMap[$j]} == -1))
then
echo -ne " "
else
echo -ne "\033[1m\033[7m\033[3${iMap[$j]}m\033[4${iMap[$j]}m[]\033[0m"
fi
done
done
}
#下落一行
function BoxDown()
{
local y s
((y = boxCurY + 1)) #新的y坐标
if BoxMove $y $boxCurX #测试是否可以下落一行
then
s="`DrawCurBox 0`" #将旧的方块抹去
((boxCurY = y))
s="$s`DrawCurBox 1`" #显示新的下落后方块
echo -ne $s
else
#走到这儿, 如果不能下落了
Box2Map #将当前移动中的方块贴到背景方块中
RandomBox #产生新的方块
fi
}
#左移一列
function BoxLeft()
{
local x s
((x = boxCurX - 1))
if BoxMove $boxCurY $x
then
s=`DrawCurBox 0`
((boxCurX = x))
s=$s`DrawCurBox 1`
echo -ne $s
fi
}
#右移一列
function BoxRight()
{
local x s
((x = boxCurX + 1))
if BoxMove $boxCurY $x
then
s=`DrawCurBox 0`
((boxCurX = x))
s=$s`DrawCurBox 1`
echo -ne $s
fi
}
#下落到底
function BoxAllDown()
{
local k j i x y iDown s
iDown=$iTrayHeight
#计算一共需要下落多少行
for ((j = 0; j < 8; j += 2))
do
((i = j + 1))
((y = ${boxCur[$j]} + boxCurY))
((x = ${boxCur[$i]} + boxCurX))
for ((k = y + 1; k < iTrayHeight; k++))
do
((i = k * iTrayWidth + x))
if (( ${iMap[$i]} != -1)); then break; fi
done
((k -= y + 1))
if (( $iDown > $k )); then iDown=$k; fi
done
s=`DrawCurBox 0` #将旧的方块抹去
((boxCurY += iDown))
s=$s`DrawCurBox 1` #显示新的下落后的方块
echo -ne $s
Box2Map #将当前移动中的方块贴到背景方块中
RandomBox #产生新的方块
}
#旋转方块
function BoxRotate()
{
local iCount iTestRotate boxTest j i s
iCount=${countBox[$iBoxCurType]} #当前的方块经旋转可以产生的样式的数目
#计算旋转后的新的样式
((iTestRotate = iBoxCurRotate + 1))
if ((iTestRotate >= iCount))
then
((iTestRotate = 0))
fi
#更新到新的样式, 保存老的样式(但不显示)
for ((j = 0, i = (${offsetBox[$iBoxCurType]} + $iTestRotate) * 8; j < 8; j++, i++))
do
boxTest[$j]=${boxCur[$j]}
boxCur[$j]=${box[$i]}
done
if BoxMove $boxCurY $boxCurX #测试旋转后是否有空间放的下
then
#抹去旧的方块
for ((j = 0; j < 8; j++))
do
boxCur[$j]=${boxTest[$j]}
done
s=`DrawCurBox 0`
#画上新的方块
for ((j = 0, i = (${offsetBox[$iBoxCurType]} + $iTestRotate) * 8; j < 8; j++, i++))
do
boxCur[$j]=${box[$i]}
done
s=$s`DrawCurBox 1`
echo -ne $s
iBoxCurRotate=$iTestRotate
else
#不能旋转，还是继续使用老的样式
for ((j = 0; j < 8; j++))
do
boxCur[$j]=${boxTest[$j]}
done
fi
}
#DrawCurBox(bDraw), 绘制当前移动中的方块, bDraw为1, 画上, bDraw为0, 抹去方块。
function DrawCurBox()
{
local i j t bDraw sBox s
bDraw=$1
s=""
if (( bDraw == 0 ))
then
sBox="\040\040"
else
sBox="[]"
s=$s"\033[1m\033[7m\033[3${cBoxCur}m\033[4${cBoxCur}m"
fi
for ((j = 0; j < 8; j += 2))
do
((i = iTrayTop + 1 + ${boxCur[$j]} + boxCurY))
((t = iTrayLeft + 1 + 2 * (boxCurX + ${boxCur[$j + 1]})))
#\033[y;xH, 光标到(x, y)处
s=$s"\033[${i};${t}H${sBox}"
done
s=$s"\033[0m"
echo -n $s
}
#更新新的方块
function RandomBox()
{
local i j t
#更新当前移动的方块
iBoxCurType=${iBoxNewType}
iBoxCurRotate=${iBoxNewRotate}
cBoxCur=${cBoxNew}
for ((j = 0; j < ${#boxNew[@]}; j++))
do
boxCur[$j]=${boxNew[$j]}
done
#显示当前移动的方块
if (( ${#boxCur[@]} == 8 ))
then
#计算当前方块该从顶端哪一行"冒"出来
for ((j = 0, t = 4; j < 8; j += 2))
do
if ((${boxCur[$j]} < t)); then t=${boxCur[$j]}; fi
done
((boxCurY = -t))
for ((j = 1, i = -4, t = 20; j < 8; j += 2))
do
if ((${boxCur[$j]} > i)); then i=${boxCur[$j]}; fi
if ((${boxCur[$j]} < t)); then t=${boxCur[$j]}; fi
done
((boxCurX = (iTrayWidth - 1 - i - t) / 2))
#显示当前移动的方块
echo -ne `DrawCurBox 1`
#如果方块一出来就没处放，Game over!
if ! BoxMove $boxCurY $boxCurX
then
kill -$sigExit ${PPID}
ShowExit
fi
fi
#清除右边预显示的方块
for ((j = 0; j < 4; j++))
do
((i = iTop + 1 + j))
((t = iLeft + 2 * iTrayWidth + 7))
echo -ne "\033[${i};${t}H "
done
#随机产生新的方块
((iBoxNewType = RANDOM % ${#offsetBox[@]}))
((iBoxNewRotate = RANDOM % ${countBox[$iBoxNewType]}))
for ((j = 0, i = (${offsetBox[$iBoxNewType]} + $iBoxNewRotate) * 8; j < 8; j++, i++))
do
boxNew[$j]=${box[$i]};
done
((cBoxNew = ${colorTable[RANDOM % ${#colorTable[@]}]}))
#显示右边预显示的方块
echo -ne "\033[1m\033[7m\033[3${cBoxNew}m\033[4${cBoxNew}m"
for ((j = 0; j < 8; j += 2))
do
((i = iTop + 1 + ${boxNew[$j]}))
((t = iLeft + 2 * iTrayWidth + 7 + 2 * ${boxNew[$j + 1]}))
echo -ne "\033[${i};${t}H[]"
done
echo -ne "\033[0m"
}
#初始绘制
function InitDraw()
{
clear
RandomBox #随机产生方块，这时右边预显示窗口中有方快了
RandomBox #再随机产生方块，右边预显示窗口中的方块被更新，原先的方块将开始下落
local i t1 t2 t3
#显示边框
echo -ne "\033[1m"
echo -ne "\033[3${cBorder}m\033[4${cBorder}m"
((t2 = iLeft + 1))
((t3 = iLeft + iTrayWidth * 2 + 3))
for ((i = 0; i < iTrayHeight; i++))
do
((t1 = i + iTop + 2))
echo -ne "\033[${t1};${t2}H||"
echo -ne "\033[${t1};${t3}H||"
done
((t2 = iTop + iTrayHeight + 2))
for ((i = 0; i < iTrayWidth + 2; i++))
do
((t1 = i * 2 + iLeft + 1))
echo -ne "\033[${iTrayTop};${t1}H=="
echo -ne "\033[${t2};${t1}H=="
done
echo -ne "\033[0m"
#显示"Score"和"Level"字样
echo -ne "\033[1m"
((t1 = iLeft + iTrayWidth * 2 + 7))
((t2 = iTop + 10))
echo -ne "\033[3${cScore}m\033[${t2};${t1}HScore"
((t2 = iTop + 11))
echo -ne "\033[3${cScoreValue}m\033[${t2};${t1}H${iScore}"
((t2 = iTop + 13))
echo -ne "\033[3${cScore}m\033[${t2};${t1}HLevel"
((t2 = iTop + 14))
echo -ne "\033[3${cScoreValue}m\033[${t2};${t1}H${iLevel}"
echo -ne "\033[0m"
}
#退出时显示GameOVer!
function ShowExit()
{
local y
((y = iTrayHeight + iTrayTop + 3))
echo -e "\033[${y};0HGameOver!\033[0m"
exit
}
#显示用法.
function Usage
{
cat << EOF
Usage: $APP_NAME
Start tetris game.
-h, --help display this help and exit
--version output version information and exit
EOF
}
#游戏主程序在这儿开始.
if [[ "$1" == "-h" || "$1" == "--help" ]]; then
Usage
elif [[ "$1" == "--version" ]]; then
echo "$APP_NAME $APP_VERSION"
elif [[ "$1" == "--show" ]]; then
#当发现具有参数--show时，运行显示函数
RunAsDisplayer
else
bash $0 --show& #以参数--show将本程序再运行一遍
RunAsKeyReceiver $! #以上一行产生的进程的进程号作为参数
fi 
[/code] 
[]     
    
带空格文件名,目录问题
文章整理: 文章来源: 网络 
    最近爱上cu论坛了,也算是个职业cuer了吧~~~。其实问题比较多的就是删除多个文件,rm参数过多.带空格的文件名,目录名处理有问题~~~。其实这些都可以用find+xargs解决 
    find和xargs是最好的组合，可以说是linux shell下的瑞士军刀，用xargs配合find，比直接用find的-exec参数，速度更快，用法也更直观。
基本的用法比如：
find ./ -name '*.bak' | xargs rm -rf
一般情况，上面这个命令运行的很好，但是如果找到的文件名代空格上面的命令运行就可能会出问题了有一个参数-print0，于默认的-print相比，输出的序列不是以空格分隔，而是以null字符分隔。而xargs也有一个参数-0，可以接受以null而非空格间隔的输入流。所以说xargs简直就是为find而生的。上面的问题就很好解决了：
find ./ -name '*.bak' -print0 | xargs -0 rm -rf 
[]     
    
sed高级用法
文章整理: 文章来源: 网络 
首先，应该明白模式空间的定义。模式空间就是读入行所在的缓存，sed对文本行进行的处理都是在这个缓存中进行的。这对接下来的学习是有帮助的。 
在正常情况下，sed将待处理的行读入模式空间，脚本中的命令就一条接着一条的对该行进行处理，直到脚本执行完毕，然后该行被输出，模式空间请空；然后重复刚才的动作，文件中的新的一行被读入，直到文件处理完备。 
但是，各种各样的原因，比如用户希望在某个条件下脚本中的某个命令被执行，或者希望模式空间得到保留以便下一次的处理，都有可能使得sed在处理文件的时候不按照正常的流程来进行。这个时候，sed设置了一些高级命令来满足用户的要求。 
总的来说，这些命令可以划分为以下三类： 
1. N、D、P：处理多行模式空间的问题； 
2. H、h、G、g、x：将模式空间的内容放入存储空间以便接下来的编辑； 
3. :、b、t：在脚本中实现分支与条件结构。 
多行模式空间的处理： 
由于正则表达式是面向行的，因此，如若某个词组一不分位于某行的结尾，另外一部分又在下一行的开始，这个时候用grep等命令来处理就相当的困难。然而，借助于sed的多行命令N、D、P，却可以轻易地完成这个任务。 
多行Next(N)命令是相对于next(n)命令的，后者将模式空间中的内容输出，然后把下一行读入模式空间，但是脚本并不会转移到开始而是从当前的n 命令之后开始执行；而前者则保存原来模式空间中的内容，再把新的一行读入，两者之间依靠一个换行符"\n"来分隔。在N命令执行后，控制流将继续用N命令以后的命令对模式空间进行处理。 
值得注意的是，在多行模式中，特殊字符"^"和"$"匹配的是模式空间的最开始与最末尾，而不是内嵌"\n"的开始与末尾。 
例1： 
$ cat expl.1 
Consult Section 3.1 in the Owner and Operator 
Guide for a description of the tape drives 
available on your system. 
现在要将"Owner and Operator Guide"替换为"Installation Guide"： 
$ sed '/Operator$/{ 
> N 
> s/Owner and Operator\nGuide/Installation Guide\ 
> / 
> }' expl.1 
在上面的例子中要注意的是，行与行之间存在内嵌的换行符；另外在用于替代的内容中要插入换行符的话，要用如上的"\"的转义。 
再看一个例子： 
例2： 
$ cat expl.2 
Consult Section 3.1 in the Owner and Operator 
Guide for a description of the tape drives 
available on your system. 
Look in the Owner and Operator Guide shipped with your system. 
Two manuals are provided including the Owner and 
Operator Guide and the User Guide. 
The Owner and Operator Guide is shipped with your system. 
$ sed 's/Owner and Operator Guide/Installation Guide/ 
> /Owner/{ 
> N 
> s/ *\n/ / 
> s/Owner and Operator Guide */Installation Guide\ 
> / 
}' expl.2 
结果得到： 
Consult Section 3.1 in the Installation Guide 
for a description of the tape drives 
available on your system. 
Look in the Installation Guide shipped with your system. 
Two manuals are provided including the Installation Guide 
and the User Guide. 
The Installation Guide is shipped with your system. 
看上去sed命令中作了两次替换是多余的。实际上，如果去掉第一次替换，再运行脚本，就会发现输出存在两个问题。一个是结果中最后一行不会被替换(在某些版本的sed中甚至不会被输出)。这是因为最后一行匹配了"Owner",执行N命令，但是已经到了文件末尾，某些版本就会直接打印这行再退出，而另外一些版本则是不作出打印立即退出。对于这个问题可以通过命令"$!N"来解决。这表示N命令对最后一行不起作用。另外一个问题是"look manuals"一段被拆为两行，而且与下一段的空行被删除了。这是因为内嵌的换行符被替换的结果。因此，sed中做两次替换一点也不是多余的。 
例3： 
$ cat expl.3 
<para> 
This is a test paragraph in Interleaf style ASCII. Another line 
in a paragraph. Yet another. 
<Figure Begin> 
v.1111111111111111111111100000000000000000001111111111111000000 
100001000100100010001000001000000000000000000000000000000000000 
000000 
<Figure End> 
<para> 
More lines of text to be found after the figure. 
These lines should print. 
我们的sed命令是这样的： 
$ sed '/<para>{ 
> N 
> c\ 
> .LP 
> } 
> /<Figure Begin>/,/<Figure End>/{ 
> w fig.interleaf 
> /<Figure End>/i\ 
> .FG\ 
> <insert figure here>\ 
> .FE 
> d 
> } 
> /^$/d' expl.3 
运行后得到的结果是： 
.LP 
This is a test paragraph in Interleaf style ASCII. Another line 
in a paragraph. Yet another. 
.FG 
<insert figure here> 
.FE 
.LP 
More lines of text to e found after the figure. 
These lines should print. 
而<Figure Begin>与<Figure End>之间的内容则写入文件"fig.interleaf"。值得注意的是命令"d"并不会影响命令i插入的内容。 
命令"d"作用是删除模式空间的内容，然后读入新的行，sed脚本从头再次开始执行。而命令"D"的不同之处在于它删除的是直到第一个内嵌换行符为止的模式空间的一部分，但是不会读入新的行，脚本将回到开始对剩下内容进行处理。 
例4： 
$ cat expl.4 
This line is followed by 1 blank line. 
This line is followed by 2 blank line. 
This line is followed by 3 blank line. 
This line is followed by 4 blank line. 
This is the end. 
不同的删除命令获得不同的结果： 
$ sed '/^$/{ $ sed '/^$/{ 
> N > N 
> /^\n$/d > /^\n$/D 
> }' expl.4 > }' expl.4 
sed对文件中每一行(不管处理与否)的默认动作是将其输出，如果加上选项"-n"，则输出动作会被抑制，这时还希望输出就需要打印命令。单行模式空间的打印命令是"p"，多行模式空间的打印命令是"P"。P命令打印的是模式空间中直到第一个内嵌换行符为止的一部分。 
P命令通常出现在N命令之后D命令之前，由此构成一个输入输出循环。在这种情况下，模式空间中始终存在两行文本，而输出始终是一行文本。使用这种循环的目的在于输出模式空间中的第一行，然后脚本回到起始处，再对空间中的第二行进行处理。设想一下，如果没有这个循环，当脚本执行完备，模式空间中的内容都会被输出，可能就不符合使用者的要求或者降低了程序执行的效率。 
下面是一个例子： 
例5： 
$ cat expl.5 
Here are examples of the UNIX 
System. Where UNIX 
System appears, it should be the UNIX 
Operating System. 
$ sed '/UNIX$/{ 
> N 
> /\nSystem/{ 
> s// Operating &/ 
> P 
> D 
> } 
> }' expl.5 
替换的结果是： 
Here are examples of the UNIX Operating 
System. Where UNIX Operating 
System appears, it should be the UNIX 
Operating System. 
可以将sed命令中的"P"、"D"换作小写，比较一下两种类型的命令的不同之处。 
下面的例子就有相当的难度了： 
例6： 
$ cat expl.6 
I want to see @fl(what will happen) if we put the 
font change commands @fl(on a set of lines). If I understand 
things (correctly), the @fl(third) line causes problems. (No?). 
Is this really the case, or is it (maybe) just something else? 
Let's test having two on a line @fl(here) and @fl(there) as 
well as one that begins on one line and ends @fl(somewhere 
on another line). What if @fl(it is here) on the line? 
Another @fl(one). 
现在要作的就是将"fl@(…)替换为"\fB(…)\fR。以下就是满足条件的sed命令： 
$ sed 's/@fl(\([^)]*\))/\\fB\1\\fR/g 
> /@fl(.*/{ 
> N 
> s/@fl(\(.*\n[^)]*\))/\\fB\1\\fR/g 
> P 
> D 
> }' expl.6 
然而，如果不使用这种输入输出循环，而是单单用N来实现的话，就会出现问题： 
$ sed 's/@fl(\([^)]*\))/\\fB\1\\fR/g 
> /@fl(.*/{ 
> N 
> s/@fl(\(.*\n[^)]*\))/\\fB\1\\fR/g 
> }' expl.6 
这样的sed脚本是有漏洞的。 
对行进行存储： 
前面已经解释了模式空间的定义，而在sed中还有一个缓存叫作存储空间。在模式空间和存储空间中的内容可以通过一组命令互相拷贝： 
命令 简写 功能 
Hold h或H 将模式空间的内容拷贝或附加到存储空间 
Get g或G 将存储空间的内容拷贝或附加到模式空间 
Exchange x 交换模式空间和存储空间中的内容 
命令的大小写的区别在于大写的命令是将源空间的内容附加到目标空间，而小写的命令则是用源空间的内容覆盖目标空间。值得注意的是，不管是Hold命令还是Get命令，都会在目的空间的原有内容之后加上一个换行符，然后才把源空间中的内容加到换行符的后面。 
从下面这个例子，可以体会这部分内容的初步应用： 
例7： 
$ cat expl.7 
1 
2 
11 
22 
111 
222 
我们要做的工作就是将第一行与第二行，第三行与第四行，第五行与第六行互换。sed的命令各式是： 
$ sed ' 
> /1/{ 
> h 
> d 
> } 
> /2/{ 
> G 
> }' expl.7 
这个过程是这样的：首先，sed将第一行读入模式空间，然后h命令将其放入存储空间保存起来，一个d命令又把模式空间中的内容清空；接着sed把第二行读入模式空间，然后G命令把存储空间中的内容附加到模式空间(注意的是在模式空间的原内容末尾是加了一个换行符的)。 
最后得到的结果如下： 
2 
1 
22 
11 
222 
111 
使用H或h命令的时候，比较常见的是在这个命令之后加上d命令，这样一来，sed脚本不会到达最后，因而模式空间中的内容也就不会输出了。另外，如果把d换作n，或者把G换作g，都不会达到目的的。 
子母的大小写转换什么最方便，估计是tr了。 
$ tr "[a-z]" "[A-Z]" File 
很利害的是sed也可以完成这个转换。相应的命令是y： 
$ sed ' 
> /[address]/y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/' File 
然而y命令是对整个行完全进行修改，因此如果只是将行里面的几个字符变换大小写的话，这样做是行不通的。为完成这个工作，需要借助上面刚提到的Hold和Get命令了。 
cat expl.8 
find the Match statement 
Consult the Get statement 
using the Read statement to retrieve data 
$ sed '/the .* statement/{ 
> h 
> s/.*the \(.*\) statement.*/\1/ 
> y/abcdefghijklmnopqrstuvwxyz/ABCDEFGHIJKLMNOPQRSTUVWXYZ/ 
> G 
> s/\(.*\)\n\(.*the \).*\( statement.*\)/\2\1\3/ 
> }' expl.8 
以第一行的处理过程来说明这段命令的含意： 
(1) "find the Match statement"被放入存储空间； 
(2) 替换改行得到：Match； 
(3) 将(2)的结果转换为大写：MATCH； 
(4) 从存储空间去处(1)保留的内容附加到模式空间，此时模式空间的内容为： 
MATCH\nfind the Match statement 
(5) 再次对模式空间的内容替换得到：find the MATCH statement。 
下面将举到的例子要用到比较扎实的正则表达式，不过没有关系，慢慢来，一切问题都是可以解决的。另外这个例子用到的文本主要是和编辑排版有关的，这方面我不大会，所以我就只是把sed脚本拿出来，抓住核心，省掉那些细枝末节的东西： 
例9： 
$ cat expl.9.sed 
h 
s/[][\\*.]/\\&/g 
x 
s/[\\&]/\\&/g 
s/^\.XX // 
s/$/\// 
x 
s/^\\\.XX \(.*\)$/\/^\\.XX \/s\/\1// 
G 
s/\n// 
(1) h：讲文本行放入存储空间。 
(2) s/[][\\*.]/\\&/g：这个表达式难度比较大，如果在类表达，也就是"[]"中的第一个字符是"]"的话，那么"]"就丧失了它的特殊含意；另外，唉"[]"中，仅仅只有"\"是有特殊含意的，言下之意就是"*"、"."都是理解为字面意思，要使他们具有特殊意义就必须使用"\"的转义了；虽然在表达式中没有出现，也要提一下，在"[]"中只有"^"出现在第一的位置时，表示"非"的含意，其余情况就是字面解释，而"$"仅仅是在正则表达式的末尾时才有特殊含意。"\\"去掉了"\"的特殊含意，"&"表示向前引用，因此，第二个命令的意思就是：将模式空间中的"["、"] "、"\"、"*"、"."依次用"\["、"\]"、"\\"、"\*"、"\."来替换。 
(3) x：交换模式空间和存储空间。执行这个命令后模式空间的内容是原文的内容，而存储空间中的内容发生变化，各个特殊字符都被替换成为了"\&"。 
(4) s/[\\&]/\\&/g：对模式空间处理，出现的"\"或者"&"都会替换为"\\"或者"\&"。 
(5) s/$/\//：这个好理解，就是在模式空间的结尾加上一个"/"。 
(6) x：再次交换两个空间的内容。 
(7) s/^\\\.XX \(.*\)$/\/^\\.XX \/s\/\1//：这个没有什么难度，就是那几个引用容易把人看晕了，仔细一点，不会有问题的，就略过吧。 
( G：略了。 
(9) s/\n//：删除换行符。 
这个脚本有什么用呢？用以下的文本实验就清楚了： 
.XX "asterisk (*) metacharacter" 
下面是每次命令的结果，第一行和第二行分别表示模式空间和存储空间的内容： 
1. .XX "asterisk (*) metacharacter" 
.XX "asterisk (*) metacharacter" 
2. \.XX "asterisk (\*) metacharacter" 
.XX "asterisk (*) metacharacter" 
3. .XX "asterisk (*) metacharacter" 
\.XX "asterisk (\*) metacharacter" 
4. .XX "asterisk (*) metacharacter" 
\.XX "asterisk (\*) metacharacter" 
5. "asterisk (*) metacharacter" 
\.XX "asterisk (\*) metacharacter" 
6. "asterisk (*) metacharacter"/ 
\.XX "asterisk (\*) metacharacter" 
7. \.XX "asterisk (\*) metacharacter" 
"asterisk (*) metacharacter"/ 
8. /^\.XX /s/"asterisk (\*) metacharacter"/ 
"asterisk (*) metacharacter"/ 
9. /^\.XX /s/"asterisk (\*) metacharacter"/\n/"asterisk (*) metacharacter"/ 
10./^\.XX /s/"asterisk (\*) metacharacter"/"asterisk (*) metacharacter"/ 
看到没有，其实"s/[\\&]/\\&/"没有在我们的例子中没有起作用，但是它不可少，因为在s命令的第二部分，"\"和"&"都是有特殊含意的，所以要预先转义掉其特殊含意。 
明白了吗？当你希望用一个shell脚本自动生成一个主要是替换命令的sed脚本的时候，会发现这个以上的内容对特殊字符的处理是多么得关键。 
出了上面的应用，存储空间甚至还能够将很多行的内容存储起来供以后的输出。实际上，这一功能对html等具有非常明显的结构的文本非常有效。下面是相关的例子： 
例10 
cat expl.10 
<p>My wife won't let me buy a power saw. She is afraid of an 
accident if I use one. 
So I rely on a hand saw for a variety of weekend projects like 
building shelves. 
However, if I made my living as a carpenter, I would 
have to use a power 
saw. The speed and efficiency provided by power tools 
would be essential to being productive.</p> 
<p>For people who create and modify text files, 
sed and awk are power tools for editing.</p> 
<p>Most of the things that you can do with these programs 
can be done interactively with a text editor. However, 
using these programs can save many hours of repetitive 
work in achieving the same result.</p> 
$ sed '/^$/!{ 
> H 
> d 
> } 
> /^$/{ 
> x 
> s/^\n/<p>/ 
> s/$/<\/p>/ 
> G 
> }' expl.10 
运行一下这个命令，看看结果是怎样的。其实结果已经不重要了。通过这个子，应该学会的是脚本中体现的流程控制的思想。脚本的第一部分使用"!"表示对不匹配的行进行处理，但是这种处理因为"d"的存在，不会走脚本的底部，自然也就不会有任何的输出；在脚本的第二部分中，脚本的确是到了最后的，相应的也清除了模式空间和存储空间的内容，为读入下一段做好了准备。 
本来这个例子已经完了，但是还有种情况，如果文件的最后一行不是空行会出现什么结果？显然，文本的最后一段不会被输出。这种情况怎么处理呢？最明智的办法就是自己"制造"一个空行。新的脚本是这样的： 
$ sed '${ 
> /^$/!{ 
> H 
> s/.*// 
> } 
> } 
> /^$/!{ 
> H 
> d 
> } 
> /^$/{ 
> x 
> s/^\n/<p>/ 
> s/$/<\/p>/ 
> G 
> }' expl.10 
流程控制命令 
为了使使用者在书写sed脚本的时候真正的"自由"，sed还允许在脚本中用":"设置记号，然后用"b"和"t"命令进行流程控制。顾名思义，"b"表示"branch"，"t"表示"test"；前者就是分支命令，后者则是测试命令。 
首先来看标签的各式是什么。这个标签放置在你希望流程所开始的地方，单独放一行，以冒号开始。冒号与变迁之间不允许有空格或者制表符，标签最后如果有空格的话，也会被认为是标签的一部分。 
再来说b命令。它的格式是这样的： 
[address]b[label] 
它的含意是，如果满足address，则sed流程跟随标签跳转：如果标签指明的话，脚本首先假设这个标签在b命令以下的某行，然后转入该行执行相应的命令；如果这个标签不存在的话，控制流程就直接跳到脚本的末尾。否则继续执行后续的命令。 
在某些情况下，b命令和!命令有些相似，但是!命令只能对紧挨它的{}中的内容起作用，而b命令则给予使用者足够的自由在sed脚本中选择哪些命令应该被执行，哪些命令不应该被执行。下面提供几种b命令的经典用法： 
(1) 创建循环： 
:top 
command1 
command2 
/pattern/b top 
command3 
(2) 忽略某些不满足条件的命令： 
command1 
/patern/b end 
command2 
:end 
command3 
(3) 命令的两个部分只能执行其中一个： 
command1 
/pattern/b dothere 
command 
b 
:dothere 
command3 
t命令的格式和b命令是一样的： 
[address]t[label] 
它表示的是如果满足address的话，sed脚本就会根据t命令指示的标签进行流程转移。而标签的规则和上面讲的b命令的规则是一样的。下面也给出一个例子： 
s/pattern/replacement/ 
t break 
command 
:break 
还是用例6的sed脚本为例子。其实仔细思考一下就会发现这个脚本不是足够强大：如果某个@fl结构跨越了两行，比如说三行怎么办？这就需要下面这个加强版的sed了： 
$ cat expl.6.sed 
:begin 
/@fl(\([^)]*\))/{ 
s//\\fB\1\\fR/g 
b begin 
} 
/@fl(.*/{ 
N 
s/@f1(\([^)]*\n[^)]*\))/\\fB\1\\fR/g 
t again 
b begin 
} 
:again 
P 
D 
[]     
    
shell 应用（一）
文章整理: 文章来源: 网络 
1.建立和运行shell程序
  什么是shell程序呢? 简单的说shell程序就是一个包含若干行
shell或者linux命令的文件.
象编写高级语言的程序一样,编写一个shell程序需要一个文本编辑器.如VI等.
在文本编辑环境下,依据shell的语法规则,输入一些shell/linux命令行,形成一个完整
的程序文件.
  执行shell程序文件有三种方法
  (1)#chmod +x file
  (2)#sh file
  (3)# . file
在编写shell时,第一行一定要指明系统需要那种shell解释你的shell程序,如:#! /bin/bash,
#! /bin/csh,/bin/tcsh,还是#! /bin/pdksh .
2.shell中的变量
  (1)常用系统变量
     $ #        :保存程序命令行参数的数目
     $ ?        :保存前一个命令的返回码
     $ 0        :保存程序名
     $ *        :以("$1 $2...")的形式保存所有输入的命令行参数
     $ @        :以("$1""$2"...)的形式保存所有输入的命令行参数
  (2)定义变量
   shell语言是非类型的解释型语言,不象用C++/JAVA语言编程时需要事先声明变量.给一
个变量赋值,实际上就是定义了变量.
   在linux支持的所有shell中,都可以用赋值符号(=)为变量赋值.
如:
  abc=9  (bash/pdksh不能在等号两侧留下空格 )
  set abc = 9 (tcsh/csh)
   由于shell程序的变量是无类型的,所以用户可以使用同一个变量时而存放字符时而存放
整数.
如:
  name=abc  (bash/pdksh)
  set name = abc (tcsh)
  在变量赋值之后,只需在变量前面加一个$去引用.
如:
  echo $abc
  (3)位置变量
  当运行一个支持多个命令行参数的shell程序时,这些变量的值将分别存放在位置变量里.
其中第一个参数存放在位置变量1,第二个参数存放在位置变量2,依次类推...,shell保留
这些变量,不允许用户以令外的方式定义他们.同别的变量,用$符号引用他们.
3.shell中引号的使用方法
  shell使用引号(单引号/双引号)和反斜线("\")用于向shell解释器屏蔽一些特殊字符.
反引号(")对shell则有特殊意义.
如:
abc="how are you"  (bash/pdksh)
  set abc = "how are you"  (tcsh)
这个命令行把三个单词组成的字符串how are you作为一个整体赋值给变量abc.
  abc1='@LOGNAME,how are you!' (bash/pdksh)
  set abc1='$LOGNAME,how are you!' (tcsh)
  abc2="$LOGNAME,how are you!" (bash/pdksh)
  set abc2="$LOGNAME,how are you!" (tcsh)
LOGNAME变量是保存当前用户名的shell变量,假设他的当前值是:wang.执行完两条命令后,
abc1的内容是:$LOGNAME, how are you!.而abc2的内容是;wang, how are you!.
象单引号一样,反斜线也能屏蔽所有特殊字符.但是他一次只能屏蔽一个字符.而不能屏蔽
一组字符.
反引号的功能不同于以上的三种符号.他不具有屏蔽特殊字符的功能.但是可以通过他将
一个命令的运行结果传递给另外一个命令.
如:
  contents=`ls` (bash/pdksh)
  set contents = `ls` (tcsh)
4.shell程序中的test命令
  在bash/pdksh中,命令test用于计算一个条件表达式的值.他们经常在条件语句和循环
语句中被用来判断某些条件是否满足.
test命令的语法格式:
  test expression
  或者
  [expression]
在test命令中,可以使用很多shell的内部操作符.这些操作符介绍如下:
(1)字符串操作符  用于计算字符串表达式
  test命令    |    含义
  -----------------------------------------
  Str1 = str2 | 当str1与str2相同时,返回True
  Str1! = str2| 当str1与str2不同时,返回True
     Str      | 当str不是空字符时,返回True
    -n str    | 当str的长度大于0时,返回True
    -z str    | 当str的长度是0时,返回True
  -----------------------------------------
  (2)整数操作符具有和字符操作符类似的功能.只是他们的操作是针对整数
  test表达式   |    含义
  ---------------------------------------------
  Int1 -eq int2|当int1等于int2时,返回True
  Int1 -ge int2|当int1大于/等于int2时,返回True
  Int1 -le int2|当int1小于/等于int2时,返回True
  Int1 -gt int2|当int1大于int2时,返回True
  Int1 -ne int2|当int1不等于int2时,返回True
  -----------------------------------------
  (3)用于文件操作的操作符,他们能检查:文件是否存在,文件类型等
  test表达式   |    含义
  ------------------------------------------------
  -d file      |当file是一个目录时,返回 True
  -f file      |当file是一个普通文件时,返回 True
  -r file      |当file是一个刻读文件时,返回 True
  -s file      |当file文件长度大于0时,返回 True
  -w file      |当file是一个可写文件时,返回 True
  -x file      |当file是一个可执行文件时,返回 True
  ------------------------------------------------
(4)shell的逻辑操作符用于修饰/连接包含整数,字符串,文件操作符的表达式
  test表达式    |    含义
  ----------------------------------------------------------
  ! expr        |当expr的值是False时,返回True
  Expr1 -a expr2|当expr1,expr2值同为True时,返回True
  Expr1 -o expr2|当expr1,expr2的值至少有一个为True时,返回True
  -----------------------------------------------------------
注意:
tcsh shell 不使用test命令,但是tcsh中的表达式同样能承担相同的功能.tcsh
支持的表达式于C中的表达式相同.通常使用在if和while命令中.
  tcsh表达式    |    含义
  -------------------------------------------------------
  Int1 <= int2  |当int1小于/等于int2时,返回True
  Int1 >= int2  |当int1大于/等于int2时,返回True
  Int1 < int2   |当int1小于int2时,返回True
  Int1 > int2   |当int1大于int2时,返回True
  Str1 == str2  |当str1与str2相同时,返回True
  Str1 != str2  |当str1与str2不同时,返回True
  -r file       |当file是一个可读文件时,返回True
  -w file       |当file是一个可写文件时,返回True
  -x file       |当file是一个可执行文件时,返回True
  -e file       |当file存在时,返回True
  -o file       |当file文件的所有者是当前用户时,返回True
  -z file       |当file长度为0时,返回True
  -f file       |当file是一个普通文件时,返回True
  -d file       |当file是一个目录时,返回True
  Exp1 || exp2  |当exp1和exp2的值至少一个为True时,返回True
  Exp1 && exp2  |当exp1和exp2的值同为True时,返回True
  ! exp         |当exp的值为False时,返回True
  -------------------------------------------------------
引用地址：http://blog.programfan.com/trackback.asp?id=12348
[]     
    
shell 应用（二）
文章整理: 文章来源: 网络 
5.条件语句
同其他高级语言程序一样,复杂的shell程序中经常使用到分支和循环控制结构,
bash,pdksh和tcsh分别都有两种不同形式的条件语句:if语句和case语句.
(1)if语句
语法格式:
bash/pdksh用法:
if [expression1]
then
commands1
elif [expression2]
commands2
else
commands3
if
tcsh用法:
if (expression1) then
commands1
else if (expression2) then
commands2
else
commands3
endif
含义:当expression1的条件为True时,shell执行then后面的commands1命令;当
expression1的条件为false并且expression2的条件满足为True时,shell执行
commands2命令;当expression1和expressin2的条件值同为false时,shell执行
commands3命令.if语句以他的反写fi结尾.
(2)case语句
case语句要求shell将一个字符串S与一组字符串模式P1,P2,...,Pn比较,当S与
某个模式Pi想匹配时,就执行相应的那一部分程序/命令.shell的case语句中字符
模式里可以包含象*这样的通配符.
语法格式:
bash/pdksh用法:
case string1 in
str1)
commands1;;
str2)
commands2;;
*)
commands3;;
esac
tcsh用法:
switch (string1)
case str1:
statements1
breaksw
case str2:
statements2
breaksw
default:
statements3
breaksw
endsw
含义:shell将字符串string1分别和字符串模式str1和str2比较.如果string1与str1匹配,则
shell执行commands1的命令/语句;如果string11和str2匹配,则shell执行commands2的命令/
语句.否则shell将执行commands3的那段程序/命令.其中,每个分支的程序/命令都要以两个
分号(;;)结束.
6.循环语句
当需要重复的某些操作时,就要用到循环语句.
(1)for语句
大家知道在很多编程语言中for语句是最常见.在shell中也不例外.for语句要求shell将包含
在这个语句中的一组命令连续执行一定的次数.
语法格式:
bash/pdksh
用法1:
for var1 in list
do
commands
done
含义:在这个for语句中,对应于list中的每个值,shell将执行一次commands代表的一组命令.
在整个循环的每一次执行中,变量var1将依此取list中的不同的值.
用法2:
for var1
do
setatements
done
含义:在这个for语句中,shell针对变量var1中的每一项分别执行一次statements代表的一组
命令.当使用这种形式的语句时,shell认为var1变量中包含了所有的位置变量,而位置变量中
存放着程序的命令行参数值.也就是说,他等价于下列形式:
for var1 in " $@"
do
statements
done
tcsh用法:
在tcsh中没有for这个单词,与for语句起同样功能的是foreach语句
foreach name (list)
commands
end
举例:
for file                       ;bash/pdksh
do
tr a-z A-Z<$file>file.caps
done
#                              ;tcsh
foreach file ( $ * )
tr a-z A-Z<$file>$file.caps
end
(2)while语句
while语句是shell提供的另一种循环语句. while语句指定一个表达式和一组命令.这个
语句使得shell重复执行一组命令,直到表达式的值为False为止.
语法格式:
while expression     ;bash
do
statements
done
while (expression)   ;tcsh
statements
end
举例:
count=1              ;bash
while [ -n "$ *"]    ***
do
echo "this is a parameter number $count $1"
shift
count='expr $count + 1'
done
set count = 1         ;tcsh
while ( " $ * " ! = "")
echo "this is a parameter number $count $1"
shift
set count = 'expr $count + 1'
end
语句中shift命令的功能是将所有的命令行参数依次相左传递.
(3)until语句
until与while语句具有类似的语法格式和功能,不同的是while中expression的值为True时,
shell执行命令组;而until中当expression的值为False时,shell才执行那组命令.
语法格式:
until expression
do
commands
done
举例:
count=1
until [ -z " $ * "]       ***
echo "this is a parameter number $count $1"
shift
count='expr $count + 1'
done
情注意上述例子中带***号.在while中的表达式: -n string,他的含义是当string不是空
字符串时,表达式的值为True;在until中的表达式: -z string,他的 含义是当string是空
字符串时,表达式的值为True.由此可见,两个程序对条件表达式的设置恰好是相反的.
(4)shift语句
bash和tcsh都支持shift命令.shift将存放在位置变量中的命令行参数,依次向左传递.例如
位置变量当前值为:
$1=file1 $2=file2 $3=file3
执行一次shift命令后,位置变量的值为:
$1=file2 $2=file3
还可以在shift命令中指定位置变量转移的次数, 如:
shift n
例子:
while [ "$1"]
do
if [ "$1"="-i"] then
infile=" $2"
shift 2
else if [ "$1"="-o"] then
outfile="$2"
shift 2
else
echo "Program $0 does not recognize option $1"
fi
done
tr a-z A-Z<$infile>$outfile
(5)select语句
select语句是pdksh提供的一个独特的循环语句.他不同于前面介绍的循环语句.他不是
反复计算一个条件表达式,并依据表达式的值决定是否执行一组命令.select的功能是自动的
生成一个简单的文本菜单.
语法格式:
select menu [in list_of_items]
do
commands
done
含义:当执行一个select语句时,pdksh分别为每个列在list_of_items中的成员建立一个菜单
选项.list_of_items既可以是一个包含多个选项的变量,也可以是直接列在程序中的一组选项
.如果语句中没有提供list_of_items,select语句将使用位置变量作为list_of_items.
举例:
select menuitem in pick1 pick2 pick3
do
echo "are you sure you want to pick $menuitem"
read res                   ;接收用户的输入,并且将输入的值存放在特定变量里.
if [ $res=" y" -o $res=" Y"]
then
break                      ;用于退出while,for,select等循环语句
fi
done
(6)repeat语句
repeat语句是tcsh提供的独有的循环语句.使用repeat命令要求shell对一个命令执行一定
的次数.
语法格式:
repeat count command
如;
foreach num ( $ *)
repeat $num echo -n " *"
echo " "
end
7.shell中的函数
shell允许用户定义自己的函数.函数是高级语言中的重要结构.shell中的函数于C或者其他
语言中定义的函数一样.与从头开始,一行一行地写程序相比,使用函数主要好处是有利于组织
整个程序.在bash中,一个函数的语法格式如下:
fname (){
shell comands
}
定义好函数后,需要在程序中调用他们.bash中调用函数的格式:
fname [parm1 parm2 parm3...]
调用函数时,可以向函数传递任意多个参数.函数将这些参数看做是存放他的命令行参数的
位置变量.
举例:
这个程序定义了4个函数:
upper ():将传递给他的文件中的字母转换成大写,并存放到同名的结尾为.out的文件中.
lower ():将传递给他的文件里的字母转换成小写,并存放到同名的结尾为.out的文件中.
print ():输出传递给他的文件的内容.
usage_error ():输出程序的帮助信息.
程序的主模块是个case条件语句,他根据命令行中第一个参数,决定程序要完成的功能,并调用相应
的函数完成这一功能.
upper (){
shift
for i
do
tr a-a A-Z<$!>$1.out
rm $1
mv $1.out $1
shift
done; }
lower () {
shift
for i
do
tr A-Z a-z<$1>$1.out
rm $1
mv $1.out $1
shift
done; }
print() {
shift
for i
do
lpr $1
shift
done; }
usage_error() {
echo " $1 syntax is $1<option><input files>"
echo ""
echo " where option is one of the following"
echo " p--to print frame files"
echo " u--to save as uppercase"
echo " l--to save as lowercase";}
case $1 in
p | -p)print $@;;
u | -u)upper $@;;
l | -l)lower $@;;
*) usage_error $0;;
esac
引用地址：http://blog.programfan.com/trackback.asp?id=12349 
[]     
    
递归函数的性能问题
文章整理: 文章来源: 网络 
性能问题
尽管编写 bash 脚本可以实现递归函数，但是由于先天性的不足，使用 bash 脚本编写的递归函数的性能都比较差，问题的根本在于它的主要流程都是要不断地调用其他程序，这会 fork 出很多进程，从而极大地增加运行时的开销。下面让我们来看一个计算累加和的例子，清单 15 和清单 16 给出了两个实现，它们分别利用全局变量和标准输入输出设备来传递返回值。为了简单起见，我们也不对输入参数进行任何判断。
清单15. 累加和，利用全局变量传递返回值
               
[root@localhost shell]# cat -n sum1.sh
     1  #!/bin/bash
     2
     3  sum()
     4  {
     5    local i=$1
     6
     7    if [ $i -eq 1 ]
     8    then
     9      rtn=1
    10    else
    11      sum `expr $i - 1`
    12      rtn=`expr $i + $rtn `
    13    fi
    14
    15    return $rtn
    16  }
    17
    18  if [ -z $1 ]
    19  then
    20    echo "Need one parameter."
    21    exit 1
    22  fi
    23
    24  sum $1
    25
    26  echo $rtn
 
清单16. 累加和，利用标准输入输出设备传递返回值
               
[root@localhost shell]# cat -n sum2.sh
     1  #!/bin/bash
     2
     3  sum()
     4  {
     5    local i=$1
     6
     7    if [ $i -eq 1 ]
     8    then
     9      echo 1
    10    else
    11      local j=`expr $i - 1`
    12      local k=`sum $j`
    13      echo `expr $i + $k `
    14    fi
    15  }
    16
    17  if [ -z $1 ]
    18  then
    19    echo "Need one parameter."
    20    exit 1
    21  fi
    22
    23  rtn=`sum $1`
    24  echo $rtn
下面让我们来测试一下这两个实现的性能会有多大的差距：
清单17. 利用全局变量和标准输入输出设备传递返回值的性能比较
               
[root@localhost shell]# cat -n run.sh
     1  #!/bin/bash
     2
     3  if [ $# -lt 2 ]
     4  then
     5    echo "Usage: $0 [number] [executable list]"
     6    exit 1
     7  fi
     8
     9  NUM=$1
    10  shift
    11
    12  for i in $*
    13  do
    14    echo "Running command: $i $NUM"
    15    time ./$i $NUM
    16
    17    sleep 5
    18    echo
    19  done
[root@localhost shell]# ./run.sh 500 sum1.sh sum2.sh
Running command: sum1.sh 500
125250
real    0m8.336s
user    0m0.532s
sys     0m7.772s
Running command: sum2.sh 500
125250
real    0m20.775s
user    0m1.316s
sys     0m17.741s
在计算 1 到 500 的累加和时，利用标准输入输出设备传递返回值的方法速度要比利用全局变量慢 1 倍以上。随着迭代次数的增加，二者的差距也会越来越大，主要原因标准输入输出设备都是字符设备，从中读写数据耗时会很长；而全局变量则是在内存中进行操作的，速度会明显快很多。
为了提高 shell 脚本的性能，在编写 shell 脚本时，应该尽量多使用 shell 的内嵌命令，而不能过多地调用外部脚本或命令，因为调用内嵌命令时不会 fork 新的进程，而是在当前 shell 环境中直接执行这些命令，这样可以减少很多系统开销。以计算表达式的值为例，前面的例子我们都是通过调用 expr 来对表达式进行求值的，但是 bash 中提供了一些内嵌的计算表达式手段，例如 ((i = $j + $k)) 与 i=`expr $j + $k` 的效果就是完全相同的，都是计算变量 j 与 k 的值，并将结果赋值给变量 i，但是前者却节省了一次 fork 新进程以及执行 expr 命令的开销。下面让我们对清单 15 中的脚本进行一下优化，如清单 18 所示。
清单18. 优化后的计算累加和的脚本
               
[root@localhost shell]# cat -n sum3.sh
     1  #!/bin/bash
     2
     3  sum()
     4  {
     5    local i=$1
     6
     7    if [ $i -eq 1 ]
     8    then
     9      rtn=1
    10    else
    11      sum $(($i - 1))
    12      ((rtn = rtn + i))
    13    fi
    14
    15    return $rtn
    16  }
    17
    18  sum $1
    19
    20  echo $rtn
现在让我们来比较一下优化前后的性能差距，如清单 19 所示。
清单19. 优化前后的性能对比
               
[root@localhost shell]# ./run.sh 2000 sum1.sh sum3.sh
Running command: sum1.sh 2000
2001000
real    1m19.378s
user    0m15.877s
sys     1m3.472s
Running command: sum3.sh 2000
2001000
real    0m12.202s
user    0m10.949s
sys     0m1.220s
可以看出，在迭代 2000 次时，优化后的脚本速度要比优化前快 5 倍以上。但是无论如何，使用 shell 脚本编写的递归函数的执行效率都不高，c 语言的实现与其相比，快了可能都不止一个数量级，详细数据请参看清单 20。
清单20. c 语言与 bash 脚本实现递归函数的对比
               
[root@localhost shell]# cat -n sum.c
     1  #include <stdlib.h>
     2  #include <stdio.h>
     3
     4  int sum(int i)
     5  {
     6    if (i == 1)
     7      return 1;
     8    else
     9      return i + sum(i-1);
    10  }
    11
    12  int main(int argc, char **argv[])
    13  {
    14    printf("%d\n", sum(atoi((char *)argv[1])));
    15  }
[root@localhost shell]# gcc -O2 -o sum sum.c
[root@localhost shell]# ./run.sh 3000 sum sum3.sh
Running command: sum 3000
4501500
real    0m0.004s
user    0m0.000s
sys     0m0.004s
Running command: sum3.sh 3000
4501500
real    0m31.182s
user    0m28.998s
sys     0m2.004s
 
因此，如果编写对性能要求很高的递归程序，还是选择其他语言实现好了，这并不是 shell 的强项。
[]     
    
递归函数的参数传递问题
文章整理: 文章来源: 网络 
参数传递问题
    在设计函数时，除了返回值之外，我们可能还希望所调用的函数还能够返回其他一些信息。例如，在上面的阶乘递归函数中，我们除了希望计算最后的结果之外，还希望了解这个函数一共被调用了多少次。熟悉 c 语言之类的读者都会清楚，这可以通过传递一个指针类型的参数实现。然而，在 bash 中并不支持指针，它提供了另外一种在解释性语言中常见的设计：间接变量引用(indirect variable reference)。让我们看一下下面这个例子：
var2=$var3
var1=$var2
 
    其中变量 var2 的存在实际上就是为了让 var1 能够访问 var3，实际上也可以通过 var1 直接引用 var3 的值，方法是 var1=\$$var3(请注意转义字符是必须的，否则 $$ 符号会被解释为当前进程的进程 ID 号)，这种方式就称为间接变量引用。从 bash2 开始，对间接变量引入了一种更为清晰的语法，方法是 var1=${!var3}。
清单 10 中给出了使用间接变量引用来统计阶乘函数被调用次数的实现。
清单10. 利用间接变量引用统计递归函数的调用次数
               
[root@localhost shell]# cat -n depth.sh
     1  #!/bin/bash
     2
     3  factorial()
     4  {
     5    local i=$1
     6    local l=$2
     7
     8    if [ $i -eq 0 ]
     9    then
    10      eval ${l}=1
    11      rtn=1
    12    else
    13      factorial `expr $i - 1` ${l}
    14      rtn=`expr $i \* $rtn `
    15     
    16      local k=${!l}
    17      eval ${l}=`expr ${k} + 1`
    18    fi
    19
    20    return $rtn
    21  }
    22
    23  if [ -z $1 ]
    24  then
    25    echo "Need one parameter."
    26    exit 1
    27  fi
    28
    29  level=0
    30  factorial $1 level
    31
    32  echo "The factorial of $1 is : $rtn"
    33  echo " the function of factorial is invoked $level times."
[root@localhost shell]# ./depth.sh 6
The factorial of 6 is : 720
 the function of factorial is invoked 7 times.
    在上面我们曾经介绍过，为了解决变量作用域和函数返回值的问题，在递归函数中我们使用 local 声明局部变量，并采用全局变量来传递返回值。但是随着调用关系变得更加复杂，全局变量的值有可能在其他地方被错误地修改。实际上，使用局部变量也存在一个问题，下面让我们来看一下清单 11 中给出的例子。
清单11. 查找字符串在文件中是否存在，并计算所在行数和出现次数
               
[root@localhost shell]# cat -n getline1.sh
     1  #!/bin/bash
     2
     3  GetLine()
     4  {
     5    string=$1
     6    file=$2
     7
     8    line=`grep -n $string $file`
     9    if [ $? -eq 0 ]
    10    then
    11      printf "$string is found as the %drd line in $file \n" `echo $line \
                         | cut -f1 -d:`
    12      num=`grep $string $file | wc -l`
    13      rtn=0
    14    else
    15      printf "$string is not found in $file \n"
    16      num=0
    17      rtn=1
    18    fi
    19
    20    return $rtn;
    21  }
    22
    23  if [ ! -f testfile.$$ ]
    24  then
    25    cat >> testfile.$$ <<EOF
    26  first line .
    27  second line ..
    28  third line ...
    29  EOF
    30  fi
    31
    32  num=0
    33  rtn=0
    34  for i in "second" "six" "line"
    35  do
    36    echo
    37    GetLine $i testfile.$$
    38    echo "return value: $rtn"
    39
    40    if [ $num -gt 0 ]
    41    then
    42      echo "$num occurences found totally."
    43    fi
    44  done
[root@localhost shell]# ./getline1.sh
second is found as the 2rd line in testfile.4280
return value: 0
1 occurences found totally.
six is not found in testfile.4280
return value: 1
line is found as the 1rd line in testfile.4280
return value: 0
3 occurences found totally.
[root@localhost shell]#
 
    这段程序的目的是查找某个字符串在指定文件中是否存在，如果存在，就计算第一次出现的行数和总共出现的次数。为了说明局部变量和后面提到的子函数的问题，我们故意将对出现次数的打印也放到了 GetLine 函数之外进行处理。清单 11 中全部使用全局变量，并没有出现什么问题。下面让我们来看一下将 GetLine 中使用的局部变量改用 local 声明后会出现什么问题，修改后的代码和执行结果如清单 12 所示。
清单12. 使用 local 声明局部变量需要注意的问题
               
[root@localhost shell]# cat -n getline2.sh
     1  #!/bin/bash
     2
     3  GetLine()
     4  {
     5    local string=$1
     6    local file=$2
     7
     8    local line=`grep -n $string $file`
     9    if [ $? -eq 0 ]
    10    then
    11      printf "$string is found as the %drd line in $file \n" `echo $line \
                         | cut -f1 -d:`
    12      num=`grep $string $file | wc -l`
    13      rtn=0
    14    else
    15      printf "$string is not found in $file \n"
    16      num=0
    17      rtn=1
    18    fi
    19
    20    return $rtn;
    21  }
    22
    23  if [ ! -f testfile.$$ ]
    24  then
    25    cat >> testfile.$$ <<EOF
    26  first line .
    27  second line ..
    28  third line ...
    29  EOF
    30  fi
    31
    32  num=0
    33  rtn=0
    34  for i in "second" "six" "line"
    35  do
    36    echo
    37    GetLine $i testfile.$$
    38    echo "return value: $rtn"
    39
    40    if [ $num -gt 0 ]
    41    then
    42      echo "$num occurences found totally."
    43    fi
    44  done
[root@localhost shell]# ./getline2.sh
second is found as the 2rd line in testfile.4300
return value: 0
1 occurences found totally.
six is found as the 0rd line in testfile.4300
                return value: 0
line is found as the 1rd line in testfile.4300
return value: 0
3 occurences found totally.
    清单 12 的运行结果显示，在文件中搜索 six 关键字时的结果是错误的，调试会发现，问题的原因在于：第 8 行使用 local 将 line 声明为局部变量，并将 grep 命令的执行结果赋值给 line 变量。然而不论 grep 是否成功在文件中找到匹配项(grep 程序找到匹配项返回值为 0，否则返回值为 1)，第 9 行中 $? 的值总是 0。实际上，第 8 行相当于执行了两条语句：第一条语句使用 grep 在文件中查找匹配项，第二条语句将 grep 命令的结果赋值给变量 line，并设定其作用域只对于本函数及其子进程可见。因此第 9 行命令中 $? 的值实际上是执行 local 命令的返回值，不管 grep 命令的结果如何，它总是 0。
    要解决这个问题，可以将第 8 行的命令拆分开，首先使用单独一行将变量 line 声明为 local的，然后再执行这条 grep 命令，并将结果赋值给变量 line(此时前面不能加上 local)。
    解决变量作用域的另外一种方法是使用子 shell。所谓子 shell 是在当前 shell 环境中启动一个子 shell 来执行所调用的命令或函数，这个函数中所声明的所有变量都是局部变量，它们不会污染原有 shell 的名字空间。清单 13 给出了使用子 shell 修改后的例子。
清单13. 利用子 shell 实现局部变量
               
[root@localhost shell]# cat -n getline3.sh
     1  #!/bin/bash
     2
     3  GetLine()
     4  {
     5    string=$1
     6    file=$2
     7
     8    line=`grep -n $string $file`
     9    if [ $? -eq 0 ]
    10    then
    11      printf "$string is found as the %drd line in $file \n" `echo $line  \
                     | cut -f1 -d:`
    12      num=`grep $string $file | wc -l`
    13      rtn=0
    14    else
    15      printf "$string is not found in $file \n"
    16      num=0
    17      rtn=1
    18    fi
    19
    20    return $rtn;
    21  }
    22
    23  if [ ! -f testfile.$$ ]
    24  then
    25    cat >> testfile.$$ <<EOF
    26  first line .
    27  second line ..
    28  third line ...
    29  EOF
    30  fi
    31
    32  num=0
    33  rtn=0
    34  for i in "second" "six" "line"
    35  do
    36    echo
    37    (GetLine $i testfile.$$)
    38    echo "return value: $? (rtn = $rtn)"
    39
    40    if [ $num -gt 0 ]
    41    then
    42      echo "$num occurences found totally."
    43    fi
    44  done
[root@localhost shell]# ./getline3.sh
second is found as the 2rd line in testfile.4534
return value: 0 (rtn = 0)
six is not found in testfile.4534
return value: 1 (rtn = 0)
line is found as the 1rd line in testfile.4534
return value: 0 (rtn = 0)
 
    在清单 13 中，GetLine 函数并不需要任何变化，变量定义和程序调用都沿用正常方式。唯一的区别在于调用该函数时，要将其作为一个子 shell 来调用(请注意第 37 行两边的圆括号)。另外一个问题是在子 shell 中修改的所有变量对于原有 shell 来说都是不可见的，这也就是为什么在第 38 行要通过 $? 来检查返回值，而 rtn 变量的值却是错误的。另外由于 num 在 GetLine 函数中也被当作是局部变量，同样无法将修改后的值传出来，因此也并没有打印所匹配到的 line 的数目是 3 行的信息。
    解决上面这个问题就只能使用前面提到的利用标准输入输出设备的方法了，否则即使使用间接变量引用也无法正常工作。清单 14 给出了一个使用间接变量引用的例子，尽管我们使用不同的名字来命名全局变量和局部变量，从而确保不会引起同名混淆，但是依然无法正常工作。原因同样在于 GetLine 函数是在另外一个子进程中运行的，它对变量所做的更新随着子 shell 的退出就消失了。
清单14. 利用间接变量索引也无法解决子 shell 通过变量回传值的问题
               
[root@localhost shell]# cat -n getline4.sh
     1  #!/bin/bash
     2
     3  GetLine()
     4  {
     5    string=$1
     6    file=$2
     7    num=$3
     8    rtn=$4
     9
    10    line=`grep -n $string $file`
    11    if [ $? -eq 0 ]
    12    then
    13      printf "$string is found as the %drd line in $file \n"  \
                       `echo $line | cut -f1 -d:`
    14      eval ${num}=`grep $string $file | wc -l`
    15      eval ${rtn}=0
    16    else
    17      printf "$string is not found in $file \n"
    18      eval ${num}=0
    19      eval ${rtn}=1
    20    fi
    21
    22    return ${!rtn};
    23  }
    24
    25  if [ ! -f testfile.$$ ]
    26  then
    27    cat >> testfile.$$ <<EOF
    28  first line .
    29  second line ..
    30  third line ...
    31  EOF
    32  fi
    33
    34  g_num=0
    35  g_rtn=0
    36  for i in "second" "six" "line"
    37  do
    38    echo
    39    (GetLine $i testfile.$$ g_num g_rtn)
    40    echo "return value: $? (g_rtn = $g_rtn)"
    41
    42    if [ $g_num -gt 0 ]
    43    then
    44      echo "$g_num occurence(s) found totally."
    45    fi
    46  done
[root@localhost shell]# ./getline4.sh
second is found as the 2rd line in testfile.4576
return value: 0 (g_rtn = 0)
six is not found in testfile.4576
return value: 1 (g_rtn = 0)
line is found as the 1rd line in testfile.4576
return value: 0 (g_rtn = 0)
[]     
    
递归函数的返回值问题
文章整理: 文章来源: 网络 
返回值问题
有一些经典的数学问题，使用递归函数来解决都非常方便。阶乘就是这样一个典型的问题，清单 5 给出了一个实现阶乘计算的bash脚本(当然，除了使用递归函数之外，简单地利用一个循环也可以实现计算阶乘的目的，不过本文以此为例来介绍递归函数的相关问题)。
清单5. 阶乘函数的bash实现
               
[root@localhost shell]# cat -n factorial1.sh
     1  #!/bin/bash
     2
     3  factorial()
     4  {
     5    i=$1
     6
     7    if [ $i -eq 0 ]
     8    then
     9      return 1;
    10    else
    11      factorial `expr $i - 1`
    12      return `expr $i \* $? `
    13    fi
    14  }
    15
    16  if [ -z $1 ]
    17  then
    18    echo "Need one parameter."
    19    exit 1
    20  fi
    21
    22  factorial $1
    23
    24  echo $?
[root@localhost shell]# ./factorial1.sh 5
0
 
这个脚本看上去并没有什么问题：递归函数的参数传递和普通函数没什么不同，返回值是通过获取 $? 的值实现的，这是利用了执行命令的退出码。然而，最终的结果却显然是错误的。调试一下就会发现，当递归回溯到尽头时，变量 i 的值被修改为 0；而退出上次函数调用之后，变量 i 的新值也被带了回来，详细信息如清单 6 所示。
清单6. 调试 factorial1.sh 的问题
               
[root@localhost shell]# export PS4='+[$FUNCNAME: $LINENO] '
[root@localhost shell]# sh -x factorial1.sh 5
+[: 16] '[' -z 5 ']'
+[: 22] factorial 5
+[factorial: 5] i=5
+[factorial: 7] '[' 5 -eq 0 ']'
++[factorial: 11] expr 5 - 1
+[factorial: 11] factorial 4
+[factorial: 5] i=4
+[factorial: 7] '[' 4 -eq 0 ']'
++[factorial: 11] expr 4 - 1
+[factorial: 11] factorial 3
+[factorial: 5] i=3
+[factorial: 7] '[' 3 -eq 0 ']'
++[factorial: 11] expr 3 - 1
+[factorial: 11] factorial 2
+[factorial: 5] i=2
+[factorial: 7] '[' 2 -eq 0 ']'
++[factorial: 11] expr 2 - 1
+[factorial: 11] factorial 1
+[factorial: 5] i=1
+[factorial: 7] '[' 1 -eq 0 ']'
++[factorial: 11] expr 1 - 1
+[factorial: 11] factorial 0
+[factorial: 5] i=0
+[factorial: 7] '[' 0 -eq 0 ']'
+[factorial: 9] return 1
++[factorial: 12] expr 0 '*' 1
+[factorial: 12] return 0
++[factorial: 12] expr 0 '*' 0
+[factorial: 12] return 0
++[factorial: 12] expr 0 '*' 0
+[factorial: 12] return 0
++[factorial: 12] expr 0 '*' 0
+[factorial: 12] return 0
++[factorial: 12] expr 0 '*' 0
+[factorial: 12] return 0
+[: 24] echo 0
0
 
这段脚本问题的根源在于变量的作用域：在shell脚本中，不管是否在函数中定义，变量默认就是全局的，一旦定义之后，对于此后执行的命令全部可见。 bash也支持局部变量，不过需要使用local关键字进行显式地声明。local 是bash中的一个内嵌命令，其作用是将变量的作用域设定为只有对本函数及其子进程可见。局部变量只能在变量声明的代码块中可见，这也就意味着在函数内声明的局部变量只能在函数代码块中才能被访问，它们并不会污染同名全局变量。因此为了解决上面这个程序的问题，我们应该使用local关键字将i声明为局部变量。修改后的脚本如清单7所示。
清单7. 递归函数中使用local关键字声明局部变量
               
[root@localhost shell]# cat -n factorial2.sh
     1  #!/bin/bash
     2
     3  factorial()
     4  {
     5    local i=$1
     6
     7    if [ $i -eq 0 ]
     8    then
     9      return 1;
    10    else
    11      factorial `expr $i - 1`
    12      return `expr $i \* $? `
    13    fi
    14  }
    15
    16  if [ -z $1 ]
    17  then
    18    echo "Need one parameter."
    19    exit 1
    20  fi
    21
    22  factorial $1
    23
    24  echo $?
[root@localhost shell]# ./factorial2.sh 5
120
[root@localhost shell]# ./factorial2.sh 6
208
            
这下 5 的阶乘计算对了，但是稍微大一点的数字都会出错，比如 6 的阶乘计算出来是错误的 208。这个问题的原因在于脚本中传递函数返回值的方式存在缺陷，$? 所能传递的最大值是 255，超过该值就没有办法利用这种方式来传递返回值了。解决这个问题的方法有两种，一种是利用全局变量，另外一种则是利用其他方式进行周转(例如标准输入输出设备)。清单 8 和清单 9 分别给出了这两种方法的参考实现。
清单8. 使用全局变量传递返回值
               
[root@localhost shell]# cat -n factorial3.sh
     1  #!/bin/bash
     2
     3  factorial()
     4  {
     5    local i=$1
     6
     7    if [ $i -eq 0 ]
     8    then
     9      rtn=1
    10    else
    11      factorial `expr $i - 1`
    12      rtn=`expr $i \* $rtn `
    13    fi
    14
    15    return $rtn
    16  }
    17
    18  if [ -z $1 ]
    19  then
    20    echo "Need one parameter."
    21    exit 1
    22  fi
    23
    24  factorial $1
    25
    26  echo $rtn
[root@localhost shell]# ./factorial3.sh 6
720
 
清单9. 利用标准输入输出设备传递返回值
               
[root@localhost shell]# cat -n factorial4.sh
     1  #!/bin/bash
     2
     3  factorial()
     4  {
     5    local i=$1
     6
     7    if [ $i -eq 0 ]
     8    then
     9      echo 1
    10    else
    11      local j=`expr $i - 1`
    12      local k=`factorial $j`
    13      echo `expr $i \* $k `
    14    fi
    15  }
    16
    17  if [ -z $1 ]
    18  then
    19    echo "Need one parameter."
    20    exit 1
    21  fi
    22
    23  rtn=`factorial $1`
    24  echo $rtn
[root@localhost shell]# ./factorial4.sh 6
720
 
尽管利用全局变量或标准输入输出设备都可以解决如何正确传递返回值的问题，但是它们却各有缺点：如果利用全局变量，由于全局变量对此后的程序全部可见，一旦被其他程序修改，就会出错，所以编写代码时需要格外小心，特别是在编写复杂的递归程序的时候；如果利用标准输入输出设备，那么递归函数中就存在诸多限制，例如任何地方都不能再向标准输出设备中打印内容，否则就可能被上一层调用当作正常输出结果读走了，另外速度方面也可能存在严重问题。
[]     
    
递归经典之教你制做fork炸弹
文章整理: 文章来源: 网络 
函数在程序设计中是一个非常重要的概念，它可以将程序划分成一个个功能相对独立的代码块，使代码的模块化更好，结构更加清晰，并可以有效地减少程序的代码量。递归函数更是充分提现了这些优点，通过在函数定义中调用自身，可以将复杂的计算问题变成一个简单的迭代算法，当回溯到边界条件时，再逐层返回上一层函数。有很多数学问题都非常适合于采用递归的思想来设计程序求解，例如阶乘、汉诺(hanoi)塔等。 
可能很多人都曾经听说过fork炸弹，它实际上只是一个非常简单的递归程序，程序所做的事情只有一样：不断fork一个新进程。由于程序是递归的，如果没有任何限制，这会导致这个简单的程序迅速耗尽系统里面的所有资源。 
在bash中设计这样一个fork炸弹非常简单，Jaromil在2002年设计了最为精简的一个fork炸弹的实现，整个程序从函数定义到调用仅仅包含 13 个字符，如清单 1 所示。 
清单1.bash中的fork炸弹 
.(){ .|.& };. 
  
    这串字符乍看上去根本就看不出个所以然来，下面让我们逐一解释一下它究竟在干些什么。为了解释方便，我们对清单1中的内容重新设置一下格式，并在前面加上了行号，如清单 2 所示。 
清单2.bash中的fork炸弹的解释:                
  1 .() 
  2 { 
  3  .|.& 
  4 } 
  5 ; 
  6 . 
  
* 第 1 行说明下面要定义一个函数，函数名为小数点，没有可选参数。 
* 第 2 行表示函数体开始。 
* 第 3 行是函数体真正要做的事情，首先它递归调用本函数，然后利用管道调用一个新进程（它要做的事情也是递归调用本函数），并将其放到后台执行。 
* 第 4 行表示函数体结束。 
* 第 5 行并不会执行什么操作，在命令行中用来分隔两个命令用。从总体来看，它表明这段程序包含两个部分，首先定义了一个函数，然后调用这个函数。 
* 第 6 行表示调用本函数。 
    对于函数名，大家可能会有所疑惑，小数点也能做函数名使用吗？毕竟小数点是 shell 的一个内嵌命令，用来在当前 shell 环境中读取指定文件，并运行其中的命令。实际上的确可以，这取决于bash对命令的解释顺序。默认情况下，bash 处于非 POSIX 模式，此时对命令的解释顺序如下： 
* 关键字，例如 if、for 等。 
* 别名。别名不能与关键字相同，但是可以为关键字定义别名，例如 end=fi。 
* 特殊内嵌命令，例如 break、continue 等。POSIX 定义的特殊内嵌命令包括：.（小数点）、:（冒号）、break、continue、eval、exec、exit、export、readonly、 return、set、shift、times、trap 和 unset。bash 又增加了一个特殊的内嵌命令 source。 
* 函数。如果处于非 POSIX 模式，bash 会优先匹配函数，然后再匹配内嵌命令。 
* 非特殊内嵌命令，例如 cd、test 等。 
* 脚本和可执行程序。在 PATH 环境变量指定的目录中进行搜索，返回第一个匹配项。 
    由于默认情况下，bash 处于非 POSIX 模式，因此fork炸弹中的小数点会优先当成一个函数进行匹配。(实际上，Jaromil 最初的设计并没有使用小数点，而是使用的冒号，也能起到完全相同的效果。)要使用 POSIX 模式来运行bash脚本，可以使用以下三种方法： 
* 使用 --posix 选项启动 bash。 
* 在运行bash之后，执行 set -o posix 命令。 
* 使用 /bin/sh 。 
  
    最后一种方法比较有趣，尽管 sh 在大部分系统上是一个指向bash的符号链接，但是它所启用的却是 POSIX 模式，所有的行为都完全遵守 POSIX 规范。在清单 3 给出的例子中，我们可以发现，小数点在默认bash中被解释成一个函数，能够正常执行；但是在 sh 中，小数点却被当作一个内嵌命令，因此调用函数时会被认为存在语法错误，无法正常执行。 
清单3.bash与 sh 对命令匹配顺序的区别 
[root@localhost ~]# ls -l /bin/bash /bin/sh 
-rwxr-xr-x 1 root root 735144 2007-08-31 22:20 /bin/bash 
lrwxrwxrwx 1 root root      4 2007-12-18 13:26 /bin/sh -> bash 
[root@localhost ~]# echo $SHELL 
/bin/bash 
[root@localhost ~]# .() { echo hello; } ; . 
hello 
[root@localhost ~]# sh 
sh-3.2# echo $SHELL 
/bin/bash 
sh-3.2# .() { echo hello; } ; . 
sh: `.’: not a valid identifier 
sh: .: filename argument required 
.: usage: . filename [arguments] 
sh-3.2# 
    一旦运行清单 1 给出的fork炸弹，会以2的指数次幂的速度不断产生新进程，这会导致系统资源会被迅速耗光，最终除非重新启动机器，否则基本上就毫无办法了。为了防止这会造成太大的损害，我们可以使用 ulimit 限制每个用户能够创建的进程数，如清单 4 所示。 
清单4. 限制用户可以创建的进程数 
[root@localhost ~]# ulimit -u 128 
[root@localhost ~]# ulimit -a 
core file size          (blocks, -c) 0 
data seg size           (kbytes, -d) unlimited 
max nice                        (-e) 20 
file size               (blocks, -f) unlimited 
pending signals                 (-i) unlimited 
max locked memory       (kbytes, -l) unlimited 
max memory size         (kbytes, -m) unlimited 
open files                      (-n) 1024 
pipe size            (512 bytes, -p) 8 
POSIX message queues     (bytes, -q) unlimited 
max rt priority                 (-r) unlimited 
stack size              (kbytes, -s) 8192 
cpu time               (seconds, -t) unlimited 
max user processes              (-u) 128 
virtual memory          (kbytes, -v) unlimited 
file locks                      (-x) unlimited 
[root@localhost ~]# .() { .|.& } ; . 
[1] 6152 
[root@localhost ~]# bash: fork: Resource temporarily unavailable 
bash: fork: Resource temporarily unavailable 
bash: fork: Resource temporarily unavailable 
... 
    在清单 4 中，我们将用户可以创建的最大进程数限制为 128，执行fork炸弹会迅速fork出大量进程，此后会由于资源不足而无法继续执行。 
   fork炸弹让我们认识到了递归函数的强大功能，同时也意识到一旦使用不当，递归函数所造成的破坏将是巨大的。实际上，fork 炸弹只是一个非常简单的递归函数，它并不涉及参数传递、返回值等问题，而这些问题在使用bash编程时是否有完善的支持呢？下面让我们通过几个例子来逐一介绍在bash中编写递归函数时应该注意的相关问题。
[]     
    
SHELL十三问之一：什么是shell？
文章整理: 文章来源: 网络 
在介绍 shell 是甚么东西之前，不妨让我们重新检视使用者与计算机系统的关系，我们知道计算机的运作不能离开硬件，但使用者却无法直接对硬件作驱动，硬件的驱动只能透过一个称为"操作系统(Operating System)"的软件来控管，事实上，我们每天所谈的 freebsd、netbsd、openbsd、linux 等等 ，严格来说只是一个操作系统，我们称之为"核心(kernel)"。然而，从使用者的角度来说，使用者也没办法直接操作 kernel ，而是透过 kernel 的"外壳"程序，也就是所谓的shell ，来与 kernel 沟通。从技术角度来说，shell是一个使用者与系统的互动界面(interface)，主要是让使用者透过命令行(command line)来使用系统以完成工作。因此，shell 的最简单的定义就是---命令解译器(Command Interpreter)：
* 将使用者的命令翻译给核心处理，
* 同时，将核心处理结果翻译给使用者。
    每次当我们完成系统登入(login)，我们就取得一个互动模式的shell ，也称为 login shell 或 primary shell。若从进程(process)角度来说，我们在 shell 所下达的命令，均是 shell 所产生的子进程。这现象，我们暂可称之为fork。 如果是执行脚本(shell script)的话，脚本中的命令则是由另外一个非互动模式的子 shell (sub shell)来执行的。也就是primary shell 产生 sub shell 的进程，sub shell 再产生 script 中所有命令的进程。
    FreeBSD的基本系统中可以使用的shell有两个：sh和csh。这两个基本shell的风格不太相同，不同的使用者常常会根据喜好来在两者之间进行选择。当然当前有更好的shell程序可供使用者选择，这些后续的 shell均是根据sh或csh的风格进一步发展出的，因此可以说在shell中，也有两种风格，需要使用者根据自己的使用习惯进行选择。
在默认安装下，FreeBSD支持sh、csh、tsch，从/etc/shells中可以看出。
命令提示符补充一下：
如果shell是sh，则提示符为“$”，如果shell是csh，则为“%”，需要注意的是如果是root用户，则提示符为“#”。
sh和csh又有以下不同的分支：
Bourne shell ：
burne shell (sh)
burne again shell (bash)
korn shell (ksh)
POSIX shell ( sh) C shell ：
c shell (csh)
TENEX/TOPS C shell ( tcsh)
QUOTE:
Bourne Shell 最初的UNIX shell是由Stephen R. Bourne于20世纪70年代中期在新泽西的AT&T贝尔实验室编写的，这就是Bourne shell。Bourne shell 是一个交换式的命令解释器和命令编程语言。Bourne shell 可以运行为login shell或者login shell的子shell(subshell)。只有login命令可以调用Bourne shell作为一个login shell。此时，shell先读取/etc/profile文件和$HOME/.profile文件。/etc/profile文件为所有的用户定制环境,$HOME/.profile文件为本用户定制环境。最后，shell会等待读取你的输入。
C Shell Bill Joy于20世纪80年代早期，在Berkeley的加利福尼亚大学开发了C shell。它主要是为了让用户更容易的使用交互式功能，并把ALGOL风格的语法结构变成了C语言风格。它新增了命令历史、别名、文件名替换、作业控制等功能。
有很长一段时间，只有两类shell供人们选择，Bourne shell用来编程，C shell用来交互。为了改变这种状况，AT&T的bell实验室David Korn开发了Korn shell。ksh结合了所有的C shell的交互式特性，并融入了Bourne shell的语法。因此，Korn shell广受用户的欢迎。它还新增了数学计算,进程协作(coprocess)、行内编辑(inline editing)等功能。Korn Shell 是一个交互式的命令解释器和命令编程语言.它符合POSIX――一个操作系统的国际标准.POSIX不是一个操作系统,而是一个目标在于应用程序的移植性的标准――在源程序一级跨越多种平台。
bash是GNU计划的一部分，用来替代Bourne shell。它用于基于GNU的系统如Linux.大多数的Linux(Red Hat, Slackware, Caldera)都以bash作为缺省的shell，并且运行sh时，其实调用的是bash。
POSIX shell 是Korn shell的一个变种. 当前提供POSIX shell的最大卖主是Hewlett-Packard。在HP-UX 11.0 , POSIX shell 就是/bin/sh,而bsh是/usr/old/bin/sh.
各主要操作系统下缺省的shell: AIX 下是Korn Shell. Solaris和FreeBSD缺省的是Bourne shell. HP-UX缺省的是POSIX shell. Linux是Bourne Again shell输入命令echo $SHELL可查看你用的是什么shell，也可以根据提示符来看，如果shell是sh，则提示符为“$”，如果shell是csh，则为“%”，需要注意的是如果是root用户，则提示符为“#”。
对于管理员来将，要为使用不同shell的用户都设置好基本的环境，就必须了解这两种风格的shell设置方式。
系统登录时，sh将首先执行/etc/profile文件，为每个用户设置最基本的环境，而csh将使用/etc/csh.cshrc，csh.login和csh.logout作为系统csh资源文件。
执行了系统级别的登录文件之后，每个用户的shell就在该用户的主目录下寻找该用户个人的资源文件：sh使用.profile文件，csh使用.login和.cshrc文件。这些资源文件均使用相应的shell语言，/etc/profile和个人目录下的.profile使用sh风格的控制语言，/etc/cshrc和个人目录下的.login、.cshrc使用csh 风格的控制语言。
系统管理员可以改动这些资源文件，为用户提供一个最方便的使用环境。当然，系统管理员没有必要直接去修改个人主目录下的资源文件，这些文件应该由用户自己管理，但是系统管理员可以在生成帐号时为用户产生缺省的资源文件，以减轻用户设置资源文件的麻烦。adduser命令缺省使用/usr/share/skel下的文件为用户提供各种资源文件的缺省设置，这个目录下除了可以放入shell的资源文件之外，还可以放入其他应用程序的资源文件。由于这些资源文件都是以点开头的隐藏文件，为了表示清楚，在skel目录下使用了一种转换方式，如使用dot.profile 作为.profile的模板。
CODE:
# ls /usr/share/skel
dot.cshrc               dot.login_conf          dot.mailrc              dot.rhosts
dot.login               dot.mail_aliases        dot.profile             dot.shrc在/usr/share/skel中为用户设置的缺省配置文件，在用户生成之后，就不会对用户产生影响了。因此对系统登录文件进行修改更有效和直接。对于sh风格的用户，可以更改/etc/profile文件，对csh应更改/etc/csh.cshrc文件。在这些文件中可以改动shell使用的环境变量，这样来改变shell的行为方式，或者执行一系列自动操作，完成一些用户登录时需要自动执行的任务。
常用的环境变量：
EDITOR        设置用户常用的编辑器，很多程序查看这个变量来启动具体的编辑器，可以 根据系统的情况更改
HOME        用户的主目录的名字，这个变量由login程序设置，一般不需要更改
DISPLAYX        使用这个环境变量来标识具体的显示位置，格式为“计算机名字：X服务 器序号.显示屏序号” ，例如：xt1:0.0，它不需要在资源文件中进行定义
LANG        系统使用的语言，用于系统的本地化，缺省为 “C” ，具体的设置可以查看 /usr/share/locale 目录，那里定义了不同的语言，可以将其设置为zh_CN.EUC来使得一些软件使用中文字符。
MAIL        用户mail文件的位置，也不需要改动
PATH        使用冒号分隔的一系列路径，系统用它来查找具体可执行程序，因此这个变量非常重要，可以根据具体的情况改动其值。为了安全的原因，不要将当前目录作为执行程序的搜寻路径，尤其对于root用户。这样在当前目录下启动程序，需要加上路径，例如启动当前目录下的a.out 程序，输入 “./a.out” 。
MANPATH         使用冒号分隔的一系列路径，系统用它来查找具体命令的在线手册，设置方法与PATH相同。
PS1sh        风格的shell使用这个变量的值作为提示符，缺省值为 “$”（root为 “#” ）。更现代的sh就增强了提示符的灵活性，可以在提示符中加入当前目录、用户名、机器名，命令的序号等。
PS2sh        风格的shell使用这个变量的值作为后续提示符，提示命令还没有完全输入，缺省为 “>;“
TERM        终端的类型，对于需要全屏操作的程序，非常重要。有时要根据情况对设置进行调整。
TZ        时区设置，具体的时区信息位于/usr/share/zoneinfo目录下，需要设置为适合本地时区的标准值
可以将用户的shell设置为特殊的应用程序，来达到对特殊用户进行限制的目的。例如，仅仅给予用户一个电子邮件信箱，但不想给他终端使用权，可以将用户的 shell更改为/bin/true或者其他立即退出的程序。为了安全起见，用户shell应该是一个不存在漏洞的二进制程序，最好不要使用解释性语言脚本作为登录shell。由于系统认可的shell程序是在/etc/shells文件中列出的程序，将特殊用户的shell设置为特殊的应用程序，但这些应用程序没有列入shells文件，那么这个用户就会被一些应用程序区分出与普通用户的差异，从而拒绝提供服务。例如ftp服务器程序ftpd，通过检查用户的shell是不是标准shell，来区分这个用户是普通用户还是用于特定目的的用户。
例如通过源代码编译安装mysql的时候，需要首先建立一个mysql用户，该用户我们不希望他可以登录系统，因此把它的shell设置为/nonexistent:
CODE:
pw groupadd mysql
pw useradd mysql -g mysql -s /nonexistent 
[]     
    
SHELL十三问之二：shell prompt(PS1) 与 Carriage Return(CR)
文章整理: 文章来源: 网络 
当你成功登录进一个文字界面之后，大部份情形下，你会在荧幕上看到一个不断闪烁的方块或底线(视不同版本而别)，我们称之为*游标*(coursor)。游标的作用就是告诉你接下来你从键盘输入的按键所插入的位置，且每输入一键游标便向右边移动一个格子，若连续输入太多的话，则自动接在下一行输入。
假如你刚完成登录还没输入任何按键之前，你所看到的游标所在位置的同一行的左边部份，我们称之为*提示符号*(prompt)。提示符号的格式或因不同系统版本而各有不同，
在FreeBSD上，只需留意最接近游标的一个可见的提示符号，通常是如下两者之一：
$：给一般使用者帐号使用
#：给root (管理员)帐号使用
 
事实上，shell prompt的意思很简单：
   *是shell告诉使用者：您现在可以输入命令行了。我们可以说，使用者只有在得到shell prompt才能打命令行，而cursor是指示键盘在命令行所输入的位置，使用者每输入一个键，cursor就往后移动一格，直到碰到命令行读进CR(Carriage Return，由Enter键产生)字符为止。
CR的意思也很简单：
   *是使用者告诉shell：老兄你可以执行我的命令行了。严格来说：
   *所谓的命令行，就是在shell prompt与CR字符之间所输入的文字。(思考：为何我们这里坚持使用CR字符而不说Enter键呢？答案在后面的学习中揭晓。)
 
不同的命令可接受的命令行格式或有不同，一般情况下，一个标准的命令行格式为如下所列：command-name options argument
若从技术细节来看，shell会依据IFS(Internal Field Seperator)将command line所输入的文字给拆解为"字段"(word)。然后再针对特殊字符(meta)先作处理，最后再重组整行command line。
 
其中的IFS是shell预设使用的字段分隔符，可以由一个及多个如下按键组成：
*空格键(White Space)
*表格键(Tab)
*回车键(Enter)
系统可接受的命令名称(command-name)可以从如下途径获得：
*明确路径所指定的外部命令
*命令别名(alias)
*自定义功能(function)
* shell内建命令(built-in)
* $PATH之下的外部命令
每一个命令行均必须含有命令名称，这是不能缺少的。 
[]     
    
SHELL十三问之三：别人 echo、你也 echo ，是问 echo 知多少？
文章整理: 文章来源: 网络 
承接上一章所介绍的command line，这里我们用echo这个命令加以进一步说明。
 
温习---标准的command line包含三个部件：
* command_name option argument
echo是一个非常简单、直接的命令：
*将argument送出至标准输出(STDOUT)，通常就是在监视器(monitor)上输出。
 
为了更好理解，不如先让我们先跑一下echo命令好了：
$ echo
$
[]     
    
SHELL十三问之四：双引号与单引号差别在哪？
文章整理: 文章来源: 网络 
还是回到我们的command line来吧...
经过前面两章的学习，应该很清楚当你在shell prompt后面敲打键盘、直到按下Enter的时候，你输入的文字就是command line了，然后shell才会以行程的方式执行你所交给它的命令。但是，你又可知道：你在command line输入的每一个文字，对shell来说，是有类别之分的呢？
简单而言(我不敢说这是精确的定议，注一)，command line的每一个charactor，分为如下两种：
* literal：也就是普通纯文字，对shell来说没特殊功能。
* meta：对shell来说，具有特定功能的特殊保留字符。
(注一：关于bash shell在处理command line时的顺序说明，请参考O'Reilly出版社之Learning the Bash Shell, 2nd Edition，第177 - 180页的说明，尤其是178页的流程图Figure 7-1 ... )
Literal没甚么好谈的，凡举abcd、123456这些"文字"都是literal ... (easy？)
但meta却常使我们困惑..... (confused?)
事实上，前两章我们在command line中已碰到两个几乎每次都会碰到的meta：
* IFS：由<space>或<tab>或<enter>三者之一组成(我们常用space )。
* CR：由<enter>产生。
IFS是用来拆解command line的每一个词(word)用的，因为shell command line是按词来处理的。而CR则是用来结束command line用的，这也是为何我们敲<enter>命令就会跑的原因。除了IFS与CR，常用的meta还有：
=：设定变量。
$：作变量或运算替换(请不要与shell prompt搞混了)。
>：重导向(重定向)stdout。
<：重导向(重定向)stdin。
|：命令管线(管道)。
&：重导向file desCRiptor，或将命令置于背境(后台)执行。
( )：将其内的命令置于nested subshell执行，或用于运算或命令替换。
{ }：将其内的命令置于non-named function中执行，或用在变量替换的界定范围。
;：在前一个命令结束时，而忽略其返回值，继续执行下一个命令。
&&：在前一个命令结束时，若返回值为true，继续执行下一个命令。
||：在前一个命令结束时，若返回值为false，继续执行下一个命令。
!：执行history列表中的命令
...
 
假如我们需要在command line中将这些保留字符的功能关闭的话，就需要quoting处理了。
在bash中，常用的quoting有如下三种方法：
* hard quote：' ' (单引号)，凡在hard quote中的所有meta均被关闭。
* soft quote：" " (双引号)，在soft quoe中大部份meta都会被关闭，但某些则保留(如$，反引号，反斜杠)。
* escape：\(反斜线)，只有紧接在escape (跳脱字符)之后的单一meta才被关闭。
下面的例子将有助于我们对quoting的了解：
$ A=B C       #空格键未被关掉，作为IFS处理。
$ C: command not found.
$ echo $A
$ A="B C"       #空格键已被关掉，仅作为空格键处理。
$ echo $A
B C
在第一次设定A变量时，由于空格键没被关闭，command line将被解读为：
* A=B然后碰到<IFS>，再执行C命令在第二次设定A变量时，由于空格键被置于soft quote中，因此被关闭，不再作为IFS：
* A=B<space>C事实上，空格键无论在soft quote还是在hard quote中，均会被关闭。Enter键亦然：
 
$ A='B
> C
> '
$ echo "$A"
B
C
[]     
    
SHELL十三问之五：var=value？export 前后差在哪？
文章整理: 文章来源: 网络 
这次让我们暂时丢开command line，先来了解一下bash变量(variable)吧...
所谓的变量，就是就是利用一个特定的"名称"(name)来存取一段可以变化的"值"(value)。
*设定(set)*
在bash中，你可以用"="来设定或重新定义变量的内容：
        name=value
在设定变量的时侯，得遵守如下规则：
        *等号左右两边不能使用区隔符号(IFS)，也应避免使用shell的保留字符(meta charactor)。
        *变量名称不能使用$符号。
        *变量名称的第一个字母不能是数字(number)。
        *变量名称长度不可超过256个字母。
        *变量名称及变量值之大小写是有区别的(case sensitive)。
如下是一些变量设定时常见的错误：
        A= B       ：不能有IFS
        1A=B       ：不能以数字开头
        $A=B       ：名称不能有$
        a=B       ：这跟a=b是不同的
如下则是可以接受的设定：
        A=" B"       ：IFS被关闭了(请参考前面的quoting章节)
        A1=B       ：并非以数字开头
        A=$B       ：$可用在变量值内
        This_Is_A_Long_Name=b       ：可用_连接较长的名称或值，且大小写有别。
*变量替换(substitution)*
Shell之所以强大，其中的一个因素是它可以在命令行中对变量作替换(substitution)处理。
在命令行中使用者可以使用$符号加上变量名称(除了在用=号定义变量名称之外)，
将变量值给替换出来，然后再重新组建命令行。
比方：
        $ A=ls
        $ B=la
        $ C=/tmp
        $ $A -$B $C
(注意：以上命令行的第一个$是shell prompt，并不在命令行之内。)
必需强调的是，我们所提的变量替换，只发生在command line上面。(是的，让我们再回到command line吧u)
仔细分析最后那行command line，不难发现在被执行之前(在输入CR字符之前)，
$符号会对每一个变量作替换处理(将变量值替换出来再重组命令行)，最后会得出如下命令行：
        ls -la /tmp
还记得第二章我请大家"务必理解"的那两句吗？若你忘了，那我这里再重贴一遍：
若从技术细节来看，shell会依据IFS(Internal Field Seperator)将command line所输入的文字给拆解为"字段"(word)。
然后再针对特殊字符(meta)先作处理，最后再重组整行command line。
这里的$就是command line中最经典的meta之一了，就是作变量替换的u
在日常的shell操作中，我们常会使用echo命令来查看特定变量的值，例如：
        $ echo $A -$B $C
我们已学过，echo命令只单纯将其argument送至"标准输出"(STDOUT，通常是我们的荧幕)。
所以上面的命令会在荧幕上得到如下结果：
        ls -la /tmp
这是由于echo命令在执行时，会先将$A(ls)、$B(la)、跟$C(/tmp)给替换出来的结果。
利用shell对变量的替换处理能力，我们在设定变量时就更为灵活了：
        A=B
        B=$A
这样，B的变量值就可继承A变量"当时"的变量值了。
不过，不要以"数学罗辑"来套用变量的设定，比方说：
        A=B
        B=C
这样并不会让A的变量值变成C。
上面是单纯定义了两个不同名称的变量：A与  B，它们的值分别是B与  C。再如：
        A=B
        B=$A
        A=C
同样也不会让B的值换成C。
 
若变量被重复定义的话，则原有旧值将被新值所取代。(这不正是"可变的量"吗？  ^_^)
当我们在设定变量的时侯，请记着这点：
        *用一个名称储存一个数值
仅此而已。
此外，我们也可利用命令行的变量替换能力来"扩充"(append)变量值：
        A=B:C:D
        A=$A:E
这样，第一行我们设定A的值为"B:C:D"，然后，第二行再将值扩充为"A:B:C:E"。
上面的扩充范例，我们使用区隔符号( : )来达到扩充目的，
要是没有区隔符号的话，如下是有问题的：
        A=BCD
        A=$AE
因为第二次是将A的值继承$AE的提换结果，而非$A再加Eu
要解决此问题，我们可用更严谨的替换处理：
        A=BCD
        A=${A}E
上例中，我们使用{}将变量名称的范围给明确定义出来，
如此一来，我们就可以将A的变量值从BCD给扩充为BCDE。
(提示：关于${name}事实上还可做到更多的变量处理能力，这些均属于比较进阶的变量处理，现阶段暂时不介绍了，请大家自行参考数据。如CU的贴子：
http://www.chinaunix.net/forum/viewtopic.php?t=201843)
* export *
严格来说，我们在当前shell中所定义的变量，均属于"本地变量"(local variable)，
只有经过export命令的"输出"处理，才能成为环境变量(environment variable)：
        $ A=B
        $ export A
或：
        $ export A=B
经过export输出处理之后，变量A就能成为一个环境变量供其后的命令使用。
在使用export  的时侯，请别忘记shell在命令行对变量的"替换"(substitution)处理，
比方说：
        $ A=B
        $ B=C
        $ export $A
上面的命令并未将A输出为环境变量，而是将B作输出，
这是因为在这个命令行中，$A会首先被提换出B然后再"塞回"作export的参数。
要理解这个export，事实上需要从process的角度来理解才能透彻。
我将于下一章为大家说明process的观念，敬请留意。
*取消变量*
要取消一个变量，在bash中可使用unset命令来处理：
        unset A
与export一样，unset命令行也同样会作变量替换(这其实就是shell的功能之一)，
因此：
        $ A=B
        $ B=C
        $ unset $A
事实上所取消的变量是B而不是A。
此外，变量一旦经过unset取消之后，其结果是将整个变量拿掉，而不仅是取消其变量值。
如下两行其实是很不一样的：
        $ A=
        $ unset A
第一行只是将变量A设定为"空值"(null  value)，但第二行则让变量A不在存在。
虽然用眼睛来看，这两种变量状态在如下命令结果中都是一样的：
        $ A=
        $ echo $A
        $ unset A
        $ echo $A
请学员务必能识别null value与unset的本质区别，这在一些进阶的变量处理上是很严格的。
比方说：
        $ str=                #设为null
        $ var=${str=expr}        #定义var
        $ echo $var
       
        $ echo $str
       
        $ unset str        #取消
        $ var=${str=expr}        #定义var
        $ echo $var
        expr
        $ echo $str
        expr
聪明的读者(yes, you!)，稍加思考的话，
应该不难发现为何同样的var=${str=expr}在null与unset之下的不同吧？
若你看不出来，那可能是如下原因之一：
a.你太笨了
b.不了解  var=${str=expr}       这个进阶处理
c.对本篇说明还没来得及消化吸收
e.我讲得不好
不知，你选哪个呢？....  ^_^
 
再来解释一下var=${str=expr}：
首先，var=$str这个大家都可理解吧。
而接下来的思考方向是，究竟$str这个变量是如下哪一种情况呢：
1) unset
2) null
3) not null
1)假如是unset，那么var=${str=expr}的结果将是：
var=expr
str=expr
2)假如是null，那var=${str=expr}的结果是：
var=
str=
3)假如是not null (比方为xyz )，那var=${str=expr}之结果是：
var=xyz
str=xyz
测试如下：
$ showvar() {
>    var=${str=expr}
>    echo \$var is $var
>    echo \$str is $str
> }
$ unset str
$ showvar
$var is expr
$str is expr
$ str=
$ showvar
$var is
$str is
$ str=xyz
$ showvar
$var is xyz
$str is xyz
 
接下来，再来看看var=${str:=expr}好了：
1) $str为not set：
var=expr
str=expr
2) $str为null：
var=expr
str=expr
3) $str为not null (str=xyz)：
var=xyz
str=xyz
测试如下：
$ showvar() {
> var=${str:=expr}
> echo \$var is $var
> echo \$str is $str
> }
$ unset str
$ showvar
$var is expr
$str is expr
$ str=
$ showvar
$var is expr
$str is expr
$ str=xyz
$ showvar
$var is xyz
$str is xyz
最后比教一下${str=expr}与${str:=expr}：
*两者在not set与not null都一致
*但当null值时，${str=expr}会将$var与$str都设为null，但${str:=expr}则设为expr
 
从这个再延伸出其它模拟，不防请大家"实作"观查一下有何不同？
var=${str-expr} vs var=${str:-expr}
var=${str+expr} vs var=${str:+expr}
var=${str?expr} vs var=${str:?expr}
 
$ showvar() {
>    var=${str-expr}
>    echo \$var is $var
>    echo \$str is $str
> }
$ unset str
$ showvar
$var is expr
$str is
$ str=
$ showvar
$var is
$str is
$ str=xyz
$ showvar
$var is xyz
$str is xyz
 
$ showvar() {
>    var=${str:-expr}
>    echo \$var is $var
>    echo \$str is $str
> }
$ unset str
$ showvar
$var is expr
$str is
$ str=
$ showvar
$var is expr
$str is
$ str=xyz
$ showvar
$var is xyz
$str is xyz
 
可以看出来${str-expr}与${str:-expr}
*两者在$str为not set与not null都一致
*但当null值时，${str-expr}会将$var与$str都设为null，但${str:-expr}则将$var设为expr
 
$ showvar() {
>    var=${str+expr}
>    echo \$var is $var
>    echo \$str is $str
> }
$ unset str
$ showvar
$var is
$str is
$ str=
$ showvar
$var is expr
$str is
$ str=xyz
$ showvar
$var is expr
$str is xyz
$ showvar() {
>    var=${str:+expr}
>    echo \$var is $var
>    echo \$str is $str
> }
$ unset str
$ showvar
$var is
$str is
$ str=
$ showvar
$var is
$str is
$ str=xyz
$ showvar
$var is expr
$str is xyz
可以看出来${str+expr}与${str:+expr}
*两者在$str为not set与not null都一致
*但当null值时，${str+expr}会将$var与$str都设为expr，但${str:+expr}则将$var设为null
 
$ showvar() {
>    var=${str?expr}
>    echo \$var is $var
>    echo \$str is $str
> }
$ unset str
$ showvar
expr
$ str=
$ showvar
$var is
$str is
$ str=xyz
$ showvar
$var is xyz
$str is xyz
$ showvar() {
>    var=${str:?expr}
>    echo \$var is $var
>    echo \$str is $str
> }
$ unset str
$ showvar
expr
$ str=
$ showvar
expr
$ str=xyz
$ showvar
$var is xyz
$str is xyz
可以看出来${str?expr}与${str:?expr}
*两者在$str为not set与not null都一致
*但当null值时，${str?expr}会将$var与$str都设为null，但${str:?expr}则将$var设为expr
综上所述：
$var=${str=expr}与$var=${str:=expr}
$var=${str-expr}与$var=${str:-expr}
$var=${str+expr}与$var=${str:+expr}
$var=${str?expr}与$var=${str:?expr}
* 两者在 $str 为not set 与 not null 都一致
* 但当 null 值时不一致
分别描述如下：
$var=${str:-expr}的功能：
当str非空的时候var赋值为str，否则（包括not set和null）将var赋值为expr
$var=${str-expr}的功能：
当str非空的时候var赋值为str，为空的时候var设置为null，not set的时候将var赋值为expr
 
$var=${str:=expr}的功能：
当str非空的时候var赋值为str，否则（包括not set和null）将var和str均赋值为expr
$var=${str=expr}的功能：
当str非空的时候var赋值为str，为空的时候var设置为null，not set的时候将var和str均赋值为expr
 
$var=${str:?expr}的功能：
当str非空的时候var赋值为expr，否则将expr写入标准错误后退出
$var=${str?expr}的功能：
当str非空的时候var赋值为expr，为空的时候var设置为null，not set的时候将expr写入标准错误后退出
 
$var=${str:+expr}的功能：
当str非空的时候var赋值为expr，否则将不做任何操作
$var=${str+expr}的功能：
当str非空的时候var赋值为expr，为空的时候var设置为expr，not set的时候不做任何操作
 
看来还是带有冒号的简单，只有两种情况：非空和其他，呵呵
[]     
    
SHELL十三问之六：exec 跟 source 差在哪？
文章整理: 文章来源: 网络 
这次先让我们从CU Shell版的一个实例贴子来谈起吧：
例中的提问是：
cd /etc/aa/bb/cc可以执行，但是把这条命令写入shell时shell不执行！
这是什么原因呀！
我当时如何回答暂时别去深究，先让我们了解一下进程(process)的观念好了。
首先，我们所执行的任何程序，都是由父进程(parent process)所产生出来的一个子进程(child process)，子进程在结束后，将返回到父进程去。此一现像在Linux系统中被称为 fork。
当子进程被产生的时候，将会从父进程那里获得一定的资源分配、及(更重要的是)继承父进程的环境u
让我们回到上一章所谈到的"环境变量"吧：
*所谓环境变量其实就是那些会传给子进程的变量。
简单而言，"遗传性"就是区分本地变量与环境变量的决定性指标。
然而，从遗传的角度来看，我们也不难发现环境变量的另一个重要特征：
*环境变量只能从父进程到子进程单向继承。换句话说：在子进程中的环境如何变更，均不会影响父进程的环境。
接下来，再让我们了解一下命令脚本(shell script)的概念。
所谓的shell script讲起来很简单，就是将你平时在shell prompt后所输入的多行command line依序写入一个文件去而已。
其中再加上一些条件判断、互动界面、参数运用、函数调用、等等技巧，得以让script更加"聪明"的执行，但若撇开这些技巧不谈，我们真的可以简单的看成script只不过依次执行预先写好的命令行而已。
再结合以上两个概念(process + script)，那应该就不难理解如下这句话的意思了：
*正常来说，当我们执行一个shell script时，其实是先产生一个sub-shell的子进程，然后sub-shell再去产生命令行的子进程。
然则，那让我们回到本章开始时所提到的例子再从新思考：
cd /etc/aa/bb/cc可以执行，但是把这条命令写入shell时shell不执行！
这是什么原因呀！
我当时的答案是这样的：
因为，一般我们跑的shell script是用subshell去执行的。
从process的观念来看，是parent process产生一个child process去执行，当child结束后，会返回parent，但parent的环境是不会因child的改变而改变的。
所谓的环境元数很多，凡举effective id, variable, workding dir等等...
其中的workding dir ($PWD)正是楼主的疑问所在：
当用subshell来跑script的话，sub shell的$PWD会因为cd而变更，
但当返回primary shell时，$PWD是不会变更的。
能够了解问题的原因及其原理是很好的，但是？如何解决问题恐怕是我们更感兴趣的u是吧？^_^
那好，接下来，再让我们了解一下source命令好了。
当你有了fork的概念之后，要理解source就不难：
*所谓source就是让script在当前shell内执行、而不是产生一个sub-shell来执行。
由于所有执行结果均于当前shell内完成，若script的环境有所改变，当然也会改变当前环境了u
因此，只要我们要将原本单独输入的script命令行变成source命令的参数，就可轻易解决前例提到的问题了。
比方说，原本我们是如此执行  script的：
./my.script
现在改成这样即可：
source ./my.script
或：
. ./my.script
说到这里，我想，各位有兴趣看看/etc底下的众多设定文件，应该不难理解它们被定义后，如何让其它script读取并继承了吧？
若然，日后你有机会写自己的script，应也不难专门指定一个设定文件以供不同的script一起"共享"了...  ^_^
okay，到这里，若你搞得懂fork与source的不同，那接下来再接受一个挑战：
----那exec又与source/fork有何不同呢？
哦...要了解exec或许较为复杂，尤其扯上File Descriptor的话...
不过，简单来说：
* exec也是让script在同一个进程上执行，但是原有进程则被结束了。
也就是简而言之：原有进程会否终止，就是exec与source/fork的最大差异了。
嗯，光是从理论去理解，或许没那么好消化，不如动手"实作+思考"来的印像深刻哦。
下面让我们写两个简单的script，分别命令为1.sh及2.sh：
1.sh
#!/bin/sh
A=B
echo "PID for 1.sh before exec/source/fork:$$"
export A
echo "1.sh: \$A is $A"
case $1 in
        exec)
                echo "using exec..."
                exec ./2.sh ;;
        source)
                echo "using source..."
                . ./2.sh ;;
        *)
                echo "using fork by default..."
                ./2.sh ;;
esac
echo "PID for 1.sh after exec/source/fork:$$"
echo "1.sh: \$A is $A"
2.sh
#!/bin/sh
echo "PID for 2.sh: $$"
echo "2.sh get \$A=$A from 1.sh"
A=C
export A
echo "2.sh: \$A is $A"
然后，分别跑如下参数来观察结果：
$ ./1.sh fork
PID for 1.sh before exec/source/fork:531
1.sh: $A is B
using fork by default...
PID for 2.sh:532
2.sh get $A=B from 1.sh
2.sh: $A is C
PID for 1.sh after exec/source/fork:531
1.sh: $A is B
 
$ ./1.sh source
PID for 1.sh before exec/source/fork:533
1.sh: $A is B
using source...
PID for 2.sh:533
2.sh get $A=B from 1.sh
2.sh: $A is C
PID for 1.sh after exec/source/fork:533
1.sh: $A is C
 
$ ./1.sh exec
PID for 1.sh before exec/source/fork:537
1.sh: $A is B
using exec...
PID for 2.sh:537
2.sh get $A=B from 1.sh
2.sh: $A is C
############
echo "PID for 1.sh after exec/source/fork:$$"
echo "1.sh: \$A is $A"
已经不会执行了，1.sh的进程已经没了。
############## 
[]     
    
SHELL十三问之七：( ) 与 { } 差在哪？
文章整理: 文章来源: 网络 
先说一下，为何要用( )或{ }好了。
许多时候，我们在shell操作上，需要在一定条件下一次执行多个命令，也就是说，要么不执行，要么就全执行，而不是每次依序的判断是否要执行下一个命令。或是，需要从一些命令执行优先次顺中得到豁免，如算术的2*(3+4)那样...
这时候，我们就可引入"命令群组"(command group)的概念：将多个命令集中处理。
在shell command line中，一般人或许不太计较( )与{ }这两对符号的差异，虽然两者都可将多个命令作群组化处理，但若从技术细节上，却是很不一样的：
( )将command group置于sub-shell去执行，也称nested sub-shell。
{ }则是在同一个shell内完成，也称为non-named command group。
如果你对上一章的fork与source的概念还记得的话，那就不难理解两者的差异了。
要是在command group中扯上变量及其它环境的修改，我们可以根据不同的需求来使用( )或{ }。通常而言，若所作的修改是临时的，且不想影响原有或以后的设定，那我们就nested sub-shell，反之，则用non-named command group。
是的，光从command line来看，( )与{ }的差别就讲完了，够轻松吧~~~  ^_^
然而，若这两个meta用在其它command meta或领域中(如Regular Expression)，还是有很多差别的。只是，我不打算再去说明了，留给读者自己慢慢发掘好了...
我这里只想补充一个概念，就是function。
所谓的function，就是用一个名字去命名一个  command group，然后再调用这个名字去执行command group。从non-named command group来推断，大概你也可以猜到我要说的是{ }了吧？
在bash中，function的定义方式有两种：
方式一：
function function_name {
  command1
  command2
  command3
  ....
}
方式二：
fuction_name () {
  command1
  command2
  command3
  ....
}
用哪一种方式无所谓，只是若碰到所定义的名称与现有的命令或别名(Alias)冲突的话，方式二或许会失败。
但方式二起码可以少打function这一串英文字母，对懒人来说(如我)，又何乐不为呢？...  ^_^
function在某一程度来说，也可称为"函式"，但请不要与传统编程所使用的函式(library)搞混了，毕竟两者差异很大。
惟一相同的是，我们都可以随时用"已定义的名称"来调用它们...
若我们在shell操作中，需要不断的重复执行某些命令，我们首先想到的，或许是将命令写成命令稿(shell script)。不过，我们也可以写成function，然后在command line中打上function_name就可当一舨的script来使用了。只是若你在shell中定义的function，除了可用unset function_name取消外，一旦退出shell，function也跟着取消。
然而，在script中使用function却有许多好处，除了可以提高整体script的执行效能外(因为已被加载)，还可以节省许多重复的代码...
简单而言，若你会将多个命令写成script以供调用的话，那，你可以将function看成是script中的script ...  ^_^
而且，透过上一章介绍的source命令，我们可以自行定义许许多多好用的function，再集中写在特定文件中，然后，在其它的script中用source将它们加载并反复执行。
若你是RedHat Linux的使用者，或许，已经猜得出/etc/rc.d/init.d/functions这个文件是作啥用的了~~~  ^_^
[]     
    
SHELL十三问之八：$(( )) 与 $( ) 还有${ } 差在哪？
文章整理: 文章来源: 网络 
我们上一章介绍了( )与{ }的不同，这次让我们扩展一下，看看更多的变化：$( )与${ }又是啥玩意儿呢？
在bash shell中，$( )与` ` (反引号)都是用来做命令替换用(command substitution)的。
所谓的命令替换与我们第五章学过的变量替换差不多，都是用来重组命令行：
*完成引号里的命令行，然后将其结果替换出来，再重组命令行。
例如：
$ echo the last sunday is $(date -d "last sunday" +%Y-%m-%d)
如此便可方便得到上一星期天的日期了...
上例是在linux下，在FreeBSD下应该用下面的：
echo the last Sunday is `date Cv Sunday +%Y%m%d`
在操作上，用$( )或` `都无所谓，只是我"个人"比较喜欢用$( )，理由是：
1,  ` `很容易与' ' (单引号)搞混乱，尤其对初学者来说。
有时在一些奇怪的字形显示中，两种符号是一模一样的(直竖两点)。
当然了，有经验的朋友还是一眼就能分辩两者。只是，若能更好的避免混乱，又何乐不为呢？
2,在多层次的复合替换中，` `须要额外的跳脱( \` )处理，而$( )则比较直观。例如：
这是错的：
command1 `command2 `command3` `
原本的意图是要在command2 `command3`先将command3提换出来给command 2处理，然后再将结果传给command1 `command2 ...`来处理。
然而，真正的结果在命令行中却是分成了`command2 `与``两段。
正确的输入应该如下：
command1 `command2 \`command3\` `
要不然，换成$( )就没问题了：
command1 $(command2 $(command3))
只要你喜欢，做多少层的替换都没问题啦~~~  ^_^
不过，$( )并不是没有弊端的...
首先，` `基本上可用在全部的unix shell中使用，若写成shell script，其移植性比较高。
而$( )并不见的每一种shell都能使用，我只能跟你说，若你用bash2的话，肯定没问题...  
接下来，再让我们看${ }吧...它其实就是用来作变量替换用的啦。
一般情况下，$var与${var}并没有啥不一样。
但是用${ }会比较精确的界定变量名称的范围，比方说：
$ A=B
$ echo $AB
原本是打算先将$A的结果替换出来，然后再补一个B字母于其后，但在命令行上，真正的结果却是只会替换变量名称为AB的值出来...
若使用${ }就没问题了：
$ echo ${A}B
BB
不过，假如你只看到${ }只能用来界定变量名称的话，那你就实在太小看bash了u
有兴趣的话，你可先参考一下cu本版的精华文章：
http://www.chinaunix.net/forum/viewtopic.php?t=201843
为了完整起见，我这里再用一些例子加以说明${ }的一些特异功能：
假设我们定义了一个变量为：
file=/dir1/dir2/dir3/my.file.txt
我们可以用${ }分别替换获得不同的值：
${file#*/}：拿掉第一条/及其左边的字符串：dir1/dir2/dir3/my.file.txt
${file##*/}：拿掉最后一条/及其左边的字符串：my.file.txt
${file#*.}：拿掉第一个.  及其左边的字符串：file.txt
${file##*.}：拿掉最后一个.  及其左边的字符串：txt
${file%/*}：拿掉最后条/及其右边的字符串：/dir1/dir2/dir3
${file%%/*}：拿掉第一条/及其右边的字符串：(空值)
${file%.*}：拿掉最后一个.  及其右边的字符串：/dir1/dir2/dir3/my.file
${file%%.*}：拿掉第一个.  及其右边的字符串：/dir1/dir2/dir3/my
记忆的方法为：
#是去掉左边(在鉴盘上#在$之左边)
%是去掉右边(在鉴盘上%在$之右边)
单一符号是最小匹配r两个符号是最大匹配。
${file:0:5}：提取最左边的5个字节：/dir1
${file:5:5}：提取第5个字节右边的连续5个字节：/dir2
我们也可以对变量值里的字符串作替换：
${file/dir/path}：将第一个dir替换为path：/path1/dir2/dir3/my.file.txt
${file//dir/path}：将全部dir替换为path：/path1/path2/path3/my.file.txt
利用${ }还可针对不同的变量状态赋值(没设定、空值、非空值)：
${file-my.file.txt}：假如$file没有设定，则使用my.file.txt作传回值。(空值及非空值时不作处理)
${file:-my.file.txt}：假如$file没有设定或为空值，则使用my.file.txt作传回值。(非空值时不作处理)
${file+my.file.txt}：假如$file设为空值或非空值，均使用my.file.txt作传回值。(没设定时不作处理)
${file:+my.file.txt}：若$file为非空值，则使用my.file.txt作传回值。(没设定及空值时不作处理)
${file=my.file.txt}：若$file没设定，则使用my.file.txt作传回值，同时将$file赋值为my.file.txt。(空值及非空值时不作处理)
${file:=my.file.txt}：若$file没设定或为空值，则使用my.file.txt作传回值，同时将$file赋值为my.file.txt。(非空值时不作处理)
${file?my.file.txt}：若$file没设定，则将my.file.txt输出至STDERR。(空值及非空值时不作处理)
${file:?my.file.txt}：若$file没设定或为空值，则将my.file.txt输出至STDERR。(非空值时不作处理)
tips:
以上的理解在于,你一定要分清楚unset与null及non-null这三种赋值状态.
一般而言, :与null有关,若不带:的话, null不受影响,若带:则连null也受影响.
还有哦，${#var}可计算出变量值的长度：
${#file}可得到27，因为/dir1/dir2/dir3/my.file.txt刚好是27个字节...
接下来，再为大家介稍一下bash的组数(array)处理方法。
一般而言，A="a b c def"这样的变量只是将$A替换为一个单一的字符串，
但是改为A=(a b c def)，则是将$A定义为组数...
bash的组数替换方法可参考如下方法：
${A[@]}或${A
・ }可得到a b c def (全部组数)
${A[0]}可得到a (第一个组数)，${A[1]}则为第二个组数...
${#A[@]}或${#A
・ }可得到4 (全部组数数量)
${#A[0]}可得到1 (即第一个组数(a)的长度)，${#A[3]}可得到3 (第四个组数(def)的长度)
A[3]=xyz则是将第四个组数重新定义为xyz ...
诸如此类的....
能够善用bash的$( )与${ }可大大提高及简化shell在变量上的处理能力哦
好了，最后为大家介绍$(( ))的用途吧：它是用来作整数运算的。
在bash中，$(( ))的整数运算符号大致有这些：
+ - * /：分别为"加、减、乘、除"。
%：余数运算
& | ^ !：分别为"AND、OR、XOR、NOT"运算。
例：
$ a=5; b=7; c=2
$ echo $(( a+b*c ))
19
$ echo $(( (a+b)/c ))
6
$ echo $(( (a*b)%c))
1
在$(( ))中的变量名称，可于其前面加$符号来替换，也可以不用，如：
$(( $a + $b * $c))也可得到19的结果
此外，$(( ))还可作不同进位(如二进制、八进位、十六进制)作运算呢，只是，输出结果皆为十进制而已：
echo $((16#2a))结果为42 (16进位转十进制)
以一个实用的例子来看看吧：
假如当前的  umask是022，那么新建文件的权限即为：
$ umask 022
$ echo "obase=8;$(( 8#666 & (8#777 ^ 8#$(umask)) ))" | bc
644
事实上，单纯用(( ))也可重定义变量值，或作testing：
a=5; ((a++))可将$a重定义为6
a=5; ((a--))则为a=4
a=5; b=7; ((a < b))会得到  0 (true)的返回值。
常见的用于(( ))的测试符号有如下这些：
<：小于
>：大于
<=：小于或等于
>=：大于或等于
==：等于
!=：不等于
不过，使用(( ))作整数测试时，请不要跟[ ]的整数测试搞混乱了。(更多的测试我将于第十章为大家介绍)
上面的介绍，并没有详列每一种可用的状态，更多的，就请读者参考手册文件...
[]     
    
SHELL十三问之九：$@ 与 $* 差在哪？
文章整理: 文章来源: 网络 
要说$@与$*之前，需得先从shell script的positional parameter谈起...我们都已经知道变量(variable)是如何定义及替换的，这个不用再多讲了。但是，我们还需要知道有些变量是shell内定的，且其名称是我们不能随意修改的，其中就有positional parameter在内。
在shell script中，我们可用$0, $1, $2, $3 ...这样的变量分别提取命令行中的如下部份：
script_name parameter1 parameter2 parameter3 ...
我们很容易就能猜出$0就是代表shell script名称(路径)本身，而$1就是其后的第一个参数，如此类推....
须得留意的是IFS的作用，也就是，若IFS被quoting处理后，那么positional parameter也会改变。
如下例：
my.sh p1 "p2 p3" p4
由于在p2与p3之间的空格键被soft quote所关闭了，因此my.sh中的$2是"p2 p3"而$3则是p4 ...
还记得前两章我们提到fucntion时，我不是说过它是script中的script吗？  ^_^
是的，function一样可以读取自己的(有别于script的) postitional parameter，惟一例外的是$0而已。
举例而言：假设my.sh里有一个fucntion叫my_fun ,若在script中跑my_fun fp1 fp2 fp3，那么，function内的$0是my.sh，而$1则是fp1而非p1了...
不如写个简单的my.sh script  看看吧：
#!/bin/bash
my_fun() {
    echo '$0 inside function is '$0
    echo '$1 inside function is '$1
    echo '$2 inside function is '$2
}
echo '$0 outside function is '$0
echo '$1 outside function is '$1
echo '$2 outside function is '$2
my_fun fp1 "fp2 fp3"
然后在command line中跑一下script就知道了：
chmod +x my.sh
./my.sh p1 "p2 p3"
$0 outside function is ./my.sh
$1 outside function is p1
$2 outside function is p2 p3
$0 inside function is ./my.sh
$1 inside function is fp1
$2 inside function is fp2 fp3
然而，在使用positional parameter的时候，我们要注意一些陷阱哦：
* $10不是替换第10个参数，而是替换第一个参数($1)然后再补一个0于其后！
也就是，my.sh one two three four five six seven eigth nine ten这样的command line，my.sh里的$10不是ten而是one0哦...小心小心！
要抓到ten的话，有两种方法：
方法一是使用我们上一章介绍的${ }，也就是用${10}即可。
方法二，就是shift了。
用通俗的说法来说，所谓的shift就是取消positional parameter中最左边的参数( $0不受影响)。其默认值为1，也就是shift或shift 1  都是取消$1，而原本的$2则变成$1、$3变成$2 ...若shift 3则是取消前面三个参数，也就是原本的$4将变成$1 ...
那，亲爱的读者，你说要shift掉多少个参数，才可用$1取得${10}呢？^_^
okay，当我们对positional parameter有了基本概念之后，那再让我们看看其它相关变量吧。
首先是$#：它可抓出positional parameter的数量。
以前面的my.sh p1 "p2 p3"为例：
由于p2与p3之间的IFS是在soft quote中，因此$#可得到2的值。
但如果p2与p3没有置于quoting中话，那$#就可得到3的值了。
同样的道理在function中也是一样的...
因此，我们常在shell script里用如下方法测试script是否有读进参数：
 [ $# = 0 ]
假如为0，那就表示script没有参数，否则就是有带参数...
接下来就是$@与$*：
精确来讲，两者只有在soft quote中才有差异，否则，都表示"全部参数"( $0除外)。
举例来说好了：
若在command line上跑my.sh p1 "p2 p3" p4的话，
不管是$@还是$*，都可得到p1 p2 p3 p4就是了。
但是，如果置于soft quote中的话：
"$@"则可得到"p1" "p2 p3" "p4"这三个不同的词段(word)r
"$*"则可得到"p1 p2 p3 p4"这一整串单一的词段。
我们可修改一下前面的my.sh，使之内容如下：
#!/bin/bash
my_fun() {
    echo "$#"
}
echo 'the number of parameter in "$@" is '$(my_fun "$@")
echo 'the number of parameter in "$*" is '$(my_fun "$*")
然后再执行./my.sh p1 "p2 p3" p4就知道$@与$*差在哪了... 
the number of parameter in "$@" is3
the number of parameter in "$*" is1
[]     
    
SHELL十三问之十一：> 与 < 差在哪？
文章整理: 文章来源: 网络 
11.1
谈到 I/O redirection ，不妨先让我们认识一下 File Descriptor (FD) 。
程序的运算，在大部份情况下都是进行数据(data)的处理， 这些数据从哪读进？又送出到哪里呢？这就是 file descriptor (FD) 的功用了。
在 shell 程序中，最常使用的 FD 大概有三个，分别为：
0: Standard Input (STDIN)
1: Standard Output (STDOUT)
2: Standard Error Output (STDERR)
在标准情况下，这些 FD 分别跟如下设备(device)关联：
stdin(0): keyboard
stdout(1): monitor
stderr(2): monitor
我们可以用如下下命令测试一下：
 
$ mail -s test root
this is a test mail.
please skip.
^d (同时按 crtl 跟 d 键)
很明显，mail 程序所读进的数据，就是从 stdin 也就是 keyboard 读进的。不过，不见得每个程序的 stdin 都跟 mail 一样从 keyboard 读进，因为程序作者可以从档案参数读进 stdin ，如：
$ cat /etc/passwd
但，要是cat 之后没有档案参数则又如何呢？
哦，请您自己玩玩看.... ^_^
 
$ cat
(请留意数据输出到哪里去了，最后别忘了按 ^d 离开...)
至于 stdout 与 stderr ，嗯... 等我有空再续吧... ^_^
还是，有哪位前辈要来玩接龙呢？
11.2
沿文再续，书接上一回... ^_^
相信，经过上一个练习后，你对 stdin 与 stdout 应该不难理解吧？ 然后，让我们继续看 stderr 好了。
事实上，stderr 没甚么难理解的：说穿了就是"错误信息"要往哪边送而已...
比方说，若读进的档案参数是不存在的，那我们在 monitor 上就看到了：
 
$ ls no.such.file
ls: no.such.file: No such file or directory
若，一个命令同时产生stdout 与 stderr 呢？
那还不简单，都送到 monitor 来就好了：
 
$ touch my.file
$ ls my.file no.such.file
ls: no.such.file: No such file or directory
my.file
okay，至此，关于 FD 及其名称、还有相关联的设备，相信你已经没问题了吧？
那好，接下来让我们看看如何改变这些 FD 的预设数据信道，我们可用 < 来改变读进的数据信道(stdin)，使之从指定的档案读进。我们可用 > 来改变送出的数据信道(stdout, stderr)，使之输出到指定的档案。
比方说：
 
$ cat < my.file
就是从my.file 读进数据
 
$ mail -s test root < /etc/passwd
则是从/etc/passwd 读进...
这样一来，stdin 将不再是从 keyboard 读进，而是从档案读进了...
严格来说，< 符号之前需要指定一个 FD 的(之间不能有空白)， 但因为 0 是 < 的默认值，因此 < 与 0< 是一样的u
okay，这个好理解吧？
那，要是用两个 << 又是啥呢？
这是所谓的 HERE Document ，它可以让我们输入一段文本，直到读到 << 后指定的字符串。
比方说：
 
$ cat <<FINISH
first line here
second line there
third line nowhere
FINISH
这样的话，cat 会读进 3 行句子，而无需从 keyboard 读进数据且要等 ^d 结束输入。
至于 > 又如何呢？
且听下回分解....
--------------
11.3
okay，又到讲古时间~~~
当你搞懂了 0< 原来就是改变 stdin 的数据输入信道之后，相信要理解如下两个 redirection 就不难了：
* 1>
* 2>
前者是改变 stdout 的数据输出信道，后者是改变 stderr 的数据输出信道。
两者都是将原本要送出到 monitor 的数据转向输出到指定档案去。
由于 1 是 > 的默认值，因此，1> 与 > 是相同的，都是改 stdout 。
用上次的 ls 例子来说明一下好了：
 
$ ls my.file no.such.file 1>file.out
ls: no.such.file: No such file or directory
这样monitor 就只剩下 stderr 而已。因为 stdout 给写进 file.out 去了。
 
$ ls my.file no.such.file 2>file.err
my.file
这样monitor 就只剩下 stdout ，因为 stderr 写进了 file.err 。
 
$ ls my.file no.such.file 1>file.out 2>file.err
这样monitor 就啥也没有，因为 stdout 与 stderr 都给转到档案去了...
呵~~~ 看来要理解 > 一点也不难啦u是不？没骗你吧？ ^_^
不过，有些地方还是要注意一下的。
首先，是同时写入的问题。比方如下这个例子：
 
$ ls my.file no.such.file 1>file.both 2>file.both
假如stdout(1) 与 stderr(2) 都同时在写入 file.both 的话， 则是采取“覆盖”方式：后来写入的覆盖前面的。
让我们假设一个 stdout 与 stderr 同时写入 file.out 的情形好了：
* 首先 stdout 写入10个字符
* 然后 stderr 写入 6 个字符
那么，这时候原本 stdout 的前面 6 个字符就被 stderr 覆盖掉了。
那，如何解决呢？所谓山不转路转、路不转人转嘛，
我们可以换一个思维：将 stderr 导进 stdout 或将 stdout 导进 sterr ，而不是大家在抢同一份档案，不就行了u
bingou就是这样啦：
* 2>&1 就是将 stderr 并进 stdout 作输出
* 1>&2 或 >&2 就是将 stdout 并进 stderr 作输出
于是，前面的错误操作可以改为：
 
$ ls my.file no.such.file 1>file.both 2>&1
或
$ ls my.file no.such.file 2>file.both >&2
这样，不就皆大欢喜了吗？ 呵~~~ ^_^
不过，光解决了同时写入的问题还不够，我们还有其它技巧需要了解的。
故事还没结束，别走开u广告后，我们再回来...u
--------------
11.4
okay，这次不讲 I/O Redirction ，讲佛吧...
(有没搞错？u网中人是否头壳烧坏了？...) 嘻~~~ ^_^
学佛的最高境界，就是"四大皆空"。至于是空哪四大块？我也不知，因为我还没到那境界...
但这个"空"字，却非常值得我们返复把玩的：
--- 色即是空、空即是色u
好了，施主要是能够领会"空"的禅意，那离修成正果不远矣~~~
在 Linux 档案系统里，有个设备档位于 /dev/null 。
许多人都问过我那是甚么玩意儿？我跟你说好了：那就是"空"啦u
没错u空空如也的空就是 null 了.... 请问施主是否忽然有所顿误了呢？然则恭喜了~~~ ^_^
这个 null 在 I/O Redirection 中可有用得很呢：
* 若将 FD1 跟 FD2 转到 /dev/null 去，就可将 stdout 与 stderr 弄不见掉。
* 若将 FD0 接到 /dev/null 来，那就是读进 nothing 。
比方说，当我们在执行一个程序时，画面会同时送出 stdout 跟 stderr ， 假如你不想看到 stderr (也不想存到档案去)，那可以：
 
$ ls my.file no.such.file 2>/dev/null
my.file
若要相反：只想看到stderr 呢？还不简单u将 stdout 弄到 null 就行：
 
$ ls my.file no.such.file >/dev/null
ls: no.such.file: No such file or directory
那接下来，假如单纯只跑程序，不想看到任何输出结果呢？
哦，这里留了一手上次节目没讲的法子，专门赠予有缘人u... ^_^
除了用 >/dev/null 2>&1 之外，你还可以如此：
 
$ ls my.file no.such.file &>/dev/null
(提示：将 &> 换成 >& 也行啦~~! )
okay？讲完佛，接下来，再让我们看看如下情况：
 
$ echo "1" > file.out
$ cat file.out
1
$ echo "2" > file.out
$ cat file.out
2
看来，我们在重导stdout 或 stderr 进一份档案时，似乎永远只获得最后一次导入的结果。
那，之前的内容呢？
呵~~~ 要解决这个问提很简单啦，将 > 换成 >> 就好：
 
$ echo "3" >> file.out
$ cat file.out
2
3
如此一来，被重导的目标档案之内容并不会失去，而新的内容则一直增加在最后面去。
easy ？ 呵 ... ^_^
但，只要你再一次用回单一的 > 来重导的话，那么，旧的内容还是会被"洗"掉的u
这时，你要如何避免呢？
----备份u yes ，我听到了u不过.... 还有更好的吗？
既然与施主这么有缘份，老纳就送你一个锦囊妙法吧：
 
$ set -o noclobber
$ echo "4" > file.out
-bash: file: cannot overwrite existing file
那，要如何取消这个"限制"呢？
哦，将 set -o 换成 set +o 就行：
 
$ set +o noclobber
$ echo "5" > file.out
$ cat file.out
5
再问：那... 有办法不取消而又"临时"盖写目标档案吗？
哦，佛曰：不可告也u
啊~~~ 开玩笑的、开玩笑的啦~~~ ^_^ 唉，早就料到人心是不足的了u
 
$ set -o noclobber
$ echo "6" >| file.out
$ cat file.out
6
留意到没有：在> 后面再加个" | "就好(注意： > 与 | 之间不能有空白哦)....
呼.... (深呼吸吐纳一下吧)~~~ ^_^
再来还有一个难题要你去参透的呢：
 
$ echo "some text here" > file
$ cat < file
some text here
$ cat < file > file.bak
$ cat < file.bak
some text here
$ cat < file > file
$ cat < file
嗯？u注意到没有？uu
---- 怎么最后那个 cat 命令看到的 file 竟是空的？u
why? why? why?
同学们：下节课不要迟到~~~!
--------------
11.5
当当当~~~ 上课~~~ ^_^
前面提到：$ cat < file > file 之后原本有内容的档案结果却被洗掉了u
要理解这一现像其实不难，这只是 priority 的问题而已：
* 在 IO Redirection 中，stdout 与 stderr 的管道会先准备好，才会从 stdin 读进资料。
也就是说，在上例中，> file 会先将 file 清空，然后才读进 < file ， 但这时候档案已经被清空了，因此就变成读不进任何数据了...
哦~~~ 原来如此~~~~ ^_^
那... 如下两例又如何呢？
 
$ cat <> file
$ cat < file >> file
嗯... 同学们，这两个答案就当练习题，下节课之前请交作业u
好了，I/O Redirection 也快讲完了，sorry，因为我也只知道这么多而已啦~~~ 嘻~~ ^_^
不过，还有一样东东是一定要讲的，各位观众(请自行配乐~!#@!$%) ：
---- 就是 pipe line 也u
谈到 pipe line ，我相信不少人都不会陌生：
我们在很多 command line 上常看到的" | "符号就是 pipe line 了。
不过，究竟 pipe line 是甚么东东呢？
别急别急... 先查一下英汉字典，看看 pipe 是甚么意思？
没错u它就是"水管"的意思...
那么，你能想象一下水管是怎么一根接着一根的吗？
又，每根水管之间的 input 跟 output 又如何呢？
嗯？？
灵光一闪：原来 pipe line 的 I/O 跟水管的 I/O 是一模一样的：
* 上一个命令的 stdout 接到下一个命令的 stdin 去了u
的确如此... 不管在 command line 上你使用了多少个 pipe line ，
前后两个 command 的 I/O 都是彼此连接的u(恭喜：你终于开窍了u ^_^ )
不过... 然而... 但是... ... stderr 呢？
好问题u不过也容易理解：
* 若水管漏水怎么办？
也就是说：在 pipe line 之间，前一个命令的 stderr 是不会接进下一命令的 stdin 的， 其输出，若不用 2> 导到 file 去的话，它还是送到监视器上面来u
这点请你在 pipe line 运用上务必要注意的。
那，或许你又会问：
* 有办法将 stderr 也喂进下一个命令的 stdin 去吗？
(贪得无厌的家伙u)
方法当然是有，而且你早已学过了u ^_^
我提示一下就好：
* 请问你如何将 stderr 合并进 stdout 一同输出呢？
若你答不出来，下课之后再来问我吧... (如果你脸皮真够厚的话...)
或许，你仍意尤未尽u或许，你曾经碰到过下面的问题：
* 在 cm1 | cm2 | cm3 ... 这段 pipe line 中，若要将 cm2 的结果存到某一档案呢？
若你写成 cm1 | cm2 > file | cm3 的话，
那你肯定会发现 cm3 的 stdin 是空的u(当然啦，你都将水管接到别的水池了u)
聪明的你或许会如此解决：
 
cm1 | cm2 > file ; cm3 < file
是的，你的确可以这样做，但最大的坏处是：这样一来，file I/O 会变双倍u
在 command 执行的整个过程中，file I/O 是最常见的最大效能杀手。
凡是有经验的 shell 操作者，都会尽量避免或降低 file I/O 的频率。
那，上面问题还有更好方法吗？
有的，那就是 tee 命令了。
*所谓 tee 命令是在不影响原本 I/O 的情况下，将 stdout复制一份到档案去。
因此，上面的命令行可以如此打：
 
cm1 | cm2 | tee file | cm3
在预设上，tee 会改写目标档案，若你要改为增加内容的话，那可用 -a 参数达成。
基本上，pipe line 的应用在 shell 操作上是非常广泛的，尤其是在 text filtering 方面， 凡举 cat, more, head, tail, wc, expand, tr, grep, sed, awk, ... 等等文字处理工具， 搭配起 pipe line 来使用，你会惊觉 command line 原来是活得如此精彩的u
常让人有"众里寻他千百度，蓦然回首，那人却在灯火阑珊处u"之感... ^_^
....
好了，关于 I/O Redirection 的介绍就到此告一段落。
若日后有空的话，再为大家介绍其它在 shell 上好玩的东西ubye... ^_^ 
[]     
    
SHELL十三问之十二：你要 if 还是 case 呢？
文章整理: 文章来源: 网络 
还记得我们在第10 章所介绍的 return value 吗？
若你记得  return value ，我想你也应该记得了 && 与 || 是甚么意思吧？
用这两个符号再配搭 command group 的话，我们可让 shell script 变得更加聪明哦。
比方说：
comd1 && {
    comd2
    comd3
} || {
    comd4
    comd5
}
意思是说：
假如comd1 的 return value 为 true 的话，
然则执行 comd2 与 comd3 ，
否则执行 comd4 与 comd5 。
事实上，我们在写 shell script 的时候，经常需要用到这样那样的条件以作出不同的处理动作。
用 && 与 || 的确可以达成条件执行的效果，然而，从"人类语言"上来理解，却不是那么直观。
更多时候，我们还是喜欢用 if .... then ... else ... 这样的 keyword 来表达条件执行。
在 bash shell 中，我们可以如此修改上一段代码：
if comd1
then
    comd2
    comd3
else
    comd4
    comd5
fi
这也是我们在shell script 中最常用到的 if 判断式：
只要if 后面的 command line 返回 true 的 return value (我们最常用 test 命令来送出 return value)，然则就执行 then 后面的命令，否则执行  else 后的命令rfi 则是用来结束判断式的 keyword 。
在 if 判断式中，else 部份可以不用，但 then 是必需的。
(若 then 后不想跑任何 command ，可用" ： " 这个 null command 代替)。
当然，then 或 else 后面，也可以再使用更进一层的条件判断式，这在 shell script 设计上很常见。
若有多项条件需要"依序"进行判断的话，那我们则可使用 elif 这样的 keyword ：
if comd1; then
    comd2
elif comd3; then
    comd4
else
    comd5
fi
意思是说：
若comd1 为 true ，然则执行 comd2 r
否则再测试 comd3 ，然则执行 comd4 r
倘若 comd1 与 comd3 均不成立，那就执行 comd5 。
if 判断式的例子很常见，你可从很多 shell script 中看得到，我这里就不再举例子了...
接下来要为大家介绍的是 case 判断式。
虽然 if 判断式已可应付大部份的条件执行了，然而，在某些场合中，却不够灵活，尤其是在 string 式样的判断上，比方如下：
QQ () {
    echo -n "Do you want to continue? (Yes/No): "
    read YN
    if [ "$YN" = Y -o "$YN" = y -o "$YN" = "Yes" -o "$YN" = "yes" -o "$YN" = "YES" ]
    then
        QQ
    else
        exit 0
    fi
}
QQ
从例中，我们看得出来，最麻烦的部份是在于判断YN 的值可能有好几种式样。
聪明的你或许会如此修改：
...
if echo "$YN" | grep -q '^[Yy]\([Ee][Ss]\)*$'
...
也就是用Regular Expression 来简化代码。(我们有机会再来介绍 RE)
只是... 是否有其它更方便的方法呢？
有的，就是用 case 判断式即可：
QQ () {
    echo -n "Do you want to continue? (Yes/No): "
    read YN
   case "$YN" in
        [Yy]|[Yy][Ee][Ss])
            QQ
            ;;
        *)
            exit 0
            ;;
    esac
}
QQ
我们常case 的判断式来判断某一变量在同的值(通常是 string)时作出不同的处理，
比方说，判断 script 参数以执行不同的命令。
若你有兴趣、且用 Linux 系统的话，不妨挖一挖 /etc/init.d/* 里那堆 script 中的  case 用法。
如下就是一例：
case "$1" in
  start)
        start
        ;;
  stop)
        stop
        ;;
  status)
        rhstatus
        ;;
  restart|reload)
        restart
        ;;
  condrestart)
        [ -f /var/lock/subsys/syslog ] && restart || :
        ;;
  *)
        echo $"Usage: $0 {start|stop|status|restart|condrestart}"
        exit 1
esac
(若你对 positional parameter 的印像已经模糊了，请重看第 9 章吧。) 
[]     
    
SHELL十三问之十三：for、while 与 until 差在哪？
文章整理: 文章来源: 网络 
终于，来到shell 十三问的最后一问了...  长长吐一口气~~~~
最后要介绍的是 shell script 设计中常见的"循环"(loop)。
所谓的 loop 就是 script 中的一段在一定条件下反复执行的代码。
bash shell  中常用的 loop 有如下三种：
* for
* while
* until
for loop 是从一个清单列表中读进变量值，并"依次"的循环执行 do 到 done 之间的命令行。
例：
for var in one two three four five
do
    echo -----------
    echo '$var is '$var
    echo
done
上例的执行结果将会是：
1) for 会定义一个叫 var 的变量，其值依次是 one two three four five 。
2) 因为有 5 个变量值，因此 do 与 done 之间的命令行会被循环执行 5 次。
3) 每次循环均用 echo 产生三行句子。
     而第二行中不在 hard quote 之内的 $var 会依次被替换为 one two three four five 。
4) 当最后一个变量值处理完毕，循环结束。
我们不难看出，在  for loop 中，变量值的多寡，决定循环的次数。
然而，变量在循环中是否使用则不一定，得视设计需求而定。
倘若 for loop 没有使用 in 这个 keyword 来指定变量值清单的话，其值将从 $@ (或 $* )中继承：
for var; do
    ....
done
(若你忘记了 positional parameter ，请温习第 9 章...)
for loop 用于处理"清单"(list)项目非常方便，其清单除了可明确指定或从 positional parameter 取得之外，也可从变量替换或命令替换取得... (再一次提醒：别忘了命令行的"重组"特性u)
然而，对于一些"累计变化"的项目(如整数加减)，for 亦能处理：
for ((i=1;i<=10;i++))
do
   echo "num is $i"
done
除了for loop ，上面的例子我们也可改用  while loop 来做到：
num=1
while [ "$num" -le 10 ]; do
    echo "num is $num"
    num=$(($num + 1))
done
while loop 的原理与 for loop 稍有不同：
它不是逐次处理清单中的变量值，而是取决于 while 后面的命令行之 return value ：
* 若为 ture ，则执行 do 与 done 之间的命令，然后重新判断 while 后的 return value 。
* 若为 false ，则不再执行 do 与 done 之间的命令而结束循环。
分析上例：
1) 在 while 之前，定义变量 num=1 。
2) 然后测试(test) $num 是否小于或等于 10 。
3) 结果为 true ，于是执行 echo 并将 num 的值加一。
4) 再作第二轮测试，其时 num 的值为 1+1=2 ，依然小于或等于 10，因此为  true ，继续循环。
5) 直到 num 为 10+1=11 时，测试才会失败... 于是结束循环。
我们不难发现：
* 若 while 的测试结果永远为 true 的话，那循环将一直永久执行下去：
while :; do
    echo looping...
done
上例的" : "是 bash 的 null command ，不做任何动作，除了送回 true 的 return value 。
因此这个循环不会结束，称作死循环。
死循环的产生有可能是故意设计的(如跑 daemon)，也可能是设计错误。
若要结束死寻环，可透过 signal 来终止(如按下 ctrl-c )。
(关于 process 与 signal ，等日后有机会再补充，十三问暂时略过。)
一旦你能够理解 while loop 的话，那，就能理解 until loop ：
* 与 while 相反，until 是在 return value 为 false 时进入循环，否则结束。
因此，前面的例子我们也可以轻松的用  until 来写：
num=1
until [ ! "$num" -le 10 ]; do
    echo "num is $num"
    num=$(($num + 1))
done
或是：
num=1
until [ "$num" -gt 10 ]; do
    echo "num is $num"
    num=$(($num + 1))
done
okay ，关于 bash 的三个常用的 loop 暂时介绍到这里。
在结束本章之前，再跟大家补充两个与 loop 有关的命令：
*  break
* continue
这两个命令常用在复合式循环里，也就是在 do ... done 之间又有更进一层的 loop ，
当然，用在单一循环中也未尝不可啦...  ^_^
break 是用来打断循环，也就是"强迫结束" 循环。
若 break 后面指定一个数值 n 的话，则"从里向外"打断第 n 个循环，默认值为 break 1 ，也就是打断当前的循环。
在使用 break 时需要注意的是， 它与 return 及 exit 是不同的：
* break 是结束 loop
* return 是结束 function
* exit 是结束 script/shell
而 continue 则与 break 相反：强迫进入下一次循环动作。
若你理解不来的话，那你可简单的看成：在 continue 到 done 之间的句子略过而返回循环顶端...
与 break 相同的是：continue 后面也可指定一个数值 n ，以决定继续哪一层(从里向外计算)的循环，
默认值为 continue 1 ，也就是继续当前的循环。
在 shell script 设计中，若能善用 loop ，将能大幅度提高 script 在复杂条件下的处理能力。
请多加练习吧....
-----------
好了，该是到了结束的时候了。
婆婆妈妈的跟大家唆了一堆关于 shell 的基础概念，目的不是要告诉大家"答案"，而是要带给大家"启发"...
在日后关于 shell 的讨论中，我或许会经常用"链接"方式指引回来十三问中的内容，以便我们在进行技术探讨时彼此能有一些讨论基础，而不至于各说各话、徒费时力。但，更希望十三问能带给你更多的思考与乐趣，至为重要的是透过实作来加深理解。
是的，我很重视"实作"与"独立思考"这两项学习要素，若你能够掌握其中真义，那请容我说声：
--- 恭喜u十三问你没白看了u  ^_^
p.s.
至于补充问题部份，我暂时不写了。而是希望：
1) 大家扩充题目。
2) 一起来写心得。
Good luck and happy studying!
[]     
    
《Unix Shell 实例精解》学习笔记之grep篇
文章整理: 文章来源: 网络 
1．grep的含义是“全局搜索正则表达式(RE)并打印该行”
2.grep 的选项
 选项   功能
 -b  在各行之前放置它发现的块号。有时在根据上下文定位磁盘字块时有用
 -c  显示匹配行数而不是内容
 -h  不显示文件名
 -I  在座比较时忽略字母大小写
 -n  文件中每行之前给出它的相关行号
 -s  无声操作。即除了错误消息外不做任何显示。用于检查退出状态
 -v  把搜索翻转为只显示不匹配的行
 -w  把表达式当作一个次来搜索，相当于用\<和\>括起来
3．grep命令的退出状态
   如果grep操作成功，则状态是0，如果模式没找到，状态是1，如果文件没找到，状态是2。如果操作被取消，则状态是130。
   查看状态的方法：
  在csh中用echo $status。
  在sh和ksh中用echo $? 。
例如
  $ echo $? 0
    5
4.带正则表达式的grep举例：
   用于这些例子的文本文件叫datafile，位于chap03目录(你也可以放在别的目录下)。datafile内容如下：
northwest NW Charles Main      3.0 .98 3 34
western  WE Sharon Gray      5.3 .97 5 23
southwest SW Lewis Dalsass      2.7 .8 2 18
southern SO Suan Chin      5.1  .95 4 15
southeast SE      Patricia Hemenway    4.0  .7  4  17
eastern  EA  TB Savage       4.4  .84  5  20
northeast  NE  AM Main Jr.       5.1  .94  3  13
north   NO  Margot Weber       4.5  .89 5  9
central  CT  Ann Stephens         5.7  .94   5  13
1) % grep NW datafile
解释：打印datafile中包含NW的行
2) grep NW d*
解释：打印所有以d开头的文件中含有NW的文件。
3) % grep '^n' datafile
解释：打印文件datafile中所有以字母n开头的行
4) % grep TB Savage datafile
解释：在Savage和datafile文件中查找有TB的行
5) % grep 'TB Savage' datafile
解释：在datafile文件中查找含有TB Savage的行并打印。
6) % grep '^[we]' datafile
解释：打印datafile中以w或者e开头的行
7) % grep 'ss* ' datafile
northwest NW Charles Main      3.0 .98 3 34
southwest SW Lewis Dalsass      2.7 .8 2 18
解释：打印所有包含一个s并跟0个或者多个s，然后跟一个空格的行
6．用管道的grep.
grep 可以从管道得到输入。
% ls Cl
drwxr-xr-x 6 oracle dba    512   4月 3 21:49 chap10
drwxr-xr-x 2 oracle dba    512   4月 10 22:23 exam
-rwxr--r-- 1 oracle dba    1842  4月 3 21:51 readme.txt
-rwxr--r-- 1 oracle dba    1801  4月 3 21:51 unix_readme.txt
% ls Cl | grep '^d'
drwxr-xr-x 6 oracle dba    512   4月 3 21:49 chap10
drwxr-xr-x 2 oracle dba    512   4月 10 22:23 exam
% ls -l |grep '^[^d]'
-rwxr--r-- 1 oracle dba    1842  4月 3 21:51 readme.txt
-rwxr--r-- 1 oracle dba    1801  4月 3 21:51 unix_readme.txt
7．带选项的grep举例：
% grep Cc ‘west’ datafile
  3
解释:计算datafile中含有west的总数。
8．egrep (扩展的grep)
   egrep可以使用额外的正则表达式，如下表。
元字符 功能                        例子               解释
+      匹配一个或多个前驱字符    '[a-z]+ove'        匹配一个或多个小写字母，后跟ove
?      匹配0个或者1个前驱字符    'lo?ve'            将找到love或love
a|b    匹配a或者b                'love|hate'        与love或hate匹配
()     组字符                    'lov(ely|able)     与lovely或lovable匹配
9．egrep 举例：
% egrep '2\.?[0-9]' datafile
解释：打印所有这样的行：它包含一个2，后跟0个或者一个句号，然后跟一个数字。
10． fgrep
fgrep 把所有的元字符都当作字符本身，只代表自己。
11． UNIX 工具试验参考答案（内容参考datebook）
(1) 打印包含San的行
% grep 'San' datebook
(2) 打印所有以J开头的人名所在的行
% grep '^J' datebook
(3) 打印以700结尾的行
% grep '700$' datebook
(4) 打印所有不包含834的行
% grep -v '834' datebook
(5) 打印出生在12月(December)的行
% grep '/12' datebook
(6) 打印工资是6位数的行，并给出行号
% grep -n '[0-9]\{6,\}$' datebook 
[]     
    
《Unix Shell 实例精解》学习笔记之sed篇
文章整理: 文章来源: 网络 
1．sed命令简介
sed是流线型、非交互式编辑器。它允许你执行与vi和ex编辑器里一样的编辑任务。Sed 程序不是与编辑器交互式工作的，而是让你在命令行里敲入编辑的命令，给文件命名，然后在屏幕上查看命令输出结果。
2．sed工作原理
sed编辑器按一次处理一行的方式来处理文件，并把输出送到屏幕上。
3．sed 可以用寻址的方式来决定想要编辑哪一行。
4．sed 命令和选项
命令 功能
a\  在当前行上添加一个文本行或者多个文本行
c\  用新闻本改变（取代）当前行里的文本
d  删除行
i\  在当前行之前插入文本
h  把模式空间内容复制到一个固定缓存
H  把模式空间内容添加到一个固定缓存
g  得到固定缓存里所有的禀复制到模式缓存，重写其内容
G  得到固定缓存的内容并复制到模式缓存，添加到里面
I  列出不打印的字符
p  打印行
n  读下一输入行，并开始用下一个命令处理换行符，而不是用第一个命令
q  结束或退出sed
r  从一个文件读如行
!  把命令应用到除了选出的行以外的其他所有行
s  把一个字串替换成另一个
替换标志
g  在一行上进行全局替换
p  打印行
w  把行写到一个文件中
x  用模式空间的内容交换固定缓存的内容
y  把一个字符转换成另一个(不能和整则表达式元字符一起使用)
5．sed元字符
    基本上，grep和vi使用的元字符都可以用在sed中。下表列出了一些特别的sed元字符：
元字符 &                            
功能 保存搜索串以便可以记在替换串里
例子    s/love/**&**/
解释    &号代表搜索串。串love将被星号包围的自身所替代；即love变成**love**
6． sed 的实例(使用datafile)
datafile内容如下：
northwest NW Charles Main      3.0 .98 3 34
western  WE Sharon Gray      5.3 .97 5 23
southwest SW Lewis Dalsass      2.7 .8 2 18
southern SO Suan Chin      5.1  .95 4 15
southeast SE      Patricia Hemenway    4.0  .7  4  17
eastern  EA  TB Savage       4.4  .84  5  20
northeast  NE  AM Main Jr.       5.1  .94  3  13
north   NO  Margot Weber       4.5  .89 5   9
central  CT  Ann Stephens         5.7  .94   5  13
1> 打印：p命令
sed '/north/p' datafile
默认输出所有行，找到north的行重复打印
sed Cn '/north/p' datafile
禁止默认输出，只打印找到north的行
2> 删除：d命令
sed '3d' datafile
删除第三行，其余行输出到屏幕
sed '3,$d' datafile
从第3行到最后一行都删除，将剩余部分输出到屏幕
sed '/north/d' datafile
将含有north的行删除，其余输出到屏幕
3> 替换：s命令
sed 's/west/north/g' datafile
解释：找到datafile中的所有west并替换成north，将替换后的内容输出到屏幕。
sed 's/[0-9][0-9]$/&.5/' datafile
解释：在替代串里的&字符代表在搜索串中真正找到的。每个以两个数字结尾的行都被它自己取代，且要在后面加上.5
sed -n 's/Hemenway/Jones/gp' datafile
解释：所有的Hemenway所在的位置都用Jones来取代，而且只有改变的行被打印。-n与p命令选项相结合来禁止默认输出。g代表全局替换
sed -n 's/\(Mar\)got/\1ianne/p' datafile
解释：模式Mar被封装在括弧里且在一个专用寄存器里存为标记1。在替换串里它将被引用做\1。然后用Marianne替代Margot。
sed 's#3#88#g' datafile
解释：s命令后面的字符是搜索串和替换串之间的分界符。默认的分界符是一个正斜杠，但也可以改变（只有使用s命令时）。无论s命令后面跟什么字符，它都是新的串分界符。当搜索包含一个正斜杠的模式，如路径或生日时，这种技巧可能有用的 ^V^
4> 被选中的行的范围：逗号
sed -n '/west/,/east/p' datafile
解释：打印在west和east之间的模式范围内所有行。如果west出现在east之后，则打印从west到下一个east或者到文件末尾的行，无论哪种情况先出现都可以。
sed '/west/,/east/s/$/**VACA**/' datafile
解释：对于在模式west到east范围内的行，行末尾将用**VACA**来取代。
5> 多次编辑 -e 选项
sed -e '1,3d' -e 's/Hemenway/Jones/' datafile
-e选项允许多次编辑。不同的编辑顺序可能导致不同的结果。
例如，如果两个命令都执行了替换，第一次替换可能影响第二次替换。
6> 从文件中读取：r命令
sed '/Suan/r newfile' datafile
解释：r命令从newfile中读取内容，将内容输出到Suan的后面。如果datafile中Suan出现的次数不只一次，则分别放到Suan的后面。
7> 写入文件：w命令
sed -n '/north/w newfile' datafile
解释：w命令把指定的行写入到一个文件。本例中所有的包含north的行写入到newfile中。
等同于 sed -n '/north/p' datafile > newfile
8> 添加：a命令
$ sed '/north/a\
  > ---->THE NORTH SALES DISTRICT HAS MOVED<-----' datafile
 northwest NW Charles Main      3.0 .98 3 34
  ---->THE NORTH SALES DISTRICT HAS MOVED<-----
 western WE Sharon Gray      5.3 .97 5 23
 southwest SW Lewis Dalsass      2.7 .8 2 18
 southern SO Suan Chin      5.1  .95 4 15
 southeast SE      Patricia Hemenway    4.0  .7  4  17
 eastern  EA  TB Savage       4.4  .84  5  20
 northeast  NE  AM Main Jr.       5.1  .94  3  13
 ---->THE NORTH SALES DISTRICT HAS MOVED<-----
 north   NO  Margot Weber       4.5  .89 5  9
 ---->THE NORTH SALES DISTRICT HAS MOVED<-----
 central  CT  Ann Stephens         5.7  .94   5  13
    解释：红颜色的内容是要输入的内容。a\命令后面跟要添加的内容。奇怪的是a\后面必须另起一行，在输入要添加的内容，否则会提示命令错乱，真是搞不懂。
9> 插入：i命令
$ sed '/north/i\
  > ---->THE NORTH SALES DISTRICT HAS MOVED<-----' datafile
  ---->THE NORTH SALES DISTRICT HAS MOVED<-----
 northwest NW Charles Main      3.0 .98 3 34
  ---->THE NORTH SALES DISTRICT HAS MOVED<-----
 western WE Sharon Gray      5.3 .97 5 23
 southwest SW Lewis Dalsass      2.7 .8 2 18
 southern SO Suan Chin      5.1  .95 4 15
 southeast SE      Patricia Hemenway    4.0  .7  4  17
 eastern  EA  TB Savage       4.4  .84  5  20
 ---->THE NORTH SALES DISTRICT HAS MOVED<-----
 northeast  NE  AM Main Jr.       5.1  .94  3  13
 ---->THE NORTH SALES DISTRICT HAS MOVED<-----
 north   NO  Margot Weber       4.5  .89 5  9
 central  CT  Ann Stephens         5.7  .94   5  13
10>下一个：n命令
$ sed '/eastern/{n;s/AM/Archie/;}' datafile
  northwest NW Charles Main      3.0 .98 3 34
  western WE Sharon Gray      5.3 .97 5 23
  southwest SW Lewis Dalsass      2.7 .8 2 18
  southern SO Suan Chin      5.1  .95 4 15
  southeast SE      Patricia Hemenway    4.0  .7  4  17
  eastern  EA  TB Savage       4.4  .84  5  20
  northeast  NE  AM Main Jr.       5.1  .94  3  13
  ......
解释：如果在某一行里模式eastern被匹配，n命令使sed区的下一行，用该行带换模式空间，用Archie替换AM，打印并继续。
11>变换：y 命令
% sed '1,3y/abcdefghijklmnopqrst/ABCDEFGHIJKLMNOPQRST/' datafile
解释:将对应字母进行转换。
12>退出：q命令
% sed '5q' datafile
解释：在打印了5行之后，用q命令退出sed程序。
13>保存和取得：h和G命令
$ sed -e '/southeast/h' -e '$G' datafile
 northwest NW Charles Main      3.0 .98 3 34
 western  WE Sharon Gray      5.3 .97 5 23
 southwest SW Lewis Dalsass      2.7 .8 2 18
 southern SO Suan Chin      5.1  .95 4 15
 southeast SE      Patricia Hemenway    4.0  .7  4  17
 eastern  EA  TB Savage       4.4  .84  5  20
 northeast  NE  AM Main Jr.       5.1  .94  3  13
 north   NO  Margot Weber       4.5  .89 5   9
 central  CT  Ann Stephens         5.7  .94   5  13
 southeast SE      Patricia Hemenway    4.0  .7  4  17
解释：当sed处理文件时，每行都存在模式空间(pattern space)的临时缓存中。除非行被禁止打印或删除,否则行将在处理完后被打印到屏幕，然后请模式空间并把下一输入行保存在那里等待处理。在这个例子中，在找到模式之后，把它放在模式空间里，而且h命令复制它并把它存到另一个叫做保存缓存(holding buffer)中。
第二个sed指令里，当读入最后一行($)时,G命令告诉sed从包存缓存中取得该行并放回模式空间缓存，添加到当前存在那里的行中。本例子就是最后一行。
$ sed -e '/WE/{h;d;}' -e '/CT/G' datafile
 northwest NW Charles Main      3.0 .98 3 34
 southwest SW Lewis Dalsass      2.7 .8 2 18
 southern SO Suan Chin      5.1  .95 4 15
 southeast SE      Patricia Hemenway    4.0  .7  4  17
 eastern  EA  TB Savage       4.4  .84  5  20
 northeast  NE  AM Main Jr.       5.1  .94  3  13
 north   NO  Margot Weber       4.5  .89 5   9
 central  CT  Ann Stephens         5.7  .94   5  13
 western WE Sharon Gray      5.3 .97 5 23
解释：第一个命令h将找到了WE的行放到保存缓存中，然后删除该行；第二个命令/CT/G就是在找到了CT的行的后面加入保存缓存的内容。
14>G和g的区别
    G命令在符合的条件行后面添加保存缓存中的内容；g命令用保存缓存中的内容覆盖符合条件的行。
15>sed 命令的花括号{}的作用
   花括号{}中可以放入多个命令，每个命令后面要用分号;。
16>保存和交换：h 和 x命令。
$ sed -e '/Patricia/h' -e '/Margot/x' datafile
northwest  NW  Charles Main   3.0  .98  3  34
western  WE  Sharon Gray   5.3  .97  5  23
southwest  SW  Lewis Dalsass  2.7  .8  2  18
southern  SO  Suan Chin          5.1  .95  4  15
southeast  SE  Patricia Hemenway  4.0  .7  4  17
eastern  EA  TB Savage          4.4  .84  5  20
northeast  NE  AM Main Jr.          5.1  .94  3  13
southeast  SE  Patricia Hemenway  4.0  .7  4  17
central  CT  Ann Stephens          5.7  .94  5  13
解释：x命令将找到的行用保存缓存中的内容替换。
7． 用sed来编写命令表
     sed 命令表(script)是文件里的一个sed命令列表。用-f选项来引用一个命令表文件。编辑sed命令表有特殊要求：命令末尾不能有任何为岁的空白符或者文本。如果命令不是自成一行，就必须用分号结束。在源代码chap4目录下有两个编辑好的命令表文件(sedding1和sedding2)可以参考。
   下面是使用sed命令表的例子。
$ sed -f sedding1 datafile
  EMPLOYEE DATABASE
  ---------------------
  northwest NW Charles Main 3.0 .98 3 34
  western WE Sharon Gray 5.3 .97 5 23
  southwest SW Lewis Dalsass 2.7 .8 2 18
 Lewis is the TOP Salesperson for April!!
 Lewis is moving to the southern district next month.
 CONGRATULATIONS!
  southern SO Suan Chin 5.1 .95 4 15
  southeast SE Patricia Hemenway 4.0 .7 4 17
  eastern EA TB Savage 4.4 .84 5 20
  northeast NE AM Main Jr. 5.1 .94 3 13
 *******************
        MARGOT HAS RETIRED
 *******************
8． Sed练习参考答案
    练习内容参考databook文件
 1〉 把Jon改成Jonathan
sed 's/Jon/Jonathan/' datebook
2〉 删除头3行
sed '1,3d' datebook
3〉 打印5―10行
sed -n '5,10p' datebook
4〉 删除包含Lane的行
sed '/Lane/d' datebook
5〉 打印所有生日是在Noverber到December之间的行
sed -n '/:1[12]\//p' datebook
6〉 把三个星添加到以Fred开头的行尾
sed '/^Fred/s/$/***/' datebook
7〉 用JOSE HAS RETIRED取代包含Jose的行
sed 's/^Jose[0-9]*[a-z]*[A-Z]* *.*$/JOSE HAS LEFT/' datebook
8〉 把Popeye的生日改成11/14/46
sed '/Popeye/s/:[0-9]*[0-9]*\/[0-9]*[0-9]*\/[0-9]*[0-9]*/:11\/14\/46/' datebook
9〉 删除所有空白行 sed '/^$/d' datebook 10〉 写一个sed命令表，将:
a. 在第1行之前插入标题PERSONNEL FILE
b. 删除以500结尾的工资
c. 打印文件内容，把姓和名颠倒
d. 在文件末尾添加THE END
答案放在chap04/a10文件中，内容如下：
# My first sed script by Wangzhh.
1i\
 PERSONNEL FILE
/500/d
s/\([A-Z][a-z]*\) \([A-Z][a-z]*\):/\2 \1:/
$a\
 THE END 
[]     
    
sed 实例讲解(上篇)
文章整理: 文章来源: 网络 
前面的几句罗嗦话
在 UNIX/Linux 世界中有很多文本编辑器(如：vi、emacs 和 jed 以及很多其它工具)可供我们选择。我们都有自己熟悉并且喜爱的编辑器(和我们喜爱的组合键)。有了可信赖的编辑器，我们可以轻松处理任何数量与 UNIX 有关的管理或编程任务。
虽然交互式编辑器很棒，但却有其限制。尽管其交互式特性可以成为强项，但也有其不足之处。考虑一下需要对一组文件执行类似更改的情形。您可能会本能地运行自己所喜爱的编辑器，然后手工执行一组烦琐、重复和耗时的编辑任务。然而，有一种更好的方法。
开始说sed了，注意好好听
如果可以使编辑文件的过程自动化，以便用“批处理”方式编辑文件，甚至编写可以对现有文件进行复杂更改的脚本，那将太好了。幸运的是，对于这种情况，有一种更好的方法 -- 这种更好的方法称为 "sed"。
sed 是一种几乎包括在所有 UNIX/Linux 平台的轻量级流编辑器。sed 有许多很好的特性。首先，它相当小巧，通常要比您所喜爱的脚本语言小很多倍。其次，因为 sed 是一种流编辑器，所以，它可以对从如管道这样的标准输入接收的数据进行编辑。因此，无需将要编辑的数据存储在磁盘上的文件中。因为可以轻易将数据管道输出到 sed，所以，将 sed 用作强大的 shell 脚本中长而复杂的管道很容易。试一下用您所喜爱的编辑器去那样做。
GNU sed
对 Linux 用户来说幸运的是，最好的 sed 版本之一恰好是 GNU sed，其当前版本是 3.02。每一个 Linux 发行版都有（或至少应该有）GNU sed。GNU sed 之所以流行不仅因为可以自由分发其源代码，还因为它恰巧有许多对 POSIX sed 标准便利、省时的扩展。另外，GNU 没有 sed 早期专门版本的很多限制，如行长度限制 -- GNU 可以轻松处理任意长度的行。
最新的 GNU sed
在研究这篇文章之时我注意到：几个在线 sed 爱好者提到 GNU sed 3.02a。奇怪的是，在ftp.gnu.org上找不到sed 3.02a，所以，我只得在别处寻找。我在alpha.gnu.org 的 /pub/sed 中找到了它。于是我高兴地将其下载、编译然后安装，而几分钟后我发现最新的 sed 版本却是 3.02.80 -- 可在alpha.gnu.org 上 3.02a 源代码旁边找到其源代码。安装完 GNU sed 3.02.80 之后，我就完全准备好了。
alpha.gnu.org
alpha.gnu.org是新的和实验性 GNU 源代码的所在地。然而，您还会在那里发现许多优秀、稳定的源代码。出于某种原因，不是许多 GNU 开发人员忘记将稳定的源代码移至ftp.gnu.org，就是它们的 "beta" 期间格外长（2 年！）。例如，sed 3.02a 已有两年，甚至 3.02.80 也有一年。
 
正确的 sed
在本系列中，将使用 GNU sed 3.02.80。在即将出现的本系列后续文章中，某些（但非常少）最高级的示例将不能在 GNU sed 3.02 或 3.02a 中使用。如果您使用的不是 GNU sed，那么结果可能会不同。现在为什么不花些时间安装 GNU sed 3.02.80 呢？那样，不仅可以为本系列的余下部分作好准备，而且还可以使用可能是目前最好的 sed。
sed 示例
sed 通过对输入数据执行任意数量用户指定的编辑操作（“命令”）来工作。sed 是基于行的，因此按顺序对每一行执行命令。然后，sed 将其结果写入标准输出 (stdout)，它不修改任何输入文件。
让我们看一些示例。头几个会有些奇怪，因为我要用它们演示 sed 如何工作，而不是执行任何有用的任务。然而，如果您是 sed 新手，那么理解它们是十分重要的。下面是第一个示例：
$ sed -e 'd' /etc/services
如果输入该命令，将得不到任何输出。那么，发生了什么？在该例中，用一个编辑命令 'd' 调用 sed。sed 打开 /etc/services 文件，将一行读入其模式缓冲区，执行编辑命令（“删除行”），然后打印模式缓冲区（缓冲区已为空）。然后，它对后面的每一行重复这些步骤。这不会产生输出，因为 "d" 命令除去了模式缓冲区中的每一行！
在该例中，还有几件事要注意。首先，根本没有修改 /etc/services。这还是因为 sed 只读取在命令行指定的文件，将其用作输入 -- 它不试图修改该文件。第二件要注意的事是 sed 是面向行的。'd' 命令不是简单地告诉 sed 一下子删除所有输入数据。相反，sed 逐行将 /etc/services 的每一行读入其称为模式缓冲区的内部缓冲区。一旦将一行读入模式缓冲区，它就执行 'd' 命令，然后打印模式缓冲区的内容（在本例中没有内容）。我将在后面为您演示如何使用地址范围来控制将命令应用到哪些行 -- 但是，如果不使用地址，命令将应用到所有行。
第三件要注意的事是括起 'd' 命令的单引号的用法。养成使用单引号来括起 sed 命令的习惯是个好注意，这样可以禁用 shell 扩展。
另一个 sed 示例
下面是使用 sed 从输出流除去 /etc/services 文件第一行的示例：
$ sed -e '1d' /etc/services | more
如您所见，除了前面有 '1' 之外，该命令与第一个 'd' 命令十分类似。如果您猜到 '1' 指的是第一行，那您就猜对了。与第一个示例中只使用 'd' 不同的是，这一次使用的 'd' 前面有一个可选的数字地址。通过使用地址，可以告诉 sed 只对某一或某些特定行进行编辑。
地址范围
现在，让我们看一下如何指定地址范围。在本例中，sed 将删除输出的第 1 到 10 行：
$ sed -e '1,10d' /etc/services | more
当用逗号将两个地址分开时，sed 将把后面的命令应用到从第一个地址开始、到第二个地址结束的范围。在本例中，将 'd' 命令应用到第 1 到 10 行（包括这两行）。所有其它行都被忽略。
带规则表达式的地址
现在演示一个更有用的示例。假设要查看 /etc/services 文件的内容，但是对查看其中包括的注释部分不感兴趣。如您所知，可以通过以 '#' 字符开头的行在 /etc/services 文件中放置注释。为了避免注释，我们希望 sed 删除以 '#' 开始的行。以下是具体做法：
$ sed -e '/^#/d' /etc/services | more
试一下该例，看看发生了什么。您将注意到，sed 成功完成了预期任务。现在，让我们分析发生的情况。
要理解 '/^#/d' 命令，首先需要对其剖析。首先，让我们除去 'd' -- 这是我们前面所使用的同一个删除行命令。新增加的是 '/^#/' 部分，它是一种新的规则表达式地址。规则表达式地址总是由斜杠括起。它们指定一种模式，紧跟在规则表达式地址之后的命令将仅适用于正好与该特定模式匹配的行。
因此，'/^#/' 是一个规则表达式。但是，它做些什么呢？很明显，现在该复习规则表达式了。
规则表达式复习
可以使用规则表达式来表示可能会在文本中发现的模式。您在 shell 命令行中用过 '*' 字符吗？这种用法与规则表达式类似，但并不相同。下面是可以在规则表达式中使用的特殊字符：
字符  描述 
%  与行首匹配 
  与行末尾匹配 
  与任一个字符匹配 
  将与前一个字符的零或多个出现匹配 
[ ]  与 [ ] 之内的所有字符匹配 
感受规则表达式的最好方法可能是看几个示例。所有这些示例都将被 sed 作为合法地址接受，这些地址出现在命令的左边。下面是几个示例：
规则
表达式  描述 
/./  将与包含至少一个字符的任何行匹配 
/../  将与包含至少两个字符的任何行匹配 
/^#/  将与以 '#' 开始的任何行匹配 
/^$/  将与所有空行匹配 
/}^/  将与以 '}'（无空格）结束的任何行匹配 
/} *^/  将与以 '}' 后面跟有零或多个空格结束的任何行匹配 
/[abc]/ 将与包含小写 'a'、'b' 或 'c' 的任何行匹配 
/^[abc]/ 将与以 'a'、'b' 或 'c'开始的任何行匹配 
在这些示例中，鼓励您尝试几个。花一些时间熟悉规则表达式，然后尝试几个自己创建的规则表达式。可以如下使用 regexp：
$ sed -e '/regexp/d' /path/to/my/test/file | more
这将导致 sed 删除任何匹配的行。然而，通过告诉 sed打印 regexp 匹配并删除不匹配的内容，而不是与之相反的方法，会更有利于熟悉规则表达式。可以用以下命令这样做：
$ sed -n -e '/regexp/p' /path/to/my/test/file | more
请注意新的 '-n' 选项，该选项告诉 sed 除非明确要求打印模式空间，否则不这样做。您还会注意到，我们用 'p' 命令替换了 'd' 命令，如您所猜想的那样，这明确要求 sed 打印模式空间。就这样，将只打印匹配部分。
有关地址的更多内容
目前为止，我们已经看到了行地址、行范围地址和 regexp 地址。但是，还有更多的可能。我们可以指定两个用逗号分开的规则表达式，sed 将与所有从匹配第一个规则表达式的第一行开始，到匹配第二个规则表达式的行结束（包括该行）的所有行匹配。例如，以下命令将打印从包含 "BEGIN" 的行开始，并且以包含 "END" 的行结束的文本块：
$ sed -n -e '/BEGIN/,/END/p' /my/test/file | more
如果没发现 "BEGIN"，那么将不打印数据。如果发现了 "BEGIN"，但是在这之后的所有行中都没发现 "END"，那么将打印所有后续行。发生这种情况是因为 sed 面向流的特性 -- 它不知道是否会出现 "END"。
C 源代码示例
如果只要打印 C 源文件中的 main() 函数，可输入：
$ sed -n -e '/main[[]]*(/,/^}/p' sourcefile.c | more
该命令有两个规则表达式 '/main[[]]*(/' 和 '/^}/'，以及一个命令 'p'。第一个规则表达式将与后面依次跟有任意数量的空格或制表键以及开始圆括号的字符串 "main" 匹配。这应该与一般 ANSI C main() 声明的开始匹配。
在这个特别的规则表达式中，出现了 '[[]]' 字符类。这只是一个特殊的关键字，它告诉 sed 与 TAB 或空格匹配。如果愿意的话，可以不输入 '[[]]'，而输入 '['，然后是空格字母，然后是 -V，然后再输入制表键字母和 ']' -- Control-V 告诉 bash 要插入“真正”的制表键，而不是执行命令扩展。使用 '[[]]' 命令类（特别是在脚本中）会更清楚。
好，现在看一下第二个 regexp。'/^}' 将与任何出现在新行行首的 '}' 字符匹配。如果代码的格式很好，那么这将与 main() 函数的结束花括号匹配。如果格式不好，则不会正确匹配 -- 这是执行模式匹配任务的一件棘手之事。
因为是处于 '-n' 安静方式，所以 'p' 命令还是完成其惯有任务，即明确告诉 sed 打印该行。试着对 C 源文件运行该命令 -- 它应该输出整个 main() { } 块，包括开始的 "main()" 和结束的 '}'。 
[]     
    
sed 实例讲解(中篇)
文章整理: 文章来源: 网络 
sed 是很有用（但常被遗忘）的 UNIX 流编辑器。在以批处理方式编辑文件或以有效方式创建 shell 脚本来修改现有文件方面，它是十分理想的工具。
替换！
让我们看一下 sed 最有用的命令之一，替换命令。使用该命令，可以将特定字符串或匹配的规则表达式用另一个字符串替换。下面是该命令最基本用法的示例：
$ sed -e 's/foo/bar/' myfile.txt
上面的命令将 myfile.txt 中每行第一次出现的 'foo'（如果有的话）用字符串 'bar' 替换，然后将该文件内容输出到标准输出。请注意，我说的是每行第一次出现，尽管这通常不是您想要的。在进行字符串替换时，通常想执行全局替换。也就是说，要替换每行中的所有出现，如下所示： 
$ sed -e 's/foo/bar/g' myfile.txt 
在最后一个斜杠之后附加的 'g' 选项告诉 sed 执行全局替换。
关于 's///' 替换命令，还有其它几件要了解的事。首先，它是一个命令，并且只是一个命令，在所有上例中都没有指定地址。这意味着，'s///' 还可以与地址一起使用来控制要将命令应用到哪些行，如下所示：
$ sed -e '1,10s/enchantment/entrapment/g' myfile2.txt 
上例将导致用短语 'entrapment' 替换所有出现的短语 'enchantment'，但是只在第一到第十行（包括这两行）上这样做。
$ sed -e '/^$/,/^END/s/hills/mountains/g' myfile3.txt 
该例将用 'mountains' 替换 'hills'，但是，只从空行开始，到以三个字符 'END' 开始的行结束（包括这两行）的文本块上这样做。
关于 's///' 命令的另一个妙处是 '/' 分隔符有许多替换选项。如果正在执行字符串替换，并且规则表达式或替换字符串中有许多斜杠，则可以通过在 's' 之后指定一个不同的字符来更改分隔符。例如，下例将把所有出现的 /usr/local 替换成 /usr：
$ sed -e 's:/usr/local:/usr:g' mylist.txt 
在该例中，使用冒号作为分隔符。如果需要在规则表达式中指定分隔符字符，可以在它前面加入反斜杠。
规则表达式混乱
目前为止，我们只执行了简单的字符串替换。虽然这很方便，但是我们还可以匹配规则表达式。例如，以下 sed 命令将匹配从 '<' 开始、到 '>' 结束、并且在其中包含任意数量字符的短语。下例将删除该短语（用空字符串替换）：
$ sed -e 's/<.*>//g' myfile.html 
这是要从文件除去 HTML 标记的第一个很好的 sed 脚本尝试，但是由于规则表达式的特有规则，它不会很好地工作。原因何在？当 sed 试图在行中匹配规则表达式时，它要在行中查找最长的匹配。在我的前一篇 sed 文章中，这不成问题，因为我们使用的是 'd' 和 'p' 命令，这些命令总要删除或打印整行。但是，在使用 's///' 命令时，确实有很大不同，因为规则表达式匹配的整个部分将被目标字符串替换，或者，在本例中，被删除。这意味着，上例将把下行：
<b>This</b> is what <b>I</b> meant. 
变成：
 meant. 
我们要的不是这个，而是：
 This is what I meant. 
幸运的是，有一种简便方法来纠正该问题。我们不输入“'<' 字符后面跟有一些字符并以 '>' 字符结束”的规则表达式，而只需输入一个“'<' 字符后面跟有任意数量非 '>' 字符并以 '>' 字符结束”的规则表达式。这将与最短、而不是最长的可能性匹配。新命令如下：
 $ sed -e 's/<[^>]*>//g' myfile.html 
在上例中，'[^>]' 指定“非 '>'”字符，其后的 '*' 完成该表达式以表示“零或多个非 '>' 字符”。对几个 html 文件测试该命令，将它们管道输出到 "more"，然后仔细查看其结果。
更多字符匹配
'[ ]' 规则表达式语法还有一些附加选项。要指定字符范围，只要字符不在第一个或最后一个位置，就可以使用 '-'，如下所示：
 '[a-x]*' 
这将匹配零或多个全部为 'a'、'b'、'c'...'v'、'w'、'x' 的字符。另外，可以使用 '[]' 字符类来匹配空格。以下是可用字符类的相当完整的列表：
字符类   描述 
[:alnum:] 字母数字 [a-z A-Z 0-9]
[:alpha:] 字母 [a-z A-Z]
[:blank:] 空格或制表键
[:cntrl:] 任何控制字符
[:digit:] 数字 [0-9]
[:graph:] 任何可视字符（无空格）
[:lower:] 小写 [a-z]
[:print:] 非控制字符
[:punct:] 标点字符
[:space:] 空格
[:upper:] 大写 [A-Z]
[:xdigit:] 十六进制数字 [0-9 a-f A-F]
 
尽可能使用字符类是很有利的，因为它们可以更好地适应非英语 locale（包括某些必需的重音字符等等）.
高级替换功能
我们已经看到如何执行简单甚至有些复杂的直接替换，但是 sed 还可以做更多的事。实际上可以引用匹配规则表达式的部分或全部，并使用这些部分来构造替换字符串。作为示例，假设您正在回复一条消息。下例将在每一行前面加上短语 "ralph said: "：
 $ sed -e 's/.*/ralph said: &/' origmsg.txt 
输出如下： 
 ralph said: Hiya Jim, ralph said: ralph said: 
 I sure like this sed stuff! ralph said: 
该例的替换字符串中使用了 '&' 字符，该字符告诉 sed 插入整个匹配的规则表达式。因此，可以将与 '.*' 匹配的任何内容（行中的零或多个字符的最大组或整行）插入到替换字符串中的任何位置，甚至多次插入。这非常好，但 sed 甚至更强大。
那些极好的带反斜杠的圆括号
's///' 命令甚至比 '&' 更好，它允许我们在规则表达式中定义区域，然后可以在替换字符串中引用这些特定区域。作为示例，假设有一个包含以下文本的文件：
 foo bar oni eeny meeny miny larry curly moe jimmy the weasel 
现在假设要编写一个 sed 脚本，该脚本将把 "eeny meeny miny" 替换成 "Victor eeny-meeny Von miny" 等等。要这样做，首先要编写一个由空格分隔并与三个字符串匹配的规则表达式。
 '.* .* .*' 
现在，将在其中每个感兴趣的区域两边插入带反斜杠的圆括号来定义区域：
 '\(.*\) \(.*\) \(.*\)' 
除了要定义三个可在替换字符串中引用的逻辑区域以外，该规则表达式的工作原理将与第一个规则表达式相同。下面是最终脚本：
 $ sed -e 's/\(.*\) \(.*\) \(.*\)/Victor \1-\2 Von \3/' myfile.txt 
如您所见，通过输入 '\x'（其中，x 是从 1 开始的区域号）来引用每个由圆括号定界的区域。输入如下：
 Victor foo-bar Von oni Victor eeny-meeny Von miny Victor larry-curly Von moe Victor jimmy-the Von weasel 
随着对 sed 越来越熟悉，您可以花最小力气来进行相当强大的文本处理。您可能想如何使用熟悉的脚本语言来处理这种问题 -- 能用一行代码轻易实现这样的解决方案吗？
组合使用
在开始创建更复杂的 sed 脚本时，需要有输入多个命令的能力。有几种方法这样做。首先，可以在命令之间使用分号。例如，以下命令系列使用 '=' 命令和 'p' 命令，'=' 命令告诉 sed 打印行号，'p' 命令明确告诉 sed 打印该行（因为处于 '-n' 模式）。
 $ sed -n -e '=;p' myfile.txt 
无论什么时候指定了两个或更多命令，都按顺序将每个命令应用到文件的每一行。在上例中，首先将 '=' 命令应用到第 1 行，然后应用 'p' 命令。接着，sed 继续处理第 2 行，并重复该过程。虽然分号很方便，但是在某些场合下，它不能正常工作。另一种替换方法是使用两个 -e 选项来指定两个不同的命令：
 $ sed -n -e '=' -e 'p' myfile.txt 
然而，在使用更为复杂的附加和插入命令时，甚至多个 '-e' 选项也不能帮我们的忙。对于复杂的多行脚本，最好的方法是将命令放入一个单独的文件中。然后，用 -f 选项引用该脚本文件：
 $ sed -n -f mycommands.sed myfile.txt 
这种方法虽然可能不太方便，但总是管用。
一个地址的多个命令
有时，可能要指定应用到一个地址的多个命令。这在执行许多 's///' 以变换源文件中的字和语法时特别方便。要对一个地址执行多个命令，可在文件中输入 sed 命令，然后使用 '{ }' 字符将这些命令分组，如下所示：
 1,20{  s/[Ll]inux/GNU\/Linux/g  s/samba/Samba/g  s/posix/POSIX/g } 
上例将把三个替换命令应用到第 1 行到第 20 行（包括这两行）。还可以使用规则表达式地址或者二者的组合：
 1,/^END/{         s/[Ll]inux/GNU\/Linux/g         s/samba/Samba/g         s/posix/POSIX/g  p } 
该例将把 '{ }' 之间的所有命令应用到从第 1 行开始，到以字母 "END" 开始的行结束（如果在源文件中没发现 "END"，则到文件结束）的所有行。
附加、插入和更改行
既然在单独的文件中编写 sed 脚本，我们可以利用附加、插入和更改行命令。这些命令将在当前行之后插入一行，在当前行之前插入一行，或者替换模式空间中的当前行。它们也可以用来将多行插入到输出。插入行命令用法如下：
 i\ This line will be inserted before each line 
如果不为该命令指定地址，那么它将应用到每一行，并产生如下的输出：
 This line will be inserted before each line line 1 here 
 This line will be inserted before each line line 2 here 
 This line will be inserted before each line line 3 here 
 This line will be inserted before each line line 4 here 
如果要在当前行之前插入多行，可以通过在前一行之后附加一个反斜杠来添加附加行，如下所示：
 i\ insert this line\ and this one\ and this one\ and, uh, this one too.
 
附加命令的用法与之类似，但是它将把一行或多行插入到模式空间中的当前行之后。其用法如下：
 a\ insert this line after each line.  Thanks! :) 
另一方面，“更改行”命令将实际替换模式空间中的当前行，其用法如下：
 c\ You're history, original line! Muhahaha! 
因为附加、插入和更改行命令需要在多行输入，所以将把它们输入到一个文本 sed 脚本中，然后通过使用 '-f' 选项告诉 sed 执行它们。使用其它方法将命令传递给 sed 会出现问题。 
[]     
    
sed 实例讲解(下篇)
文章整理: 文章来源: 网络 
在上一篇sed介绍文章中，我们演示 sed 的工作原理，但是它们当中很少有示例能实际做特别有用的事。在这篇 sed 系列的最后文章中，我要改变那种方式，并使用 sed 来做实际的事。我将为您显示几个示例，它们不仅演示 sed 的能力，而且还做一些真正巧妙（和方便）的事。例如，在本文的后半部，将为您演示如何设计一个 sed 脚本来将 .QIF 文件从 Intuit 的 Quicken 金融程序转换成具有良好格式的文本文件。在那样做之前，我们将看一下不怎么复杂但却很有用的 sed 脚本。
文本转换
第一个实际脚本将 UNIX 风格的文本转换成 DOS/Windows 格式。您可能知道，基于 DOS/Windows 的文本文件在每一行末尾有一个 CR（回车）和 LF（换行），而 UNIX 文本只有一个换行。有时可能需要将某些 UNIX 文本移至 Windows 系统，该脚本将为您执行必需的格式转换。
 $ sed -e 's/$/\r/' myunix.txt > mydos.txt 
在该脚本中，'$' 规则表达式将与行的末尾匹配，而 '\r' 告诉 sed 在其之前插入一个回车。在换行之前插入回车，立即，每一行就以 CR/LF 结束。请注意，仅当使用 GNU sed 3.02.80 或以后的版本时，才会用 CR 替换 '\r'。如果还没有安装 GNU sed 3.02.80，请在我的 第一篇 sed 文章中查看如何这样做的说明。
我已记不清有多少次在下载一些示例脚本或 C 代码之后，却发现它是 DOS/Windows 格式。虽然很多程序不在乎 DOS/Windows 格式的 CR/LF 文本文件，但是有几个程序却在乎 -- 最著名的是 bash，只要一遇到回车，它就会出问题。以下 sed 调用将把 DOS/Windows 格式的文本转换成可信赖的 UNIX 格式：
 $ sed -e 's/.$//' mydos.txt > myunix.txt 
该脚本的工作原理很简单：替代规则表达式与一行的最末字符匹配，而该字符恰好就是回车。我们用空字符替换它，从而将其从输出中彻底删除。如果使用该脚本并注意到已经删除了输出中每行的最末字符，那么，您就指定了已经是 UNIX 格式的文本文件。也就没必要那样做了！
反转行
下面是另一个方便的小脚本。与大多数 Linux 发行版中包括的 "tac" 命令一样，该脚本将反转文件中行的次序。"tac" 这个名称可能会给人以误导，因为 "tac" 不反转行中字符的位置（左和右），而是反转文件中行的位置（上和下）。用 "tac" 处理以下文件：
 foo bar oni 
....将产生以下输出：
 oni bar foo 
可以用以下 sed 脚本达到相同目的：
 $ sed -e '1!G;h;$!d' forward.txt > backward.txt 
如果登录到恰巧没有 "tac" 命令的 FreeBSD 系统，将发现该 sed 脚本很有用。虽然方便，但最好还是知道该脚本为什么那样做。让我们对它进行讨论。
反转解释
首先，该脚本包含三个由分号隔开的单独 sed 命令：'1!G'、'h' 和 '$!d'。现在，需要好好理解用于第一个和第三个命令的地址。如果第一个命令是 '1G'，则 'G' 命令将只应用第一行。然而，还有一个 '!' 字符 -- 该 '!' 字符 忽略该地址，即，'G' 命令将应用到除第一行之外的 所有行。'$!d' 命令与之类似。如果命令是 '$d'，则将只把 'd' 命令应用到文件中的最后一行（'$' 地址是指定最后一行的简单方式）。然而，有了 '!' 之后，'$!d' 将把 'd' 命令应用到除最后一行之外的 所有行。现在，我们所要理解的是这些命令本身做什么。
当对上面的文本文件执行反转脚本时，首先执行的命令是 'h'。该命令告诉 sed 将模式空间（保存正在处理的当前行的缓冲区）的内容复制到保留空间（临时缓冲区）。然后，执行 'd' 命令，该命令从模式空间中删除 "foo"，以便在对这一行执行完所有命令之后不打印它。
现在，第二行。在将 "bar" 读入模式空间之后，执行 'G' 命令，该命令将保留空间的内容 ("foo\n") 附加到模式空间 ("bar\n")，使模式空间的内容为 "bar\n\foo\n"。'h' 命令将该内容放回保留空间保护起来，然后，'d' 从模式空间删除该行，以便不打印它。
对于最后的 "oni" 行，除了不删除模式空间的内容（由于 'd' 之前的 '$!'）以及将模式空间的内容（三行）打印到标准输出之外，重复同样的步骤。
现在，要用 sed 执行一些强大的数据转换。
sed QIF 魔法
过去几个星期，我一直想买一份 Quicken来结算我的银行帐户。Quicken 是一个非常好的金融程序，当然会成功地完成这项工作。但是，经过考虑之后，我觉得自己可以轻易编写某个软件来结算我的支票簿。我想，毕竟，我是个软件开发人员！
我开发了一个很好的小型支票簿结算程序（使用 awk），它通过分析包含我的所有交易的文本文件的语法来计算余额。略微调整之后，我将其改进，以便可以象 Quicken 那样跟踪不同的贷款和借款类别。但是，我还要添加一个特性。最近，我将帐户转移到一家有联机 Web 帐户界面的银行。有一天，我注意到，这家银行的 Web 站点允许以 Quicken 的 .QIF 格式下载我的帐户信息。我马上觉得，如果可以将该信息转换成文本格式，那就太棒了。
两种格式的故事
在查看 QIF 格式之前，先看一下我的 checkbook.txt 格式：
28 Aug 2000   food   -   -   Y   Supermarket   30.94 25 Aug 2000    watr   -  103   Y  Check 103  52.86 
在我的文件中，所有字段都由一个或多个制表符分开，每个交易占据一行。日期之后的下一个字段列出支出类型（如果是收入项，则为 "-"）。第三个字段列出收入类型（如果是支出项，则为 "-"）。然后，是一个支票号字段（如果为空，则还是 "-"），一个交易完成字段（"Y" 或 "N"），一个注释和一个美元金额字段。现在，让我们看一下 QIF 格式。当用文本查看器查看下载的 QIF 文件时，它看起来如下：
!Type:Bank D08/28/2000 T-8.15 N PCHECKCARD SUPERMARKET ^ D08/28/2000 T-8.25 N PCHECKCARD PUNJAB RESTAURANT ^ D08/28/2000 T-17.17 N PCHECKCARD SUPERMARKET 
浏览过文件之后，不难猜出其格式 -- 忽略第一行，其余的格式如下：
    
         D<数据> 
T<交易量> 
N<支票号> 
P<描述> 
^   （这是字段分隔符）
      
开始处理
在处理象这样重要的 sed 项目时，不要气馁 -- sed 允许您将数据逐渐修改成最终形式。在进行当中，可以继续细化 sed 脚本，直到输出与预期的完全一样为止。无需在试第一次时就保证其完全正确。
要开始，首先创建一个名为 "qiftrans.sed" 的文件，然后开始修改数据：
 1d /^^/d s/[[:cntrl:]]//g 
第一个 '1d' 命令删除第一行，第二个命令从输出除去那些讨厌的 '^' 字符。最后一行除去文件中可能存在的任何控制字符。既然在处理外来文件格式，我想消除在中途遇到任何控制字符的风险。到目前为止，一切顺利。现在，要向该基本脚本中添加一些处理功能：
 1d /^^/d s/[[:cntrl:]]//g /^D/ {
 s/^D\(.*\)/\1\tOUTY\tINNY\t/
 s/^01/Jan/         s/^02/Feb/
 s/^03/Mar/         s/^04/Apr/
 s/^05/May/         s/^06/Jun/
 s/^07/Jul/         s/^08/Aug/
 s/^09/Sep/         s/^10/Oct/
 s/^11/Nov/         s/^12/Dec/
 s:^\(.*\)/\(.*\)/\(.*\):\2 \1 \3:  } 
首先，添加一个 '/^D/' 地址，以便 sed 只在遇到 QIF 数据字段的第一个字符 'D' 时才开始处理。当 sed 将这样一行读入其模式空间时，将按顺序执行花括号中的所有命令。
花括号中的第一个命令将把如下行：
 D08/28/2000 
变换成：
 08/28/2000 OUTY INNY 
当然，现在的格式还不完美，但没关系。我们将在进行过程中逐渐细化模式空间的内容。后面 12 行的最后效果是将数据变换成三个字母的格式，最后一行从数据中除去三个斜杠。最后得到这一行：
 Aug 28 2000 OUTY INNY 
OUTY 和 INNY 字段是占位符，以后将被替换。现在还不能确定它们，因为如果美元金额为负，将把 OUTY 和 INNY 设置成 "misc" 和 "-"，但是，如果美元金额为正，将分别把它们更改成 "-" 和 "inco"。既然还没有读入美元金额，所以，需要暂时使用占位符。
细化
现在进一步细化：
 1d  /^^/d s/[[:cntrl:]]//g  /^D/ {
 s/^D\(.*\)/\1\tOUTY\tINNY\t/
 s/^01/Jan/          s/^02/Feb/
         s/^03/Mar/          s/^04/Apr/
   s/^05/May/          s/^06/Jun/
   s/^07/Jul/          s/^08/Aug/
   s/^09/Sep/          s/^10/Oct/
   s/^11/Nov/          s/^12/Dec/
   s:^\(.*\)/\(.*\)/\(.*\):\2 \1 \3:
   N          N          N         
   s/\nT\(.*\)\nN\(.*\)\nP\(.*\)/NUM\2NUM\t\tY\t\t\3\tAMT\1AMT/
   s/NUMNUM/-/          s/NUM\([0-9]*\)NUM/\1/
   s/\([0-9]\),/\1/  } 
后七行有些复杂，所以将详细讨论它们。首先，连续使用三个 'N' 命令。'N' 命令告诉 sed 将 下一行读入输入中，然后将其附加到当前模式空间。这三个 'N' 命令导致将下三行附加到当前模式空间缓冲区，现在这一行看起来如下：
 28 Aug 2000 OUTY INNY \nT-8.15\nN\nPCHECKCARD SUPERMARKET 
sed 的模式空间变得很难看 -- 需要除去额外的新行，并执行某些附加的格式化。要这样做，将使用替代命令。要匹配的模式为：
 '\nT.*\nN.*\nP.*' 
这将与后面依次跟有 'T'、零或多个字符、新行、'N'、任何数量的字符、新行、'P'、以及任何数量字符的新行匹配。呀！这个规则表达式将与刚刚附加到模式空间的三行的全部内容匹配。但我们要重新格式化该区域，而不是整个替换它。美元金额、支票号（如果有的话）和描述需要出现在替换字符串中。要这样做，我们用带有反斜杠的圆括号括起那些“感兴趣部分”，以便可以在替换字符串中引用它们（使用 '\1'、'\2\ 和 '\3' 来告诉 sed 将它们插入到何处）。以下是最后的命令：
 s/\nT\(.*\)\nN\(.*\)\nP\(.*\)/NUM\2NUM\t\tY\t\t\3\tAMT\1AMT/  
该命令将我们的行变换成：
  28 Aug 2000  OUTY  INNY  NUMNUM    Y    CHECKCARD SUPERMARKET  AMT-8.15AMT 
虽然该行正变得好一些，但是，有几件事一看就有点...啊...有趣。首先是那个愚蠢的 "NUMNUM" 字符串 -- 其目的何在？如果查看 sed 脚本的后两行，就会发现其目的，后两行将把 "NUMNUM" 替换成 "-"，而把 "NUM"<number>"NUM" 替换成 <number>。如您所见，用愚蠢的标记括起支票号允许我们在该字段为空时方便地插入一个 "-"。
结束尝试
最后一行除去数字后的逗号。它把如 "3,231.00" 这样的美元金额转换成我使用的格式 "3231.00"。现在，让我们看一下最终脚本：
最终的“QIF 到文本”脚本  1d /^^/d s/[[:cntrl:]]//g /^D/ {  s/^D\(.*\)/\1\tOUTY\tINNY\t/
 s/^01/Jan/  s/^02/Feb/  s/^03/Mar/  s/^04/Apr/  s/^05/May/
 s/^06/Jun/  s/^07/Jul/  s/^08/Aug/  s/^09/Sep/  s/^10/Oct/
 s/^11/Nov/  s/^12/Dec/  s:^\(.*\)/\(.*\)/\(.*\):\2 \1 \3:
 N  N  N  s/\nT\(.*\)\nN\(.*\)\nP\(.*\)/NUM\2NUM\t\tY\t\t\3\tAMT\1AMT/
 s/NUMNUM/-/  s/NUM\([0-9]*\)NUM/\1/  s/\([0-9]\),/\1/
 /AMT-[0-9]*.[0-9]*AMT/b fixnegs
 s/AMT\(.*\)AMT/\1/  s/OUTY/-/  s/INNY/inco/
 b done :fixnegs  s/AMT-\(.*\)AMT/\1/  s/OUTY/misc/
 s/INNY/-/ :done } 
附加的十一行使用替代和一些分支功能来美化输出。首先看一下这行：
         /AMT-[0-9]*.[0-9]*AMT/b fixnegs  
该行包含一个格式为 "/regexp/b label" 的分支命令。如果模式空间与规则表达式匹配，sed 将分支到 fixnegs 标号。您应该可以轻易找到该标号，它在代码中为 ":fixnegs"。如果规则表达式不匹配，则以常规方式继续处理下一个命令。
既然您理解该命令本身的工作原理，让我们看一下分支。如果看一下分支规则表达式，将看到它与后面依次跟有 '-'、任意数量的数字、一个 '.'、任意数量的数字和 'AMT' 的字符串 'AMT' 匹配。就象我确信您已猜到一样，该规则表达式专门处理负的美元金额。在这之前，用 'ATM' 括起美元金额，以便以后可以轻易找到它。因为规则表达式只与以 '-' 开始的美元金额匹配，所以，该分支只在恰巧处理借款时才发生。如果正处理贷款，应该将 OUTY 设置成 'misc'，将 INNY 设置成 '-'，并且应该除去贷款数量前面的负号。如果跟踪代码的流程，将看到实际情况正是这样。如果不执行分支，则用 '-' 替换 OUTY，用 'inco' 替换 INNY。完成了！现在输出行是完美的：
 28 Aug 2000 misc - -       Y     CHECKCARD SUPERMARKET  -8.15 
别犯糊涂
如您所见，只要循序渐进地解决问题，使用 sed 转换数据就没有那么难。不要试图使用一个 sed 命令或一下子解决所有问题。相反，要朝着目标逐步进行，并不断改进 sed 脚本，直到其输出正如您希望那样为止。sed 有许多功能，希望您已非常熟悉其内部工作原理并继续努力以进一步掌握它！
[]     
    
sort实例应用
文章整理: 文章来源: 网络 
通过使用 sort 和 tsort，而不是采取使用 Perl 或 Awk 的较复杂的解决方案，可以节省时间，同时还能避免令人头疼的问题。Jacek Artymiak 将向您说明如何做到这一点。
尽管可以用 Perl 或 Awk 编写高级排序应用程序，但并非总是有此必要，而且这样的工作也常常令人感到头疼。使用 sort 命令，您同样可以实现您所需的大多数功能，而且更容易，它可以对多个文件中的行进行排序、合并文件甚至可以查看是否有必要对它们进行排序。您可以指定排序键（用于比较的行中的一部分），也可不指定，后一种情况下 sort 就比较所有行。
因此，如果您想对密码文件进行排序，就可以使用下列命令（请注意，您不能将输出直接发送到输入文件，因为这会破坏输入文件。这就是为何您需要将它发送到临时文件中，然后将该文件重命名为 /etc/passwd 的原因，如下所示）。
1、清单 1. 简单排序
$ su -
# sort /etc/passwd > /etc/passwd-new
# mv /etc/passwd-new /etc/passwd
2、有关 sort 和 tsort 的更多信息
通过打开有关排序操作的 GNU 手册页来学习手册页中的内容，或者通过在命令行中输入 man sort 或 man tsort 在新的终端窗口的手册页或信息页中查看这些选项。
如果您想倒转排序的次序，则应当使用 -r 选项。您还可以用 -u 选项来禁止打印相同的行。
3、sort 的一个非常实用的特性是它用字段键进行排序的能力。字段是一个文本字符串，通过某个字符与其它字段分隔开。例如，/etc/passwd 中的字段是用冒号（:）分隔的。因此，如果愿意的话，您可以按照用户标识、组标识、注释字段、主目录或 shell 对 /etc/passwd 进行排序。要做到这一点，请使用 -t 选项，其后跟着用作分隔符的字符，接着是用作排序键的字段编号，再跟作为键的最后一个字段的编号；
例如，
sort -t : -k 5,5 /etc/passwd
按照注释字段对密码文件进行排序，该字段中存储了完整的用户名（如“John Smith”）。
而
sort -t : -k 3,4 /etc/passwd
同时使用用户标识和组标识对同一个文件进行排序。如果您省略了第二个数字，那么 sort 会假定键是从给定的字段开始，一直到每一行的末尾。动手试一试，并观察其中的区别（当数字排序看上去有错时，请添加 -g 选项）。
还要注意的是，空白过渡是缺省的分隔符，因此，如果字段已经用空白字符分隔了，那么您可以省略分隔符，只使用 -t（另注：字段的编号是从 1 开始的）。
5、为了更好地进行控制，您可以使用键和偏移量。偏移量是用点与键相分隔的，比如在 -k 1.3,5.7 中，表示排序键应当从第 1 个字段的第 3 个字符开始，到第 5 个字段的第 7 个字符结束（偏移量也是从 1 开始编号的）。何时会用得着偏移量呢？嗯，我时常用它来对 Apache 日志进行排序；键和偏移量表示法让我跳过了日期字段。
6、另一个要关注的选项是 -b，它告知 sort 忽略空白字符（空格、跳格等等）并将行中的第一个非空白字符当做是排序键的开始。还有，如果您使用该选项，那么将从第一个非空白字符开始计算偏移量（当字段分隔符不是空白字符，且字段可能包含以空白字符开头的字符串时，这非常有用）。
可以用下面这些选项来进一步修改排序算法：
-d（只将字母、数字和空白用作排序键）、
-f（关闭大小写区分，认为小写和大写字符是一样的）、
-i（忽略非打印的 ASCII 字符）、
-M（使用三个字母的月份名称缩写：JAN、FEB、MAR … 来对行进行排序）和
-n（只用数字、- 和逗号或另外一个千位分隔符对行进行排序）。
这些选项以及 -b 和 -r 选项可以用作键编号的一部分，
在这种情况下，它们只适用于该键而非全局，其作用就跟在键定义外使用它时一样。
以键编号的用法为例，请考虑：
sort -t: -k 4g,4 -k 3gr,3 /etc/passwd
这条命令将按照组标识对 passwd 文件进行排序，而在组内按照用户标识进行逆向排序。
7、如果您所使用的键不能用来确定哪一行是在先，那么它也可以解决这类平局问题。增加一个解决平局问题的提示，请添加另一个 -k 选项，让它跟在字段和（可选的）偏移量后面，使用与前面用于定义键相同的表示法；
例如，
sort -k 3.4,4.5 -k 7.3,9.4 /etc/passwd
对行进行排序时，使用从第 3 个键的第 4 个字符开始到第 4 个键的第 5 个字符结束的键，然后再采用从第 7 个字段的第 3 个字符到第 9 个字段的第 4 个字符结束的键来解决上述难题。
8、最后一组选项处理输入、输出和临时文件。例如，-c 选项，当它用于 sort -c < file 中时，它检查输入文件是否已进行了排序（您也可以使用其它选项），如果已进行了排序，则报告一个错误。这样，在处理可能需要花很长时间进行排序的大型文件之前，可以很方便地对其进行检查。当您将 -u 选项和 -c 选项一起使用时，会被解释为一个请求：检查输入文件中不存在两个相同的行。
9、当您处理大型文件时还有一个很重要的 -T 选项，它用于为临时文件（这些临时文件在 sort 完成工作之后会被除去）指定其它目录，而不是缺省的 /tmp 目录。
10、您可以使用 sort 来同时处理多个文件，这样做的方式基本上有两种：首先可以使用 cat 来并置它们，如下所示：
cat file1 file2 file3 | sort > outfile
或者，可以使用下面这个命令：
sort -m file1 file2 file3 > outfile
第二种情况有个条件：在将所有输入文件一起进行 sort -m 之前，每个文件都必须经过排序。这看起来似乎是个不必要的负担，但事实上这加快了工作速度并节约了宝贵的系统资源。对了，别忘了 -m 选项。在这里您可以使用 -u 选项来禁止打印相同的行。
11、如果需要某种更深奥的排序方法，您可能要查看 tsort 命令，该命令对文件执行拓扑排序。拓扑排序和标准 sort 之间的差别如清单 2 所示。
清单 2. 拓扑排序和标准排序之间的差别
$ cat happybirthday.txt
Happy Birthday to You!
Happy Birthday to You!
Happy Birthday Dear Tux!
Happy Birthday to You!
$ sort happybirthday.txt
Happy Birthday Dear Tux!
Happy Birthday to You!
Happy Birthday to You!
Happy Birthday to You!
$ tsort happybirthday.txt
Dear
Happy
to
Tux!
Birthday
You!
当然，对于 tsort 的使用来说，这并非一个非常有用的演示，只是举例说明了这两个命令输出的不同。
tsort 通常用于解决一种逻辑问题，即必须通过观察到的部分次序预测出整个次序；例如（来自 tsort 信息页中）：
tsort <<EOF a b c d e f b c d e EOF
会产生这样的输出
      a
      b
      c
      d
      e
      f
tsort的没试过，最后一个我不行耶，不知道咋回事
[]     
    
高级Bash脚本编程指南(一)
文章整理: 文章来源: 网络 
高级Bash脚本编程指南(一) 
  
  
目录
++++
第一部分. 热身 
    1. 为什么使用shell编程
    2. 带着一个Sha-Bang出发(Sha-Bang指的是#!) 
        2.1. 调用一个脚本
        2.2. 初步的练习 
第二部分. 基本 
    3. 特殊字符
    4. 变量和参数的介绍 
        4.1. 变量替换
        4.2. 变量赋值
        4.3. Bash变量是不分类型的
        4.4. 特殊的变量类型 
    5. 引用(翻译的可能有问题,特指引号) 
        5.1. 引用变量
        5.2. 转义(\) 
    6. 退出和退出状态
    7. Tests 
        7.1. Test结构
        7.2. 文件测试操作
        7.3. 其他比较操作
        7.4. 嵌套的if/then条件test
        7.5. 检查你的test知识 
    8. 操作符和相关的主题 
        8.1. 操作符
        8.2. 数字常量 
第三部分. 超越基本 
    9. 变量重游 
        9.1. 内部变量
        9.2. 操作字符串
        9.3. 参数替换
        9.4. 指定类型的变量:declare或者typeset
        9.5. 变量的间接引用
        9.6. $RANDOM: 产生随机整数
        9.7. 双圆括号结构 
    10. 循环和分支 
        10.1. 循环
        10.2. 嵌套循环
        10.3. 循环控制
        10.4. 测试与分支(case和select结构) 
    11. 内部命令与内建 
        11.1. 作业控制命令 
    12. 外部过滤器,程序和命令 
        12.1. 基本命令
        12.2. 复杂命令
        12.3. 时间/日期 命令
        12.4. 文本处理命令
        12.5. 文件与归档命令
        12.6. 通讯命令
        12.7. 终端控制命令
        12.8. 数学计算命令
        12.9. 混杂命令 
    13. 系统与管理命令 
        13.1. 分析一个系统脚本 
    14. 命令替换
    15. 算术扩展
    16. I/O 重定向 
        16.1. 使用exec
        16.2. 代码块的重定向
        16.3. 应用 
    17. Here Documents 
        17.1. Here Strings 
    18. 休息时间 
Part 4. 高级 
    19. 正则表达式 
        19.1. 一个简要的正则表达式介绍
        19.2. 通配 
    20. 子shell(Subshells)
    21. 受限shell(Restricted Shells)
    22. 进程替换
    23. 函数 
        23.1. 复杂函数和函数复杂性
        23.2. 局部变量
        23.3. 不使用局部变量的递归 
    24. 别名(Aliases)
    25. 列表结构
    26. 数组
    27. /dev 和 /proc 
        27.1. /dev
        27.2. /proc 
    28. 关于Zeros和Nulls
    29. 调试
    30. 选项
    31. Gotchas
    32. 脚本编程风格 
        32.1. 非官方的Shell脚本风格 
    33. 杂项 
        33.1. 交互式和非交互式的shells和脚本
        33.2. Shell 包装
        33.3. 测试和比较: 另一种方法
        33.4. 递归
        33.5. 彩色脚本
        33.6. 优化
        33.7. 各种小技巧
        33.8. 安全话题 
   33.8.1. 被感染的脚本
   33.8.2. 隐藏Shell脚本源码 
        33.9. 移植话题
        33.10. 在Windows下进行Shell编程 
    34. Bash, 版本 2 和 3 
        34.1. Bash, 版本2
        34.2. Bash, 版本3 
35. 后记 
    35.1. 作者后记
    35.2. 关于作者
    35.3. 哪里可以取得帮助?
    35.4. 制作这本书的工具 
        35.4.1. 硬件
        35.4.2. 软件和排版软件 
    35.5. Credits 
Bibliography
A. Contributed Scripts
B. Reference Cards
C. A Sed and Awk Micro-Primer 
    C.1. Sed
    C.2. Awk 
D. Exit Codes With Special Meanings
E. A Detailed Introduction to I/O and I/O Redirection
F. Standard Command-Line Options
G. Important Files
H. Important System Directories
I. Localization
J. History Commands
K. A Sample .bashrc File
L. Converting DOS Batch Files to Shell Scripts
M. Exercises 
    M.1. Analyzing Scripts
    M.2. Writing Scripts 
N. Revision History
O. Mirror Sites
P. To Do List
Q. Copyright 
表格清单: 
11-1. 作业标识符
30-1. Bash 选项
33-1. 转义序列中数值和彩色的对应
B-1. Special Shell Variables
B-2. TEST Operators: Binary Comparison
B-3. TEST Operators: Files
B-4. Parameter Substitution and Expansion
B-5. String Operations
B-6. Miscellaneous Constructs
C-1. Basic sed operators
C-2. Examples of sed operators
D-1. "Reserved" Exit Codes
L-1. Batch file keywords / variables / operators, and their shell equivalents
L-2. DOS commands and their UNIX equivalents
N-1. Revision History 
例子清单: 
2-1. 清除:清除/var/log下的log文件
2-2. 清除:一个改良的清除脚本
2-3. cleanup:一个增强的和广义的删除logfile的脚本
3-1. 代码块和I/O重定向
3-2. 将一个代码块的结果保存到文件
3-3. 在后台运行一个循环
3-4. 备份最后一天所有修改的文件.
4-1. 变量赋值和替换
4-2. 一般的变量赋值
4-3. 变量赋值,一般的和比较特殊的
4-4. 整型还是string?
4-5. 位置参数
4-6. wh,whois节点名字查询
4-7. 使用shift
5-1. echo一些诡异的变量
5-2. 转义符
6-1. exit/exit状态
6-2. 否定一个条件使用!
7-1. 什么情况下为真?
7-2. 几个等效命令test,/usr/bin/test,[],和/usr/bin/[
7-3. 算数测试使用(( ))
7-4. test死的链接文件
7-5. 数字和字符串比较
7-6. 测试字符串是否为null
7-7. zmore
8-1. 最大公约数
8-2. 使用算术操作符
8-3. 使用&&和||进行混合状态的test
8-4. 数字常量的处理
9-1. $IFS和空白
9-2. 时间输入
9-3. 再来一个时间输入
9-4. Timed read
9-5. 我是root?
9-6. arglist:通过$*和$@列出所有的参数
9-7. 不一致的$*和$@行为
9-8. 当$IFS为空时的$*和$@
9-9. 下划线变量
9-10. 在一个文本文件的段间插入空行
9-11. 利用修改文件名,来转换图片格式
9-12. 模仿getopt命令
9-13. 提取字符串的一种可选的方法
9-14. 使用参数替换和error messages
9-15. 参数替换和"usage"messages
9-16. 变量长度
9-17. 参数替换中的模式匹配
9-18. 重命名文件扩展名
9-19. 使用模式匹配来分析比较特殊的字符串
9-20. 对字符串的前缀或后缀使用匹配模式
9-21. 使用declare来指定变量的类型
9-22. 间接引用
9-23. 传递一个间接引用给awk
9-24. 产生随机数
9-25. 从一副扑克牌中取出一张随机的牌
9-26. 两个指定值之间的随机数
9-27. 使用随机数来摇一个骰子
9-28. 重新分配随机数种子
9-29. 使用awk产生伪随机数
9-30. C风格的变量处理
10-1. 循环的一个简单例子
10-2. 每个[list]元素带两个参数的for循环
10-3. 文件信息:对包含在变量中的文件列表进行操作
10-4. 在for循环中操作文件
10-5. 在for循环中省略[list]
10-6. 使用命令替换来产生for循环的[list]
10-7. 对于二进制文件的一个grep替换
10-8. 列出系统上的所有用户
10-9. 在目录的所有文件中查找源字串
10-10. 列出目录中所有的符号连接文件
10-11. 将目录中的符号连接文件名保存到一个文件中
10-12. 一个C风格的for循环
10-13. 在batch mode中使用efax
10-14. 简单的while循环
10-15. 另一个while循环
10-16. 多条件的while循环
10-17. C风格的while循环
10-18. until循环
10-19. 嵌套循环
10-20. break和continue命令在循环中的效果
10-21. 多层循环的退出
10-22. 多层循环的continue
10-23. 在实际的任务中使用"continue N"
10-24. 使用case
10-25. 使用case来创建菜单
10-26. 使用命令替换来产生case变量
10-27. 简单字符串匹配
10-28. 检查是否是字母输入
10-29. 用select来创建菜单
10-30. 用函数中select结构来创建菜单
11-1. 一个fork出多个自己实例的脚本
11-2. printf
11-3. 使用read,变量分配
11-4. 当使用一个不带变量参数的read命令时,将会发生什么?
11-5. read命令的多行输入
11-6. 检测方向键
11-7. 通过文件重定向来使用read
11-8. 管道输出到read中的问题
11-9. 修改当前的工作目录
11-10. 用"let"命令来作算术操作.
11-11. 显示eval命令的效果
11-12. 强制登出(log-off)
11-13. 另一个"rot13"的版本
11-14. 在Perl脚本中使用eval命令来强制变量替换
11-15. 使用set来改变脚本的位置参数
11-16. 重新分配位置参数
11-17. Unset一个变量
11-18. 使用export命令传递一个变量到一个内嵌awk的脚本中
11-19. 使用getopts命令来读取传递给脚本的选项/参数.
11-20. "Including"一个数据文件
11-21. 一个没什么用的,source自身的脚本
11-22. exec的效果
11-23. 一个exec自身的脚本
11-24. 在继续处理之前,等待一个进程的结束
11-25. 一个结束自身的脚本.
12-1. 使用ls命令来创建一个烧录CDR的内容列表
12-2. Hello or Good-bye
12-3. 删除当前目录下文件名中包含一些特殊字符(包括空白)的文件..
12-4. 通过文件的 inode 号来删除文件
12-5. Logfile: 使用 xargs 来监控系统 log
12-6. 把当前目录下的文件拷贝到另一个文件中
12-7. 通过名字Kill进程
12-8. 使用xargs分析单词出现的频率
12-9. 使用 expr
12-10. 使用 date 命令
12-11. 分析单词出现的频率
12-12. 那个文件是脚本?
12-13. 产生10进制随机数
12-14. 使用 tail 命令来监控系统log
12-15. 在一个脚本中模仿 "grep" 的行为
12-16. 在1913年的韦氏词典中查找定义
12-17. 检查列表中单词的正确性
12-18. 转换大写: 把一个文件的内容全部转换为大写.
12-19. 转换小写: 将当前目录下的所有文全部转换为小写.
12-20. Du: DOS 到 UNIX 文本文件的转换.
12-21. rot13: rot13, 弱智加密.
12-22. Generating "Crypto-Quote" Puzzles
12-23. 格式化文件列表.
12-24. 使用 column 来格式化目录列表
12-25. nl: 一个自己计算行号的脚本.
12-26. manview: 查看格式化的man页
12-27. 使用 cpio 来拷贝一个目录树
12-28. 解包一个 rpm 归档文件 
12-29. 从 C 文件中去掉注释
12-30. Exploring /usr/X11R6/bin
12-31. 一个"改进过"的 strings  命令
12-32. 在一个脚本中使用 cmp 来比较2个文件.
12-33. basename 和 dirname
12-34. 检查文件完整性 
12-35. Uudecod 编码后的文件
12-36. 查找滥用的连接来报告垃圾邮件发送者
12-37. 分析一个垃圾邮件域
12-38. 获得一份股票报价
12-39. 更新 Fedora Core 4 
12-40. 使用 ssh
12-41. 一个可以mail自己的脚本
12-42. 按月偿还贷款
12-43. 数制转换
12-44. 使用 "here document" 来调用 bc
12-45. 计算圆周率
12-46. 将10进制数字转换为16进制数字
12-47. 因子分解
12-48. 计算直角三角形的斜边
12-49. 使用 seq 来产生循环参数
12-50. 字母统计
12-51. 使用getopt来分析命令行选项
12-52. 一个拷贝自身的脚本
12-53. 练习dd
12-54. 记录按键
12-55. 安全的删除一个文件
12-56. 文件名产生器
12-57. 将米转换为英里
12-58. 使用 m4
13-1. 设置一个新密码
13-2. 设置一个擦除字符
13-3. 关掉终端对于密码的echo
13-4. 按键检测
13-5. Checking a remote server for identd<rojy bug>
13-6. pidof 帮助杀掉一个进程
13-7. 检查一个CD镜像
13-8. 在一个文件中创建文件系统
13-9. 添加一个新的硬盘驱动器
13-10. 使用umask来将输出文件隐藏起来
13-11. killall, 来自于 /etc/rc.d/init.d
14-1. 愚蠢的脚本策略
14-2. 从循环的输出中产生一个变量
14-3. 找anagram(回文构词法, 可以将一个有意义的单词, 变换为1个或多个有意义的单词, 但是还是原来的子母集合)
16-1. 使用exec重定向标准输入
16-2. 使用exec来重定向stdout
16-3. 使用exec在同一脚本中重定向stdin和stdout
16-4. 避免子shell
16-5. while循环的重定向
16-6. 另一种while循环的重定向
16-7. until循环重定向
16-8. for循环重定向
16-9. for循环重定向 loop (将标准输入和标准输出都重定向了)
16-10. 重定向if/then测试结构
16-11. 用于上面例子的"names.data"数据文件
16-12. 记录日志事件
17-1. 广播: 发送消息给每个登录上的用户
17-2. 仿造文件: 创建一个两行的仿造文件
17-3. 使用cat的多行消息
17-4. 带有抑制tab功能的多行消息
17-5. 使用参数替换的here document
17-6. 上传一个文件对到"Sunsite"的incoming目录
17-7. 关闭参数替换
17-8. 一个产生另外一个脚本的脚本
17-9. Here documents与函数
17-10. "匿名" here Document
17-11. 注释掉一段代码块 
17-12. 一个自文档化(self-documenting)的脚本
17-13. 在一个文件的开头添加文本
20-1. 子shell中的变量作用域
20-2. 列出用户的配置文件
20-3. 在子shell里进行串行处理
21-1. 在受限的情况下运行脚本
23-1. 简单函数
23-2. 带着参数的函数
23-3. 函数和被传给脚本的命令行参数
23-4. 传递间接引用给函数
23-5. 解除传递给函数的参数引用
23-6. 再次尝试解除传递给函数的参数引用
23-7. 两个数中的最大者
23-8. 把数字转化成罗马数字
23-9. 测试函数最大的返回值
23-10. 比较两个大整数
23-11. 用户名的真实名
23-12. 局部变量的可见范围
23-13. 用局部变量来递归
23-14. 汉诺塔
24-1. 脚本中的别名
24-2. unalias: 设置和删除别名
25-1. 使用"与列表(and list)"来测试命令行参数
25-2. 用"与列表"的另一个命令行参数测试
25-3. "或列表"和"与列表"的结合使用
26-1. 简单的数组用法
26-2. 格式化一首诗
26-3. 多种数组操作
26-4. 用于数组的字符串操作符
26-5. 将脚本的内容传给数组
26-6. 一些数组专用的工具
26-7. 关于空数组和空数组元素
26-8. 初始化数组
26-9. 复制和连接数组
26-10. 关于连接数组的更多信息
26-11. 一位老朋友: 冒泡排序
26-12. 内嵌数组和间接引用
26-13. 复杂数组应用: 埃拉托色尼素数筛子
26-14. 模拟下推的堆栈
26-15. 复杂的数组应用: 列出一种怪异的数学序列
26-16. 模拟二维数组,并使它倾斜
27-1. 利用/dev/tcp 来检修故障
27-2. 搜索与一个PID相关的进程
27-3. 网络连接状态
28-1. 隐藏cookie而不再使用
28-2. 用/dev/zero创建一个交换临时文件
28-3. 创建ramdisk
29-1. 一个错误的脚本
29-2. 丢失关键字(keyword)
29-3. 另一个错误脚本
29-4. 用"assert"测试条件
29-5. 捕捉 exit
29-6. 在Control-C后清除垃圾
29-7. 跟踪变量
29-8. 运行多进程 (在多处理器的机器里)
31-1. 数字和字符串比较是不相等同的
31-2. 子SHELL缺陷
31-3. 把echo的输出用管道输送给read命令
33-1. shell 包装
33-2. 稍微复杂一些的shell包装
33-3. 写到日志文件的shell包装
33-4. 包装awk的脚本
33-5. 另一个包装awk的脚本
33-6. 把Perl嵌入Bash脚本
33-7. Bash 和 Perl 脚本联合使用
33-8. 递归调用自己本身的(无用)脚本
33-9. 递归调用自己本身的(有用)脚本
33-10. 另一个递归调用自己本身的(有用)脚本
33-11. 一个 "彩色的" 地址资料库
33-12. 画盒子
33-13. 显示彩色文本
33-14. "赛马" 游戏
33-15. 返回值技巧
33-16. 整型还是string?
33-17. 传递和返回数组
33-18. anagrams游戏
33-19. 在shell脚本中调用的窗口部件
34-1. 字符串扩展
34-2. 间接变量引用 - 新方法
34-3. 使用间接变量引用的简单数据库应用
34-4. 用数组和其他的小技巧来处理四人随机打牌 
A-1. mailformat: Formatting an e-mail message
A-2. rn: A simple-minded file rename utility
A-3. blank-rename: renames filenames containing blanks
A-4. encryptedpw: Uploading to an ftp site, using a locally encrypted password
A-5. copy-cd: Copying a data CD
A-6. Collatz series
A-7. days-between: Calculate number of days between two dates
A-8. Make a "dictionary"
A-9. Soundex conversion
A-10. "Game of Life"
A-11. Data file for "Game of Life"
A-12. behead: Removing mail and news message headers
A-13. ftpget: Downloading files via ftp
A-14. password: Generating random 8-character passwords
A-15. fifo: Making daily backups, using named pipes
A-16. Generating prime numbers using the modulo operator
A-17. tree: Displaying a directory tree
A-18. string functions: C-like string functions
A-19. Directory information
A-20. Object-oriented database
A-21. Library of hash functions
A-22. Colorizing text using hash functions
A-23. Mounting USB keychain storage devices
A-24. Preserving weblogs
A-25. Protecting literal strings
A-26. Unprotecting literal strings
A-27. Spammer Identification
A-28. Spammer Hunt
A-29. Making wget easier to use
A-30. A "podcasting" script
A-31. Basics Reviewed
A-32. An expanded cd command
C-1. Counting Letter Occurrences
K-1. Sample .bashrc file
L-1. VIEWDATA.BAT: DOS Batch File
L-2. viewdata.sh: Shell Script Conversion of VIEWDATA.BAT
P-1. Print the server environment 
第一部分 热身
++++++++++++++++
shell是一个命令解释器.是介于操作系统kernel与用户之间的一个绝缘层.准确地说,它也是一
一种强力的计算机语言.一个shell程序,被称为一个脚本,是一种很容易使用的工具,它可以通过
将系统调用,公共程序,工具,和编译过的二进制程序粘合在一起来建立应用.事实上,所有的UNIX
命令和工具再加上公共程序,对于shell脚本来说,都是可调用的.如果这些你还觉得不够,那么
shell内建命令,比如test与循环结构,也会给脚本添加强力的支持和增加灵活性.Shell脚本对于
管理系统任务和其它的重复工作的例程来说,表现的非常好,根本不需要那些华而不实的成熟
紧凑的程序语言. 
第1章 为什么使用shell编程
===========================
没有程序语言是完美的.甚至没有一个唯一最好的语言,只有对于特定目的,比较适合和不适合
的程序语言.
                Herbert Mayer 
对于任何想适当精通一些系统管理知识的人来说,掌握shell脚本知识都是最基本的,即使这些
人可能并不打算真正的编写一些脚本.想一下Linux机器的启动过程,在这个过程中,必将运行
/etc/rc.d目录下的脚本来存储系统配置和建立服务.详细的理解这些启动脚本对于分析系统的
行为是非常重要的,并且有时候可能必须修改它. 
学习如何编写shell脚本并不是一件很困难的事,因为脚本可以分为很小的块,并且相对于shell
特性的操作和选项[1]部分,只需要学习很小的一部分就可以了.语法是简单并且直观的,编写脚
本很像是在命令行上把一些相关命令和工具连接起来,并且只有很少的一部分规则需要学习.
绝大部分脚本第一次就可以正常的工作,而且即使调试一个长一些的脚本也是很直观的. 
一个shell脚本是一个类似于小吃店的(quick and dirty)方法,在你使用原型设计一个复杂的
应用的时候.在工程开发的第一阶段,即使从功能中取得很有限的一个子集放到shell脚本中来
完成往往都是非常有用的.使用这种方法,程序的结果可以被测试和尝试运行,并且在处理使用
诸如C/C++,Java或者Perl语言编写的最终代码前,主要的缺陷和陷阱往往就被发现了. 
Shell脚本遵循典型的UNIX哲学,就是把大的复杂的工程分成小规模的子任务,并且把这些部件
和工具组合起来.许多人认为这种办法更好一些,至少这种办法比使用那种高\大\全的语言更
美,更愉悦,更适合解决问题.比如Perl就是这种能干任何事能适合任何人的语言,但是代价就是
你需要强迫自己使用这种语言来思考解决问题的办法. 
什么时候不使用Shell脚本
 
 资源密集型的任务,尤其在需要考虑效率时(比如,排序,hash等等) 
 需要处理大任务的数学操作,尤其是浮点运算,精确运算,或者复杂的算术运算
 (这种情况一般使用C++或FORTRAN来处理) 
 有跨平台移植需求(一般使用C或Java) 
 复杂的应用,在必须使用结构化编程的时候(需要变量的类型检查,函数原型,等等) 
 对于影响系统全局性的关键任务应用。 
 对于安全有很高要求的任务,比如你需要一个健壮的系统来防止入侵,破解,恶意破坏等等. 
 项目由连串的依赖的各个部分组成。 
 需要大规模的文件操作 
 需要多维数组的支持 
 需要数据结构的支持,比如链表或数等数据结构 
 需要产生或操作图形化界面GUI 
 需要直接操作系统硬件 
 需要I/O或socket接口 
 需要使用库或者遗留下来的老代码的接口 
 私人的,闭源的应用(shell脚本把代码就放在文本文件中,全世界都能看到) 
如果你的应用符合上边的任意一条,那么就考虑一下更强大的语言吧--或许是Perl,Tcl,Python,
Ruby -- 或者是更高层次的编译语言比如C/C++,或者是Java.即使如此,你会发现,使用shell
来原型开发你的应用,在开发步骤中也是非常有用的. 
我们将开始使用Bash,Bash是"Bourne-Again shell"首字母的缩写,也是Stephen Bourne的经典
的Bourne shell的一个双关语,(译者:说实话,我一直搞不清这个双关语是什么意思,为什么叫
"Bourn-Again shell",这其中应该有个什么典故吧,哪位好心,告诉我一下^^).Bash已经成为了
所有UNIX中shell脚本的事实上的标准了.同时这本书也覆盖了绝大部分的其他一些shell的原
则,比如Korn Shell,Bash从ksh中继承了一部分特性,[2]C Shell和它的变种.(注意:C Shell
编程是不被推荐的,因为一些特定的内在问题,Tom Christiansen在1993年10月指出了这个问题
请在http://www.etext.org/Quartz/computer/unix/csh.harmful.gz中查看具体内容.) 
接下来是脚本的一些说明.在展示shell不同的特征之前,它可以减轻一些阅读书中例子
的负担.本书中的例子脚本,都在尽可能的范围内进行了测试,并且其中的一些将使用在真
实的生活中.读者可以运行这些例子脚本(使用scriptname.sh或者scriptname.bash的形式),
[3]并给这些脚本执行权限(chmod u+rx scriptname),然后执行它们,看看发生了什么.如果存
档的脚本不可用,那么就从本书的HTML,pdf或者text的发行版本中把它们拷贝粘贴出来.考虑到
这些脚本中的内容在我们还没解释它之前就被列在这里,可能会影响读者的理解,这就需要读者
暂时忽略这些内容. 
除非特别注明,本书作者编写了本书中的绝大部分例子脚本. 
注意事项:
[1]  这些在builtins章节被引用,这些是shell的内部特征.
[2]  ksh88的许多特性,甚至是一些ksh93的特性都被合并到Bash中了.
[3]  根据惯例,用户编写的Bourne shell脚本应该在脚本的名字后边加上.sh扩展名.
  一些系统脚本,比如那些在/etc/rc.d中的脚本,则不遵循这种命名习惯. 
  
第2章 带着一个Sha-Bang出发(Sha-Bang指的是#!)
==============================================
在一个最简单的例子中,一个shell脚本其实就是将一堆系统命令列在一个文件中.它的最基本的
用处就是,在你每次输入这些特定顺序的命令时可以少敲一些字. 
Example 2-1 清除:清除/var/log下的log文件
################################Start Script#######################################
1 # Cleanup
2 # 当然要使用root身份来运行这个脚本
3 
4 cd /var/log
5 cat /dev/null > messages
6 cat /dev/null > wtmp
7 echo "Logs cleaned up."
################################End Script#########################################
这根本就没什么稀奇的, 只不过是命令的堆积, 来让从console或者xterm中一个一个的输入命
令更方便一些.好处就是把所有命令都放在一个脚本中,不用每次都敲它们.这样的话,对于特定
的应用来说,这个脚本就很容易被修改或定制. 
Example 2-2 清除:一个改良的清除脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 # 一个Bash脚本的正确的开头部分.
 3 
 4 # Cleanup, 版本 2
 5 
 6 # 当然要使用root身份来运行.
 7 # 在此处插入代码,来打印错误消息,并且在不是root身份的时候退出.
 8 
 9 LOG_DIR=/var/log
10 # 如果使用变量,当然比把代码写死的好.
11 cd $LOG_DIR
12 
13 cat /dev/null > messages
14 cat /dev/null > wtmp
15 
16 
17 echo "Logs cleaned up."
18 
19 exit # 这个命令是一种正确并且合适的退出脚本的方法.
################################End Script######################################### 
现在,让我们看一下一个真正意义的脚本.而且我们可以走得更远...
Example 2-3. cleanup:一个增强的和广义的删除logfile的脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 # 清除, 版本 3
 3 
 4 #  Warning:
 5 #  -------
 6 #  这个脚本有好多特征,这些特征是在后边章节进行解释的,大概是进行到本书的一半的
 7 #  时候,
 8 #  你就会觉得它没有什么神秘的了.
 9 #
10 
11 
12 
13 LOG_DIR=/var/log
14 ROOT_UID=0     # $UID为0的时候,用户才具有根用户的权限
15 LINES=50       # 默认的保存行数
16 E_XCD=66       # 不能修改目录?
17 E_NOTROOT=67   # 非根用户将以error退出
18 
19 
20 # 当然要使用根用户来运行
21 if [ "$UID" -ne "$ROOT_UID" ]
22 then
23   echo "Must be root to run this script."
24   exit $E_NOTROOT
25 fi  
26 
27 if [ -n "$1" ]
28 # 测试是否有命令行参数(非空).
29 then
30   lines=$1
31 else  
32   lines=$LINES # 默认,如果不在命令行中指定
33 fi  
34 
35 
36 #  Stephane Chazelas 建议使用下边
37 #+ 的更好方法来检测命令行参数.
38 #+ 但对于这章来说还是有点超前.
39 #
40 #    E_WRONGARGS=65  # 非数值参数(错误的参数格式)
41 #
42 #    case "$1" in
43 #    ""      ) lines=50;;
44 #    *[!0-9]*) echo "Usage: `basename $0` file-to-cleanup"; exit $E_WRONGARGS;;
45 #    *       ) lines=$1;;
46 #    esac
47 #
48 #* 直到"Loops"的章节才会对上边的内容进行详细的描述.
49 
50 
51 cd $LOG_DIR
52 
53 if [ `pwd` != "$LOG_DIR" ]  # 或者 if[ "$PWD" != "$LOG_DIR" ]
54                             # 不在 /var/log中?
55 then
56   echo "Can't change to $LOG_DIR."
57   exit $E_XCD
58 fi  # 在处理log file之前,再确认一遍当前目录是否正确.
59 
60 # 更有效率的做法是
61 #
62 # cd /var/log || {
63 #   echo "Cannot change to necessary directory." >&2
64 #   exit $E_XCD;
65 # }
66 
67 
68 
69 
70 tail -$lines messages > mesg.temp # 保存log file消息的最后部分.
71 mv mesg.temp messages             # 变为新的log目录.
72 
73 
74 # cat /dev/null > messages
75 #* 不再需要了,使用上边的方法更安全.
76 
77 cat /dev/null > wtmp  #  ': > wtmp' 和 '> wtmp'具有相同的作用
78 echo "Logs cleaned up."
79 
80 exit 0
81 #  退出之前返回0,返回0表示成功.
82 #
################################End Script######################################### 
因为你可能希望将系统log全部消灭,这个版本留下了log消息最后的部分.你将不断地找到新
的方法来完善这个脚本,并提高效率. 
要注意,在每个脚本的开头都使用"#!",这意味着告诉你的系统这个文件的执行需要指定一个解
释器.#!实际上是一个2字节[1]的魔法数字,这是指定一个文件类型的特殊标记, 换句话说, 在
这种情况下,指的就是一个可执行的脚本(键入man magic来获得关于这个迷人话题的更多详细
信息).在#!之后接着是一个路径名.这个路径名指定了一个解释脚本中命令的程序,这个程序可
以是shell,程序语言或者是任意一个通用程序.这个指定的程序从头开始解释并且执行脚本中
的命令(从#!行下边的一行开始),忽略注释.[2]
如:
1 #!/bin/sh
2 #!/bin/bash
3 #!/usr/bin/perl
4 #!/usr/bin/tcl
5 #!/bin/sed -f
6 #!/usr/awk -f 
上边每一个脚本头的行都指定了一个不同的命令解释器,如果是/bin/sh,那么就是默认shell
(在Linux系统中默认是Bash).[3]使用#!/bin/sh,在大多数商业发行的UNIX上,默认是Bourne
shell,这将让你的脚本可以正常的运行在非Linux机器上,虽然这将会牺牲Bash一些独特的特征.
脚本将与POSIX[4] 的sh标准相一致. 
注意: #! 后边给出的路径名必须是正确的,否则将会出现一个错误消息,通常是
"Command not found",这将是你运行这个脚本时所得到的唯一结果. 
当然"#!"也可以被忽略,不过这样你的脚本文件就只能是一些命令的集合,不能够使用shell内建
的指令了,如果不能使用变量的话,当然这也就失去了脚本编程的意义了. 
 注意:这个例子鼓励你使用模块化的方式来编写脚本,平时也要注意收集一些零碎的代码,
  这些零碎的代码可能用在你将来编写的脚本中.这样你就可以通过这些代码片段来构
  造一个较大的工程用例. 以下边脚本作为序,来测试脚本被调用的参数是否正确.
################################Start Script#######################################
 1 E_WRONG_ARGS=65
 2 script_parameters="-a -h -m -z"
 3 #                  -a = all, -h = help, 等等.
 4 
 5 if [ $# -ne $Number_of_expected_args ]
 6 then
 7   echo "Usage: `basename $0` $script_parameters"
 8   # `basename $0`是这个脚本的文件名
 9   exit $E_WRONG_ARGS
10 fi
################################End Script#########################################
大多数情况下,你需要编写一个脚本来执行一个特定的任务,在本章中第一个脚本就是一个这样
的例子, 然后你会修改它来完成一个不同的,但比较相似的任务.用变量来代替写死的常量,就是
一个好方法,将重复的代码放到一个函数中,也是一种好习惯. 
2.1 调用一个脚本
----------------
编写完脚本之后,你可以使用sh scriptname,[5]或者bash scriptname来调用它.
(不推荐使用sh <scriptname,因为这禁用了脚本从stdin中读数据的功能.)
更方便的方法是让脚本本身就具有可执行权限,通过chmod命令可以修改. 
比如:
    chmod 555 scriptname (允许任何人都具有 可读和执行权限) [6]  
或:
 chmod +rx scriptname (允许任何人都具有 可读和执行权限)
 chmod u+rx scriptname (只给脚本的所有者 可读和执行权限) 
既然脚本已经具有了可执行权限,现在你可以使用./scriptname.[7]来测试它了.如果这个脚本
以一个"#!"行开头,那么脚本将会调用合适的命令解释器来运行. 
最后一步,在脚本被测试和debug之后,你可能想把它移动到/usr/local/bin(当然是以root身份)
,来让你的脚本对所有用户都有用.这样用户就可以直接敲脚本名字来运行了. 
注意事项:
[1]  那些具有UNIX味道的脚本(基于4.2BSD)需要一个4字节的魔法数字,在#!后边需要一个
  空格#! /bin/sh.
[2]  脚本中的#!行的最重要的任务就是命令解释器(sh或者bash).因为这行是以#开始的,
  当命令解释器执行这个脚本的时候,会把它作为一个注释行.当然,在这之前,这行语句
  已经完成了它的任务,就是调用命令解释器. 
  如果在脚本的里边还有一个#!行,那么bash将把它认为是一个一般的注释行.
   1 #!/bin/bash
   2 
   3 echo "Part 1 of script."
   4 a=1
   5 
   6 #!/bin/bash
   7 # 这将不会开始一个新脚本.
   8 
   9 echo "Part 2 of script."
  10 echo $a  # Value of $a stays at 1.
[3]  这里可以玩一些小技巧.
   1 #!/bin/rm
   2 # 自删除脚本.
   3 
   4 # 当你运行这个脚本时,基本上什么都不会发生...除非这个文件消失不见.
   5 
   6 WHATEVER=65
   7 
   8 echo "This line will never print (betcha!)."
   9 
  10 exit $WHATEVER  # 没关系,脚本是不会在这退出的.
  当然,你还可以试试在一个README文件的开头加上#!/bin/more,并让它具有执行权限.
  结果将是文档自动列出自己的内容.(一个使用cat命令的here document可能是一个
  更好的选则,--见Example 17-3).
[4]  可移植的操作系统接口,标准化类UNIX操作系统的一种尝试.POSIX规范可以在
  http://www.opengroup.org/onlinepubs/007904975/toc.htm中查阅.
[5]  小心:使用sh scriptname来调用脚本的时候将会关闭一些Bash特定的扩展,脚本可能
  因此而调用失败.
[6]  脚本需要读和执行权限,因为shell需要读这个脚本.
[7]  为什么不直接使用scriptname来调用脚本?如果你当前的目录下($PWD)正好有你想要
  执行的脚本,为什么它运行不了呢?失败的原因是,出于安全考虑,当前目录并没有被
  加在用户的$PATH变量中.因此,在当前目录下调用脚本必须使用./scriptname这种
  形式. 
2.2 初步的练习
--------------
1. 系统管理员经常会为了自动化一些常用的任务而编写脚本.举出几个这种有用的脚本的实例.
2. 编写一个脚本,显示时间和日期,列出所有的登录用户,显示系统的更新时间.然后这个脚本
   将会把这些内容保存到一个log file中. 
第二部分 基本
++++++++++++++++ 
第3章 特殊字符
================ 
#  注释,行首以#开头为注释(#!是个例外). 
  1 # This line is a comment. 
  注释也可以存在于本行命令的后边. 
  1 echo "A comment will follow." # 注释在这里
  2 #                            ^ 注意#前边的空白 
  注释也可以在本行空白的后边. 
  1  # A tab precedes this comment. 
  注意:命令是不能跟在同一行上注释的后边的,没有办法,在同一行上,注释的后边想
  要再使用命令,只能另起一行.
  当然,在echo命令中被转义的#是不能作为注释的. 
  同样的,#也可以出现在特定的参数替换结构中或者是数字常量表达式中. 
  1 echo "The # here does not begin a comment."
  2 echo 'The # here does not begin a comment.'
  3 echo The \# here does not begin a comment.
  4 echo The # 这里开始一个注释
  5 
  6 echo ${PATH#*:}       # 参数替换,不是一个注释
  7 echo $(( 2#101011 ))  # 数制转换,不是一个注释
  8 
  9 # Thanks, S.C. 
  标准的引用和转义字符("'\)可以用来转义# 
;  命令分隔符,可以用来在一行中来写多个命令. 
  1 echo hello; echo there
  2 
  3 
  4 if [ -x "$filename" ]; then    # 注意:"if"和"then"需要分隔
  5                                # 为啥?
  6   echo "File $filename exists."; cp $filename $filename.bak
  7 else
  8   echo "File $filename not found."; touch $filename
  9 fi; echo "File test complete." 
  有时候需要转义 
;;  终止"case"选项. 
  1 case "$variable" in
  2 abc)  echo "\$variable = abc" ;;
  3 xyz)  echo "\$variable = xyz" ;;
  4 esac 
.  .命令等价于source命令(见Example 11-20).这是一个bash的内建命令. 
.  .作为文件名的一部分.如果作为文件名的前缀的话,那么这个文件将成为隐藏文件.
  将不被ls命令列出. 
  bash$ touch .hidden-file
  bash$ ls -l       
  total 10
  -rw-r--r--    1 bozo      4034 Jul 18 22:04 data1.addressbook
  -rw-r--r--    1 bozo      4602 May 25 13:58 data1.addressbook.bak
  -rw-r--r--    1 bozo       877 Dec 17  2000 employment.addressbook
  
  
  bash$ ls -al       
  total 14
  drwxrwxr-x    2 bozo  bozo      1024 Aug 29 20:54 ./
  drwx------   52 bozo  bozo      3072 Aug 29 20:51 ../
  -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.addressbook
  -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.addressbook.bak
  -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.addressbook
  -rw-rw-r--    1 bozo  bozo         0 Aug 29 20:54 .hidden-file 
  .命令如果作为目录名的一部分的话,那么.表达的是当前目录.".."表示上一级目录. 
  bash$ pwd
  /home/bozo/projects 
  bash$ cd .
  bash$ pwd
  /home/bozo/projects 
  bash$ cd ..
  bash$ pwd
  /home/bozo/ 
  .命令经常作为一个文件移动命令的目的地. 
  bash$ cp /home/bozo/current_work/junk/* . 
.  .字符匹配,这是作为正则表达是的一部分,用来匹配任何的单个字符. 
"  部分引用."STRING"阻止了一部分特殊字符,具体见第5章. 
'  全引用. 'STRING' 阻止了全部特殊字符,具体见第5章. 
,  逗号链接了一系列的算术操作,虽然里边所有的内容都被运行了,但只有最后一项被
  返回. 
  如:
  1 let "t2 = ((a = 9, 15 / 3))"  # Set "a = 9" and "t2 = 15 / 3" 
\  转义字符,如\X等价于"X"或'X',具体见第5章. 
/  文件名路径分隔符.或用来做除法操作. 
`  后置引用,命令替换,具体见第14章 
:  空命令,等价于"NOP"(no op,一个什么也不干的命令).也可以被认为与shell的内建命令(true)作用相同.":"命令是一
  个bash的内建命令,它的返回值为0,就是shell返回的true. 
  如:
  1 :
  2 echo $?   # 0 
  死循环,如: 
   1 while :
   2 do
   3    operation-1
   4    operation-2
   5    ...
   6    operation-n
   7 done
   8 
   9 # 与下边相同:
  10 #    while true
  11 #    do
  12 #      ...
  13 #    done 
  在if/then中的占位符,如:
  1 if condition
  2 then :   # 什么都不做,引出分支.
  3 else
  4    take-some-action
  5 fi 
  在一个2元命令中提供一个占位符,具体见Example 8-2,和"默认参数".如:
  1 : ${username=`whoami`}
  2 # ${username=`whoami`}   如果没有":"的话,将给出一个错误,除非"username"是
  3 #                        个命令
  在here document中提供一个占位符,见Example 17-10. 
  使用"参数替换"来评估字符串变量(见Example 9-14).如:
  1 : ${HOSTNAME?} ${USER?} ${MAIL?}
  2 #  如果一个或多个必要的环境变量没被设置的话,
  3 #+ 就打印错误信息. 
  "变量扩展/子串替换"
  在和 > (重定向操作符)结合使用时,把一个文件截断到0长度,没有修改它的权限.
  如果文件在之前并不存在,那么就创建它.如:
  1 : > data.xxx  #文件"data.xxx"现在被清空了.
  2
  3 #与 cat /dev/null >data.xxx 的作用相同
  4 #然而,这不会产生一个新的进程,因为":"是一个内建命令.
  具体参见Example 12-14. 
  在和>>重定向操作符结合使用时,将不会对想要附加的文件产生任何影响.
  如果文件不存在,将创建.
  注意: 这只适用于正规文件,而不是管道,符号连接,和某些特殊文件. 
  也可能用来作为注释行,虽然我们不推荐这么做.使用#来注释的话,将关闭剩余行的
  错误检查,所以可以在注释行中写任何东西.然而,使用:的话将不会这样.如:
  1 : This is a comment thar generates an error,(if [ $x -eq 3] ). 
  ":"还用来在/etc/passwd和$PATH变量中用来做分隔符.
  bash$ echo $PATH
  /usr/local/bin:/bin:/usr/X11R6/bin:/sbin:/usr/sbin:/usr/games
!  取反操作符,将反转"退出状态"结果,(见Example 6-2).也会反转test操作符的意义.比
  如修改=为!=.!操作是Bash的一个关键字. 
  在一个不同的上下文中,!也会出现在"间接变量引用"见Example 9-22. 
  在另一种上下文中,!还能反转bash的"history mechanism"(见附录J 历史命令)
  需要注意的是,在一个脚本中,"history mechanism"是被禁用的. 
*  万能匹配字符,用于文件名匹配(这个东西有个专有名词叫file globbing),或者是正则
  表达式中.注意:在正则表达式匹配中的作用和在文件名匹配中的作用是不同的.
  bash$ echo *
  abs-book.sgml add-drive.sh agram.sh alias.sh
*  数学乘法.
  **是幂运算.
?  测试操作.在一个确定的表达式中,用?来测试结果.
  (())结构可以用来做数学计算或者是写c代码,那?就是c语言的3元操作符的
  一个.
  在"参数替换"中,?测试一个变量是否被set了.
?  在file globbing中和在正则表达式中一样匹配任意的单个字符. 
$  变量替换
  1 var1=5
  2 var2=23skidoo
  3 
  4 echo $var1     # 5
  5 echo $var2     # 23skidoo
$  在正则表达式中作为行结束符.
${}  参数替换,见9.3节.
$*,$@ 位置参数
$?  退出状态变量.$?保存一个命令/一个函数或者脚本本身的退出状态.
$$  进程ID变量.这个$$变量保存运行脚本进程ID
()  命令组.如:
  1 (a=hello;echo $a)
  注意:在()中的命令列表,将作为一个子shell来运行.
  在()中的变量,由于是在子shell中,所以对于脚本剩下的部分是不可用的.
  如:
  1 a=123
  2 ( a=321; )       
  3 
  4 echo "a = $a"   # a = 123
  5 # 在圆括号中a变量,更像是一个局部变量. 
  用在数组初始化,如:
  1 Array=(element1,element2,element3) 
{xxx,yyy,zzz...}
  大括号扩展,如:
  1 cat {file1,file2,file3} > combined_file
  2 # 把file1,file2,file3连接在一起,并且重定向到combined_file中.
  3 
  4 
  5 cp file22.{txt,backup}
  6 # 拷贝"file22.txt" 到"file22.backup"中 
  一个命令可能会对大括号中的以逗号分割的文件列表起作用[1]. file globbing将对
  大括号中的文件名作扩展.
  注意: 在大括号中,不允许有空白,除非这个空白是有意义的.
  echo {file1,file2}\ :{\ A," B",' C'}
  file1 : A file1 : B file1 : C file2 : A file2 : B file2 : C
{}  代码块.又被称为内部组.事实上,这个结构创建了一个匿名的函数.但是与函数不同的
  是,在其中声明的变量,对于脚本其他部分的代码来说还是可见的.如:
  bash$ 
  {
   local a;
   a= 123;
  }
  bash中的local申请的变量只能够用在函数中. 
  1 a=123
  2 { a=321; }
  3 echo "a = $a"   # a = 321   (说明在代码块中对变量a所作的修改,影响了外边的变量a)
  4 
  5 # Thanks, S.C. 
  下边的代码展示了在{}结构中代码的I/O重定向. 
Example 3-1. 代码块和I/O重定向
################################Start Script#######################################
 1 #!/bin/bash
 2 # 从 /etc/fstab中读行
 3 
 4 File=/etc/fstab
 5 
 6 {
 7 read line1
 8 read line2
 9 } < $File
10 
11 echo "First line in $File is:"
12 echo "$line1"
13 echo
14 echo "Second line in $File is:"
15 echo "$line2"
16 
17 exit 0
18 
19 # 现在,你怎么分析每行的分割域
20 # 暗示: 使用 awk.
################################End Script######################################### 
Example 3-2. 将一个代码块的结果保存到文件
################################Start Script#######################################
 1 #!/bin/bash
 2 # rpm-check.sh
 3 
 4 # 这个脚本的目的是为了描述,列表,和确定是否可以安装一个rpm包.
 5 # 在一个文件中保存输出.
 6 # 
 7 # 这个脚本使用一个代码块来展示
 8 
 9 SUCCESS=0
10 E_NOARGS=65
11 
12 if [ -z "$1" ]
13 then
14   echo "Usage: `basename $0` rpm-file"
15   exit $E_NOARGS
16 fi  
17 
18 { 
19   echo
20   echo "Archive Description:"
21   rpm -qpi $1       # 查询说明
22   echo
23   echo "Archive Listing:"
24   rpm -qpl $1       # 查询列表
25   echo
26   rpm -i --test $1  # 查询rpm包是否可以被安装
27   if [ "$?" -eq $SUCCESS ]
28   then
29     echo "$1 can be installed."
30   else
31     echo "$1 cannot be installed."
32   fi  
33   echo
34 } > "$1.test"       # 把代码块中的所有输出都重定向到文件中
35 
36 echo "Results of rpm test in file $1.test"
37 
38 # 查看rpm的man页来查看rpm的选项
39 
40 exit 0
################################End Script#########################################
  注意: 与()中的命令不同的是,{}中的代码块将不能正常地开启一个新shell.[2] 
{} \; 路径名.一般都在find命令中使用.这不是一个shell内建命令.
  注意: ";"用来结束find命令序列的-exec选项. 
[]  test.
  test的表达式将在[]中.
  值得注意的是[是shell内建test命令的一部分,并不是/usr/bin/test中的扩展命令
  的一个连接. 
[[]] test.
  test表达式放在[[]]中.(shell关键字)
  具体查看[[]]结构的讨论. 
[]  数组元素
  Array[1]=slot_1
  echo ${Array[1]} 
[]  字符范围
  在正则表达式中使用,作为字符匹配的一个范围 
(()) 数学计算的扩展
  在(())结构中可以使用一些数字计算.
  具体参阅((...))结构. 
>&>>&>><
  重定向.
  scriptname >filename 重定向脚本的输出到文件中.覆盖文件原有内容.
  command &>filename 重定向stdout和stderr到文件中
  command >&2 重定向command的stdout到stderr
  scriptname >>filename 重定向脚本的输出到文件中.添加到文件尾端,如果没有文件,
  则创建这个文件. 
  进程替换,具体见"进程替换部分",跟命令替换极其类似.
  (command)>
  <(command) 
  <和> 可用来做字符串比较
  <和> 可用在数学计算比较 
<<  重定向,用在"here document" 
<<<  重定向,用在"here string" 
<,>  ASCII比较
   1 veg1=carrots
   2 veg2=tomatoes
   3 
   4 if [[ "$veg1" < "$veg2" ]]
   5 then
   6   echo "Although $veg1 precede $veg2 in the dictionary,"
   7   echo "this implies nothing about my culinary preferences."
   8 else
   9   echo "What kind of dictionary are you using, anyhow?"
  10 fi 
\<,\> 正则表达式中的单词边界.如:
  bash$grep '\<the\>' textfile
 
|  管道.分析前边命令的输出,并将输出作为后边命令的输入.这是一种产生命令链的
  好方法.
  1 echo ls -l | sh
  2 #  传递"echo ls -l"的输出到shell中,
  3 #+ 与一个简单的"ls -l"结果相同.
  4 
  5 
  6 cat *.lst | sort | uniq
  7 # 合并和排序所有的".lst"文件,然后删除所有重复的行.
  
  管道是进程间通讯的一个典型办法,将一个进程的stdout放到另一个进程的stdin中.
  标准的方法是将一个一般命令的输出,比如cat或echo,传递到一个过滤命令中(在这个
  过滤命令中将处理输入),得到结果,如:
  cat $filename1 | $filename2 | grep $search_word 
  当然输出的命令也可以传递到脚本中.如:
################################Start Script#######################################
1 #!/bin/bash
2 # uppercase.sh : 修改输出,全部转换为大写
3 
4 tr 'a-z' 'A-Z'
5 #  字符范围必须被""引用起来
6 #+ 来阻止产生单字符的文件名.
7 
8 exit 0
################################End Script#########################################
  
  现在让我们输送ls -l的输出到一个脚本中.
  bash$ ls -l | ./uppercase.sh
  -RW-RW-R--    1 BOZO  BOZO       109 APR  7 19:49 1.TXT
  -RW-RW-R--    1 BOZO  BOZO       109 APR 14 16:48 2.TXT
  -RW-R--R--    1 BOZO  BOZO       725 APR 20 20:56 DATA-FILE 
  注意:管道中的一个进程的stdout必须被下一个进程作为stdin读入.否则,数据流会阻
  塞,并且管道将产生非预期的行为.
  如:
  1 cat file1 file2 | ls -l | sort
  2 #从"cat file1 file2"中的输出并没出现 
  作为子进程的运行的管道,不能够改变脚本的变量.
  1 variable="initial_value"
  2 echo "new_value" | read variable
  3 echo "variable = $variable"   #variable = initial_value
  如果管道中的某个命令产生了一个异常,并中途失败,那么这个管道将过早的终止.
  这种行为被叫做a broken pipe,并且这种状态下将发送一个SIGPIPE信号. 
>|  强制重定向(即使设置了noclobber选项--就是-C选项).这将强制的覆盖一个现存文件. 
||  或-逻辑操作. 
&  后台运行命令.一个命令后边跟一个&,将表示在后台运行.
  bash$sleep 10 &
  [1] 850
  [1]+ Done   sleep 10
  在一个脚本中,命令和循环都可能运行在后台. 
Example 3-3. 在后台运行一个循环
################################Start Script#######################################
 1 #!/bin/bash
 2 #background-loop.sh
 3
 4 for i in 1 2 3 4 5 6 7 8 9 10    #第一个循环
 5 do
 6 echo -n "$i"
 7 done&      #在后台运行这个循环
 8        #在第2个循环之后,将在某些时候执行.
 9 
10 echo #这个'echo'某些时候将不会显示.
11 
12 for i in 11 12 13 14 15 16 17 18 19 20  #第二个循环
13 do
14  echo -n "$i"
15 done
16
17 echo #这个'echo'某些时候将不会显示.
18
19 #--------------------------------------------------------
20 
21 #期望的输出应该是
22 #1 2 3 4 5 6 7 8 9 10
23 #11 12 13 14 15 16 17 18 19 20
24 
25 #然而实际的结果有可能是
26 #11 12 13 14 15 16 17 18 19 20
27 #1 2 3 4 5 6 7 8 9 10 bozo $
28 #(第2个'echo'没执行,为什么?)
29 
30 #也可能是
31 #1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20
32 #(第1个'echo'没执行,为什么?)
33 
34 #非常少见的执行结果,也有可能是:
35 #11 12 13 1 2 3 4 5 6 7 8 9 10 14 15 16 17 18 19 20
36 #前台的循环先于后台的执行
37 
38 exit 0
39 
40 # Nasimuddin Ansari 建议加一句 sleep 1
41 #+ 在 6行和14行的 echo -n "$i"之后加
42 #+ 将看到一些乐趣
################################End Script#########################################
  注意:在一个脚本内后台运行一个命令,有可能造成这个脚本的挂起,等待一个按键
   响应.幸运的是,我们可以在Example 11-24附近,看到这个问题的解决办法. 
&&  与-逻辑操作. 
-  选项,前缀.在所有的命令内如果想使用选项参数的话,前边都要加上"-". 
  COMMAND -[Option1][Option2][...]
  ls -al
  sort -dfu $filename
  set -- $variable 
   1 if [ $file1 -ot $file2 ]
   2 then
   3   echo "File $file1 is older than $file2."
   4 fi
   5 
   6 if [ "$a" -eq "$b" ]
   7 then
   8   echo "$a is equal to $b."
   9 fi
  10 
  11 if [ "$c" -eq 24 -a "$d" -eq 47 ]
  12 then
  13   echo "$c equals 24 and $d equals 47."
  14 fi 
-  用于重定向 stdin 或 stdout. 
################################Start Script#######################################
 1 (cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -)
 2 # 从一个目录移动整个目录树到另一个目录
 3 # [courtesy Alan Cox <a.cox@swansea.ac.uk>, with a minor change]
 4 
 5 # 1) cd /source/directory    源目录
 6 # 2) &&                      与操作,如果cd命令成功了,那么就执行下边的命令
 7 # 3) tar cf - .              'c'创建一个新文档,'f'后边跟'-'指定目标文件作为stdout
 8 #                            '-'后边的'f'(file)选项,指明作为stdout的目标文件.
 9 #                            并且在当前目录('.')执行.
10 # 4) |                       管道...
11 # 5) ( ... )                 一个子shell
12 # 6) cd /dest/directory      改变当前目录到目标目录.
13 # 7) &&                      与操作,同上.
14 # 8) tar xpvf -              'x'解档,'p'保证所有权和文件属性,
15 #       'v'发完整消息到stdout
16 #                            'f'后边跟'-',从stdin读取数据
17 #
18 #                            注意:'x' 是一个命令, 'p', 'v', 'f' 是选项.
19 # Whew!
20 
21 
22 
23 # 更优雅的写法应该是
24 #   cd source/directory
25 #   tar cf - . | (cd ../dest/directory; tar xpvf -)
26 #
27 #     当然也可以这么写:
28 # cp -a /source/directory/* /dest/directory
29 #     或者:
30 # cp -a /source/directory/* /source/directory/.[^.]* /dest/directory
31 #     如果在/source/directory中有隐藏文件的话.
################################End Script######################################### 
################################Start Script#######################################
1 bunzip2 linux-2.6.13.tar.bz2 | tar xvf -
2 # --未解压的tar文件--    | --然后把它传递到"tar"中--
3 # 如果 "tar" 没能够正常的处理"bunzip2",
4 # 这就需要使用管道来执行2个单独的步骤来完成它.
5 # 这个练习的目的是解档"bzipped"的kernel源文件.
################################End Script#########################################
  注意:在上边这个例子中'-'不太象是bash的操作符,而更像是tar的参数.
  bash$echo "whatever" | cat -
  whatever 
  在需要一个文件名的地方,-重定向输出到stdout(如在tar和cf命令中),或者从
  stdin中接受输入,而不是从一个文件中接受输入.这是在管道中作为一个过滤
  器,来使用文件定位工具的一种办法.
  bash$file
  用法: file [-bciknvzl] [-f namefile] [-m magicfiles] file...
  上边这个例子file将会出错,提示你如何使用file命令. 
  添加一个"-"将得到一个更有用的结果.这将使得shell等待用户输入.
  bash$file -
  abc
  standard input:     ASCII text 
  bash$file -
  #!/bin/bash
  standard input:     Bourn-Again shell script tesxt executable 
  现在命令从stdin中接受了输入,并分析它. 
  "-"常用于管道后边的命令,具体参看33.7节,来看使用技巧.
  使用diff命令来和另一个文件的一部分进行比较.
  grep Linux file1 | diff file2 - 
  最后,一个真实世界的使用tar命令的例子. 
Example 3-4. 备份最后一天所有修改的文件.
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 #  在一个"tarball"中(经过tar和gzip处理过的文件)
 4 #+ 备份最后24小时当前目录下d所有修改的文件.
 5 
 6 BACKUPFILE=backup-$(date +%m-%d-%Y)
 7 #                 在备份文件中嵌入时间.
 8 #                 Thanks, Joshua Tschida, for the idea.
 9 archive=${1:-$BACKUPFILE}
10 #  如果在命令行中没有指定备份文件的文件名,
11 #+ 那么将默认使用"backup-MM-DD-YYYY.tar.gz".
12 
13 tar cvf - `find . -mtime -1 -type f -print` > $archive.tar
14 gzip $archive.tar
15 echo "Directory $PWD backed up in archive file \"$archive.tar.gz\"."
16 
17 
18 #  Stephane Chazelas指出上边代码,
19 #+ 如果在发现太多的文件的时候,或者是如果文件
20 #+ 名包括空格的时候,将执行失败.
21 
22 # Stephane Chazelas建议使用下边的两种代码之一
23 # -------------------------------------------------------------------
24 #   find . -mtime -1 -type f -print0 | xargs -0 tar rvf "$archive.tar"
25 #      使用gnu版本的find.
26 
27 
28 #   find . -mtime -1 -type f -exec tar rvf "$archive.tar" '{}' \;
29 #         对于其他风格的UNIX便于移植,但是比较慢.
30 # -------------------------------------------------------------------
31 
32 
33 exit 0
################################End Script######################################### 
  注意:以"-"开头的文件名在使用"-"作为重定向操作符的时候,可能会产生问题.
  应该写一个脚本来检查这个问题,并给这个文件加上合适的前缀.如:
  ./-FILENAME, $PWD/-FILENAME,或$PATHNAME/-FILENAME. 
  如果变量的值以"-"开头,可能也会引起问题.
  1 var="-n"
  2 echo $var
  3 #具有"echo -n"的效果了,这样什么都不会输出的. 
-  之前工作的目录."cd -"将回到之前的工作目录,具体请参考"$OLDPWD"环境变量.
  注意:一定要和之前讨论的重定向功能分开,但是只能依赖上下文区分. 
-  算术减号. 
=  算术等号,有时也用来比较字符串.
  1 a=28
  2 echo $a   # 28 
+  算术加号,也用在正则表达式中.
+  选项,对于特定的命令来说使用"+"来打开特定的选项,用"-"来关闭特定的选项. 
%  算术取模运算.也用在正则表达式中. 
~  home目录.相当于$HOME变量.~bozo是bozo的home目录,并且ls ~bozo将列出其中的
  内容. ~/就是当前用户的home目录,并且ls ~/将列出其中的内容,如:
  bash$ echo ~bozo
  /home/bozo 
  bash$ echo ~
  /home/bozo 
  bash$ echo ~/
  /home/bozo/ 
  bash$ echo ~:
  /home/bozo: 
  bash$ echo ~nonexistent-user
  ~nonexistent-user 
~+  当前工作目录,相当于$PWD变量. 
~-  之前的工作目录,相当于$OLDPWD内部变量. 
=~  用于正则表达式,这个操作将在正则表达式匹配部分讲解,只有version3才支持. 
^  行首,正则表达式中表示行首."^"定位到行首. 
控制字符
  修改终端或文本显示的行为.控制字符以CONTROL + key组合.
  控制字符在脚本中不能正常使用.
  Ctl-B  光标后退,这应该依赖于bash输入的风格,默认是emacs风格的.
  Ctl-C  Break,终止前台工作.
  Ctl-D  从当前shell登出(和exit很像)
     "EOF"(文件结束符).这也能从stdin中终止输入.
     在console或者在xterm window中输入的时候,Ctl-D将删除光标下字符.
     当没有字符时,Ctrl-D将退出当前会话.在xterm window也有关闭窗口
     的效果.
  Ctl-G  beep.在一些老的终端,将响铃.
  Ctl-H  backspace,删除光标前边的字符.如:
      1 #!/bin/bash
      2 # 在一个变量中插入Ctl-H
      3 
      4 a="^H^H"                  # 两个 Ctl-H (backspaces).
      5 echo "abcdef"             # abcdef
      6 echo -n "abcdef$a "       # abcd f
      7 # 注意结尾的空格 ^              ^ 两个 twice.
      8 echo -n "abcdef$a"        # abcdef
      9 #  结尾没有空格             没有 backspace 的效果了(why?).
     10                           # 结果并不像期望的那样
     11 echo; echo
  Ctl-I  就是tab键.
  Ctl-J  新行.
  Ctl-K  垂直tab.(垂直tab?新颖,没听过)
     作用就是删除光标到行尾的字符.
  Ctl-L  clear,清屏.
  Ctl-M  回车
################################Start Script#######################################
 1 #!/bin/bash
 2 # Thank you, Lee Maschmeyer, for this example.
 3 
 4 read -n 1 -s -p $'Control-M leaves cursor at beginning of this line. Press Enter. \x0d'
 5                                   #当然,'0d'就是二进制的回车.
 6 echo >&2   #  '-s'参数使得任何输入都不将回显出来
 7            #+ 所以,明确的重起一行是必要的.
 8 
 9 read -n 1 -s -p $'Control-J leaves cursor on next line. \x0a'
10 echo >&2   #  Control-J 是换行.
11 
12 ###
13 
14 read -n 1 -s -p $'And Control-K\x0bgoes straight down.'
15 echo >&2   #  Control-K 是垂直制表符.
16 
17 # 关于垂直制表符效果的一个更好的例子见下边:
18 
19 var=$'\x0aThis is the bottom line\x0bThis is the top line\x0a'
20 echo "$var"
21 #  这句与上边的例子使用的是同样的办法,然而:
22 echo "$var" | col
23 #  这将造成垂直制表符右边的部分在左边部分的上边.
24 #  这也解释了为什么我们要在行首和行尾加上一个换行符--
25 #+ 来避免一个混乱的屏幕输出.
26 
27 # Lee Maschmeyer的解释:
28 # ---------------------
29 #  In the [first vertical tab example] . . . the vertical tab
29 #  在这里[第一个垂直制表符的例子中] . . . 这个垂直制表符
30 #+ makes the printing go straight down without a carriage return.
31 #  This is true only on devices, such as the Linux console,
32 #+ that can't go "backward."
33 #  The real purpose of VT is to go straight UP, not down.
34 #  It can be used to print superscripts on a printer.
34 #  它可以用来在一个打印机上打印上标.
35 #  col的作用,可以用来模仿VT的合适的行为.
36 
37 exit 0
################################End Script#########################################
  Ctl-Q  继续(等价于XON字符),这个继续的标准输入在一个终端里
  Ctl-S  挂起(等价于XOFF字符),这个被挂起的stdin在一个终端里,用Ctl-Q恢复
  Ctl-U  删除光标到行首的所有字符,在某些设置下,删除全行.
  Ctl-V  当输入字符时,Ctl-V允许插入控制字符.比如,下边2个例子是等价的
     echo -e '\x0a'
     echo <Ctl-V><Ctl-J>
     Ctl-V在文本编辑器中十分有用,在vim中一样.
  Ctl-W  删除当前光标到前边的最近一个空格之间的字符.
     在某些设置下,删除到第一个非字母或数字的字符.
  Ctl-Z  终止前台工作.
  
空白部分
  分割命令或者是变量.包括空格,tab,空行,或任何它们的组合.
  在一些特殊情况下,空白是不允许的,如变量赋值时,会引起语法错误.
  空白行在脚本中没有效果.
  "$IFS",对于某些命令输入的特殊变量分割域,默认使用的是空白.
  如果想保留空白,使用引用. 
注意事项:
[1]  shell做大括号的命令扩展.但是命令本身需要对扩展的结果作处理.
[2]  例外:在pipe中的一个大括号中的代码段可能运行在一个子shell中.
  1 ls | { read firstline; read secondline; }
  2 #  错误,在打括号中的代码段,将运行到子shell中.
  3 #+ 所以ls的输出将不能传递到代码块中.
  4 echo "First line is $firstline; second line is $secondline"  # 不能工作
  5 
  6 # Thanks, S.C.
[3]  换行符也被认为是空白.这也解释了为什么一个空行也会被认为是空白. 
  
第4章 变量和参数的介绍
====================== 
4.1 变量替换
------------
$  变量替换操作符
  只有在变量被声明,赋值,unset或exported或者是在变量代表一个signal的时候,
  变量才会是以本来的面目出现在脚本里.变量在被赋值的时候,可能需要使用"=",
  read状态或者是在循环的头部.
  在""中还是会发生变量替换,这被叫做部分引用,或叫弱引用.而在''中就不会发生变
  量替换,这叫做全引用,也叫强引用.具体见第5章的讨论. 
  注意:$var与${var}的区别,不加{},在某些上下文将引起错误,为了安全,使用2.
   具体见9.3节 参数替换. 
Example 4-1. 变量赋值和替换
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # 变量赋值和替换
 4 
 5 a=375
 6 hello=$a
 7 
 8 #-------------------------------------------------------------------------
 9 # 强烈注意,在赋值的前后一定不要有空格.
10 # 如果有空格会发生什么?
11 
12 #  如果"VARIABLE =value",
13 #              ^
14 #+ 脚本将尝试运行一个"VARIABLE"的命令,带着一个"=value"参数.
15 
16 #  如果"VARIABLE= value",
17 #               ^
18 #+ script tries to run "value" command with
18 #+ 脚本将尝试运行一个"value"的命令,带着
19 #+ the environmental variable "VARIABLE" set to "".
19 #+ 一个被赋成""值的环境变量"VARIABLE".
20 #-------------------------------------------------------------------------
21 
22 
23 echo hello    # 没有变量引用,不过是个hello字符串
24 
25 echo $hello
26 echo ${hello} # 同上
27 
28 echo "$hello"
29 echo "${hello}"
30 
31 echo
32 
33 hello="A B  C   D"
34 echo $hello   # A B C D
35 echo "$hello" # A B  C   D
36 # 就象你看到的echo $hello   和    echo "$hello"   将给出不同的结果.
37 #                                      ^      ^
38 # Quoting a variable preserves whitespace.
38 # 引用一个变量将保留其中的空白,当然,如果是变量替换就不会保留了.
39 
40 echo
41 
42 echo '$hello'  # $hello
43 #    ^      ^
44 # 全引用的作用
45 #+ 将导致"$"变成一个单独的字符.
46 
47 # 注意两种引用不同的效果
48 
49 
50 hello=    # 设置为空值
51 echo "\$hello (null value) = $hello"
52 #  注意设置一个变量为空,与unset它,不是一回事,虽然看起来一样
53 #
54 
55 # --------------------------------------------------------------
56 
57 #  可以在同一行上设置多个变量.
58 #+ 要以空白分隔
59 #  小心,这会降低可读性,和可移植性.
60 
61 var1=21  var2=22  var3=$V3
62 echo
63 echo "var1=$var1   var2=$var2   var3=$var3"
64 
65 # 在老版本的"sh"上,可能会有问题.
66 
67 # --------------------------------------------------------------
68 
69 echo; echo
70 
71 numbers="one two three"
72 #           ^   ^
73 other_numbers="1 2 3"
74 #               ^ ^
75 #  如果变量中有空白,那么引用就必要了.
76 #
77 echo "numbers = $numbers"
78 echo "other_numbers = $other_numbers"   # other_numbers = 1 2 3
79 echo
80 
81 echo "uninitialized_variable = $uninitialized_variable"
82 # Uninitialized变量为空值(根本就没赋值). 
83 uninitialized_variable=   #  声明,但是没被初始化
84                           #+ 其实和前边设置为空值得作用是一样的.
85 echo "uninitialized_variable = $uninitialized_variable"
86                           # 还是一个空值
87 
88 uninitialized_variable=23       # 赋值
89 unset uninitialized_variable    # Unset it.
90 echo "uninitialized_variable = $uninitialized_variable"
91                                 # 还是空值
92 echo
93 
94 exit 0
################################End Script#########################################
注意: 一个空值变量,或者是根本就没声明的变量,在赋值之前使用它可能会引起问题.
  但是还是可以用来做算术运算
################################Start Script#######################################
1 echo "$uninitialized"                                # (blank line)
2 let "uninitialized += 5"                             # Add 5 to it.
3 echo "$uninitialized"                                # 5
4 
5 #  结论:
6 #  对于一个空值变量在做算术操作的时候,就好像它的值为0一样.
8 #  This is undocumented (and probably non-portable) behavior.
7 #  这并没被文档化(可能是不可移植)的行为.
################################End Script#########################################
具体参考 Example 11-21 
4.2 变量赋值
------------
=  赋值操作符(前后都不能有空白)
  不要与-eq混淆,那个是test,并不是赋值.
  注意,=也可被用来做test操作,这依赖于上下文. 
Example 4-2. 一般的变量赋值
################################Start Script#######################################
 1 #!/bin/bash
 2 # "裸体"变量
 3 
 4 echo
 5 
 6 # 变量什么时候是"裸体"的,比如前边少了$的时候.
 7 # 当它被赋值的时候,而不是被引用的时候.
 8 
 9 # 赋值
10 a=879
11 echo "The value of \"a\" is $a."
12 
13 # 使用let赋值
14 let a=16+5
15 echo "The value of \"a\" is now $a."
16 
17 echo
18 
19 # 在for循环中
20 echo -n "Values of \"a\" in the loop are: "
21 for a in 7 8 9 11
22 do
23   echo -n "$a "
24 done
25 
26 echo
27 echo
28 
29 # 在read命令状态中
30 echo -n "Enter \"a\" "
31 read a
32 echo "The value of \"a\" is now $a."
33 
34 echo
35 
36 exit 0
################################End Script######################################### 
Example 4-3. 变量赋值,一般的和比较特殊的
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 a=23              # Simple case
 4 echo $a
 5 b=$a
 6 echo $b
 7 
 8 # 现在让我们来点小变化
 9 
10 a=`echo Hello!`   # 把echo命令的结果传给变量a
11 echo $a
12 #  注意,如果在命令扩展结构中使用一个(!)的话,在命令行中将不能工作
13 #+ 因为这触发了Bash的"历史机制".
14 #  但是,在校本里边使用的话,历史功能是被关闭的,所以就能够正常运行.
15
16 
17 a=`ls -l`         # 把ls -l的结果给a
18 echo $a           # 别忘了,这么引用的话,ls的结果中的所有空白部分都没了(包括换行)
19 echo
20 echo "$a"         # 这么引用就正常了,保留了空白
21                   # (具体参阅章节"引用")
22 
23 exit 0
################################End Script#########################################
使用$(...)机制进行的变量赋值(除去使用``来赋值的另外一种新方法).事实上这两种方法都是
命令替换的一种形式.
# 来自于/ect/rc.d/rc.local
R=$(cat /ect/redhat-release)
arch=$(uname -m) 
4.3 Bash变量是不分类型的
------------------------
不像其他程序语言一样,Bash并不对变量区分"类型".本质上,Bash变量都是字符串.
但是依赖于上下文,Bash也允许比较操作和算术操作.决定这些的关键因素就是,变量中的值
是否只有数字. 
Example 4-4 整型还是string?
################################Start Script#######################################
 1 #!/bin/bash
 2 # int-or-string.sh: 整形还是string?
 3 
 4 a=2334                   # 整型
 5 let "a += 1"
 6 echo "a = $a "           # a = 2335
 7 echo                     # 还是整型
 8 
 9 
10 b=${a/23/BB}             # 将23替换成BB
11                          # 这将把b变量从整型变为string
12 echo "b = $b"            # b = BB35
13 declare -i b             # 即使使用declare命令也不会对此有任何帮助,9.4节有解释
14 echo "b = $b"            # b = BB35
15 
16 let "b += 1"             # BB35 + 1 =
17 echo "b = $b"            # b = 1
18 echo
19 
20 c=BB34
21 echo "c = $c"            # c = BB34
22 d=${c/BB/23}             # S将BB替换成23
23                          # 这使得$d变为一个整形
24 echo "d = $d"            # d = 2334
25 let "d += 1"             # 2334 + 1 =
26 echo "d = $d"            # d = 2335
27 echo
28 
29 # 关于空变量怎么样?
30 e=""
31 echo "e = $e"            # e =
32 let "e += 1"             # 算术操作允许一个空变量?
33 echo "e = $e"            # e = 1
34 echo                     # 空变量将转换成一个整型变量
35 
36 # 关于未声明的变量怎么样?
37 echo "f = $f"            # f =
38 let "f += 1"             # 算术操作允许么?
39 echo "f = $f"            # f = 1
40 echo                     # 未声明的变量将转换成一个整型变量
41 
42 
43 
44 # 所以说Bash中的变量都是无类型的.
45 
46 exit 0
################################End Script######################################### 
4.4 特殊的变量类型
------------------
local variables
  这种变量只有在代码块或者是函数中才可见(具体见23.2和23章)
environmental variables
  这种变量将改变用户接口和shell的行为. 
  在一般的上下文中,每个进程都有自己的环境,就是一组保持进程可能引用的信息的
  变量.这种情况下,shell于一个一般进程是相同的. 
  每次当shell启动时,它都将创建自己的环境变量.更新或者添加新的环境变量,将导
  致shell更新它的环境,同时也会影响所有继承自这个环境的所有子进程(由这个命令
  导致的). 
  注意:分配给环境变量的空间是受限的.创建太多的环境变量将引起空间溢出,这会引
  起问题.
  关于eval命令,具体见第11章
  bash$ eval "`seq 10000 | sed -e 's/.*/export var&=ZZZZZZZZZZZZZZ/'`"
  bash$ du
  bash: /usr/bin/du: Argument list too long 
  如果一个脚本设置了环境变量,需要export它,来通知本脚本的环境,这是export
  命令的功能,关于export命令,具体见11章.
  
  脚本只能对它产生的子进程export变量.一个从命令行被调用的脚本export的变量,将
  不能影响调用这个脚本的那个命令行shell的环境. 
positional parameters
  就是从命令行中传进来的参数,$0, $1, $2, $3... 
  $0就是脚本文件的名字,$1是第一个参数,$2为第2个...,参见[1](有$0的说明),$9
  以后就需要打括号了,如${10},${11},${12}...
  两个值得注意的变量$*和$@(第9章有具体的描述),表示所有的位置参数. 
Example 4-5 位置参数
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # 作为用例,调用这个脚本至少需要10个参数,如
 4 # ./scriptname 1 2 3 4 5 6 7 8 9 10
 5 MINPARAMS=10
 6 
 7 echo
 8 
 9 echo "The name of this script is \"$0\"."
10 # 添加./是为了当前目录
11 echo "The name of this script is \"`basename $0`\"."
12 # 去掉目录信息,具体见'basename'命令
13 
14 echo
15 
16 if [ -n "$1" ]              # 测试变量被被引用
17 then
18  echo "Parameter #1 is $1"  # "#"没被转义
19 fi 
20 
21 if [ -n "$2" ]
22 then
23  echo "Parameter #2 is $2"
24 fi 
25 
26 if [ -n "$3" ]
27 then
28  echo "Parameter #3 is $3"
29 fi 
30 
31 # ...
32 
33 
34 if [ -n "${10}" ]  # 大于9的参数必须出现在{}中.
35 then
36  echo "Parameter #10 is ${10}"
37 fi 
38 
39 echo "-----------------------------------"
40 echo "All the command-line parameters are: "$*""
41 
42 if [ $# -lt "$MINPARAMS" ]  #$#是传到脚本里的位置参数的个数
43 then
44   echo
45   echo "This script needs at least $MINPARAMS command-line arguments!"
46 fi  
47 
48 echo
49 
50 exit 0
################################End Script#########################################
  {}标记法是一种很好的使用位置参数的方法.这也需要间接引用(见Example 34-2)
  1 args=$#           # 位置参数的个数
  2 lastarg=${!args}
  3 # 或:       lastarg=${!#}
  4 # 注意 lastarg=${!$#} 将报错 
  一些脚本可能会依赖于使用不同的调用名字,而表现出不同的行为,这样一般都需要
  判断$0,而其他的名字都是通过ln命令产生的链接.(具体参见Example 12-2) 
  如果脚本需要一个命令行参数,而调用的时候,没用这个参数,这就有可能造成分配一个
  空变量,这样估计就会引起问题.一种解决办法就是在这个位置参数,和相关的变量后
  边,都添加一个额外的字符.具体见下边的例子.
################################Start Script#######################################
 1 variable1_=$1_  # 而不是 variable1=$1
 2 # 这将阻止一个错误,即使在调用时没使用这个位置参数.
 3 
 4 critical_argument01=$variable1_
 5 
 6 # 这个扩展的字符是可以被消除掉的,就像这样.
 7 variable1=${variable1_/_/}
 8 # 副作用就是$variable1_多了一个下划线
 9 # 这里使用了一个参数替换模版(后边会有具体的讨论)
10 # (Leaving out the replacement pattern results in a deletion.)
10 # (在一个删除动作中,节省了一个替换模式)
11 
12 
13 # 一个解决这种问题的更简单的做法就是,判断一下这个位置参数是否传递下来了 
14 if [ -z $1 ]
15 then
16   exit $E_MISSING_POS_PARAM
17 fi
18 
19 
20 #  但是上边的方法将可能产生一个意外的副作用
21 #  参数替换的更好的办法应该是:
22 #         ${1:-$DefaultVal}
23 #  具体察看"Parameter Substition"节
24 #+ 在第9章
################################End Script#########################################
   
Example 4-6 wh,whois节点名字查询
################################Start Script#######################################
 1 #!/bin/bash
 2 # ex18.sh
 3 
 4 # Does a 'whois domain-name' lookup on any of 3 alternate servers:
 5 #                    ripe.net, cw.net, radb.net
 6 
 7 # 把这个脚本重命名为'wh',然后放到/usr/local/bin下
 8 
 9 # 需要3个符号链接
10 # ln -s /usr/local/bin/wh /usr/local/bin/wh-ripe
11 # ln -s /usr/local/bin/wh /usr/local/bin/wh-cw
12 # ln -s /usr/local/bin/wh /usr/local/bin/wh-radb
13 
14 E_NOARGS=65
15 
16 
17 if [ -z "$1" ]
18 then
19   echo "Usage: `basename $0` [domain-name]"
20   exit $E_NOARGS
21 fi
22 
23 # Check script name and call proper server.
23 # 检查脚本名字,然后调用合适的服务器
24 case `basename $0` in    # Or:    case ${0##*/} in
25     "wh"     ) whois $1@whois.ripe.net;;
26     "wh-ripe") whois $1@whois.ripe.net;;
27     "wh-radb") whois $1@whois.radb.net;;
28     "wh-cw"  ) whois $1@whois.cw.net;;
29     *        ) echo "Usage: `basename $0` [domain-name]";;
30 esac 
31 
32 exit $?
################################End Script######################################### 
shift  shift命令重新分配位置参数,其实就是向左移动一个位置.
 $1 <--- $2, $2 <--- $3, $3 <--- $4, 等等.
  老的$1将消失,但是$0(脚本名)是不会改变的.如果你使用了大量的位置参数,那么
  shift命令允许你存取超过10个参数.虽然{}表示法也允许这样. 
Example 4-7 使用shift
################################Start Script#######################################
 1 #!/bin/bash
 2 # 使用'shift'来穿过所有的位置参数.
 3 
 4 #  把这个脚本命名为shft,
 5 #+ 并且使用一些参数来调用它,如:
 6 #          ./shft a b c def 23 skidoo
 7 
 8 until [ -z "$1" ]  # 知道所有参数都用光
 9 do
10   echo -n "$1 "
11   shift
12 done
13 
14 echo               # 额外的换行.
15 
16 exit 0
################################End Script#########################################
  在将参数传递到函数中时,shift的工作方式也基本差不多.具体见Example 33-15 
注意事项:
[1]  进程调用设置$0参数的脚本.一般的,这个参数就是脚本名字.具体察看execv的man页. 
  
第5章 引用(翻译的可能有问题,特指引号)
======================================
引号的特殊效果就是,保护字符串中的特殊字符不被shell或者是shell脚本重新解释或者扩展.
(我们这里所说的"特殊"指的是一些字符在shell中具有的特殊意义,比如*)
如:
 bash$ ls -l [Vv]*
-rw-rw-r--    1 bozo  bozo       324 Apr  2 15:05 VIEWDATA.BAT
-rw-rw-r--    1 bozo  bozo       507 May  4 14:25 vartrace.sh
-rw-rw-r--    1 bozo  bozo       539 Apr 14 17:11 viewdata.sh
  
bash$ ls -l '[Vv]*'
ls: [Vv]*: No such file or directory 
在我们一般的生活中,引号内的内容往往有特殊的含义,而在Bash中,当我们引用一个字符串,
我们是保护它的字面含义. 
特定的程序和工具能够重新解释或扩展特殊的字符.引用的一个重要的作用就是保护命令行中
的参数,但还是允许正在调用的程序来扩展它.
 bash$ grep '[Ff]irst' *.txt
 file1.txt:This is the first line of file1.txt.
 file2.txt:This is the First line of file2.txt. 
注意 grep [Ff]irst *.txt在Bash下的行为(其实就是正则表达式么),[1] 
引用还可以抑制echo命令的换行作用. 
bash$ echo $(ls -l)
total 8 -rw-rw-r-- 1 bozo bozo 130 Aug 21 12:57 t222.sh -rw-rw-r-- 1 bozo bozo 78 Aug 21 12:57 t71.sh 
bash$ echo "$(ls -l)"
total 8
-rw-rw-r--  1 bozo bozo 130 Aug 21 12:57 t222.sh
-rw-rw-r--  1 bozo bozo  78 Aug 21 12:57 t71.sh 
5.1 引用变量
------------
在一个双引号中直接使用变量名,一般都是没有问题的.它阻止了所有在引号中的特殊字符的
重新解释--包括变量名[2]--但是$,`和\除外.[3]保留$,作为特殊字符的意义,是为了能够在双
引号中也能够正常地引用变量("$var").这样在""中可以使用变量所表达的值(Example 4-1). 
使用""来防止单词分割.[4]如果在参数列表中使用双引号,将使得双引号中的参数作为一个参
数.即使双引号中的字符串包含多个单词(也就是包含空白部分),也不会变为多个参数,如:
 1 variable1="a variable containing five words"
 2 COMMAND This is $variable1    # COMMAND将以7个参数来执行
 3 # "This" "is" "a" "variable" "containing" "five" "words"
 4 
 5 COMMAND "This is $variable1"  # COMMAND将以1个参数来执行
 6 # "This is a variable containing five words"
 7 
 8 
 9 variable2=""    # 空值
10 
11 COMMAND $variable2 $variable2 $variable2        # COMMAND将不带参数执行
12 COMMAND "$variable2" "$variable2" "$variable2"  # COMMAND将以3个空参数来执行
13 COMMAND "$variable2 $variable2 $variable2"      # COMMAND将以1个参数来执行(2空格)
 用双引号把参数封到echo中是很有必要的,只有在单词分隔或时保留空白时的时候可能
 有些问题. 
Example 5-1 echo一些诡异的变量
################################Start Script#######################################
 1 #!/bin/bash
 2 # weirdvars.sh: echo诡异的变量
 3 
 4 var="'(]\\{}\$\""
 5 echo $var        # '(]\{}$"
 6 echo "$var"      # '(]\{}$"    并没有什么不同 
 7 
 8 echo
 9 
10 IFS='\'
11 echo $var        # '(] {}$"     \ 转换成空格了?明显和IFS有关系么!又不傻!
12 echo "$var"      # '(]\{}$"
13 
14 exit 0
################################End Script######################################### 
单引号操作总体上和""很像,但不允许引用变量.因为$的特殊含义被关闭了.在''中除了',其他
字符都没有特殊的含义了.所以单引号比双引号严格.
 因为即使是\,在''中都被关闭了,所以你想在''中显示'的含义,将得不到预期的效果.
   1 echo "Why can't I write 's between single quotes"
   2 
   3 echo
   4 
   5 # 一种绕弯的方法
   6 echo 'Why can'\''t I write '"'"'s between single quotes'
   7 #    |-------|  |----------|   |-----------------------|
   8 # 包含了2个单引号字符,原书好像有错误 
注意事项:
[1]  除非当前目录下,正好有个叫first的文件.
[2]  即使是变量的值也是有副作用的(见下边)
[3]  如果在""中包含"!"的话,在命令行中将会出现错误.因为这个"!"被当作历史命令来解释了.
  在一个脚本中,这种情况是不会发生的,因为在脚本中,Bash历史记录被关闭了. 
  下边是一些关于"\"一些不协调的行为.
  bash$ echo hello\!
  hello! 
  bash$ echo "hello\!"
  hello\! 
  bash$ echo -e x\ty
  xty 
  bash$ echo -e "x\ty"
  x       y 
[4]  "单词分隔",在这个上下文中意味着,将一个字符串分隔为一些分离的参数. 
5.2 转义(\)
-----------
转义是一种引用单个字符的方法.一个具有特殊含义的字符前边放上一个转义符(\)就告诉shell
这个字符失去了特殊的含义.
 值得注意的是,在某些特定的命令和工具中,比如echo和sed,转义符往往会起到相反的效果,
 它反倒有可能引发出这个字符特殊的含义. 
对于特定的转义符的特殊的含义
在echo和sed中所使用的
\n  意味着新的一行
\r  回车
\t  tab键
\v  vertical tab(垂直tab),查前边的Ctl-K
\b  backspace,查前边的Ctl-H
\a  "alert"(如beep或flash)
\0xx 转换成8进制ASCII解码,等价于oxx 
Example 5-2 转义符
################################Start Script#######################################
 1 #!/bin/bash
 2 # escaped.sh: 转义符
 3 
 4 echo; echo
 5 
 6 echo "\v\v\v\v"      # 逐字的打印\v\v\v\v .
 7 # 使用-e选项的echo命令来打印转义符
 8 echo "============="
 9 echo "VERTICAL TABS"
10 echo -e "\v\v\v\v"   # Prints 4 vertical tabs.
11 echo "=============="
12 
13 echo "QUOTATION MARK"
14 echo -e "\042"       # 打印" (引号, 8进制的ASCII 码就是42).
15 echo "=============="
16 
17 # The $'\X' construct makes the -e option unnecessary.
17 # 如果使用$'\X'结构,那-e选项就不必要了
18 echo; echo "NEWLINE AND BEEP"
19 echo $'\n'           # 新行.
20 echo $'\a'           # Alert (beep).
21 
22 echo "==============="
23 echo "QUOTATION MARKS"
24 # 版本2以后Bash允许使用$'\nnn'结构
25 # 注意这种情况,'\nnn\是8进制
26 echo $'\t \042 \t'   # Quote (") framed by tabs.
27 
28 # 当然,也可以使用16进制的值,使用$'\xhhh' 结构
29 echo $'\t \x22 \t'  # Quote (") framed by tabs.
30 
31 # 早一点的Bash版本允许'\x022'这种形式
32 echo "==============="
33 echo
34 
35 
36 # 分配ASCII字符到变量中
37 # ---------------------
38 quote=$'\042'        # \042是",分配到变量中
39 echo "$quote This is a quoted string, $quote and this lies outside the quotes."
40 
41 echo
42 
43 # Concatenating ASCII chars in a variable.
43 # 变量中的连续的ASCII char.
44 triple_underline=$'\137\137\137'  # 137 是8进制的ASCII 码'_'.
45 echo "$triple_underline UNDERLINE $triple_underline"
46 
47 echo
48 
49 ABC=$'\101\102\103\010'           # 101, 102, 103 是8进制的码A, B, C.
50 echo $ABC
51 
52 echo; echo
53 
54 escape=$'\033'                    # 033 是8进制码for escape.
55 echo "\"escape\" echoes as $escape"
56 #"escape" echoes as                  没有变量被输出
57 
58 echo; echo
59 
60 exit 0
################################End Script#########################################
 另一个关于$''字符串扩展结果的例子见Example 34-1 
\"  表达引号本身
  1 echo "Hello"                  # Hello
  2 echo "\"Hello\", he said."    # "Hello", he said. 
\$  $号本身,跟在\$后的变量名,将不能扩展
  1 echo "\$variable01"  # 结果是$variable01 
\\  \号本身.
  1 echo "\\"  # 结果是\
  2 
  3 # 相反的 . . .
  4 
  5 echo "\"   # 这会出现第2个命令提示符,说白了就是提示你命令不全,你再补个"就
  6    # 好了.如果是在脚本里,就会给出一个错误. 
 注意:\的行为依赖于它是否被转义,被"",或者是否在"命令替换"和"here document"中.
################################Start Script#######################################
 1                       #  简单的转义和""
 2 echo \z               #  z
 3 echo \\z              # \z
 4 echo '\z'             # \z
 5 echo '\\z'            # \\z
 6 echo "\z"             # \z
 7 echo "\\z"            # \z
 8 
 9                       #  命令替换
10 echo `echo \z`        #  z
11 echo `echo \\z`       #  z
12 echo `echo \\\z`      # \z
13 echo `echo \\\\z`     # \z
14 echo `echo \\\\\\z`   # \z
15 echo `echo \\\\\\\z`  # \\z
16 echo `echo "\z"`      # \z
17 echo `echo "\\z"`     # \z
18 
19                       # Here document
20 cat <<EOF              
21 \z                      
22 EOF                   # \z
23 
24 cat <<EOF              
25 \\z                     
26 EOF                   # \z
################################End Script######################################### 
 分配给变量的字符串的元素也会被转义,但是只把一个转义符分配给变量将会报错.
################################Start Script#######################################
 1 variable=\
 2 echo "$variable"
 3 # Will not work - gives an error message:
 3 # 将不能正常工作- 将给出一个错误消息:
 4 # test.sh: : command not found
 5 # 一个"裸体的" 转义符将不能够安全的分配给变量.
 6 #
 7 #  What actually happens here is that the "\" escapes the newline and
 7 #  这里其实真正发生的是variable=\,这句被shell认为是没有完成,\被认为是一个续行符
 8 #+ 这样,下边的这句echo,也被认为是上一行的补充.所以,总的来说就是一个非法变量分配
 9 
10 variable=\
11 23skidoo
12 echo "$variable"        #  23skidoo
13                         #  这句就可以使用,因为这是一个合法的变量分配
14 
15 variable=\ 
16 #        \^   转义一个空格 
17 echo "$variable"        # 显示空格
18 
19 variable=\\
20 echo "$variable"        # \
21 
22 variable=\\\
23 echo "$variable"
24 # 不能正常工作,给出一个错误
25 # test.sh: \: command not found
26 #
27 #  第一个转义符把第2个\转义了,但是第3个又变成"裸体的"了,
28 #+ 与上边的例子的原因相同
29 
30 variable=\\\\
31 echo "$variable"        # \\
32                         # 转了两个\
33                         # 没问题
################################End Script######################################### 
转义一个空格,在命令行参数列表中将会阻止单词分隔问题.
################################Start Script#######################################
 1 file_list="/bin/cat /bin/gzip /bin/more /usr/bin/less /usr/bin/emacs-20.7"
 2 # 列出的文件都作为命令的参数.
 3 
 4 # Add two files to the list, and list all.
 4 # 加2个文件到list中,并且列出全部.
 5 ls -l /usr/X11R6/bin/xsetroot /sbin/dump $file_list
 6 
 7 echo "-------------------------------------------------------------------------"
 8 
 9 # 如果我们转义2个空格,会发生什么?
10 ls -l /usr/X11R6/bin/xsetroot\ /sbin/dump\ $file_list
11 # 错误: 因为前3个路径名被合并成一个参数传给了'ls -l'
12 #        因为2个转义符阻止了参数(单词)分离
################################End Script######################################### 
转义符也提供续行功能.一般,每一行都包含一个不同的命令,但如果在行尾加上\,那就会接受
新行的输入,作为这一行的补充.
1 (cd /source/directory && tar cf - . ) | \
2 (cd /dest/directory && tar xpvf -)
3 # 重复了 Alan Cox的目录树拷贝命令
4 # 为了增加可读性分成2行.
5 
6 # 也可以使用如下方式:
7 tar cf - -C /source/directory . |
8 tar xpvf - -C /dest/directory
9 # 察看下边的注意事项 
注意:如果一个脚本以|(管道字符)结束.那么一个\(转义符),就不用非加上不可了.
 但是一个好的shell脚本编写风格,还是应该在行尾加上\,以增加可读性.
################################Start Script#######################################
 1 echo "foo
 2 bar" 
 3 #foo
 4 #bar
 5 
 6 echo
 7 
 8 echo 'foo
 9 bar'    # 没区别
10 #foo
11 #bar
12 
13 echo
14 
15 echo foo\
16 bar     # 续行
17 #foobar
18 
19 echo
20 
21 echo "foo\
22 bar"     # 与上边一样,\还是作为续行符
23 #foobar
24 
25 echo
26 
27 echo 'foo\
28 bar'     # 由于是强引用,所以\没被解释成续行符
29 #foo\
30 #bar
################################End Script######################################### 
  
第6章 退出和退出状态
====================
exit命令被用来结束脚本,就像C语言一样.他也会返回一个值来传给父进程,父进程会判断是否
可用. 
每个命令都会返回一个exit状态(有时候也叫return状态).成功返回0,如果返回一个非0值,通
常情况下都会被认为是一个错误码.一个编写良好的UNIX命令,程序,和工具都会返回一个0作为
退出码来表示成功,虽然偶尔也会有例外. 
同样的,脚本中的函数和脚本本身都会返回退出状态.在脚本或者是脚本函数中执行的最后的命
令会决定退出状态.在脚本中,exit nnn命令将会把nnn退出码传递给shell(nnn必须是10进制数
0-255). 
当一个脚本以不带参数exit来结束时,脚本的退出状态就由脚本中最后执行命令来决定.
 1 #!/bin/bash
 2 
 3 COMMAND_1
 4 
 5 . . .
 6 
 7 # 将以最后的命令来决定退出状态
 8 COMMAND_LAST
 9 
10 exit $? 
1 #!/bin/bash
2 
3 COMMAND1
4 
5 . . . 
6 
7 # 将以最后的命令来决定退出状态
8 COMMAND_LAST 
$?读取最后执行命令的退出码.函数返回后,$?给出函数最后执行的那条命令的退出码.这种给
函数返回值的方法是Bash的方法.对于脚本来说也一样.总之,一般情况下,0为成功,非0失败W.
Example 6-1 exit/exit状态
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 echo hello
 4 echo $?    # 返回0,因为执行成功
 5 
 6 lskdf      # 不认识的命令.
 7 echo $?    # 返回非0值,因为失败了.
 8 
 9 echo
10 
11 exit 113   # 将返回113给shell.
12            # To verify this, type "echo $?" after script terminates.
12            # 为了验证这个,在脚本结束的地方使用"echo $?"
################################End Script######################################### 
$?对于测试脚本中的命令的结果特别有用(见Example 12-32和Example 12-17).
注意: !逻辑非操作,将会反转test命令的结果,并且这会影响exit状态.
Example 6-2 否定一个条件使用!
################################Start Script#######################################
 1 true  # true是shell内建命令,什么事都不做,就是shell返回0
 2 echo "exit status of \"true\" = $?"     # 0
 3 
 4 ! true
 5 echo "exit status of \"! true\" = $?"   # 1
 6 # 注意:"!"需要一个空格
 7 #    !true   将导致一个"command not found"错误
 8 #
 9 # 如果一个命令以'!'开头,那么将使用Bash的历史机制.就是显示这个命令被使用的历史.
10 
11 true
12 !true
13 # 这次就没有错误了.
14 # 他不过是重复了之前的命令(true).
################################End Script######################################### 
注意事项:
 特定的退出码都有预定的含义(见附录D),用户不应该在自己的脚本中指定他. 
  
第7章 Tests
===========
每个完整的合理的编程语言都具有条件判断的功能.Bash具有test命令,不同的[]和()操作,和
if/then结构. 
7.1 Test结构
------------
一个if/then结构可以测试命令的返回值是否为0(因为0表示成功),如果是的话,执行更多命令. 
有一个专用命令"["(左中括号,特殊字符).这个命令与test命令等价,但是出于效率上的考虑,
它是一个内建命令.这个命令把它的参数作为比较表达式或是文件测试,并且根据比较的结果,
返回一个退出码. 
在版本2.02的Bash中,推出了一个新的[[...]]扩展test命令.因为这种表现形式可能对某些语
言的程序员来说更加熟悉.注意"[["是一个关键字,并不是一个命令. 
Bash把[[ $a -lt $b ]]看作一个单独的元素,并且返回一个退出码. 
((...))和let...结果也能够返回一个退出码,当它们所测试的算术表达式的结果为非0的时候,
他们的退出码将返回0.这些算术扩展(见第15章)结构被用来做算术比较.
1 let "1<2" returns 0 (as "1<2" expands to "1")
2 (( 0 && 1 )) returns 1 (as "0 && 1" expands to "0") 
if命令可以测试任何命令,不仅仅是括号中的条件.
 1 if cmp a b &> /dev/null  # 阻止输出.
 2 then echo "Files a and b are identical."
 3 else echo "Files a and b differ."
 4 fi
 5 
 6 # 非常有用的"if-grep" 结构:
 7 # ------------------------
 8 if grep -q Bash file
 9 then echo "File contains at least one occurrence of Bash."
10 fi
11 
12 word=Linux
13 letter_sequence=inu
14 if echo "$word" | grep -q "$letter_sequence"
15 # "-q"选项是用来阻止输出
16 then
17   echo "$letter_sequence found in $word"
18 else
19   echo "$letter_sequence not found in $word"
20 fi
21 
22 
23 if COMMAND_WHOSE_EXIT_STATUS_IS_0_UNLESS_ERROR_OCCURRED
24 then echo "Command succeeded."
25 else echo "Command failed."
26 fi 
一个if/then结构可以包含多级比较和tests. 
 1 if echo "Next *if* is part of the comparison for the first *if*."
 2 
 3   if [[ $comparison = "integer" ]]
 4     then (( a < b ))
 5   else
 6     [[ $a < $b ]]
 7   fi
 8 
 9 then
10   echo '$a is less than $b'
11 fi 
Example 7-1 什么情况下为真?
################################Start Script#######################################
  1 #!/bin/bash
  2 
  3 #  技巧:
  4 #  如果你不确定一个特定的条件如何判断.
  5 #+ 在一个if-test结构中测试它.
  6 
  7 echo
  8 
  9 echo "Testing \"0\""
 10 if [ 0 ]      # zero
 11 then
 12   echo "0 is true."
 13 else
 14   echo "0 is false."
 15 fi            # 0 is true.
 16 
 17 echo
 18 
 19 echo "Testing \"1\""
 20 if [ 1 ]      # one
 21 then
 22   echo "1 is true."
 23 else
 24   echo "1 is false."
 25 fi            # 1 is true.
 26 
 27 echo
 28 
 29 echo "Testing \"-1\""
 30 if [ -1 ]     # -1
 31 then
 32   echo "-1 is true."
 33 else
 34   echo "-1 is false."
 35 fi            # -1 is true.
 36 
 37 echo
 38 
 39 echo "Testing \"NULL\""
 40 if [ ]        # NULL (控状态)
 41 then
 42   echo "NULL is true."
 43 else
 44   echo "NULL is false."
 45 fi            # NULL is false.
 46 
 47 echo
 48 
 49 echo "Testing \"xyz\""
 50 if [ xyz ]    # 字符串
 51 then
 52   echo "Random string is true."
 53 else
 54   echo "Random string is false."
 55 fi            # Random string is true.
 56 
 57 echo
 58 
 59 echo "Testing \"\$xyz\""
 60 if [ $xyz ]   # 测试$xyz是否为null,但是...(明显没人定义么!)
 61               # 只不过是一个未定义的变量
 62 then
 63   echo "Uninitialized variable is true."
 64 else
 65   echo "Uninitialized variable is false."
 66 fi            # Uninitialized variable is false.
 67 
 68 echo
 69 
 70 echo "Testing \"-n \$xyz\""
 71 if [ -n "$xyz" ]            # 更学究的的检查
 72 then
 73   echo "Uninitialized variable is true."
 74 else
 75   echo "Uninitialized variable is false."
 76 fi            # Uninitialized variable is false.
 77 
 78 echo
 79 
 80 
 81 xyz=          # 初始化了,但是将其设为空值
 82 
 83 echo "Testing \"-n \$xyz\""
 84 if [ -n "$xyz" ]
 85 then
 86   echo "Null variable is true."
 87 else
 88   echo "Null variable is false."
 89 fi            # Null variable is false.
 90 
 91 
 92 echo
 93 
 94 
 95 # 什么时候"flase"为true?
 96 
 97 echo "Testing \"false\""
 98 if [ "false" ]              #  看起来"false"只不过是个字符串而已.
 99 then
100   echo "\"false\" is true." #+ 并且它test的结果就是true.
101 else
102   echo "\"false\" is false."
103 fi            # "false" is true.
104 
105 echo
106 
107 echo "Testing \"\$false\""  # 再来一个,未声明的变量
108 if [ "$false" ]
109 then
110   echo "\"\$false\" is true."
111 else
112   echo "\"\$false\" is false."
113 fi            # "$false" is false.
114               # 现在我们终于得到了期望的结果
115 
116 #  如果我们test这个变量"$true"会发生什么结果?答案是和"$flase"一样,都为空,因为我
117 #+ 们并没有定义它.
118 echo
119 
120 exit 0
################################End Script#########################################
练习.解释上边例子的行为(我想我解释的已经够清楚了) 
 1 if [ condition-true ]
 2 then
 3    command 1
 4    command 2
 5    ...
 6 else
 7    # 可选的(如果不需要可以省去)
 8    # 如果原始的条件测试结果是false,那么添加默认的代码来执行.
 9    command 3
10    command 4
11    ...
12 fi 
注意:当if和then在一个条件测试的同一行中的话,必须使用";"来终止if表达式.if和then都是
 关键字.关键字(或者命令)作为一个表达式的开头,并且在一个新的表达式开始之前,必须
 结束上一个表达式.
 1 if [ -x "$filename" ]; then 
Else if和elif 
elif
 elif是else if的缩减形式.
   1 if [ condition1 ]
   2 then
   3    command1
   4    command2
   5    command3
   6 elif [ condition2 ]
   7 # Same as else if
   8 then
   9    command4
  10    command5
  11 else
  12    default-command
  13 fi 
使用if test condition-true这种形式和if[condition-true]这种形式是等价的.向我们前边
所说的"["是test的标记.并且以"]"结束.在if/test中并不应该这么严厉,但是新版本的Bash
需要它. 
注意:test命令是Bash的内建命令,用来测试文件类型和比较字符串.因此,在Bash脚本中,test
并不调用/usr/bin/test的二进制版本(这是sh-utils工具包的一部分).同样的,[并不调用
/usr/bin/[,被连接到/usr/bin/test.
  bash$ type test
  test is a shell builtin
  bash$ type '['
  [ is a shell builtin
  bash$ type '[['
  [[ is a shell keyword
  bash$ type ']]'
  ]] is a shell keyword
  bash$ type ']'
  bash: type: ]: not found 
Example 7-2 几个等效命令test,/usr/bin/test,[],和/usr/bin/[
################################Start Script#######################################
  1 #!/bin/bash
  2 
  3 echo
  4 
  5 if test -z "$1"
  6 then
  7   echo "No command-line arguments."
  8 else
  9   echo "First command-line argument is $1."
 10 fi
 11 
 12 echo
 13 
 14 if /usr/bin/test -z "$1"      # 与内建的test结果相同
 15 then
 16   echo "No command-line arguments."
 17 else
 18   echo "First command-line argument is $1."
 19 fi
 20 
 21 echo
 22 
 23 if [ -z "$1" ]                # 与上边代码的作用相同
 24 #   if [ -z "$1"                应该工作,但是...
 25 #+  Bash相应一个缺少关闭中括号的错误消息.
 26 then
 27   echo "No command-line arguments."
 28 else
 29   echo "First command-line argument is $1."
 30 fi
 31 
 32 echo
 33 
 34 
 35 if /usr/bin/[ -z "$1" ]       # 再来一个,与上边代码的作用相同
 36 # if /usr/bin/[ -z "$1"       # 工作,但是给个错误消息
 37 #                             # 注意:
 38 #                               This has been fixed in Bash, version 3.x.
 38 #                               在ver 3.x上,这个bug已经被Bash修正了.
 39 then
 40   echo "No command-line arguments."
 41 else
 42   echo "First command-line argument is $1."
 43 fi
 44 
 45 echo
 46 
 47 exit 0
###############################End Script######################################### 
[[]]结构比Bash的[]更加灵活,这是一个扩展的test命令,从ksh88继承过来的.
注意:在[[]]结构中,将没有文件扩展或者是单词分离,但是会发生参数扩展和命令替换.
 1 file=/etc/passwd
 2 
 3 if [[ -e $file ]]
 4 then
 5   echo "Password file exists."
 6 fi
注意:使用[[]],而不是[],能够阻止脚本中的许多逻辑错误.比如,尽管在[]中将给出一个错误,
 但是&&,||,<>操作还是能够工作在一个[[]]test之中.
注意:在if后边,test命令和[]或[[]]都不是必须的.如下:
 1 dir=/home/bozo
 2 
 3 if cd "$dir" 2>/dev/null; then   # "2>/dev/null" hides error message.
 4   echo "Now in $dir."
 5 else
 6   echo "Can't change to $dir."
 7 fi
if命令将返回if后边的命令的退出码. 
与此相似,当在一个在使用与或列表结构的时候,test或中括号的使用,也并不一定非的有if不可
 1 var1=20
 2 var2=22
 3 [ "$var1" -ne "$var2" ] && echo "$var1 is not equal to $var2"
 4 
 5 home=/home/bozo
 6 [ -d "$home" ] || echo "$home directory does not exist." 
(())结构扩展并计算一个算术表达式的结果.如果表达式的结果为0,它将返回1作为退出码,或
者是"false".而一个非0表达式的结果将返回0作为退出码,或者是"true". 
Example 7-3 算数测试使用(( ))
################################Start Script#######################################
 1 #!/bin/bash
 2 # 算数测试
 3 
 4 # The (( ... )) construct evaluates and tests numerical expressions.
 4 # (( ... ))结构计算并测试算数表达式的结果.
 5 # 退出码将与[ ... ]结构相反!
 6 
 7 (( 0 ))
 8 echo "Exit status of \"(( 0 ))\" is $?."         # 1
 9 
10 (( 1 ))
11 echo "Exit status of \"(( 1 ))\" is $?."         # 0
12 
13 (( 5 > 4 ))                                      # true
14 echo "Exit status of \"(( 5 > 4 ))\" is $?."     # 0
15 
16 (( 5 > 9 ))                                      # false
17 echo "Exit status of \"(( 5 > 9 ))\" is $?."     # 1
18 
19 (( 5 - 5 ))                                      # 0
20 echo "Exit status of \"(( 5 - 5 ))\" is $?."     # 1
21 
22 (( 5 / 4 ))                                      # 除法也行
23 echo "Exit status of \"(( 5 / 4 ))\" is $?."     # 0
24 
25 (( 1 / 2 ))                                      # 出发结果<1
26 echo "Exit status of \"(( 1 / 2 ))\" is $?."     # 结果将为0
27                                                  # 1
28 
29 (( 1 / 0 )) 2>/dev/null                          # 除数为0的错误
30 #           ^^^^^^^^^^^
31 echo "Exit status of \"(( 1 / 0 ))\" is $?."     # 1
32 
33 # What effect does the "2>/dev/null" have?
33 # "2>/dev/null"的作用是什么?
34 # 如果删除"2>dev/null"将会发生什么?
35 # Try removing it, then rerunning the script.
35 # 尝试删除它,然后再运行脚本.
36 
37 exit 0
################################End Script######################################### 
7.2 文件测试操作
----------------
返回true如果... 
-e  文件存在
-a  文件存在
  这个选项的效果与-e相同.但是它已经被弃用了,并且不鼓励使用
-f  file是一个regular文件(不是目录或者设备文件)
-s  文件长度不为0
-d  文件是个目录
-b  文件是个块设备(软盘,cdrom等等)
-c  文件是个字符设备(键盘,modem,声卡等等)
-p  文件是个管道
-h  文件是个符号链接
-L  文件是个符号链接
-S  文件是个socket
-t  关联到一个终端设备的文件描述符
  这个选项一般都用来检测是否在一个给定脚本中的stdin[-t0]或[-t1]是一个终端
-r  文件具有读权限(对于用户运行这个test)
-w  文件具有写权限(对于用户运行这个test)
-x  文件具有执行权限(对于用户运行这个test)
-g  set-group-id(sgid)标志到文件或目录上
  如果一个目录具有sgid标志,那么一个被创建在这个目录里的文件,这个目录属于创建
  这个目录的用户组,并不一定与创建这个文件的用户的组相同.对于workgroup的目录
  共享来说,这非常有用.见<<UNIX环境高级编程中文版>>第58页.
-u  set-user-id(suid)标志到文件上
  如果运行一个具有root权限的文件,那么运行进程将取得root权限,即使你是一个普通
  用户.[1]这对于需要存取系统硬件的执行操作(比如pppd和cdrecord)非常有用.如果
  没有suid标志的话,那么普通用户(没有root权限)将无法运行这种程序.
  见<<UNIX环境高级编程中文版>>第58页.
        -rwsr-xr-t    1 root       178236 Oct  2  2000 /usr/sbin/pppd
  对于设置了suid的文件,在它的权限标志中有"s".
-k  设置粘贴位,见<<UNIX环境高级编程中文版>>第65页.
  对于"sticky bit",save-text-mode标志是一个文件权限的特殊类型.如果设置了这
  个标志,那么这个文件将被保存在交换区,为了达到快速存取的目的.如果设置在目录
  中,它将限制写权限.对于设置了sticky bit位的文件或目录,权限标志中有"t".
        drwxrwxrwt    7 root         1024 May 19 21:26 tmp/
  如果一个用户并不时具有stick bit位的目录的拥有者,但是具有写权限,那么用户只
  能在这个目录下删除自己所拥有的文件.这将防止用户在一个公开的目录中不慎覆盖
  或者删除别人的文件,比如/tmp(当然root或者是目录的所有者可以随便删除或重命名
  其中的文件).
-O  你是文件的所有者.
-G  文件的group-id和你的相同.
-N  从文件最后被阅读到现在,是否被修改. 
f1 -nt f2
  文件f1比f2新
f1 -ot f2
  f1比f2老
f1 -ef f2
  f1和f2都硬连接到同一个文件. 
!  非--反转上边测试的结果(如果条件缺席,将返回true) 
Example 7-4 test死的链接文件
################################Start Script#######################################
 1 #!/bin/bash
 2 # broken-link.sh
 3 # Written by Lee bigelow <ligelowbee@yahoo.com>
 4 # Used with permission.
 5 
 6 #一个真正有用的shell脚本来找出死链接文件并且输出它们的引用
 7 #以便于它们可以被输入到xargs命令中进行处理 :)
 8 #比如: broken-link.sh /somedir /someotherdir|xargs rm
 9 #
10 #这里,不管怎么说,是一种更好的方法
11 #
12 #find "somedir" -type l -print0|\
13 #xargs -r0 file|\
14 #grep "broken symbolic"|
15 #sed -e 's/^\|: *broken symbolic.*$/"/g'
16 #
17 #但这不是一个纯粹的bash,最起码现在不是.
18 #小心:小心/proc文件系统和任何的循环链接文件.
19 ##############################################################
20 
21 
22 #如果没对这个脚本传递参数,那么就使用当前目录.
23 #否则就使用传递进来的参数作为目录来搜索.
24 #
25 ####################
26 [ $# -eq 0 ] && directorys=`pwd` || directorys=$@
27 
28 #建立函数linkchk来检查传进来的目录或文件是否是链接和是否存在,
29 #并且打印出它们的引用
30 #如果传进来的目录有子目录,
31 #那么把子目录也发送到linkchk函数中处理,就是递归目录.
32 ##########
33 linkchk () {
34     for element in $1/*; do
35     [ -h "$element" -a ! -e "$element" ] && echo \"$element\"
36     [ -d "$element" ] && linkchk $element
37     # Of course, '-h' tests for symbolic link, '-d' for directory.
37     # 当然'-h'是测试链接,'-d'是测试目录.
38     done
39 }
40 
41 #如果是个可用目录,那就把每个从脚本传递进来的参数都送到linkche函数中.
42 #如果不是,那就打印出错误消息和使用信息.
43 #
44 ################
45 for directory in $directorys; do
46     if [ -d $directory ]
47  then linkchk $directory
48  else 
49      echo "$directory is not a directory"
50      echo "Usage: $0 dir1 dir2 ..."
51     fi
52 done
53 
54 exit 0
################################End Script#########################################
Example 28-1, Example 10-7, Example 10-3, Example 28-3, 和Example A-1 也会说明文件
测试操作的使用过程. 
注意事项:
[1]  小心suid,可能引起安全漏洞,但是不会影响shell脚本.
[2]  在当代UNIX系统中,已经不使用sticky bit了,只在目录中使用. 
7.3 其他比较操作
----------------
二元比较操作符,比较变量或者比较数字.注意数字与字符串的区别. 
整数比较 
-eq  等于,如:if [ "$a" -eq "$b" ]
-ne  不等于,如:if [ "$a" -ne "$b" ]
-gt  大于,如:if [ "$a" -gt "$b" ]
-ge  大于等于,如:if [ "$a" -ge "$b" ]
-lt  小于,如:if [ "$a" -lt "$b" ]
-le  小于等于,如:if [ "$a" -le "$b" ]
<  小于(需要双括号),如:(("$a" < "$b"))
<=  小于等于(需要双括号),如:(("$a" <= "$b"))
>  大于(需要双括号),如:(("$a" > "$b"))
>=  大于等于(需要双括号),如:(("$a" >= "$b")) 
字符串比较
=  等于,如:if [ "$a" = "$b" ]
==  等于,如:if [ "$a" == "$b" ],与=等价
  注意:==的功能在[[]]和[]中的行为是不同的,如下:
  1 [[ $a == z* ]]    # 如果$a以"z"开头(模式匹配)那么将为true
  2 [[ $a == "z*" ]]  # 如果$a等于z*(字符匹配),那么结果为true
  3 
  4 [ $a == z* ]      # File globbing 和word splitting将会发生
  5 [ "$a" == "z*" ]  # 如果$a等于z*(字符匹配),那么结果为true
  一点解释,关于File globbing是一种关于文件的速记法,比如"*.c"就是,再如~也是.
  但是file globbing并不是严格的正则表达式,虽然绝大多数情况下结构比较像.
!=  不等于,如:if [ "$a" != "$b" ]
  这个操作符将在[[]]结构中使用模式匹配.
<  小于,在ASCII字母顺序下.如:
  if [[ "$a" < "$b" ]]
  if [ "$a" \< "$b" ]
  注意:在[]结构中"<"需要被转义.
>  大于,在ASCII字母顺序下.如:
  if [[ "$a" > "$b" ]]
  if [ "$a" \> "$b" ]
  注意:在[]结构中">"需要被转义.
  具体参考Example 26-11来查看这个操作符应用的例子.
-z  字符串为"null".就是长度为0.
-n  字符串不为"null"
  注意:
  使用-n在[]结构中测试必须要用""把变量引起来.使用一个未被""的字符串来使用! -z
  或者就是未用""引用的字符串本身,放到[]结构中(见Example 7-6)虽然一般情况下可
  以工作,但这是不安全的.习惯于使用""来测试字符串是一种好习惯.[1] 
Example 7-5 数字和字符串比较
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 a=4
 4 b=5
 5 
 6 #  这里的变量a和b既可以当作整型也可以当作是字符串.
 7 #  这里在算术比较和字符串比较之间有些混淆,
 8 #+ 因为Bash变量并不是强类型的.
 9 
10 #  Bash允许对整型变量操作和比较
11 #+ 当然变量中只包含数字字符.
12 #  但是还是要考虑清楚再做.
13 
14 echo
15 
16 if [ "$a" -ne "$b" ]
17 then
18   echo "$a is not equal to $b"
19   echo "(arithmetic comparison)"
20 fi
21 
22 echo
23 
24 if [ "$a" != "$b" ]
25 then
26   echo "$a is not equal to $b."
27   echo "(string comparison)"
28   #     "4"  != "5"
29   # ASCII 52 != ASCII 53
30 fi
31 
32 # 在这个特定的例子中,"-ne"和"!="都可以.
33 
34 echo
35 
36 exit 0
################################End Script######################################### 
Example 7-6 测试字符串是否为null
################################Start Script#######################################
 1 #!/bin/bash
 2 #  str-test.sh: 测试null字符串和非引用字符串,
 3 #+ but not strings and sealing wax, not to mention cabbages and kings . . .
 4 #+ 上边这句没看懂 
 5 # Using   if [ ... ]
 6 
 7 
 8 # 如果一个字符串没被初始化,那么它就没有定义的值(像这种话,总感觉像屁话)
 9 # 这种状态叫做"null"(与zero不同)
10 
11 if [ -n $string1 ]    # $string1 没被声明和初始化
12 then
13   echo "String \"string1\" is not null."
14 else  
15   echo "String \"string1\" is null."
16 fi  
17 # 错误的结果.
18 # 显示$string1为非空,虽然他没被初始化.
19 
20 
21 echo
22 
23 
24 # 让我们再试一下.
25 
26 if [ -n "$string1" ]  # 这次$string1被引用了.
27 then
28   echo "String \"string1\" is not null."
29 else  
30   echo "String \"string1\" is null."
31 fi                    # ""的字符串在[]结构中
32 
33 
34 echo
35 
36 
37 if [ $string1 ]       # 这次$string1变成"裸体"的了
38 then
39   echo "String \"string1\" is not null."
40 else  
41   echo "String \"string1\" is null."
42 fi  
43 # 这工作得很好.
44 # 这个[]test操作检测string是否为null.
45 # 然而,使用("$string1")是一种很好的习惯
46 #
47 # As Stephane Chazelas points out,
48 #    if [ $string1 ]    有1个参数 "]"
49 #    if [ "$string1" ]  有2个参数,空的"$string1"和"]"
50 
51 
52 
53 echo
54 
55 
56 
57 string1=initialized
58 
59 if [ $string1 ]       # 再来,$string1"裸体了"
60 then
61   echo "String \"string1\" is not null."
62 else  
63   echo "String \"string1\" is null."
64 fi  
65 # 再来,给出了正确的结果.
66 # 不过怎么说("$string1")还是好很多,因为. . .
67 
68 
69 string1="a = b"
70 
71 if [ $string1 ]       # 再来,$string1 再次裸体了.
72 then
73   echo "String \"string1\" is not null."
74 else  
75   echo "String \"string1\" is null."
76 fi  
77 # 非引用的"$string1"现在给出了一个错误的结果!
78 
79 exit 0
80 # Thank you, also, Florian Wisser, for the "heads-up".
################################End Script######################################### 
Example 7-7 zmore
################################Start Script#######################################
 1 #!/bin/bash
 2 # zmore
 3 
 4 #使用'more'来查看gzip文件
 5 
 6 NOARGS=65
 7 NOTFOUND=66
 8 NOTGZIP=67
 9 
10 if [ $# -eq 0 ] # 与 if [ -z "$1" ]同样的效果
11 # 应该是说前边的那句注释有问题,$1是可以存在的,比如:zmore "" arg2 arg3
12 then
13   echo "Usage: `basename $0` filename" >&2
14   # 错误消息到stderr
15   exit $NOARGS
16   # 脚本返回65作为退出码.
17 fi  
18 
19 filename=$1
20 
21 if [ ! -f "$filename" ]   # 将$filename ""起来,来允许可能的空白
22 then
23   echo "File $filename not found!" >&2
24    # 错误消息到stderr
25   exit $NOTFOUND
26 fi  
27 
28 if [ ${filename##*.} != "gz" ]
29 # 在变量替换中使用中括号
30 then
31   echo "File $1 is not a gzipped file!"
32   exit $NOTGZIP
33 fi  
34 
35 zcat $1 | more
36 
37 # 使用过滤命令'more'
38 # 如果你想的话也可使用'less'
39 
40 
41 exit $?   # 脚本将返回pipe的结果作为退出码
42 # 事实上,不用非的有"exit $?",但是不管怎么说,有了这句,能正规一些
43 # 将最后一句命令的执行状态作为退出码返回
################################End Script######################################### 
混合比较 
-a  逻辑与
  exp1 -a exp2 如果exp1和exp2都为true的话,这个表达式将返回true 
-o  逻辑或
  exp1 -o exp2 如果exp1和exp2中有一个为true的话,那么这个表达式就返回true 
这与Bash的比较操作符&&和||很相像.在[[]]中使用它.
  1 [[ condition1 && condition2 ]]
-o和-a一般都是和test命令或者是[]一起工作.
  1 if [ "$exp1" -a "$exp2" ] 
请参考Example 8-3,Example 26-16和Example A-28来查看混合比较操作的行为. 
注意事项:
[1]  S.C.(这家伙是个人名)指出,在使用混合比较的时候即使"$var"也可能会产生问题.
  如果$string为空的话,[ -n "$string" -o "$a" = "$b" ]可能在某些版本的Bash中
  会有问题.为了附加一个额外的字符到可能的空变量中的一种安全的办法是,
  [ "x$string" != x -o "x$a" = "x$b" ](the "x's" cancel out)(没看懂).
  cancel out是抵消的意思. 
7.4 嵌套的if/then条件test
-------------------------
可以使用if/then来进行嵌套的条件test.最终的结果和上边的使用&&混合比较操作是相同的.
 1 if [ condition1 ]
 2 then
 3   if [ condition2 ]
 4   then
 5     do-something  # 这里只有在condition1和condition2都可用的时候才行.
 6   fi  
 7 fi
具体请查看Example 34-4. 
7.5 检查你的test知识
--------------------
系统范围的xinitrc文件可以用来启动X server.这个文件中包含了相当多的if/then test,
就像下边的节选一样:
 1 if [ -f $HOME/.Xclients ]; then
 2   exec $HOME/.Xclients
 3 elif [ -f /etc/X11/xinit/Xclients ]; then
 4   exec /etc/X11/xinit/Xclients
 5 else
 6      # 故障保险设置,虽然我们永远都不会走到这来.
 7      # (我们在Xclients中也提供了相同的机制)它不会受伤的.
 8      xclock -geometry 100x100-5+5 &
 9      xterm -geometry 80x50-50+150 &
10      if [ -f /usr/bin/netscape -a -f /usr/share/doc/HTML/index.html ]; then
11              netscape /usr/share/doc/HTML/index.html &
12      fi
13 fi 
对上边的"test"结构进行解释,然后检查整个文件,/etc/X11/xinit/xinitrc,并分析if/then
test结构.你可能需要查看一下后边才能讲解到的grep,sed和正则表达式的知识. 
  
第8章 操作符和相关的主题
======================== 
8.1 操作符
---------- 
等号操作符 
变量赋值
 初始化或者修改变量的值
=
 无论在算术运算还是字符串运算中,都是赋值语句.
 1 var=27
 2 category=minerals  # No spaces allowed after the "=". 
 注意:不要和"="test操作符混淆.
  1 #    = as a test operator
  2 
  3 if [ "$string1" = "$string2" ]
  4 # if [ "X$string1" = "X$string2" ] is safer,
  5 # to prevent an error message should one of the variables be empty.
  6 # (The prepended "X" characters cancel out.) 
  7 then
  8    command
  9 fi 
算术操作符 
+  加法
-  减法
*  乘法
/  除法
**  幂运算
  1 # Bash, version 2.02, introduced the "**" exponentiation operator.
  2 
  3 let "z=5**3"
  4 echo "z = $z"   # z = 125
%  取模
  bash$ expr 5 % 3
  2 
  5/3=1余2
  模运算经常用在其它的事情中,比如产生特定的范围的数字(Example 9-24,
  Example 9-27)和格式化程序的输出(Example 26-15,Example A-6).它甚至可以用来
  产生质数,(Example A-16).事实上取模运算在算术运算中使用的频率惊人的高. 
Example 8-1 最大公约数
################################Start Script#######################################
 1 #!/bin/bash
 2 # gcd.sh: 最大公约数
 3 #         使用Euclid's 算法
 4 
 5 #  最大公约数,就是2个数能够同时整除的最大的数.
 6 #
 7 
 8 #  Euclid's算法采用连续除法.
 9 #  在每个循环中
10 #+ 被除数 <---  除数
11 #+ 除数 <---  余数
12 #+ 直到余数= 0.
13 #+ 在最后的循环中The gcd = 被除数
14 #
15 #  关于这个算法更精彩的讨论
16 #  见Jim Loy's site, http://www.jimloy.com/number/euclids.htm.
17 
18 
19 # ------------------------------------------------------
20 # 参数检查
21 ARGS=2
22 E_BADARGS=65
23 
24 if [ $# -ne "$ARGS" ]
25 then
26   echo "Usage: `basename $0` first-number second-number"
27   exit $E_BADARGS
28 fi
29 # ------------------------------------------------------
30 
31 
32 gcd ()
33 {
34 
35   dividend=$1                    #  随便给值
36   divisor=$2                     #+ 即使$2大,也没关系.
37                                  #  Why not?
38 
39   remainder=1                    #  如果再循环中使用为初始化的变量.
40                                  #+ 那将在第一次循环中产生一个错误消息.
41                                  
42 
43   until [ "$remainder" -eq 0 ]
44   do
45     let "remainder = $dividend % $divisor"
46     dividend=$divisor            # 现在使用2个最小的数重复.
47     divisor=$remainder
48   done                           # Euclid's algorithm
49 
50 }                                # Last $dividend is the gcd.
50 }                                # 最后的$dividend就是gcd.
51 
52 
53 gcd $1 $2
54 
55 echo; echo "GCD of $1 and $2 = $dividend"; echo
56 
57 
58 # 练习:
59 # --------
60 #  检查命令行参数来确定它们都是整数,
61 #+ and exit the script with an appropriate error message if not.
61 #+ 否则就选择合适的错误消息退出.
62 
63 exit 0
################################End Script######################################### 
+=  加等于(通过常量增加变量)
  let "var += 5"  #var将在本身值的基础上增加5
-=  减等于
*=  乘等于
  let "var *= 4"
/=  除等于
%=  取模赋值,算术操作经常使用expr或者let表达式. 
Example 8-2 使用算术操作符
################################Start Script#######################################
 1 #!/bin/bash
 2 # Counting to 11 in 10 different ways.
 3 
 4 n=1; echo -n "$n "
 5 
 6 let "n = $n + 1"   # let "n = n + 1"  这么写也行
 7 echo -n "$n "
 8 
 9 
10 : $((n = $n + 1))
11 #  ":" 是必须的,这是因为,如果没有":"的话,Bash将
12 #+ 尝试把"$((n = $n + 1))"解释成一个命令
13 echo -n "$n "
14 
15 (( n = n + 1 ))
16 #  对于上边的方法的一个更简单的选则.
17 #  Thanks, David Lombard, for pointing this out.
18 echo -n "$n "
19 
20 n=$(($n + 1))
21 echo -n "$n "
22 
23 : $[ n = $n + 1 ]
24 #  ":" 是必须的,这是因为,如果没有":"的话,Bash将
25 #+ 尝试把"$[ n = $n + 1 ]" 解释成一个命令
26 #  即使"n"被初始化成为一个字符串,这句也能工作.
27 echo -n "$n "
28 
29 n=$[ $n + 1 ]
30 #  即使"n"被初始化成为一个字符串,这句也能工作.
31 #* Avoid this type of construct, since it is obsolete and nonportable.
31 #* 尽量避免这种类型的结果,因为这已经被废弃了,并且不具可移植性.
32 #  Thanks, Stephane Chazelas.
33 echo -n "$n "
34 
35 # 现在来个C风格的增量操作.
36 # Thanks, Frank Wang, for pointing this out.
37 
38 let "n++"          # let "++n"  also works.
39 echo -n "$n "
40 
41 (( n++ ))          # (( ++n )  also works.
42 echo -n "$n "
43 
44 : $(( n++ ))       # : $(( ++n )) also works.
45 echo -n "$n "
46 
47 : $[ n++ ]         # : $[ ++n ]] also works
48 echo -n "$n "
49 
50 echo
51 
52 exit 0
################################End Script######################################### 
注意:在Bash中的整型变量事实上是32位的,范围是 -2147483648 到2147483647.如果超过这个
范围进行算术操作,将不会得到你期望的结果(就是溢出么).
 1 a=2147483646
 2 echo "a = $a"      # a = 2147483646
 3 let "a+=1"         # 加1 "a".
 4 echo "a = $a"      # a = 2147483647
 5 let "a+=1"         # 再加1 "a" ,将超过上限了. 
 6 echo "a = $a"      # a = -2147483648
 7                    #      错误 (溢出了)
 在Bash 2.05b版本中,Bash支持64位整型了. 
注意:Bash并不能理解浮点运算.它把包含的小数点看作字符串.
 1 a=1.5
 2 
 3 let "b = $a + 1.3"  # 错误.
 4 # t2.sh: let: b = 1.5 + 1.3: 表达式的语义错误(错误标志为".5 + 1.3")
 5 
 6 echo "b = $b"       # b=1
 如果真想做浮点运算的话,使用bc(见12.8节),bc可以进行浮点运算或调用数学库函数. 
位操作符.
 (晕,有点强大过分了吧,位级操作都支持.)
 位操作符在shell脚本中极少使用.它们最主要的用途看起来就是操作和test从sockets中
 读出的变量."Bit flipping"与编译语言的联系很紧密,比如c/c++,在这种语言中它可以
 运行得足够快.(原文有处on the fly,我查了一下,好像是没事干的意思,没理解) 
<<  左移1位(每次左移都将乘2) 
<<=  左移几位,=号后边将给出左移几位
  let "var <<= 2"就是左移2位(就是乘4) 
>>  右移1位(每次右移都将除2) 
>>=  右移几位 
&  按位与 
&=  按位与赋值 
|  按位或 
|=  按位或赋值 
~  按位非 
!  按位否?(没理解和上边的~有什么区别?),感觉是应该放到下边的逻辑操作中 
^  按位异或XOR 
^=  异或赋值 
逻辑操作: 
&&  逻辑与
  1 if [ $condition1 ] && [ $condition2 ]
  2 # 与:  if [ $condition1 -a $condition2 ] 相同
  3 # 如果condition1和condition2都为true,那结果就为true.
  4 
  5 if [[ $condition1 && $condition2 ]]    # 也可以.
  6 # 注意&&不允许出现在[ ... ]中.
  注意:&&也可以用在and list中(见25章),但是使用的时候需要依赖上下文. 
||  逻辑或
  1 if [ $condition1 ] || [ $condition2 ]
  2 # 与:  if [ $condition1 -o $condition2 ] 相同
  3 # 如果condition1或condition2为true,那结果就为true.
  4 
  5 if [[ $condition1 || $condition2 ]]    # 也可以
  6 # 注意||不允许出现在[ ... ]中.
  注意:Bash将test每个连接到逻辑操作的状态的退出状态(见第6章). 
Example 8-3 使用&&和||进行混合状态的test
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 a=24
 4 b=47
 5 
 6 if [ "$a" -eq 24 ] && [ "$b" -eq 47 ]
 7 then
 8   echo "Test #1 succeeds."
 9 else
10   echo "Test #1 fails."
11 fi
12 
13 # 错误:   if [ "$a" -eq 24 && "$b" -eq 47 ]
14 #+         尝试执行' [ "$a" -eq 24 '
15 #+         因为没找到']'所以失败了.
16 #
17 #  注意:  如果 [[ $a -eq 24 && $b -eq 24 ]]  能够工作.
18 #  那这个[[]]的test结构就比[]结构更灵活了.
19 #
20 #    (在17行的"&&"与第6行的"&&"意义不同)
21 #    Thanks, Stephane Chazelas, for pointing this out.
22 
23 
24 if [ "$a" -eq 98 ] || [ "$b" -eq 47 ]
25 then
26   echo "Test #2 succeeds."
27 else
28   echo "Test #2 fails."
29 fi
30 
31 
32 #  -a和-o选项提供了
33 #+ 一种可选的混合test方法.
34 #  Thanks to Patrick Callahan for pointing this out.
35 
36 
37 if [ "$a" -eq 24 -a "$b" -eq 47 ]
38 then
39   echo "Test #3 succeeds."
40 else
41   echo "Test #3 fails."
42 fi
43 
44 
45 if [ "$a" -eq 98 -o "$b" -eq 47 ]
46 then
47   echo "Test #4 succeeds."
48 else
49   echo "Test #4 fails."
50 fi
51 
52 
53 a=rhino
54 b=crocodile
55 if [ "$a" = rhino ] && [ "$b" = crocodile ]
56 then
57   echo "Test #5 succeeds."
58 else
59   echo "Test #5 fails."
60 fi
61 
62 exit 0
################################End Script#########################################
 &&和||操作也能在算术运算的上下文中找到.
  bash$ echo $(( 1 && 2 )) $((3 && 0)) $((4 || 0)) $((0 || 0))
  1 0 1 0 
混杂操作:
,  逗号操作符
  逗号操作符可以连接2个或多个算术运算.所有的操作都会被执行,但是只有最后一个
  操作作为结果.
  1 let "t1 = ((5 + 3, 7 - 1, 15 - 4))"
  2 echo "t1 = $t1"               # t1 = 11
  3 
  4 let "t2 = ((a = 9, 15 / 3))"  # Set "a" and calculate "t2".
  5 echo "t2 = $t2    a = $a"     # t2 = 5    a = 9
  ","主要用在for循环中,具体见Example 10-12. 
8.2 数字常量
------------
shell脚本默认都是将数字作为10进制数处理,除非这个数字某种特殊的标记法或前缀开头.
以0开头就是8进制.以0x开头就是16进制数.使用BASE#NUMBER这种形式可以表示其它进制
表示法 
Example 8-4 数字常量的处理
################################Start Script#######################################
 1 #!/bin/bash
 2 # numbers.sh: 数字常量的几种不同的表示法
 3 
 4 # 10进制: 默认
 5 let "dec = 32"
 6 echo "decimal number = $dec"             # 32
 7 # 一切都很正常
 8 
 9 
10 # 8进制: 以'0'(零)开头
11 let "oct = 032"
12 echo "octal number = $oct"               # 26
13 # 表达式的结果用10进制表示.
14 # 
15 
16 # 16进制表示:数字以'0x'或者'0X'开头
17 let "hex = 0x32"
18 echo "hexadecimal number = $hex"         # 50
19 # 表达式的结果用10进制表示.
20 
21 # 其它进制: BASE#NUMBER
22 # BASE between 2 and 64.
22 # 2到64进制都可以.
23 # NUMBER必须在BASE的范围内,具体见下边.
24 
25 
26 let "bin = 2#111100111001101"
27 echo "binary number = $bin"              # 31181
28 
29 let "b32 = 32#77"
30 echo "base-32 number = $b32"             # 231
31 
32 let "b64 = 64#@_"
33 echo "base-64 number = $b64"             # 4031
34 # 这种64进制的表示法中的每位数字都必须在64进制表示法的限制字符内.
35 # 10 个数字+ 26 个小写字母+ 26 个大写字母+ @ + _
36 
37 
38 echo
39 
40 echo $((36#zz)) $((2#10101010)) $((16#AF16)) $((53#1aA))
41                                          # 1295 170 44822 3375
42 
43 
44 #  重要的注意事项:
45 #  ---------------
46 #  如果使用的每位数字超出了这个进制表示法规定字符的范围的话,
47 #+ 将给出一个错误消息.
48 
49 let "bad_oct = 081"
50 # (部分的) 错误消息输出:
51 #  bad_oct = 081: too great for base (error token is "081")
52 #              Octal numbers use only digits in the range 0 - 7.
53 
54 exit 0       # Thanks, Rich Bartell and Stephane Chazelas, for clarification.
################################End Script######################################### 
[]     
    
高级Bash脚本编程指南(二)
文章整理: 文章来源: 网络 
高级Bash脚本编程指南(二) 
  
  
第三部分 超越基本
++++++++++++++++++++ 
第9章 变量重游
================
如果变量使用恰当,将会增加脚本的能量和灵活性.但是前提是这需要仔细学习变量的细节知识. 
9.1 内部变量
------------
Builtin variable
 这些内建的变量,将影响bash脚本的行为.  
 $BASH
  这个变量将指向Bash的二进制执行文件的位置.
  bash$ echo $BASH
  /bin/bash 
 $BASH_ENV
  这个环境变量将指向一个Bash启动文件,这个启动文件将在调用一个脚本时被读取. 
 $BASH_SUBSHELL
  这个变量将提醒subshell的层次,这是一个在version3才被添加到Bash中的新特性.
  见Example 20-1. 
 $BASH_VERSINFO[n]
  记录Bash安装信息的一个6元素的数组.与下边的$BASH_VERSION很像,但这个更加详细.
   1 # Bash version info:
   2 
   3 for n in 0 1 2 3 4 5
   4 do
   5   echo "BASH_VERSINFO[$n] = ${BASH_VERSINFO[$n]}"
   6 done  
   7 
   8 # BASH_VERSINFO[0] = 3                      # 主版本号
   9 # BASH_VERSINFO[1] = 00                     # 次版本号
  10 # BASH_VERSINFO[2] = 14                     # Patch 次数.
  11 # BASH_VERSINFO[3] = 1                      # Build version.
  12 # BASH_VERSINFO[4] = release                # Release status.
  13 # BASH_VERSINFO[5] = i386-redhat-linux-gnu  # Architecture 
 $BASH_VERSION
  安装在系统上的Bash的版本号.
  bash$ echo $BASH_VERSION
  3.00.14(1)-release
  tcsh% echo $BASH_VERSION
  BASH_VERSION: Undefined variable.
  使用这个变量对于判断系统上到底运行的是那个shll来说是一种非常好的办法.$SHELL
  有时将不能给出正确的答案. 
 $DIRSTACK
  在目录栈中最上边的值(将受到pushd和popd的影响).
  这个内建的变量与dirs命令是保持一致的,但是dirs命令将显示目录栈的整个内容. 
 $EDITOR
  脚本调用的默认编辑器,一般是vi或者是emacs. 
 $EUID
  "effective"用户ID号.
  当前用户被假定的任何id号.可能在su命令中使用.
  注意:$EUID并不一定与$UID相同. 
 $FUNCNAME
  当前函数的名字.
  1 xyz23 ()
  2 {
  3   echo "$FUNCNAME now executing."  # xyz23 现在正在被执行.
  4 }
  5 
  6 xyz23
  7 
  8 echo "FUNCNAME = $FUNCNAME"        # FUNCNAME =
  9                                    # 出了函数就变为Null值了. 
 $GLOBIGNORE
  一个文件名的模式匹配列表,如果在file globbing中匹配到的文件包含这个列表中的
  某个文件,那么这个文件将被从匹配到的文件中去掉. 
 $GROUPS
  当前用户属于的组.
  这是一个当前用户的组id列表(数组),就像在/etc/passwd中记录的一样.
  root# echo $GROUPS
  0 
  root# echo ${GROUPS[1]}
  1 
  root# echo ${GROUPS[5]}
  6 
 $HOME
  用户的home目录,一般都是/home/username(见Example 9-14) 
 $HOSTNAME
  hostname命令将在一个init脚本中,在启动的时候分配一个系统名字.
  gethostname()函数将用来设置这个$HOSTNAME内部变量.(见Example 9-14) 
 $HOSTTYPE
  主机类型
  就像$MACHTYPE,识别系统的硬件.
  bash$ echo $HOSTTYPE
  i686 
 $IFS
  内部域分隔符.
  这个变量用来决定Bash在解释字符串时如何识别域,或者单词边界.
  $IFS默认为空白(空格,tab,和新行),但可以修改,比如在分析逗号分隔的数据文件时.
  注意:$*使用$IFS中的第一个字符,具体见Example 5-1.
  bash$ echo $IFS | cat -vte
  $ 
  bash$ bash -c 'set w x y z; IFS=":-;"; echo "$*"'
  w:x:y:o
  
  注意:$IFS并不像它处理其它字符一样处理空白. 
Example 9-1 $IFS和空白
################################Start Script#######################################
 1 #!/bin/bash
 2 # $IFS 处理空白的方法,与处理其它字符不同.
 3 
 4 output_args_one_per_line()
 5 {
 6   for arg
 7   do echo "[$arg]"
 8   done
 9 }
10 
11 echo; echo "IFS=\" \""
12 echo "-------"
13 
14 IFS=" "
15 var=" a  b c   "
16 output_args_one_per_line $var  # output_args_one_per_line `echo " a  b c   "`
17 #
18 # [a]
19 # [b]
20 # [c]
21 
22 
23 echo; echo "IFS=:"
24 echo "-----"
25 
26 IFS=:
27 var=":a::b:c:::"               # 与上边的一样,但是用" "替换了":"
28 output_args_one_per_line $var
29 #
30 # []
31 # [a]
32 # []
33 # [b]
34 # [c]
35 # []
36 # []
37 # []
38 
39 # 同样的事情也会发生在awk中的"FS"域分隔符.
40 
41 # Thank you, Stephane Chazelas.
42 
43 echo
44 
45 exit 0
################################End Script#########################################
  Example 12-37也是使用$IFS的另一个启发性的例子. 
 $IGNOREEOF
  忽略EOF: 告诉shell在log out之前要忽略多少文件结束符(control-D). 
 $LC_COLLATE
  常在.bashrc或/etc/profile中设置,这个变量用来在文件名扩展和模式匹配校对顺序.
  如果$LC_COLLATE被错误的设置,那么将会在filename globbing中引起错误的结果.
  
  注意:在2.05以后的Bash版本中,filename globbing将不在对[]中的字符区分大小写.
   比如:ls [A-M]* 将即匹配File1.txt也会匹配file1.txt.为了恢复[]的习惯用法,
   设置$LC_COLLATE的值为c,使用export LC_COLLATE=c 在/etc/profile或者是
   ~/.bashrc中. 
 $LC_CTYPE
  这个内部变量用来控制globbing和模式匹配的字符串解释. 
 $LINENO
  这个变量记录它所在的shell脚本中它所在行的行号.这个变量一般用于调试目的.
  1 # *** BEGIN DEBUG BLOCK ***
  2 last_cmd_arg=$_  # Save it.
  3 
  4 echo "At line number $LINENO, variable \"v1\" = $v1"
  5 echo "Last command argument processed = $last_cmd_arg"
  6 # *** END DEBUG BLOCK *** 
 $MACHTYPE
  系统类型
  提示系统硬件
  bash$ echo $MACHTYPE
  i686 
 $OLDPWD
  老的工作目录("OLD-print-working-directory",你所在的之前的目录) 
 $OSTYPE
  操作系统类型.
  bash$ echo $OSTYPE
  linux 
 $PATH
  指向Bash外部命令所在的位置,一般为/usr/bin,/usr/X11R6/bin,/usr/local/bin等.
  当给出一个命令时,Bash将自动对$PATH中的目录做一张hash表.$PATH中以":"分隔的
  目录列表将被存储在环境变量中.一般的,系统存储的$PATH定义在/ect/processed或
  ~/.bashrc中(见Appendix G). 
  bash$ echo $PATH
  /bin:/usr/bin:/usr/local/bin:/usr/X11R6/bin:/sbin:/usr/sbin 
  PATH=${PATH}:/opt/bin将把/opt/bin目录附加到$PATH变量中.在脚本中,这是一个
  添加目录到$PATH中的便捷方法.这样在这个脚本退出的时候,$PATH将会恢复(因为这个
  shell是个子进程,像这样的一个脚本是不会将它的父进程的环境变量修改的) 
  注意:当前的工作目录"./"一般都在$PATH中被省去. 
 $PIPESTATUS
  数组变量将保存最后一个运行的前台管道的退出码.有趣的是,这个退出码和最后一个命令
  运行的退出码并不一定相同.
  bash$ echo $PIPESTATUS
  0 
  bash$ ls -al | bogus_command
  bash: bogus_command: command not found
  bash$ echo $PIPESTATUS
  141 
  bash$ ls -al | bogus_command
  bash: bogus_command: command not found
  bash$ echo $?
  127 
  $PIPESTATUS数组的每个成员都会保存一个管道命令的退出码,$PIPESTATUS[0]保存第
  一个管道命令的退出码,$PIPESTATUS[1]保存第2个,以此类推. 
  注意:$PIPESTATUS变量在一个login shell中可能会包含一个错误的0值(3.0以下版本)
  tcsh% bash 
  bash$ who | grep nobody | sort
  bash$ echo ${PIPESTATUS[*]}
  0
  包含在脚本中的上边这行将会产生一个期望的输出0 1 0. 
  注意:在某些上下文$PIPESTATUS可能不会给出正确的结果.
  bash$ echo $BASH_VERSION
  3.00.14(1)-release 
  bash$ $ ls | bogus_command | wc
  bash: bogus_command: command not found
  0       0       0 
  bash$ echo ${PIPESTATUS[@]}
  141 127 0
  
  Chet Ramey把上边输出不成确原因归咎于ls的行为.因为如果把ls的结果放到管道上,
  并且这个输出没被读取,那么SIGPIPE将会kill掉它,并且退出码变为141,而不是我们期
  望的0.这种情况也会发生在tr命令中. 
  注意:$PIPESTATUS是一个"volatile"变量.在任何命令插入之前,并且在pipe询问之后,
  这个变量需要立即被捕捉.
  bash$ $ ls | bogus_command | wc
  bash: bogus_command: command not found
  0       0       0 
  bash$ echo ${PIPESTATUS[@]}
  0 127 0 
  bash$ echo ${PIPESTATUS[@]}
  0 
 $PPID
  一个进程的$PPID就是它的父进程的进程id(pid).[1]
  使用pidof命令对比一下. 
 $PROMPT_COMMAND
  这个变量保存一个在主提示符($PS1)显示之前需要执行的命令. 
 $PS1
  主提示符,具体见命令行上的显示. 
 $PS2
  第2提示符,当你需要额外的输入的时候将会显示,默认为">". 
 $PS3
  第3提示符,在一个select循环中显示(见Example 10-29). 
 $PS4
  第4提示符,当使用-x选项调用脚本时,这个提示符将出现在每行的输出前边.
  默认为"+". 
 $PWD
  工作目录(你当前所在的目录).
  与pwd内建命令作用相同.
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 E_WRONG_DIRECTORY=73
 4 
 5 clear # 清屏.
 6 
 7 TargetDirectory=/home/bozo/projects/GreatAmericanNovel
 8 
 9 cd $TargetDirectory
10 echo "Deleting stale files in $TargetDirectory."
11 
12 if [ "$PWD" != "$TargetDirectory" ]
13 then    # 防止偶然删除错误的目录
14   echo "Wrong directory!"
15   echo "In $PWD, rather than $TargetDirectory!"
16   echo "Bailing out!"
17   exit $E_WRONG_DIRECTORY
18 fi  
19 
20 rm -rf *
21 rm .[A-Za-z0-9]*    # Delete dotfiles.
21 rm .[A-Za-z0-9]*    # 删除"."文件(隐含文件).
22 # rm -f .[^.]* ..?*   为了删除以多个"."开头的文件.
23 # (shopt -s dotglob; rm -f *)   也行.
24 # Thanks, S.C. for pointing this out.
25 
26 # 文件名能够包含0-255范围的所有字符,除了"/".
27 # 删除以各种诡异字符开头的文件将作为一个练习留给大家.
28 
29 # 这里预留给其他的必要操作.
30 
31 echo
32 echo "Done."
33 echo "Old files deleted in $TargetDirectory."
34 echo
35 
36 
37 exit 0
################################End Script######################################### 
 $REPLY
  read命令如果没有给变量,那么输入将保存在$REPLY中.在select菜单中也可用,但是只
  提供选择的变量的项数,而不是变量本身的值.
################################Start Script#######################################
 1 #!/bin/bash
 2 # reply.sh
 3 
 4 # REPLY是'read'命令结果保存的默认变量.
 5 
 6 echo
 7 echo -n "What is your favorite vegetable? "
 8 read
 9 
10 echo "Your favorite vegetable is $REPLY."
11 #  当且仅当在没有变量提供给"read"命令时,
12 #+ REPLY才保存最后一个"read"命令读入的值.
13 
14 echo
15 echo -n "What is your favorite fruit? "
16 read fruit
17 echo "Your favorite fruit is $fruit."
18 echo "but..."
19 echo "Value of \$REPLY is still $REPLY."
20 #  $REPLY还是保存着上一个read命令的值, 
21 #+ 因为变量$fruit被传入到了这个新的"read"命令中.
22 
23 echo
24 
25 exit 0
################################End Script######################################### 
 $SECONDS
  这个脚本已经运行的时间(单位为秒).
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 TIME_LIMIT=10
 4 INTERVAL=1
 5 
 6 echo
 7 echo "Hit Control-C to exit before $TIME_LIMIT seconds."
 8 echo
 9 
10 while [ "$SECONDS" -le "$TIME_LIMIT" ]
11 do
12   if [ "$SECONDS" -eq 1 ]
13   then
14     units=second
15   else  
16     units=seconds
17   fi
18 
19   echo "This script has been running $SECONDS $units."
20   #  在一台比较慢的或者是负载很大的机器上,这个脚本可能会跳过几次循环
21   #+ 在一个while循环中.
22   sleep $INTERVAL
23 done
24 
25 echo -e "\a"  # Beep!
26 
27 exit 0
################################End Script######################################### 
 $SHELLOPTS
  这个变量里保存shell允许的选项,这个变量是只读的.
  bash$ echo $SHELLOPTS
  braceexpand:hashall:histexpand:monitor:history:interactive-comments:emacs 
 $SHLVL
  Shell层次,就是shell层叠的层次,如果是命令行那$SHLVL就是1,如果命令行执行的脚
  本中,$SHLVL就是2,以此类推. 
 $TMOUT
  如果$TMOUT环境变量被设置为一个非零的时间值,那么在过了这个指定的时间之后,
  shell提示符将会超时,这会引起一个logout. 
  在2.05b版本的Bash中,已经支持在一个带有read命令的脚本中使用$TMOUT变量.
   1 # 需要使用Bash v2.05b或者以后的版本上
   2 
   3 TMOUT=3    # Prompt times out at three seconds.
   3 TMOUT=3    # 设置超时的时间为3秒
   4 
   5 echo "What is your favorite song?"
   6 echo "Quickly now, you only have $TMOUT seconds to answer!"
   7 read song
   8 
   9 if [ -z "$song" ]
  10 then
  11   song="(no answer)"
  12   # 默认响应.
  13 fi
  14 
  15 echo "Your favorite song is $song." 
  这里有一个更复杂的方法来在一个脚本中实现超时功能.一种办法就是建立一个时间循
  环,在超时的时候通知脚本.不过,这也需要一个信号处理机制,在超时的时候来产生中
  断.
  (参见Example 29-5) 
Example 9-2 时间输入
################################Start Script#######################################
   1 #!/bin/bash
   2 # timed-input.sh
   3 
   4 # TMOUT=3    在新版本的Bash上也能工作.
   5 
   6 
   7 TIMELIMIT=3  # 在这个例子上是3秒,也可以设其他的值.
   8 
   9 PrintAnswer()
  10 {
  11   if [ "$answer" = TIMEOUT ]
  12   then
  13     echo $answer
  14   else       # 别想混合着两个例子.
  15     echo "Your favorite veggie is $answer"
  16     kill $!  # kill将不再需要TimerOn函数运行在后台.
  17              # $! 是运行在后台的最后一个工作的PID.
  18   fi
  19 
  20 }  
  21 
  22 
  23 
  24 TimerOn()
  25 {
  26   sleep $TIMELIMIT && kill -s 14 $$ &
  27   # 等待3秒,然后发送一个信号给脚本.
  28 }  
  29 
  30 Int14Vector()
  31 {
  32   answer="TIMEOUT"
  33   PrintAnswer
  34   exit 14
  35 }  
  36 
  37 trap Int14Vector 14   # 为了我们的目的,时间中断(14)被破坏了.
  38 
  39 echo "What is your favorite vegetable "
  40 TimerOn
  41 read answer
  42 PrintAnswer
  43 
  44 
  45 #  很明显的,这是一个拼凑的实现.
  46 #+ 然而使用"-t"选项来"read"的话,将会简化这个任务.
  47 #  见"t-out.sh",在下边.
  48 
  49 #  如果你需要一个真正的幽雅的写法...
  50 #+ 建议你使用c/c++来写这个应用,
  51 #+ 使用合适的库来完成这个任务,比如'alarm'和'setitimer'.
  52 
  53 exit 0
################################End Script#########################################
  使用stty也是一种选择. 
Example 9-3 再来一个时间输入
################################Start Script#######################################
 1 #!/bin/bash
 2 # timeout.sh
 3 
 4 #  Stephane Chazelas编写,
 5 #+ 本书作者进行了一些修改.
 6 
 7 INTERVAL=5                # timeout间隔 
 8 
 9 timedout_read() {
10   timeout=$1
11   varname=$2
12   old_tty_settings=`stty -g`
13   stty -icanon min 0 time ${timeout}0
14   eval read $varname      # 或者就是 read $varname
15   stty "$old_tty_settings"
16   # 察看"stty"的man页.
17 }
18 
19 echo; echo -n "What's your name? Quick! "
20 timedout_read $INTERVAL your_name
21 
22 #  这种方法可能不是每个终端类型都可以正常使用的.
23 #  最大的timeout依赖于具体的终端.
24 #+ (一般都是25.5秒).
25 
26 echo
27 
28 if [ ! -z "$your_name" ]  # If name input before timeout...
29 then
30   echo "Your name is $your_name."
31 else
32   echo "Timed out."
33 fi
34 
35 echo
36 
37 # 这个脚本的行为可能与"timed-input.sh"有点不同.
38 # 在每次按键的时候,计数器都会重置.
39 
40 exit 0
################################End Script#########################################
  或许,最简单的办法就是使用-t选项来read了. 
Example 9-4 Timed read
################################Start Script#######################################
 1 #!/bin/bash
 2 # t-out.sh
 3 # "syngin seven"的一个很好的提议 (thanks).
 4 
 5 
 6 TIMELIMIT=4         # 4 seconds
 7 
 8 read -t $TIMELIMIT variable <&1
 9 #                           ^^^
10 #  在这个例子中,对于Bash 1.x和2.x就需要使用"<&1"
11 #  但对于Bash 3.x就不需要.
12 
13 echo
14 
15 if [ -z "$variable" ]  # Is null?
16 then
17   echo "Timed out, variable still unset."
18 else  
19   echo "variable = $variable"
20 fi  
21 
22 exit 0
################################End Script######################################### 
 $UID
  用户ID号.
  当前用户的id号,在/etc/passwd中记录.
  这个值不会因为用户使用了su命令而改变.$UID是只读变量,不容易在命令行或者是脚
  本中被修改,并且和内建的id命令很相像.
Example 9-5 我是root?
################################Start Script#######################################
 1 #!/bin/bash
 2 # am-i-root.sh:   我是不是root用户?
 3 
 4 ROOT_UID=0   # Root的$UID是0.
 5 
 6 if [ "$UID" -eq "$ROOT_UID" ]  # 是否是root用户,请站出来.
 7 then
 8   echo "You are root."
 9 else
10   echo "You are just an ordinary user (but mom loves you just the same)."
11 fi
12 
13 exit 0
14 
15 
16 # ============================================================= #
17 # 下边的代码将不被执行,因为脚本已经退出了.
18 
19 # 检验是root用户的一种可选方法:
20 
21 ROOTUSER_NAME=root
22 
23 username=`id -nu`              # Or...   username=`whoami`
24 if [ "$username" = "$ROOTUSER_NAME" ]
25 then
26   echo "Rooty, toot, toot. You are root."
27 else
28   echo "You are just a regular fella."
29 fi
################################End Script#########################################
  见例子Example 2-3
  注意:变量$ENV,$LOGNAME,$MAIL,$TERM,$USER,和$USERNAME并不是Bash的内建变量.它
  们经常被设置成环境变量,它们一般都放在Bash的安装文件中.$SHELL,用户登录的
  shell的名字,可能是从/etc/passwd设置的,也可能是在一个"init"脚本中设置的,同样
  的,它也不是Bash的内建变量.
  tcsh% echo $LOGNAME
  bozo
  tcsh% echo $SHELL
  /bin/tcsh
  tcsh% echo $TERM
  rxvt 
  bash$ echo $LOGNAME
  bozo
  bash$ echo $SHELL
  /bin/tcsh
  bash$ echo $TERM
  rxvt 
位置参数
 $0, $1, $2,等等...
  位置参数,从命令行传递给脚本,或者是传递给函数.或者赋职给一个变量.
  (具体见Example 4-5和Example 11-15) 
 $#
  命令行或者是位置参数的个数.(见Example 33-2) 
 $*
  所有的位置参数,被作为一个单词.
  注意:"$*"必须被""引用.
 
 $@
  与$*同义,但是每个参数都是一个独立的""引用字串,这就意味着参数被完整地传递,
  并没有被解释和扩展.这也意味着,每个参数列表中的每个参数都被当成一个独立的
  单词.
  注意:"$@"必须被引用. 
Example 9-6 arglist:通过$*和$@列出所有的参数
################################Start Script#######################################
 1 #!/bin/bash
 2 # arglist.sh
 3 # 多使用几个参数来调用这个脚本,比如"one tow three".
 4 
 5 E_BADARGS=65
 6 
 7 if [ ! -n "$1" ]
 8 then
 9   echo "Usage: `basename $0` argument1 argument2 etc."
10   exit $E_BADARGS
11 fi  
12 
13 echo
14 
15 index=1          # 初始化数量.
16 
17 echo "Listing args with \"\$*\":"
18 for arg in "$*"  # 如果"$*"不被""引用,那么将不能正常地工作
19 do
20   echo "Arg #$index = $arg"
21   let "index+=1"
22 done             # $* sees all arguments as single word. 
22 done             # $* 认为所有的参数为一个单词
23 echo "Entire arg list seen as single word."
24 
25 echo
26 
27 index=1          # 重置数量.
28                  # 如果你忘了这句会发生什么?
29 
30 echo "Listing args with \"\$@\":"
31 for arg in "$@"
32 do
33   echo "Arg #$index = $arg"
34   let "index+=1"
35 done             # $@ 认为每个参数都一个单独的单词.
36 echo "Arg list seen as separate words."
37 
38 echo
39 
40 index=1          # 重置数量.
41 
42 echo "Listing args with \$* (unquoted):"
43 for arg in $*
44 do
45   echo "Arg #$index = $arg"
46   let "index+=1"
47 done             # 未""引用的$*把参数作为独立的单词.
48 echo "Arg list seen as separate words."
49 
50 exit 0
################################End Script######################################### 
  在shift命令后边,$@将保存命令行中剩余的参数,而$1被丢掉了.
   1 #!/bin/bash
   2 # 使用 ./scriptname 1 2 3 4 5 来调用这个脚本
   3 
   4 echo "$@"    # 1 2 3 4 5
   5 shift
   6 echo "$@"    # 2 3 4 5
   7 shift
   8 echo "$@"    # 3 4 5
   9 
  10 # 每个"shift"都丢弃$1.
  11 # "$@" 将包含剩下的参数.
  $@也作为为工具使用,用来过滤传给脚本的输入.
  cat "$@"结构接受从stdin传来的输入,也接受从参数中指定的文件传来的输入.
  具体见Example 12-21和Example 12-22. 
  注意:$*和$@的参数有时会不一致,发生令人迷惑的行为,这依赖于$IFS的设置. 
Example 9-7 不一致的$*和$@行为
################################Start Script#######################################
  1 #!/bin/bash
  2 
  3 #  "$*"和"$@"的古怪行为,
  4 #+ 依赖于它们是否被""引用.
  5 #  单词拆分和换行的不一致处理.
  6 
  7 
  8 set -- "First one" "second" "third:one" "" "Fifth: :one"
  9 # 设置这个脚本参数,$1,$2,等等.
 10 
 11 echo
 12 
 13 echo 'IFS unchanged, using "$*"'
 14 c=0
 15 for i in "$*"               # 引用
 16 do echo "$((c+=1)): [$i]"   # 这行在下边的每个例子中都一样.
 17                             # Echo参数.
 18 done
 19 echo ---
 20 
 21 echo 'IFS unchanged, using $*'
 22 c=0
 23 for i in $*                 # 未引用
 24 do echo "$((c+=1)): [$i]"
 25 done
 26 echo ---
 27 
 28 echo 'IFS unchanged, using "$@"'
 29 c=0
 30 for i in "$@"
 31 do echo "$((c+=1)): [$i]"
 32 done
 33 echo ---
 34 
 35 echo 'IFS unchanged, using $@'
 36 c=0
 37 for i in $@
 38 do echo "$((c+=1)): [$i]"
 39 done
 40 echo ---
 41 
 42 IFS=:
 43 echo 'IFS=":", using "$*"'
 44 c=0
 45 for i in "$*"
 46 do echo "$((c+=1)): [$i]"
 47 done
 48 echo ---
 49 
 50 echo 'IFS=":", using $*'
 51 c=0
 52 for i in $*
 53 do echo "$((c+=1)): [$i]"
 54 done
 55 echo ---
 56 
 57 var=$*
 58 echo 'IFS=":", using "$var" (var=$*)'
 59 c=0
 60 for i in "$var"
 61 do echo "$((c+=1)): [$i]"
 62 done
 63 echo ---
 64 
 65 echo 'IFS=":", using $var (var=$*)'
 66 c=0
 67 for i in $var
 68 do echo "$((c+=1)): [$i]"
 69 done
 70 echo ---
 71 
 72 var="$*"
 73 echo 'IFS=":", using $var (var="$*")'
 74 c=0
 75 for i in $var
 76 do echo "$((c+=1)): [$i]"
 77 done
 78 echo ---
 79 
 80 echo 'IFS=":", using "$var" (var="$*")'
 81 c=0
 82 for i in "$var"
 83 do echo "$((c+=1)): [$i]"
 84 done
 85 echo ---
 86 
 87 echo 'IFS=":", using "$@"'
 88 c=0
 89 for i in "$@"
 90 do echo "$((c+=1)): [$i]"
 91 done
 92 echo ---
 93 
 94 echo 'IFS=":", using $@'
 95 c=0
 96 for i in $@
 97 do echo "$((c+=1)): [$i]"
 98 done
 99 echo ---
100 
101 var=$@
102 echo 'IFS=":", using $var (var=$@)'
103 c=0
104 for i in $var
105 do echo "$((c+=1)): [$i]"
106 done
107 echo ---
108 
109 echo 'IFS=":", using "$var" (var=$@)'
110 c=0
111 for i in "$var"
112 do echo "$((c+=1)): [$i]"
113 done
114 echo ---
115 
116 var="$@"
117 echo 'IFS=":", using "$var" (var="$@")'
118 c=0
119 for i in "$var"
120 do echo "$((c+=1)): [$i]"
121 done
122 echo ---
123 
124 echo 'IFS=":", using $var (var="$@")'
125 c=0
126 for i in $var
127 do echo "$((c+=1)): [$i]"
128 done
129 
130 echo
131 
132 # 用ksh或者zsh -y来试试这个脚本.
133 
134 exit 0
135 
136 # This example script by Stephane Chazelas,
137 # and slightly modified by the document author.
################################End Script#########################################
  注意:$@和$*中的参数只有在""中才会不同. 
Example 9-8 当$IFS为空时的$*和$@
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 #  如果$IFS被设置为空时,
 4 #+ 那么"$*" 和"$@" 将不会象期望那样echo出位置参数.
 5 
 6 mecho ()       # Echo 位置参数.
 7 {
 8 echo "$1,$2,$3";
 9 }
10 
11 
12 IFS=""         # 设置为空.
13 set a b c      # 位置参数.
14 
15 mecho "$*"     # abc,,
16 mecho $*       # a,b,c
17 
18 mecho $@       # a,b,c
19 mecho "$@"     # a,b,c
20 
21 #  当$IFS设置为空时,$* 和$@ 的行为依赖于
22 #+ 正在运行的Bash或者sh的版本.
23 #  所以在脚本中使用这种"feature"不是明智的行为.
24 
25 
26 # Thanks, Stephane Chazelas.
27 
28 exit 0
################################End Script######################################### 
其他的特殊参数 
 $-
  传递给脚本的falg(使用set命令).参考Example 11-15. 
  注意:这起初是ksh的特征,后来被引进到Bash中,但不幸的是,在Bash中它看上去也不
  能可靠的工作.使用它的一个可能的方法就是让这个脚本进行自我测试(查看是否是交
  互的). 
 $!
  在后台运行的最后的工作的PID(进程ID).
   1 LOG=$0.log
   2 
   3 COMMAND1="sleep 100"
   4 
   5 echo "Logging PIDs background commands for script: $0" >> "$LOG"
   6 # 所以它们可以被监控,并且在必要的时候kill掉.
   7 echo >> "$LOG"
   8 
   9 # Logging 命令.
  10 
  11 echo -n "PID of \"$COMMAND1\":  " >> "$LOG"
  12 ${COMMAND1} &
  13 echo $! >> "$LOG"
  14 # PID of "sleep 100":  1506
  15 
  16 # Thank you, Jacques Lederer, for suggesting this. 
  1 possibly_hanging_job & { sleep ${TIMEOUT}; eval 'kill -9 $!' &> /dev/null; }
  2 # 强制结束一个品行不良的程序.
  3 # 很有用,比如在init脚本中.
  4 
  5 # Thank you,Sylvain Fourmanoit,for this creative use of the "!" variable. 
 $_
  保存之前执行的命令的最后一个参数. 
Example 9-9 下划线变量
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 echo $_              # /bin/bash
 4                      # 只是调用/bin/bash来运行这个脚本.
 5 
 6 du >/dev/null        # 将没有命令的输出
 7 echo $_              # du
 8 
 9 ls -al >/dev/null    # 没有命令输出
10 echo $_              # -al  (最后的参数)
11 
12 :
13 echo $_              # :
################################End Script######################################### 
 $?
  命令,函数或者脚本本身的退出状态(见Example 23-7) 
 $$
  脚本自身的进程ID.这个变量经常用来构造一个"unique"的临时文件名.
  (参考Example A-13,Example 29-6,Example 12-28和Example 11-25).
  这通常比调用mktemp来得简单. 
注意事项:
[1]  当前运行的脚本的PID为$$.
[2]  "argument"和"parameter"这两个单词经常不加区分的使用.在这整本书中,这两个
  单词的意思完全相同.(在翻译的时候就未加区分,统统翻译成参数) 
9.2 操作字符串
--------------
Bash支持超多的字符串操作,操作的种类和数量令人惊异.但不幸的是,这些工具缺乏集中性.
一些是参数替换的子集,但是另一些则属于UNIX的expr命令.这就导致了命令语法的不一致和
功能的重叠,当然也会引起混乱. 
字符串长度 
 ${#string}
 expr length $string
 expr "$string" : '.*' 
 1 stringZ=abcABC123ABCabc
 2 
 3 echo ${#stringZ}                 # 15
 4 echo `expr length $stringZ`      # 15
 5 echo `expr "$stringZ" : '.*'`    # 15 
Example 9-10 在一个文本文件的段间插入空行
################################Start Script#######################################
 1 #!/bin/bash
 2 # paragraph-space.sh
 3 
 4 # 在一个不空行的文本文件的段间插入空行.
 5 # Usage: $0 <FILENAME
 6 
 7 MINLEN=45        # 可能需要修改这个值.
 8 #  假定行的长度小于$MINLEN指定的长度
 9 #+ $MINLEN中的值用来描述多少个字符结束一个段.
10 
11 while read line  # 对于需要多行输入的文件基本都是这个样子
12 do
13   echo "$line"   # 输出line.
14 
15   len=${#line}
16   if [ "$len" -lt "$MINLEN" ]
17     then echo    # 在短行后边添加一个空行
18   fi  
19 done
20 
21 exit 0
################################End Script######################################### 
从字符串开始的位置匹配子串的长度 
 expr match "$string" '$substring'
  $substring是一个正则表达式
 
 expr "$string" : '$substring'
  $substring是一个正则表达式 
 1 stringZ=abcABC123ABCabc
 2 #       |------|
 3 
 4 echo `expr match "$stringZ" 'abc[A-Z]*.2'`   # 8
 5 echo `expr "$stringZ" : 'abc[A-Z]*.2'`       # 8 
索引 
 expr index $string $substring
  匹配到子串的第一个字符的位置. 
 1 stringZ=abcABC123ABCabc
 2 echo `expr index "$stringZ" C12`             # 6
 3                                              # C position.
 4 
 5 echo `expr index "$stringZ" 1c`              # 3
 6 # 'c' (in #3 position) matches before '1'. 
 在C语言中最近的等价函数为strchr(). 
提取子串
 
 ${string:position}
  在string中从位置$position开始提取子串.
  如果$string为"*"或"@",那么将提取从位置$position开始的位置参数,[1] 
 ${string:position:length}
  在string中从位置$position开始提取$length长度的子串. 
################################Start Script#######################################
 1 stringZ=abcABC123ABCabc
 2 #       0123456789.....
 3 #       0-based indexing.
 4 
 5 echo ${stringZ:0}                            # abcABC123ABCabc
 6 echo ${stringZ:1}                            # bcABC123ABCabc
 7 echo ${stringZ:7}                            # 23ABCabc
 8 
 9 echo ${stringZ:7:3}                          # 23A
10                                              # 3个字符长度的子串.
11 
12 
13 
14 # 有没有可能从字符结尾开始,反向提取子串?
15     
16 echo ${stringZ:-4}                           # abcABC123ABCabc
17 # 以${parameter:-default}方式,默认是提取完整地字符串.
18 # 然而 . . .
19 
20 echo ${stringZ:(-4)}                         # Cabc 
21 echo ${stringZ: -4}                          # Cabc
22 # 现在,它可以工作了.
23 # 使用圆括号或者添加一个空格来转义这个位置参数.
24 
25 # Thank you, Dan Jacobson, for pointing this out.
################################End Script#########################################
  如果$string参数为"*"或"@",那将最大的提取从$position开始的$length个位置参数.
 1 echo ${*:2}          # Echo出第2个和后边所有的位置参数.
 2 echo ${@:2}          # 与前边相同.
 3 
 4 echo ${*:2:3}        # 从第2个开始,Echo出后边3个位置参数. 
 expr substr $string $position $length
  在string中从位置$position开始提取$length长度的子串.
 1 stringZ=abcABC123ABCabc
 2 #       123456789......
 3 #       1-based indexing.
 4 
 5 echo `expr substr $stringZ 1 2`              # ab
 6 echo `expr substr $stringZ 4 3`              # ABC 
 expr match "$string" '\($substring\)'
  从$string的开始位置提取$substring,$substring是一个正则表达式. 
 expr "$string" : '\($substring\)'
  从$string的开始位置提取$substring,$substring是一个正则表达式.
 1 stringZ=abcABC123ABCabc
 2 #       =======     
 3 
 4 echo `expr match "$stringZ" '\(.[b-c]*[A-Z]..[0-9]\)'`   # abcABC1
 5 echo `expr "$stringZ" : '\(.[b-c]*[A-Z]..[0-9]\)'`       # abcABC1
 6 echo `expr "$stringZ" : '\(.......\)'`                   # abcABC1
 7 # All of the above forms give an identical result. 
子串削除 
 ${string#substring}
   从$string的左边截掉第一个匹配的$substring
 ${string##substring}
   从$string的左边截掉最后一个个匹配的$substring 
 1 stringZ=abcABC123ABCabc
 2 #       |----|
 3 #       |----------|
 4 
 5 echo ${stringZ#a*C}      # 123ABCabc
 6 # 截掉'a'和'C'之间最近的匹配.
 7 
 8 echo ${stringZ##a*C}     # abc
 9 # 截掉'a'和'C'之间最远的匹配. 
  
 
 ${string%substring}
   从$string的右边截掉第一个匹配的$substring
 ${string%%substring}
   从$string的右边截掉最后一个匹配的$substring 
 1 stringZ=abcABC123ABCabc
 2 #                    ||
 3 #        |------------|
 4 
 5 echo ${stringZ%b*c}      # abcABC123ABCa
 6 # 从$stringZ的后边开始截掉'b'和'c'之间的最近的匹配
 7 
 8 echo ${stringZ%%b*c}     # a
 9 # 从$stringZ的后边开始截掉'b'和'c'之间的最远的匹配 
Example 9-11 利用修改文件名,来转换图片格式
################################Start Script#######################################
 1 #!/bin/bash
 2 #  cvt.sh:
 3 #  把一个目录下的所有MacPaint格式的图片文件都转换为"pbm"格式的图片文件.
 4 
 5 #  使用来自"netpbm"包的"macptopbm"程序,
 6 #+ 这个程序主要是由Brian Henderson(bryanh@giraffe-data.com)来维护的.
 7 #  Netpbm是大多数Linux发行版的标准部分.
 8 
 9 OPERATION=macptopbm
10 SUFFIX=pbm          # 新的文件名后缀
11 
12 if [ -n "$1" ]
13 then
14   directory=$1      # 如果目录名作为第1个参数给出...
15 else
16   directory=$PWD    # 否则使用当前的工作目录.
17 fi  
18   
19 #  假设在目标目录中的所有文件都是MacPaint格式的图片文件,
20 #+ 以".mac"为文件名的后缀.
21 
22 for file in $directory/*    # Filename globbing.
23 do
24   filename=${file%.*c}      #  去掉文件名的".mac"后缀
25                             #+ ('.*c' matches everything
25                             #+ ('.*c' 将匹配'.'和'c'之间的任何字符串).
26
27   $OPERATION $file > "$filename.$SUFFIX"
28                             # 转换为新的文件名.
29   rm -f $file               # 转换完毕后删除原有的文件.
30   echo "$filename.$SUFFIX"  # 从stdout输出反馈.
31 done
32 
33 exit 0
34 
35 # 练习:
36 # --------
37 #  就像它现在这个样子,这个脚本把当前目录的所有文件都转换了.
38 #
39 #  修改这个脚本,让他只转换以".mac"为后缀的文件.
################################End Script#########################################
  一个简单的模拟getopt命令的办法就是使用子串提取结构.
Example 9-12 模仿getopt命令
################################Start Script#######################################
 1 #!/bin/bash
 2 # getopt-simple.sh
 3 # Author: Chris Morgan
 4 # 授权使用在ABS Guide中.
 5 
 6 
 7 getopt_simple()
 8 {
 9     echo "getopt_simple()"
10     echo "Parameters are '$*'"
11     until [ -z "$1" ]
12     do
13       echo "Processing parameter of: '$1'"
14       if [ ${1:0:1} = '/' ]
15       then
16           tmp=${1:1}               # 去掉开头的'/' . . .
17           parameter=${tmp%%=*}     # 提取名字.
18           value=${tmp##*=}         # 提取值.
19           echo "Parameter: '$parameter', value: '$value'"
20           eval $parameter=$value
21       fi
22       shift
23     done
24 }
25 
26 # 传递所有的选项到getopt_simple().
27 getopt_simple $*
28 
29 echo "test is '$test'"
30 echo "test2 is '$test2'"
31 
32 exit 0
33 
34 ---
35 
36 sh getopt_example.sh /test=value1 /test2=value2
37 
38 Parameters are '/test=value1 /test2=value2'
39 Processing parameter of: '/test=value1'
40 Parameter: 'test', value: 'value1'
41 Processing parameter of: '/test2=value2'
42 Parameter: 'test2', value: 'value2'
43 test is 'value1'
44 test2 is 'value2'
################################End Script######################################### 
子串替换 
 ${string/substring/replacement}
  使用$replacement来替换第一个匹配的$substring.
 ${string//substring/replacement}
  使用$replacement来替换所有匹配的$substring. 
 1 stringZ=abcABC123ABCabc
 2 
 3 echo ${stringZ/abc/xyz}           # xyzABC123ABCabc
 4                                   # 用'xyz'来替换第一个匹配的'abc'.
 5 
 6 echo ${stringZ//abc/xyz}          # xyzABC123ABCxyz
 7                                   # 用'xyz'来替换所有匹配的'abc'. 
 ${string/#substring/replacement}
  如果$substring匹配$string的开头部分,那么就用$replacement来替换$substring.
 ${string/%substring/replacement}
  如果$substring匹配$string的结尾部分,那么就用$replacement来替换$substring.
 1 stringZ=abcABC123ABCabc
 2 
 3 echo ${stringZ/#abc/XYZ}          # XYZABC123ABCabc
 4                                   # 用'XYZ'替换开头的'abc'
 5 
 6 echo ${stringZ/%abc/XYZ}          # abcABC123ABCXYZ
 7                                   # 用'XYZ'替换结尾的'abc' 
9.2.1 使用awk来操作字符串
~~~~~~~~~~~~~~~~~~~~~~~~~
Bash脚本也可以使用awk来操作字符串. 
Example 9-13 提取字符串的一种可选的方法
################################Start Script#######################################
 1 #!/bin/bash
 2 # substring-extraction.sh
 3 
 4 String=23skidoo1
 5 #      012345678    Bash
 6 #      123456789    awk
 7 # 注意,对于awk和Bash来说,它们使用的是不同的string索引系统:
 8 # Bash的第一个字符是从'0'开始记录的.
 9 # Awk的第一个字符是从'1'开始记录的. 
10 
11 echo ${String:2:4} # 位置3 (0-1-2), 4 个字符长
12                                          # skid
13 
14 # awk中等价于${string:pos:length}的命令是substr(string,pos,length).
15 echo | awk '
16 { print substr("'"${String}"'",3,4)      # skid
17 }
18 '
19 #  使用一个空的"echo"通过管道给awk一个假的输入,
20 #+ 这样可以不用提供一个文件名.
21 
22 exit 0
################################End Script######################################### 
9.2.2 更深的讨论
~~~~~~~~~~~~~~~~
关于在脚本中使用字符串更深的讨论,请参考 9.3节,h和expr命令列表的相关章节.
关于脚本的例子,见: 
1 Example 12-9
2 Example 9-16
3 Example 9-17
4 Example 9-18
5 Example 9-20 
注意事项:
[1]  这适用于命令行参数和函数参数. 
  
9.3 参数替换
------------ 
操作和扩展变量 
 ${parameter}
  与$parameter相同,就是parameter的值.在特定的上下文中,只有少部分会产生
  ${parameter}的混淆.可以组合起来一起赋指给字符串变量. 
  1 your_id=${USER}-on-${HOSTNAME}
  2 echo "$your_id"
  3 #
  4 echo "Old \$PATH = $PATH"
  5 PATH=${PATH}:/opt/bin  #Add /opt/bin to $PATH for duration of script.
  6 echo "New \$PATH = $PATH" 
 
 ${parameter-default},${parameter:-default}
  如果parameter没被set,那么就使用default. 
  1 echo ${username-`whoami`}
  2 # echo `whoami`的结果,如果没set username变量的话.
  
  注意:${parameter-default}和${parameter:-default}大部分时候是相同的.
   额外的":"在parameter被声明的时候(而且被赋空值),会有一些不同. 
################################Start Script#######################################
 1 #!/bin/bash
 2 # param-sub.sh
 3 
 4 #  一个变量是否被声明
 5 #+ 将会影响默认选项的触发
 6 #+ 甚至于这个变量被设为空.
 7 
 8 username0=
 9 echo "username0 has been declared, but is set to null."
10 echo "username0 = ${username0-`whoami`}"
11 # 将不会echo.
12 
13 echo
14 
15 echo username1 has not been declared.
16 echo "username1 = ${username1-`whoami`}"
17 # 将会echo.
18 
19 username2=
20 echo "username2 has been declared, but is set to null."
21 echo "username2 = ${username2:-`whoami`}"
22 #                            ^
23 # 将会echo因为使用的是:-而不是 -.
24 # 和前边的第一个例子好好比较一下.
25 
26 
27 #
28 
29 # 再来一个:
30 
31 variable=
32 # 变量已经被声明了,但是被设置为空.
33 
34 echo "${variable-0}"    # (no output)
35 echo "${variable:-1}"   # 1
36 #               ^
37 
38 unset variable
39 
40 echo "${variable-2}"    # 2
41 echo "${variable:-3}"   # 3
42 
43 exit 0
################################End Script######################################### 
  如果脚本中并没有传入命令行参数,那么default parameter将被使用.
  1 DEFAULT_FILENAME=generic.data
  2 filename=${1:-$DEFAULT_FILENAME}
  3 #  如果没有参数被传递进来,那么下边的命令快将操作
  4 #+ 文件"generic.data"
  5 #
  6 #  后续命令.
  
  另外参见Example 3-4,Example 28-2,和Example A-6.
  与"使用一个与列表来支持一个默认的命令行参数"的方法相比较. 
 ${parameter=default},${parameter:=default}
  如果parameter未设置,那么就设置为default.
  这两种办法绝大多数时候用法都一样,只有在$parameter被声明并设置为空的时候,
  才会有区别,[1]和上边的行为一样.
  1 echo ${username=`whoami`}
  2 # Variable "username" is now set to `whoami`.
  2 # 变量"username"被赋值为`whoami`. 
 ${parameter+alt_value},${parameter:+alt_value}
  如果parameter被set了,那就使用alt_value,否则就使用null字符串.
  这两种办法绝大多数时候用法都一样,只有在$parameter被声明并设置为空的时候,
  会有区别,见下. 
################################Start Script#######################################
 1 echo "###### \${parameter+alt_value} ########"
 2 echo
 3 
 4 a=${param1+xyz}
 5 echo "a = $a"      # a =
 6 
 7 param2=
 8 a=${param2+xyz}
 9 echo "a = $a"      # a = xyz
10 
11 param3=123
12 a=${param3+xyz}
13 echo "a = $a"      # a = xyz
14 
15 echo
16 echo "###### \${parameter:+alt_value} ########"
17 echo
18 
19 a=${param4:+xyz}
20 echo "a = $a"      # a =
21 
22 param5=
23 a=${param5:+xyz}
24 echo "a = $a"      # a =
25 # 与a=${param5+xyz}有不同的结果.
26 
27 param6=123
28 a=${param6+xyz}
29 echo "a = $a"      # a = xyz
################################End Script######################################### 
 ${parameter?err_msg}, ${parameter:?err_msg}
  如果parameter被set,那就是用set的值,否则print err_msg.
  这两种办法绝大多数时候用法都一样,只有在$parameter被声明并设置为空的时候,
  会有区别,见上. 
Example 9-14 使用参数替换和error messages
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 #  检查一些系统的环境变量.
 4 #  这是个好习惯.
 5 #  比如,如果$USER(在console上的用户名)没被set,
 6 #+ 那么系统就不会认你.
 7 
 8 : ${HOSTNAME?} ${USER?} ${HOME?} ${MAIL?}
 9   echo
10   echo "Name of the machine is $HOSTNAME."
11   echo "You are $USER."
12   echo "Your home directory is $HOME."
13   echo "Your mail INBOX is located in $MAIL."
14   echo
15   echo "If you are reading this message,"
16   echo "critical environmental variables have been set."
17   echo
18   echo
19 
20 # ------------------------------------------------------
21 
22 #  ${variablename?} 结果也可以用来
23 #+ 在一个脚本中检查变量是否被set.
24 
25 ThisVariable=Value-of-ThisVariable
26 #  注意,顺便提一下,这个字符串变量可能在它们的名字中会被设置
27 #+ 非法字符
28 : ${ThisVariable?}
29 echo "Value of ThisVariable is $ThisVariable".
30 echo
31 echo
32 
33 
34 : ${ZZXy23AB?"ZZXy23AB has not been set."}
35 #  如果ZZXy23AB没被set,
36 #+ 那么这个脚本将以一个error message终止.
37 
38 # 你可以指定错误消息.
39 # : ${variablename?"ERROR MESSAGE"}
40 
41 
42 # 同样的结果:    dummy_variable=${ZZXy23AB?}
43 #                      dummy_variable=${ZZXy23AB?"ZXy23AB has not been set."}
44 #
45 #                      echo ${ZZXy23AB?} >/dev/null
46 
47 #  同"set -u"命令来比较这些检查变量是否被set的方法.
48 #
49 
50 
51 
52 echo "You will not see this message, because script already terminated."
53 
54 HERE=0
55 exit $HERE   # Will NOT exit here.
56 
57 # 事实上,这个脚本将返回值1作为退出状态(echo $?).
################################End Script######################################### 
Example 9-15 参数替换和"usage"messages
################################Start Script#######################################
 1 #!/bin/bash
 2 # usage-message.sh
 3 
 4 : ${1?"Usage: $0 ARGUMENT"}
 5 #  如果没有命令行参数,那么脚本将在此处退出.
 6 #+ 并且打出如下的错误消息.
 7 #    usage-message.sh: 1: Usage: usage-message.sh ARGUMENT
 8 
 9 echo "These two lines echo only if command-line parameter given."
10 echo "command line parameter = \"$1\""
11 
12 exit 0  # 如果有命令行参数,那么将在此处退出.
13 
14 # 测试这个脚本,第1次测试带参数,第2次测试不带参数.
15 # 如果有参数,那么"$?"就是0.
16 # 如果没有,那么"$?"就是1.
################################End Script######################################### 
参数替换和扩展
 下边的表达式是使用expr字符串匹配操作的补充(见Example 12-9).
 这些特定的使用方法绝大多数情况都是用来分析文件目录名. 
变量长度/子串删除 
 ${#var}
  字符串长度($var的字符数量).对于一个数组,${#array}是数组中第一个元素的长度. 
  一些例外:
   ${#*}和${#@}将给出位置参数的个数.
   对于数组来说${#array[*]}和${$#array[@]}将给出数组元素的个数.
Example 9-16 变量长度
################################Start Script#######################################
 1 #!/bin/bash
 2 # length.sh
 3 
 4 E_NO_ARGS=65
 5 
 6 if [ $# -eq 0 ]  # 这个demo脚本必须有命令行参数.
 7 then
 8   echo "Please invoke this script with one or more command-line arguments."
 9   exit $E_NO_ARGS
10 fi  
11 
12 var01=abcdEFGH28ij
13 echo "var01 = ${var01}"
14 echo "Length of var01 = ${#var01}"
15 # 现在,让我们试试在里边嵌入一个空格.
16 var02="abcd EFGH28ij"
17 echo "var02 = ${var02}"
18 echo "Length of var02 = ${#var02}"
19 
20 echo "Number of command-line arguments passed to script = ${#@}"
21 echo "Number of command-line arguments passed to script = ${#*}"
22 
23 exit 0
################################End Script######################################### 
 ${var#Pattern}, ${var##Pattern}
  从$var开头删除最近或最远匹配$Pattern的子串. 
  来自Example A-7例子的一部分.
  1 # 来自"days-between.sh"例子的一个函数.
  2 # 去掉传递进来的参数开头的0.
  3 
  4 strip_leading_zero () #  去掉开头的0
  5 {                     #+ 从传递进来的参数中.
  6   return=${1#0}       #  "1"指的是"$1" -- 传进来的参数.
  7 }                     #  "0"就是我们想从"$1"中删除的子串. 
  下边是Manfred Schwarb's对上边函数的一个改版.
  1 strip_leading_zero2 () # 去掉开头的0,因为如果不去掉的话
  2 {                      # Bash将会把这个值作为8进制解释.
  3   shopt -s extglob     # 打开扩展globbing.
  4   local val=${1##+(0)} # 使用局部变量,匹配最长的连续的0.
  5   shopt -u extglob     # 打开扩展globbing.
  6   _strip_leading_zero2=${val:-0}
  7                        # 如果输入为0,那么返回0来代替"".
  8 } 
  另一个例子
  1 echo `basename $PWD`        # 当前工作目录的basename.
  2 echo "${PWD##*/}"           # 当前工作目录的basename.
  3 echo
  4 echo `basename $0`          # 脚本名字.
  5 echo $0                     # 脚本名字.
  6 echo "${0##*/}"             # 脚本名字.
  7 echo
  8 filename=test.data
  9 echo "${filename##*.}"      # data 
 ${var%Pattern}, ${var%%Pattern}
  从$var结尾删除最近或最远匹配$Pattern的子串. 
Bash version2 添加了额外的选项. 
Example 9-17 参数替换中的模式匹配
################################Start Script#######################################
 1 #!/bin/bash
 2 # patt-matching.sh
 3 
 4 # 使用# ## % %%来进行参数替换操作的模式匹配.
 5 
 6 var1=abcd12345abc6789
 7 pattern1=a*c  # * (通配符) 匹配a - c之间的任何字符.
 8 
 9 echo
10 echo "var1 = $var1"           # abcd12345abc6789
11 echo "var1 = ${var1}"         # abcd12345abc6789
12                               # (alternate form)
13 echo "Number of characters in ${var1} = ${#var1}"
14 echo
15 
16 echo "pattern1 = $pattern1"   # a*c  (everything between 'a' and 'c')
17 echo "--------------"
18 echo '${var1#$pattern1}  =' "${var1#$pattern1}"    #         d12345abc6789
19 # 最短的可能匹配, 去掉abcd12345abc6789的前3个字符
20 #                     |-|               ^^^
21 echo '${var1##$pattern1} =' "${var1##$pattern1}"   #                  6789      
22 # 最远的匹配,去掉abcd12345abc6789的前12个字符.
23 #                |----------|      ^^^^
24 
25 echo; echo; echo
26 
27 pattern2=b*9            # 'b' 到'9'之间的任何字符
28 echo "var1 = $var1"     # 还是 abcd12345abc6789
29 echo
30 echo "pattern2 = $pattern2"
31 echo "--------------"
32 echo '${var1%pattern2}  =' "${var1%$pattern2}"     #     abcd12345a
33 # 最近的匹配, 去掉abcd12345abc6789的最后6个字符
34 #                           |----|  ^^^^
35 echo '${var1%%pattern2} =' "${var1%%$pattern2}"    #     a
36 # 最远匹配, 去掉abcd12345abc6789的最后12个字符
37 #                |-------------|  ^^^^^^
38 
39 # 记住, # 和## 从字符串的左边开始,并且去掉左边的字符串,
40 #           % 和 %% 从字符串的右边开始,并且去掉右边的子串.
41 
42 echo
43 
44 exit 0
################################End Script######################################### 
Example 9-18 重命名文件扩展名
################################Start Script#######################################
 1 #!/bin/bash
 2 # rfe.sh: 重命名文件扩展名.
 3 #
 4 # 用法:   rfe old_extension new_extension
 5 #
 6 # 例子:
 7 # 将指定目录的所有 *.gif 文件都重命名为 *.jpg,
 8 # 用法:   rfe gif jpg
 9 
10 
11 E_BADARGS=65
12 
13 case $# in
14   0|1)             # "|" 在这里的意思是或操作.
15   echo "Usage: `basename $0` old_file_suffix new_file_suffix"
16   exit $E_BADARGS  # 如果只有0个或1个参数,那么就退出.
17   ;;
18 esac
19 
20 
21 for filename in *.$1
22 # 以第一个参数为扩展名的全部文件的列表
23 do
24   mv $filename ${filename%$1}$2
25   #  从筛选出的文件中先去掉以第一参数结尾的扩展名部门,
26   #+ 然后作为扩展名把第2个参数添加上.
27 done
28 
29 exit 0
################################End Script######################################### 
变量扩展/子串替换
 这些结构都是从ksh中吸收来的. 
 ${var:pos}
  变量var从位置pos开始扩展. 
 ${var:pos:len}
  从位置pos开始,并扩展len长度个字符.见Example A-14(这个例子里有这种操作的一个
  创造性用法) 
 ${var/Pattern/Replacement}
  使用Replacement来替换var中的第一个Pattern的匹配. 
 ${var//Pattern/Replacement}
  全局替换.在var中所有的匹配,都会用Replacement来替换. 
  向上边所说,如果Replacement被忽略的话,那么所有匹配到的Pattern都会被删除. 
Example 9-19 使用模式匹配来分析比较特殊的字符串
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 var1=abcd-1234-defg
 4 echo "var1 = $var1"
 5 
 6 t=${var1#*-*}
 7 echo "var1 (with everything, up to and including first - stripped out) = $t"
 8 #  t=${var1#*-}  在这个例子中作用是一样的,
 9 #+ 因为 # 匹配这个最近的字符串,
10 #+ 并且 * 匹配前边的任何字符串,包括一个空字符.
11 # (Thanks, Stephane Chazelas, for pointing this out.)
12 
13 t=${var1##*-*}
14 echo "If var1 contains a \"-\", returns empty string...   var1 = $t"
15 
16 
17 t=${var1%*-*}
18 echo "var1 (with everything from the last - on stripped out) = $t"
19 
20 echo
21 
22 # -------------------------------------------
23 path_name=/home/bozo/ideas/thoughts.for.today
24 # -------------------------------------------
25 echo "path_name = $path_name"
26 t=${path_name##/*/}
27 echo "path_name, stripped of prefixes = $t"
28 # 在这个特定的例子中,与 t=`basename $path_name` 的作用一致.
29 #  t=${path_name%/}; t=${t##*/}   是一个更一般的解决办法,
30 #+ 但有时还是不行.
31 #  如果 $path_name 以一个新行结束, 那么`basename $path_name` 将不能工作,
32 #+ 但是上边这个表达式可以.
33 # (Thanks, S.C.)
34 
35 t=${path_name%/*.*}
36 # 与 t=`dirname $path_name` 效果相同.
37 echo "path_name, stripped of suffixes = $t"
38 # 在某些情况下将失效,比如 "../", "/foo////", # "foo/", "/".
39 #  删除后缀,尤其是在basename没有后缀的时候,
40 #+ 但是dirname还是会使问题复杂化.
41 # (Thanks, S.C.)
42 
43 echo
44 
45 t=${path_name:11}
46 echo "$path_name, with first 11 chars stripped off = $t"
47 t=${path_name:11:5}
48 echo "$path_name, with first 11 chars stripped off, length 5 = $t"
49 
50 echo
51 
52 t=${path_name/bozo/clown}
53 echo "$path_name with \"bozo\" replaced  by \"clown\" = $t"
54 t=${path_name/today/}
55 echo "$path_name with \"today\" deleted = $t"
56 t=${path_name//o/O}
57 echo "$path_name with all o's capitalized = $t"
58 t=${path_name//o/}
59 echo "$path_name with all o's deleted = $t"
60 
61 exit 0
################################End Script######################################### 
 ${var/#Pattern/Replacement}
  如果var的前缀匹配到了Pattern,那么就用Replacement来替换Pattern. 
 ${var/%Pattern/Replacement}
  如果var的后缀匹配到了Pattern,那么就用Replacement来替换Pattern. 
Example 9-20 对字符串的前缀或后缀使用匹配模式
################################Start Script#######################################
 1 #!/bin/bash
 2 # var-match.sh:
 3 # 对字符串的前后缀使用匹配替换的一个样本
 4 
 5 v0=abc1234zip1234abc    # 原始变量.
 6 echo "v0 = $v0"         # abc1234zip1234abc
 7 echo
 8 
 9 # 匹配字符串的前缀
10 v1=${v0/#abc/ABCDEF}    # abc1234zip1234abc
11                         # |-|
12 echo "v1 = $v1"         # ABCDEF1234zip1234abc
13                         # |----|
14 
15 # 匹配字符串的后缀
16 v2=${v0/%abc/ABCDEF}    # abc1234zip123abc
17                         #              |-|
18 echo "v2 = $v2"         # abc1234zip1234ABCDEF
19                         #               |----|
20 
21 echo
22 
23 #  ----------------------------------------------------
24 #  必须在开头或结尾匹配,否则,
25 #+ 将不会产生替换结果.
26 #  ----------------------------------------------------
27 v3=${v0/#123/000}       # 匹配上了,但不是在字符串的开头
28 echo "v3 = $v3"         # abc1234zip1234abc
29                         # 没替换.
30 v4=${v0/%123/000}       # 匹配上了,但不是在字符串结尾.
31 echo "v4 = $v4"         # abc1234zip1234abc
32                         # 没替换.
33 
34 exit 0 
################################End Script######################################### 
${!varprefix*}, ${!varprefix@}
 使用变量的前缀来匹配前边所有声明过的变量.
 1 xyz23=whatever
 2 xyz24=
 3 
 4 a=${!xyz*}      # 以"xyz"作为前缀,匹配所有前边声明过的变量.
 5 echo "a = $a"   # a = xyz23 xyz24
 6 a=${!xyz@}      # 同上.
 7 echo "a = $a"   # a = xyz23 xyz24
 8 
 9 # Bash, version 2.04, 添加了这个特征. 
注意事项:
[1]  如果在一个非交互脚本中,$parameter为空的话,那么这个脚本将以127返回.
  (127退出码对应的Bash错误码为"command not found"). 
  
9.4 指定类型的变量:declare或者typeset
-------------------------------------
declare或者typeset内建命令(这两个命令是完全一样的)允许指定变量的具体类型.在某些特
定的语言中,这是一种指定类型的很弱的形式.declare命令是在Bash版本2或之后的版本才被
加入的.typeset命令也可以工作在ksh脚本中. 
declare/typeset 选项 
 -r 只读
  1 declare -r var1
  (declare -r var1与readonly var1是完全一样的)
  这和C语言中的const关键字一样,都是强制指定只读.如果你尝试修改一个只读变量
  的值,那么你将得到一个错误消息. 
 -i 整形
  1 declare -i number
  2 # 这个脚本将把变量"number"后边的赋值视为一个整形.
  3 
  4 number=3
  5 echo "Number = $number"     # Number = 3
  6 
  7 number=three
  8 echo "Number = $number"     # Number = 0
  9 # 尝试把"three"解释为整形. 
  如果把一个变量指定为整形,那么即使没有expr和let命令,也允许使用特定的算术运算
  1 n=6/3
  2 echo "n = $n"       # n = 6/3
  3 
  4 declare -i n
  5 n=6/3
  6 echo "n = $n"       # n = 2 
 -a 数组
  1 declae -a indices
  变量indices将被视为数组. 
 -f 函数
  1 declare -f
  如果使用declare -f而不带参数的话,将会列出这个脚本中之前定义的所有函数.
  1 declare -f function_name
  如果使用declare -f function_name这种形式的话,将只会列出这个函数的名字. 
 -x export
  1 declare -x var3
  这种使用方式,将会把var3 export出来. 
Example 9-21 使用declare来指定变量的类型
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 func1 ()
 4 {
 5 echo This is a function.
 6 }
 7 
 8 declare -f        # 列出之前的所有函数.
 9 
10 echo
11 
12 declare -i var1   # var1 是个整形.
13 var1=2367
14 echo "var1 declared as $var1"
15 var1=var1+1       # 变量声明不需使用'let'命令.
16 echo "var1 incremented by 1 is $var1."
17 # 尝试将变量修改为整形.
18 echo "Attempting to change var1 to floating point value, 2367.1."
19 var1=2367.1       # 结果将是一个错误消息,并且变量并没有被修改.
20 echo "var1 is still $var1"
21 
22 echo
23 
24 declare -r var2=13.36         # 'declare' 允许设置变量的属性,
25                               #+ 并且同时分配变量的值.
26 echo "var2 declared as $var2" # 尝试修改只读变量.
27 var2=13.37                    # 产生一个错误消息,并且从脚本退出了.
28 
29 echo "var2 is still $var2"    # 这行将不会被执行.
30 
31 exit 0                        # 脚本将不会在此处退出.
################################End Script######################################### 
 注意:使用declare内建命令将会限制变量的作用域.
  1 foo ()
  2 {
  3 FOO="bar"
  4 }
  5 
  6 bar ()
  7 {
  8 foo
  9 echo $FOO
 10 }
 11 
 12 bar   # Prints bar. 
 然而...
  1 foo (){
  2 declare FOO="bar"
  3 }
  4 
  5 bar ()
  6 {
  7 foo
  8 echo $FOO
  9 }
 10 
 11 bar  # Prints nothing.
 12 
 13 
 14 # Thank you, Michael Iatrou, for pointing this out. 
  
9.5 变量的间接引用
------------------
假设一个变量的值是另一个变量的名字.我们有可能从第一个变量中取得第2个变量的值么?
比如,如果a=letter_of_alphabet接着letter_of_alphabet=z,那么我们能从a中得到z么?
答案是:当然可以,并且这被称为间接引用.它使用一个不常用的符号eval var1=\$$var2. 
Example 9-22 间接引用
################################Start Script#######################################
 1 #!/bin/bash
 2 # ind-ref.sh: 间接变量引用
 3 # 存取一个变量的值的值(这里翻译得有点拗口,不过凑合吧)
 4 
 5 a=letter_of_alphabet   # 变量"a"的值是另一个变量的名字.
 6 letter_of_alphabet=z
 7 
 8 echo
 9 
10 # 直接引用.
11 echo "a = $a"          # a = letter_of_alphabet
12 
13 # 间接引用.
14 eval a=\$$a
15 echo "Now a = $a"      # Now a = z
16 
17 echo
18 
19 
20 # 现在,让我们试试修改第2个引用的值.
21 
22 t=table_cell_3
23 table_cell_3=24
24 echo "\"table_cell_3\" = $table_cell_3"            # "table_cell_3" = 24
25 echo -n "dereferenced \"t\" = "; eval echo \$$t    # 解引用 "t" = 24
26 # 在这个简单的例子中,下边的表达式也能正常工作(为什么?).
27 #         eval t=\$$t; echo "\"t\" = $t"
28 
29 echo
30 
31 t=table_cell_3
32 NEW_VAL=387
33 table_cell_3=$NEW_VAL
34 echo "Changing value of \"table_cell_3\" to $NEW_VAL."
35 echo "\"table_cell_3\" now $table_cell_3"
36 echo -n "dereferenced \"t\" now "; eval echo \$$t
37 # "eval" 将获得两个参数 "echo" 和 "\$$t" (与$table_cell_3等价)
38 
39 echo
40 
41 # (Thanks, Stephane Chazelas, 澄清了上边的行为.)
42 
43 
44 # 另一个方法是使用${!t}符号,见"Bash, 版本2"小节.
45 # 也请参阅ex78.sh.
46 
47 exit 0
################################End Script#########################################
间接应用到底有什么应用价值?它给Bash添加了一种类似于C语言指针的功能,在Example 34-3
中有例子.并且,还有一些其它的有趣的应用.... 
Nils Radtke展示了如何建立一个"dynamic"变量名字并且取出其中的值.当sourcing(包含)配置
文件时,这很有用.
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 
 4 # ---------------------------------------------
 5 # 这部分内容可能来自于单独的文件.
 6 isdnMyProviderRemoteNet=172.16.0.100
 7 isdnYourProviderRemoteNet=10.0.0.10
 8 isdnOnlineService="MyProvider"
 9 # ---------------------------------------------
10       
11 
12 remoteNet=$(eval "echo \$$(echo isdn${isdnOnlineService}RemoteNet)")
13 remoteNet=$(eval "echo \$$(echo isdnMyProviderRemoteNet)")
14 remoteNet=$(eval "echo \$isdnMyProviderRemoteNet")
15 remoteNet=$(eval "echo $isdnMyProviderRemoteNet")
16 
17 echo "$remoteNet"    # 172.16.0.100
18 
19 # ================================================================
20 
21 #  同时,它甚至能更好.
21 #  
22 
23 #  考虑下边的脚本,给出了一个变量getSparc,
24 #+ 但是没给出变量getIa64:
25 
26 chkMirrorArchs () { 
27   arch="$1";
28   if [ "$(eval "echo \${$(echo get$(echo -ne $arch |
29        sed 's/^\(.\).*/\1/g' | tr 'a-z' 'A-Z'; echo $arch |
30        sed 's/^.\(.*\)/\1/g')):-false}")" = true ]
31   then
32      return 0;
33   else
34      return 1;
35   fi;
36 }
37 
38 getSparc="true"
39 unset getIa64
40 chkMirrorArchs sparc
41 echo $?        # 0
42                # True
43 
44 chkMirrorArchs Ia64
45 echo $?        # 1
46                # False
47 
48 # 注意:
49 # -----<rojy bug>
50 # Even the to-be-substituted variable name part is built explicitly.
51 # The parameters to the chkMirrorArchs calls are all lower case.
52 # The variable name is composed of two parts: "get" and "Sparc" . . .
################################End Script######################################### 
Example 9-23 传递一个间接引用给awk
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 #  "column totaler"脚本的另一个版本
 4 #+ 这个版本在目标文件中添加了一个特殊的列(数字的).
 5 #  这个脚本使用了间接引用.
 6 
 7 ARGS=2
 8 E_WRONGARGS=65
 9 
10 if [ $# -ne "$ARGS" ] # 检查命令行参数是否是合适的个数.
11 then
12    echo "Usage: `basename $0` filename column-number"
13    exit $E_WRONGARGS
14 fi
15 
16 filename=$1
17 column_number=$2
18 
19 #===== 上边的这部分,与原来的脚本一样 =====#
20 
21 
22 # 一个多行的awk脚本被调用,通过 ' ..... '
23 
24 
25 # awk 脚本开始.
26 # ------------------------------------------------
27 awk "
28 
29 { total += \$${column_number} # 间接引用.
30 }
31 END {
32      print total
33      }
34 
35      " "$filename"
36 # ------------------------------------------------
37 # awk 脚本结束.
38 
39 #  间接的变量引用避免了在一个内嵌的awk脚本中引用
40 #+ 一个shell变量的问题.
41 #  Thanks, Stephane Chazelas.
42 
43 
44 exit 0
################################End Script#########################################
注意: 这个脚本有些狡猾.如果第2个变量修改了它的值,那么第一个变量必须被适当的解引用
   (像上边的例子一样).幸运的是,在Bash版本2中引入的${!variable}(参见Example 34-2)
   是的间接引用更加直观了. 
注意: Bash并不支持指针的算术运算,并且这严格的限制了间接引用的使用.事实上,在脚本语言
   中,间接引用本来就是丑陋的部分. 
  
9.6 $RANDOM: 产生随机整数
-------------------------
$RANDOM是Bash的内部函数(并不是常量),这个函数将返回一个范围在0 - 32767之间的一个伪
随机整数.它不应该被用来产生密匙. 
Example 9-24 产生随机数
################################Start Script#######################################
  1 #!/bin/bash
  2 
  3 # $RANDOM 在每次调用的时候,返回一个不同的随机整数.
  4 # 指定的范围是: 0 - 32767 (有符号的16-bit 整数).
  5 
  6 MAXCOUNT=10
  7 count=1
  8 
  9 echo
 10 echo "$MAXCOUNT random numbers:"
 11 echo "-----------------"
 12 while [ "$count" -le $MAXCOUNT ]      # 产生10 ($MAXCOUNT) 个随机整数.
 13 do
 14   number=$RANDOM
 15   echo $number
 16   let "count += 1"  # 数量加1.
 17 done
 18 echo "-----------------"
 19 
 20 # 如果你需要在一个特定范围内产生一个随机int,那么使用'modulo'(模)操作.
 21 # 这将返回一个除法操作的余数.
 22 
 23 RANGE=500
 24 
 25 echo
 26 
 27 number=$RANDOM
 28 let "number %= $RANGE"
 29 #           ^^
 30 echo "Random number less than $RANGE  ---  $number"
 31 
 32 echo
 33 
 34 
 35 
 36 #  如果你需要产生一个比你指定的最小边界大的随机数,
 37 #+ 那么建立一个test循环,来丢弃所有产生对比这个数小的随机数.
 38 
 39 FLOOR=200
 40 
 41 number=0   #initialize
 42 while [ "$number" -le $FLOOR ]
 43 do
 44   number=$RANDOM
 45 done
 46 echo "Random number greater than $FLOOR ---  $number"
 47 echo
 48 
 49    # 让我们对上边的循环尝试一个小改动,也就是
 50    #       让"number = $RANDOM + $FLOOR"
 51    # 这将不再需要那个while循环,并且能够运行得更快.
 52    # 但是, 这可能会产生一个问题.那么这个问题是什么呢?(译者:这很简单,有可能溢出)
 53 
 54 
 55 
 56 # 结合上边两个例子的技术,来达到获得在指定的上下限之间来产生随机数.
 57 number=0   #initialize
 58 while [ "$number" -le $FLOOR ]
 59 do
 60   number=$RANDOM
 61   let "number %= $RANGE"  # 让$number依比例落在$RANGE范围内.
 62 done
 63 echo "Random number between $FLOOR and $RANGE ---  $number"
 64 echo
 65 
 66 
 67 
 68 # 产生一个二元选择,就是"true"和"false"两个值.
 69 BINARY=2
 70 T=1
 71 number=$RANDOM
 72 
 73 let "number %= $BINARY"
 74 #  注意,让"number >>= 14" 将给出一个更好的随机分配
 75 #+ (右移14位将把所有为全部清空,除了第15位,因为有符号,所以第16位是符号位).
 76 if [ "$number" -eq $T ]
 77 then
 78   echo "TRUE"
 79 else
 80   echo "FALSE"
 81 fi  
 82 
 83 echo
 84 
 85 
 86 # 抛骰子
 87 SPOTS=6   # 模6给出的范围就是0-5.
 88           # 加1就会得到期望的范围1 - 6.
 89           # Thanks, Paulo Marcel Coelho Aragao, for the simplification.
 90 die1=0
 91 die2=0
 92 # 是否让SPOTS=7比加1更好呢?解释行或者不行的原因?
 93 
 94 # 每次抛骰子,都会给出均等的机会.
 95 
 96     let "die1 = $RANDOM % $SPOTS +1" # 抛第一次.
 97     let "die2 = $RANDOM % $SPOTS +1" # 抛第二次.
 98     #  上边的那个算术操作,具有更高的优先级呢 --
 99     #+ 模操作(%)还是加法操作(+)?
100 
101 
102 let "throw = $die1 + $die2"
103 echo "Throw of the dice = $throw"
104 echo
105 
106 
107 exit 0
################################End Script######################################### 
Example 9-25 从一副扑克牌中取出一张随机的牌
################################Start Script#######################################
 1 #!/bin/bash
 2 # pick-card.sh
 3 
 4 # 这是一个从数组中取出随机元素的一个例子.
 5 
 6 
 7 # 取出一张牌,任何一张.
 8 
 9 Suites="Clubs
10 Diamonds
11 Hearts
12 Spades"
13 
14 Denominations="2
15 3
16 4
17 5
18 6
19 7
20 8
21 9
22 10
23 Jack
24 Queen
25 King
26 Ace"
27 
28 # 注意变量的多行展开.
29 
30 
31 suite=($Suites)                # 读到数组变量中.
32 denomination=($Denominations)
33 
34 num_suites=${#suite[*]}        # 计算有多少个元素.
35 num_denominations=${#denomination[*]}
36 
37 echo -n "${denomination[$((RANDOM%num_denominations))]} of "
38 echo ${suite[$((RANDOM%num_suites))]}
39 
40 
41 # $bozo sh pick-cards.sh
42 # Jack of Clubs
43 
44 
45 # Thank you, "jipe," for pointing out this use of $RANDOM.
46 exit 0
################################End Script######################################### 
Jipe展示了一系列的在一定范围中产生随机数的方法.
 1 #  在6到30之间产生随机数.
 2    rnumber=$((RANDOM%25+6)) 
 3 
 4 #  还是产生6-30之间的随机数,
 5 #+ 但是这个数字必须被3均分.
 6    rnumber=$(((RANDOM%30/3+1)*3))
 7 
 8 #  注意,这可能不会在所有时候都能正常地运行.
 9 #  It fails if $RANDOM returns 0.
10 
11 #  Frank Wang 建议用下班的方法来取代:
12    rnumber=$(( RANDOM%27/3*3+6 )) 
Bill Gradwohl 提出了一个重要的规则来产生正数.
1 rnumber=$(((RANDOM%(max-min+divisibleBy))/divisibleBy*divisibleBy+min)) 
这里Bill给出了一个通用函数,这个函数返回一个在两个指定值之间的随机数 
Example 9-26 两个指定值之间的随机数
################################Start Script#######################################
  1 #!/bin/bash
  2 # random-between.sh
  3 # 在两个指定值之间的随机数.
  4 # Bill Gradwohl编写的本脚本,本文作者作了较小的修改.
  5 # 允许使用.
  6 
  7 
  8 randomBetween() {
  9    #  产生一个正的或者负的随机数.
 10    #+ 在$max和$max之间
 11    #+ 并且可被$divisibleBy整除的.
 12    #  给出一个合理的随机分配的返回值.
 13    #
 14    #  Bill Gradwohl - Oct 1, 2003
 15 
 16    syntax() {
 17    # 在函数中内嵌函数
 18       echo
 19       echo    "Syntax: randomBetween [min] [max] [multiple]"
 20       echo
 21       echo    "Expects up to 3 passed parameters, but all are completely optional."
 22       echo    "min is the minimum value"
 23       echo    "max is the maximum value"
 24       echo    "multiple specifies that the answer must be a multiple of this value."
 25       echo    "    i.e. answer must be evenly divisible by this number."
 26       echo    
 27       echo    "If any value is missing, defaults area supplied as: 0 32767 1"
 28       echo    "Successful completion returns 0, unsuccessful completion returns"
 29       echo    "function syntax and 1."
 30       echo    "The answer is returned in the global variable randomBetweenAnswer"
 31       echo    "Negative values for any passed parameter are handled correctly."
 32    }
 33 
 34    local min=${1:-0}
 35    local max=${2:-32767}
 36    local divisibleBy=${3:-1}
 37    # 默认值分配,用来处理没有参数传递进来的时候.
 38 
 39    local x
 40    local spread
 41 
 42    # 确认divisibleBy是正值.
 43    [ ${divisibleBy} -lt 0 ] && divisibleBy=$((0-divisibleBy))
 44 
 45    # 完整性检查.
 46    if [ $# -gt 3 -o ${divisibleBy} -eq 0 -o  ${min} -eq ${max} ]; then 
 47       syntax
 48       return 1
 49    fi
 50 
 51    # 察看是否min和max颠倒了.
 52    if [ ${min} -gt ${max} ]; then
 53       # 交换它们.
 54       x=${min}
 55       min=${max}
 56       max=${x}
 57    fi
 58 
 59    #  如果min自己并不能够被$divisibleBy整除,
 60    #+ 那么就调整min的值,使其能够被$divisibleBy整除,前提是不能放大范围.
 61    if [ $((min/divisibleBy*divisibleBy)) -ne ${min} ]; then 
 62       if [ ${min} -lt 0 ]; then
 63          min=$((min/divisibleBy*divisibleBy))
 64       else
 65          min=$((((min/divisibleBy)+1)*divisibleBy))
 66       fi
 67    fi
 68 
 69    #  如果min自己并不能够被$divisibleBy整除,
 70    #+ 那么就调整max的值,使其能够被$divisibleBy整除,前提是不能放大范围.
 71    if [ $((max/divisibleBy*divisibleBy)) -ne ${max} ]; then 
 72       if [ ${max} -lt 0 ]; then
 73          max=$((((max/divisibleBy)-1)*divisibleBy))
 74       else
 75          max=$((max/divisibleBy*divisibleBy))
 76       fi
 77    fi
 78 
 79    #  ---------------------------------------------------------------------
 80    #  现在,来做真正的工作.
 81 
 82    #  注意,为了得到对于端点来说合适的分配,
 83    #+ 随机值的范围不得不落在
 84    #+ 0 和 abs(max-min)+divisibleBy之间, 而不是 abs(max-min)+1.
 85 
 86    #  对于端点来说,
 87    #+ 这个少量的增加将会产生合适的分配.
 88 
 89    #  修改这个公式,使用abs(max-min)+1来代替abs(max-min)+divisibleBy的话,
 90    #+ 也能够产生正确的答案, 但是在这种情况下生成的随机值对于正好为端点倍数
 91    #+ 的这种情况来说将是不完美的,因为在正好为端点倍数的情况的随机率比较低,
 92    #+ 因为你才加1而已,这比正常的公式所产生的机率要小得多(正常为加divisibleBy)
 93    #  ---------------------------------------------------------------------
 94 
 95    spread=$((max-min))
 96    [ ${spread} -lt 0 ] && spread=$((0-spread))
 97    let spread+=divisibleBy
 98    randomBetweenAnswer=$(((RANDOM%spread)/divisibleBy*divisibleBy+min))
 99 
100    return 0
101 
102    #  然而,Paulo Marcel Coelho Aragao指出
103    #+ 当$max和$min不能被$divisibleBy整除时,
104    #+ 这个公式将会失败.
105    #
106    #  他建议使用如下的公式:
107    #    rnumber = $(((RANDOM%(max-min+1)+min)/divisibleBy*divisibleBy))
108 
109 }
110 
111 # 让我们测试一下这个函数.
112 min=-14
113 max=20
114 divisibleBy=3
115 
116 
117 #  产生一个数组answers,answers的下标用来表示在范围内可能出现的值,
118 #+ 而内容记录的是对于这个值出现的次数,如果我们循环足够多次,一定会得到
119 #+ 一次出现机会.
120 declare -a answer
121 minimum=${min}
122 maximum=${max}
123    if [ $((minimum/divisibleBy*divisibleBy)) -ne ${minimum} ]; then 
124       if [ ${minimum} -lt 0 ]; then
125          minimum=$((minimum/divisibleBy*divisibleBy))
126       else
127          minimum=$((((minimum/divisibleBy)+1)*divisibleBy))
128       fi
129    fi
130 
131 
132    #  如果maximum自己并不能够被$divisibleBy整除,
133    #+ 那么就调整maximum的值,使其能够被$divisibleBy整除,前提是不能放大范围.
134 
135    if [ $((maximum/divisibleBy*divisibleBy)) -ne ${maximum} ]; then 
136       if [ ${maximum} -lt 0 ]; then
137          maximum=$((((maximum/divisibleBy)-1)*divisibleBy))
138       else
139          maximum=$((maximum/divisibleBy*divisibleBy))
140       fi
141    fi
142 
143 
144 #  我们需要产生一个下标全为正的数组,
145 #+ 所以我们需要一个displacement来保正都为正的结果.
146
147 
148 displacement=$((0-minimum))
149 for ((i=${minimum}; i<=${maximum}; i+=divisibleBy)); do
150    answer[i+displacement]=0
151 done
152 
153 
154 # 现在我们循环足够多的次数来得到我们想要的答案.
155 loopIt=1000   #  脚本作者建议 100000,
156               #+ 但是这实在是需要太长的时间了.
157 
158 for ((i=0; i<${loopIt}; ++i)); do
159 
160    #  注意,我们在这里调用randomBetween函数时,故意将min和max颠倒顺序
161    #+ 我们是为了测试在这种情况下,此函数是否还能得到正确的结果.
162 
163    randomBetween ${max} ${min} ${divisibleBy}
164 
165    # 如果答案不是我们所预期的,那么就报告一个错误.
166    [ ${randomBetweenAnswer} -lt ${min} -o ${randomBetweenAnswer} -gt ${max} ] && echo MIN or MAX error - ${randomBetweenAnswer}!
167    [ $((randomBetweenAnswer%${divisibleBy})) -ne 0 ] && echo DIVISIBLE BY error - ${randomBetweenAnswer}!
168 
169    # 将统计值存到answer之中.
170    answer[randomBetweenAnswer+displacement]=$((answer[randomBetweenAnswer+displacement]+1))
171 done
172 
173 
174 
175 # 让我们察看一下结果
176 
177 for ((i=${minimum}; i<=${maximum}; i+=divisibleBy)); do
178    [ ${answer[i+displacement]} -eq 0 ] && echo "We never got an answer of $i." || echo "${i} occurred ${answer[i+displacement]} times."
179 done
180 
181 
182 exit 0
################################End Script######################################### 
$RANDOM到底有多随机?最好的办法就是写个脚本来测试一下.跟踪随机数的分配情况.
让我们用随机数摇一个骰子.
Example 9-27 使用随机数来摇一个骰子
################################Start Script#######################################
 1 #!/bin/bash
 2 # RANDOM到底有多random?
 3 
 4 RANDOM=$$       # 使用脚本的进程ID来作为随机数的产生种子.
 5 
 6 PIPS=6          # 一个骰子有6面.
 7 MAXTHROWS=600   # 如果你没别的事干,那么可以增加这个数值.
 8 throw=0         # 抛骰子的次数.
 9 
10 ones=0          #  必须把所有count都初始化为0,
11 twos=0          #+ 因为未初始化的变量为null,不是0.
12 threes=0
13 fours=0
14 fives=0
15 sixes=0
16 
17 print_result ()
18 {
19 echo
20 echo "ones =   $ones"
21 echo "twos =   $twos"
22 echo "threes = $threes"
23 echo "fours =  $fours"
24 echo "fives =  $fives"
25 echo "sixes =  $sixes"
26 echo
27 }
28 
29 update_count()
30 {
31 case "$1" in
32   0) let "ones += 1";;   # 因为骰子没有0,所以给1.
33   1) let "twos += 1";;   # 对tows做同样的事.
34   2) let "threes += 1";;
35   3) let "fours += 1";;
36   4) let "fives += 1";;
37   5) let "sixes += 1";;
38 esac
39 }
40 
41 echo
42 
43 
44 while [ "$throw" -lt "$MAXTHROWS" ]
45 do
46   let "die1 = RANDOM % $PIPS"
47   update_count $die1
48   let "throw += 1"
49 done  
50 
51 print_result
52 
53 exit 0
54 
55 #  如果RANDOM是真正的随机,那么摇出来结果应该平均的.
56 #  $MAXTHROWS设为600,那么每面都应该为100,上下的出入不应该超过20.
57 #
58 #  记住RANDOM毕竟只是一个伪随机数,
59 #+ 并且不是十分完美的.
60 
61 #  随机数的产生是一个深奥并复杂的问题.
62 #  足够长的随机序列,不但会展现杂乱无章的一面,
63 #+ 而且会展现机会均等的一面.
64 
65 # 一个很简单的练习:
66 # -----------------
67 # 重写这个例子,做成抛1000次硬币的形式.
68 # 分为正反两面.
################################End Script#########################################
像我们在上边的例子中看到的,最好在每次随机数产生时都使用新的种子.应为如果使用同样的
种子的话,那么随机数将产生相同的序列.[2](C中random()函数也会有这样的行为) 
Example 9-28 重新分配随机数种子
################################Start Script#######################################
 1 #!/bin/bash
 2 # seeding-random.sh: 设置RANDOM变量作为种子.
 3 
 4 MAXCOUNT=25       # 决定产生多少个随机数.
 5 
 6 random_numbers ()
 7 {
 8 count=0
 9 while [ "$count" -lt "$MAXCOUNT" ]
10 do
11   number=$RANDOM
12   echo -n "$number "
13   let "count += 1"
14 done  
15 }
16 
17 echo; echo
18 
19 RANDOM=1          # 为随机数的产生设置RANDOM种子.
20 random_numbers
21 
22 echo; echo
23 
24 RANDOM=1          # 设置同样的种子...
25 random_numbers    # ...将会和上边产生的随机数列相同.
26                   #
27                   # 复制一个相同的随机数序列在什么时候有用呢?
28 
29 echo; echo
30 
31 RANDOM=2          # 再试一下,但这次使用不同的种子...
32 random_numbers    # 将给出一个不同的随机数序列.
33 
34 echo; echo
35 
36 # RANDOM=$$  使用脚本的进程id 作为随机数的种子.
37 # 从'time'或'date'命令中取得RANDOM作为种子也是很常用的办法.
38 
39 # 一个有想象力的方法...
40 SEED=$(head -1 /dev/urandom | od -N 1 | awk '{ print $2 }')
41 #  首先从/dev/urandom(系统伪随机设备文件)中取出1行,
42 #+ 然后着这个可打印行转换为(8进制)数,通过使用"od"命令,
43 #+ 最后使用"awk"来获得一个数,
44 #+ 这个数将作为随机数产生的种子.
45 RANDOM=$SEED
46 random_numbers
47 
48 echo; echo
49 
50 exit 0
################################End Script#########################################
注意:/dev/urandom设备文件提供了一种比单独使用$RANDOM更好的,能产生更"随机"的随机数
 的方法.
 dd if=/dev/urandom of=targetfile bs=1 count=XX能够产生一个很分散的为随机数.
 然而,将这个数赋值到一个脚本文件的变量中,还需要可操作性,比如使用"od"命令
 (就像上边的例子,见Example 12-13),或者使用dd命令(见Example 12-55),或者管道到
 "md5sum"命令中(见Example 33-14).
 
 当然还有其它的产生伪随机数的方法.Awk就可以提供一个方便的方法.
Example 9-29 使用awk产生伪随机数
################################Start Script#######################################
 1 #!/bin/bash
 2 # random2.sh: 产生一个范围0 - 1的为随机数.
 3 # 使用awk的rand()函数.
 4 
 5 AWKSCRIPT=' { srand(); print rand() } '
 6 #            Command(s) / 传到awk中的参数
 7 # 注意,srand()函数用来产生awk的随机数种子.
 8 
 9 
10 echo -n "Random number between 0 and 1 = "
11 
12 echo | awk "$AWKSCRIPT"
13 # 如果你省去'echo'那么将发生什么?
14 
15 exit 0
16 
17 
18 # Exercises:
18 # 练习:
19 # -----
20 
21 # 1) 使用循环结构,打印出10个不同的随机数.
22 #      (提示: 在循环的每次执行过程中,你必须使用"srand()"函数来生成不同的
23 #+     种子.如果你没做这件事那么将发生什么?
24 
25 # 2) 使用一个整数乘法作为一个放缩因子,在10到100的范围之间,
26 #+   来产生随机数.
27 
28 # 3) 同上边的练习 #2,但这次产生随机整数.
################################End Script#########################################
 "data"命令也可以用来产生伪随机整数序列. 
注意事项:
[1]  真正的随机事件(在它存在的范围内),只发生在特定的几个未知的自然界现象中,比如
  放射性衰变.计算机只能产生模拟的随机事件,并且计算机产生的"随机"数因此只能称
  为伪随机数.
[2]  计算机产生的伪随机数序列用的种子可以被看成是一种标识标签.比如,使用种子23所
  产生的伪随机数序列就被称作序列#23.
  
  一个伪随机序列的特点就是在这个序列开始重复之前的所有元素的个数的和,也就是
  这个序列的长度.一个好的伪随机产生算法将可以产生一个非常长的不重复的序列. 
9.7 双圆括号结构
----------------
((...))与let命令很像,允许算术扩展和赋值.举个简单的例子a=$(( 5 + 3 )),将把a设为
"5+3"或者8.然而,双圆括号也是一种在Bash中允许使用C风格的变量处理的机制. Example 9-30 C风格的变量处理
################################Start Script#######################################
   1 #!/bin/bash
   2 # 处理一个变量,C风格,使用((...))结构.
   3 
   4 
   5 echo
   6 
   7 (( a = 23 ))  # 给一个变量赋值,从"="两边的空格就能看出这是c风格的处理.
   8 echo "a (initial value) = $a"
   9 
  10 (( a++ ))     # 变量'a'后加1,C风格.
  11 echo "a (after a++) = $a"
  12 
  13 (( a-- ))     # 变量'a'后减1,C风格.
  14 echo "a (after a--) = $a"
  15 
  16 
  17 (( ++a ))     # 变量'a'预加1,C风格.
  18 echo "a (after ++a) = $a"
  19 
  20 (( --a ))     # 变量'a'预减1,C风格.
  21 echo "a (after --a) = $a"
  22 
  23 echo
  24 
  25 ########################################################
  26 #  注意:在C语言中,预减和后减操作
  27 #+ 会有些不同的副作用.
  28 
  29 n=1; let --n && echo "True" || echo "False"  # False
  30 n=1; let n-- && echo "True" || echo "False"  # True
  31 
  32 #  Thanks, Jeroen Domburg.
  33 ########################################################
  34 
  35 echo
  36 
  37 (( t = a<45?7:11 ))   # C风格的3元操作.
  38 echo "If a < 45, then t = 7, else t = 11."
  39 echo "t = $t "        # Yes!
  40 
  41 echo
  42 
  43 
  44 # ----------------
  45 # 复活节彩蛋注意!
  46 # ----------------
  47 #  Chet Ramey 显然的偷偷摸摸的做了一些未公开的C风格的结构
  48 #+ 放在Bash中(准确地说是根据ksh来改写的,这更接近些)
  49 #  在Bash文档中,Ramey调用((...))shell算法,
  50 #+ 但是它可以走得更远.
  51 #  对不起, Chet, 现在秘密被公开了.
  52 
  53 # See also "for" and "while" loops using the ((...)) construct.
  53 # 也参考一些"for"和"while"循环中使用((...))结构的例子.
  54 
  55 # 这些只能工作在2.04或者更高版本的Bash中.
  56 
  57 exit 0
################################End Script#########################################
见Example 10-12. 
[]     
    
高级Bash脚本编程指南(三)（上）
文章整理: 文章来源: 网络 
高级Bash脚本编程指南(三) 
 第10章 循环和分支
==================
对代码块进行操作是有组织的结构化的shell脚本的关键.为了达到这个目的,循环和分支提供
帮助. 
10.1 循环
---------
循环就是重复一些命令的代码块,如果条件不满足就退出循环. 
for loops 
for arg in [list]
 这是一个基本的循环结构.它与C的相似结构有很大不同. 
 for arg in [list]
 do
  command(s)...
 done 
 注意:在循环的每次执行中,arg将顺序的存取list中列出的变量.
 1 for arg in "$var1" "$var2" "$var3" ... "$varN"  
 2 # 在第1次循环中, arg = $var1     
 3 # 在第2次循环中, arg = $var2     
 4 # 在第3次循环中, arg = $var3     
 5 # ...
 6 # 在第n次循环中, arg = $varN
 7 
 8 # 在[list]中的参数加上双引号是为了阻止单词分离. 
 list中的参数允许包含通配符.
 如果do和for想在同一行出现,那么在它们之间需要添加一个";".
 for arg in [list]; do 
Example 10-1 循环的一个简单例子
################################Start Script#######################################
 1 #!/bin/bash
 2 # 列出所有行星.
 3 
 4 for planet in Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto
 5 do
 6   echo $planet  # Each planet on a separate line.
 7 done
 8 
 9 echo
10 
11 for planet in "Mercury Venus Earth Mars Jupiter Saturn Uranus Neptune Pluto"
12 # 所有的行星都在同一行上.
13 # 完整的'list'作为一个变量都封在""中
14 do
15   echo $planet
16 done
17 
18 exit 0
################################End Script######################################### 
 注意:每个[list]中的元素都可能包含多个参数.在处理参数组时,这是非常有用的.
  在这种情况下,使用set命令(见Example 11-15)来强制解析每个[list]中的元素,
  并且分配每个解析出来的部分到一个位置参数中. 
Example 10-2 每个[list]元素带两个参数的for循环
################################Start Script#######################################
 1 #!/bin/bash
 2 # 还是行星.
 3 
 4 # 分配行星的名字和它距太阳的距离.
 5 
 6 for planet in "Mercury 36" "Venus 67" "Earth 93"  "Mars 142" "Jupiter 483"
 7 do
 8   set -- $planet  # 解析变量"planet"并且设置位置参数.
 9   # "--" 将防止$planet为空,或者是以一个破折号开头.
10 
11   # 可能需要保存原始的位置参数,因为它们被覆盖了.
12   # 一种方法就是使用数组,
13   #        original_params=("$@")
14 
15   echo "$1  $2,000,000 miles from the sun"
16   #-------two  tabs---把后边的0和$2连接起来
17 done
18 
19 # (Thanks, S.C., for additional clarification.)
20 
21 exit 0
################################End Script######################################### 
 可以在for循环中的[list]位置放入一个变量 
Example 10-3 文件信息:对包含在变量中的文件列表进行操作
################################Start Script#######################################
 1 #!/bin/bash
 2 # fileinfo.sh
 3 
 4 FILES="/usr/sbin/accept
 5 /usr/sbin/pwck
 6 /usr/sbin/chroot
 7 /usr/bin/fakefile
 8 /sbin/badblocks
 9 /sbin/ypbind"     # 你关心的文件列表.
10                   # 扔进去一个假文件, /usr/bin/fakefile.
11 
12 echo
13 
14 for file in $FILES
15 do
16 
17   if [ ! -e "$file" ]       # 检查文件是否存在.
18   then
19     echo "$file does not exist."; echo
20     continue                # 继续下一个.
21    fi
22 
23   ls -l $file | awk '{ print $9 "         file size: " $5 }'  # 打印2个域.
24   whatis `basename $file`   # 文件信息.
25   # 注意whatis数据库需要提前建立好.
26   # 要想达到这个目的, 以root身份运行/usr/bin/makewhatis.
27   echo
28 done  
29 
30 exit 0
################################End Script######################################### 
 如果在for循环的[list]中有通配符(*和?),那将会产生文件名扩展,也就是file globbing.
Example 10-4 在for循环中操作文件
################################Start Script#######################################
 1 #!/bin/bash
 2 # list-glob.sh: 产生 [list] 在for循环中, 使用 "globbing"
 3 
 4 echo
 5 
 6 for file in *
 7 #           ^  在表达式中识别file globbing时,
 8 #+             Bash 将执行文件名扩展
 9 do
10   ls -l "$file"  # 列出所有在$PWD(当前目录)中的所有文件.
11   #  回想一下,通配符"*"能够匹配所有文件,
12   #+ 然而,在"globbing"中,是不能比配"."文件的.
13 
14   #  If the pattern matches no file, it is expanded to itself.
14   #  如果没匹配到任何文件,那它将扩展成自己.
15   #  为了不让这种情况发生,那就设置nullglob选项
16   #+   (shopt -s nullglob).
17   #  Thanks, S.C.
18 done
19 
20 echo; echo
21 
22 for file in [jx]*
23 do
24   rm -f $file    # 只删除当前目录下以"j"或"x"开头的文件.
25   echo "Removed file \"$file\"".
26 done
27 
28 echo
29 
30 exit 0
################################End Script######################################### 
 在一个for循环中忽略[list]的话,将会使循环操作$@(从命令行传递给脚本的参数列表).
 一个非常好的例子,见Example A-16.
Example 10-5 在for循环中省略[list]
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 #  使用两种方法来调用这个脚本,一种是带参数的情况,另一种不带参数.
 4 #+ 观察此脚本的行为各是什么样的?
 5 
 6 for a
 7 do
 8  echo -n "$a "
 9 done
10 
11 #  The 'in list' missing, therefore the loop operates on '$@'
11 #  没有[list],所以循环将操作'$@'
12 #+ (包括空白的命令参数列表).
13 
14 echo
15 
16 exit 0
################################End Script######################################### 
 也可以使用命令替换来产生for循环的[list].具体见Example 12-49,Example 10-10,
 和Example 12-43.
Example 10-6 使用命令替换来产生for循环的[list]
################################Start Script#######################################
 1 #!/bin/bash
 2 #  for-loopcmd.sh: 带[list]的for循环
 3 #+ [list]是由命令替换产生的.
 4 
 5 NUMBERS="9 7 3 8 37.53"
 6 
 7 for number in `echo $NUMBERS`  # for number in 9 7 3 8 37.53
 8 do
 9   echo -n "$number "
10 done
11 
12 echo 
13 exit 0
################################End Script#########################################
 下边是一个用命令替换来产生[list]的更复杂的例子.
Example 10-7 对于二进制文件的一个grep替换
################################Start Script#######################################
 1 #!/bin/bash
 2 # bin-grep.sh: 在一个二进制文件中定位匹配字串.
 3 
 4 # 对于二进制文件的一个grep替换
 5 # 与"grep -a"的效果相似
 6 
 7 E_BADARGS=65
 8 E_NOFILE=66
 9 
10 if [ $# -ne 2 ]
11 then
12   echo "Usage: `basename $0` search_string filename"
13   exit $E_BADARGS
14 fi
15 
16 if [ ! -f "$2" ]
17 then
18   echo "File \"$2\" does not exist."
19   exit $E_NOFILE
20 fi  
21 
22 
23 IFS="\n"         # 由Paulo Marcel Coelho Aragao提出的建议.
24 for word in $( strings "$2" | grep "$1" )
25 # "strings" 命令列出二进制文件中的所有字符串.
26 # 输出到管道交给"grep",然后由grep命令来过滤字符串.
27 do
28   echo $word
29 done
30 
31 # S.C. 指出, 行23 - 29 可以被下边的这行来代替,
32 #    strings "$2" | grep "$1" | tr -s "$IFS" '[\n*]'
33 
34 
35 # 试试用"./bin-grep.sh mem /bin/ls"来运行这个脚本.
36 
37 exit 0
################################End Script#########################################
 大部分相同.
Example 10-8 列出系统上的所有用户
################################Start Script#######################################
 1 #!/bin/bash
 2 # userlist.sh
 3 
 4 PASSWORD_FILE=/etc/passwd
 5 n=1           # User number
 6 
 7 for name in $(awk 'BEGIN{FS=":"}{print $1}' < "$PASSWORD_FILE" )
 8 # 域分隔   = :           ^^^^^^
 9 # 打印出第一个域                 ^^^^^^^^
10 # 从password文件中取得输入                   ^^^^^^^^^^^^^^^^^
11 do
12   echo "USER #$n = $name"
13   let "n += 1"
14 done  
15 
16 
17 # USER #1 = root
18 # USER #2 = bin
19 # USER #3 = daemon
20 # ...
21 # USER #30 = bozo
22 
23 exit 0
24 
25 #  练习 :
26 #  ------
27 #  一个普通用户(或者是一个普通用户运行的脚本)
28 #+ 怎么能读取/etc/password呢?
29 #  这是否是一个安全漏洞? 为什么是?为什么不是?
################################End Script#########################################
 关于用命令替换来产生[list]的最后的例子.
Example 10-9 在目录的所有文件中查找源字串
################################Start Script#######################################
 1 #!/bin/bash
 2 # findstring.sh:
 3 # 在一个指定目录的所有文件中查找一个特定的字符串.
 4 
 5 directory=/usr/bin/
 6 fstring="Free Software Foundation"  # 查看那个文件中包含FSF.
 7 
 8 for file in $( find $directory -type f -name '*' | sort )
 9 do
10   strings -f $file | grep "$fstring" | sed -e "s%$directory%%"
11   #  在"sed"表达式中,
12   #+ 我们必须替换掉正常的替换分隔符"/",
13   #+ 因为"/"碰巧是我们需要过滤的字串之一.
14   #  如果不用"%"代替"/"作为分隔符,那么这个操作将失败,并给出一个错误消息.(试试)
15 done  
16 
17 exit 0
18 
19 #  练习 (easy):
20 #  ------------
21 #  将内部用的$directory和$fstring变量,用从
22 #+ 命令行参数代替.
################################End Script######################################### 
 for循环的输出也可以通过管道传递到一个或多个命令中.
Example 10-10 列出目录中所有的符号连接文件
################################Start Script#######################################
 1 #!/bin/bash
 2 # symlinks.sh: 列出目录中所有的符号连接文件.
 3 
 4 
 5 directory=${1-`pwd`}
 6 #  如果没有其他的特殊指定,
 7 #+ 默认为当前工作目录.
 8 #  下边的代码块,和上边这句等价.
 9 # ----------------------------------------------------------
10 # ARGS=1                 # 需要一个命令行参数.
11 #
12 # if [ $# -ne "$ARGS" ]  # 如果不是一个参数的话...
13 # then
14 #   directory=`pwd`      # 当前工作目录
15 # else
16 #   directory=$1
17 # fi
18 # ----------------------------------------------------------
19 
20 echo "symbolic links in directory \"$directory\""
21 
22 for file in "$( find $directory -type l )"   # -type l 就是符号连接文件
23 do
24   echo "$file"
25 done | sort                                  # 否则列出的文件将是未排序的
26 #  严格上说,此处并不一定非要一个循环不可,
27 #+ 因为"find"命令的结果将被扩展成一个单词.
28 #  然而,这种方式很容易理解和说明.
29 
30 #  Dominik 'Aeneas' Schnitzer 指出,
31 #+ 如果没将 $( find $directory -type l )用""引用起来的话
32 #+ 那么将会把一个带有空白部分的文件名拆成以空白分隔的两部分(文件名中允许有空白).
33 #  即使这只将取出每个参数的第一个域.
34 
35 exit 0
36 
37 
38 # Jean Helou 建议使用下边的方法:
39 
40 echo "symbolic links in directory \"$directory\""
41 # 当前IFS的备份.要小心使用这个值.
42 OLDIFS=$IFS
43 IFS=:
44 
45 for file in $(find $directory -type l -printf "%p$IFS")
46 do     #                              ^^^^^^^^^^^^^^^^
47        echo "$file"
48        done|sort
################################End Script######################################### 
 循环的输出可以重定向到文件中,我们对上边的例子做了一点修改.
Example 10-11 将目录中的符号连接文件名保存到一个文件中
################################Start Script#######################################
 1 #!/bin/bash
 2 # symlinks.sh: 列出目录中所有的符号连接文件.
 3 
 4 OUTFILE=symlinks.list                         # 保存的文件
 5 
 6 directory=${1-`pwd`}
 7 #  如果没有其他的特殊指定,
 8 #+ 默认为当前工作目录.
 9 
10 
11 echo "symbolic links in directory \"$directory\"" > "$OUTFILE"
12 echo "---------------------------" >> "$OUTFILE"
13 
14 for file in "$( find $directory -type l )"    # -type l 为符号链接
15 do
16   echo "$file"
17 done | sort >> "$OUTFILE"                     # 循环的输出
18 #           ^^^^^^^^^^^^^                       重定向到一个文件中
19 
20 exit 0
################################End Script######################################### 
 有一种非常像C语言的for循环的语法形式.这需要使用(()).
Example 10-12 一个C风格的for循环
################################Start Script#######################################
 1 #!/bin/bash
 2 # 两种循环到10的方法.
 3 
 4 echo
 5 
 6 # 标准语法.
 7 for a in 1 2 3 4 5 6 7 8 9 10
 8 do
 9   echo -n "$a "
10 done  
11 
12 echo; echo
13 
14 # +==========================================+
15 
16 # 现在, 让我们用C风格的语法做同样的事.
17 
18 LIMIT=10
19 
20 for ((a=1; a <= LIMIT ; a++))  # Double parentheses, and "LIMIT" with no "$".
20 for ((a=1; a <= LIMIT ; a++))  # 双圆括号, 并且"LIMIT"变量前边没有 "$".
21 do
22   echo -n "$a "
23 done                           # 这是一个借用'ksh93'的结构.
24 
25 echo; echo
26 
27 # +=========================================================================+
28 
29 # 让我们使用C的逗号操作符,来同时增加两个变量的值.
30 
31 for ((a=1, b=1; a <= LIMIT ; a++, b++))  # 逗号将同时进行2条操作.
32 do
33   echo -n "$a-$b "
34 done
35 
36 echo; echo
37 
38 exit 0
################################End Script#########################################
 参考Example 26-15,Example 26-16,和Example A-6.
 ---
 现在来一个现实生活中使用的for循环.
Example 10-13 在batch mode中使用efax
################################Start Script#######################################
 1 #!/bin/bash
 2 # Faxing ('fax' 必须已经被安装过了).
 3 
 4 EXPECTED_ARGS=2
 5 E_BADARGS=65
 6 
 7 if [ $# -ne $EXPECTED_ARGS ]
 8 # 检查命令行参数的个数是否正确.
 9 then
10    echo "Usage: `basename $0` phone# text-file"
11    exit $E_BADARGS
12 fi
13 
14 
15 if [ ! -f "$2" ]
16 then
17   echo "File $2 is not a text file"
18   exit $E_BADARGS
19 fi
20   
21 
22 fax make $2              # 从文本文件中创建传真格式的文件.
23 
24 for file in $(ls $2.0*)  # 连接转换过的文件.
25                          # 在变量列表中使用通配符.
26 do
27   fil="$fil $file"
28 done  
29 
30 efax -d /dev/ttyS3 -o1 -t "T$1" $fil   # 干活的地方.
31 
32 
33 # S.C. 指出, 通过下边的命令可以省去for循环.
34 #    efax -d /dev/ttyS3 -o1 -t "T$1" $2.0*
35 # 但这并不十分有讲解意义[嘿嘿].
36 
37 exit 0
################################End Script######################################### 
while
 这种结构在循环的开头判断条件是否满足,如果条件一直满足,那就一直循环下去(0为退出
 码).与for循环的区别是,这种结构适合用在循环次数未知的情况下. 
 while [condition]
 do
  command...
 done 
 和for循环一样,如果想把do和条件放到同一行上还是需要一个";". 
 while [condition]; do 
 注意一下某种特定的while循环,比如getopts结构,好像和这里所介绍的模版有点脱节. 
Example 10-14 简单的while循环
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 var0=0
 4 LIMIT=10
 5 
 6 while [ "$var0" -lt "$LIMIT" ]
 7 do
 8   echo -n "$var0 "        # -n 将会阻止产生新行.
 9   #             ^           空格,数字之间的分隔.
10 
11   var0=`expr $var0 + 1`   # var0=$(($var0+1))  也可以.
12                           # var0=$((var0 + 1)) 也可以.
13                           # let "var0 += 1"    也可以.
14 done                      # 使用其他的方法也行.
15 
16 echo
17 
18 exit 0
################################End Script######################################### 
Example 10-15 另一个while循环
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 echo
 4                                # 等价于:
 5 while [ "$var1" != "end" ]     # while test "$var1" != "end"
 6 do
 7   echo "Input variable #1 (end to exit) "
 8   read var1                    # 为什么不使用'read $var1'?
 9   echo "variable #1 = $var1"   # 因为包含"#"字符,所以需要""
10   # 如果输入为'end',那么就在这里echo.
11   # 不在这里判断结束,在循环顶判断.
12   echo
13 done  
14 
15 exit 0
################################End Script######################################### 
 一个while循环可以有多个判断条件,但是只有最后一个才能决定是否退出循环.然而这需
 要一种有点不同的循环语法.
Example 10-16 多条件的while循环
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 var1=unset
 4 previous=$var1
 5 
 6 while echo "previous-variable = $previous"
 7       echo
 8       previous=$var1
 9       [ "$var1" != end ] # 记录之前的$var1.
10       # 这个"while"循环中有4个条件, 但是只有最后一个能控制循环.
11       # 退出状态由第4个条件决定.
12 do
13 echo "Input variable #1 (end to exit) "
14   read var1
15   echo "variable #1 = $var1"
16 done  
17 
18 # 尝试理解这个脚本的运行过程.
19 # 这里还是有点小技巧的.
20 
21 exit 0
################################End Script######################################### 
 与for循环一样,while循环也可通过(())来使用C风格语法.(见Example 9-30)
Example 10-17 C风格的while循环
################################Start Script#######################################
 1 #!/bin/bash
 2 # wh-loopc.sh: 循环10次的while循环.
 3 
 4 LIMIT=10
 5 a=1
 6 
 7 while [ "$a" -le $LIMIT ]
 8 do
 9   echo -n "$a "
10   let "a+=1"
11 done           # 到目前为止都没什么令人惊奇的地方.
12 
13 echo; echo
14 
15 # +=================================================================+
16 
17 # 现在, 重复C风格的语法.
18 
19 ((a = 1))      # a=1
20 # 双圆括号允许赋值两边的空格,就像C语言一样.
21 
22 while (( a <= LIMIT ))   # 双圆括号, 变量前边没有"$".
23 do
24   echo -n "$a "
25   ((a += 1))   # let "a+=1"
26   # Yes, 看到了吧.
27   # 双圆括号允许像C风格的语法一样增加变量的值.
28 done
29 
30 echo
31 
32 # 现在,C程序员可以在Bash中找到回家的感觉了吧.
33 
34 exit 0
################################End Script#########################################
 注意:while循环的stdin可以用<来重定向到文件.
  whild循环的stdin支持管道. 
until
 这个结构在循环的顶部判断条件,并且如果条件一直为false那就一直循环下去.(与while
 相反) 
 until [condition-is-true]
 do
  command...
 done 
 注意: until循环的判断在循环的顶部,这与某些编程语言是不同的. 
 与for循环一样,如果想把do和条件放在一行里,就使用";". 
 until [condition-is-true]; do 
Example 10-18 until循环
################################Start Script#######################################
1 #!/bin/bash
2 
3 END_CONDITION=end
4 
5 until [ "$var1" = "$END_CONDITION" ]
6 # 在循环的顶部判断条件.
7 do
8   echo "Input variable #1 "
 9   echo "($END_CONDITION to exit)"
10   read var1
11   echo "variable #1 = $var1"
12   echo
13 done  
14 
15 exit 0
################################End Script######################################### 
  
10.2 嵌套循环
-------------
嵌套循环就是在一个循环中还有一个循环,内部循环在外部循环体中.在外部循环的每次执行过
程中都会触发内部循环,直到内部循环执行结束.外部循环执行了多少次,内部循环就完成多少
次.当然,不论是外部循环或内部循环的break语句都会打断处理过程. 
Example 10-19 嵌套循环
################################Start Script#######################################
 1 #!/bin/bash
 2 # nested-loop.sh: 嵌套的"for" 循环.
 3 
 4 outer=1             # 设置外部循环计数.
 5 
 6 # 开始外部循环.
 7 for a in 1 2 3 4 5
 8 do
 9   echo "Pass $outer in outer loop."
10   echo "---------------------"
11   inner=1           # 重设内部循环的计数.
12 
13   # ===============================================
14   # 开始内部循环.
15   for b in 1 2 3 4 5
16   do
17     echo "Pass $inner in inner loop."
18     let "inner+=1"  # 增加内部循环计数.
19   done
20   # 内部循环结束.
21   # ===============================================
22 
23   let "outer+=1"    # 增加外部循环的计数.
24   echo              # 每次外部循环之间的间隔.
25 done               
26 # 外部循环结束.
27 
28 exit 0
################################End Script######################################### 
  
10.3 循环控制
-------------
影响循环行为的命令 
break,continue
 break和continue这两个循环控制命令[1]与其它语言的类似命令的行为是相同的.break
 命令将会跳出循环,continue命令将会跳过本次循环下边的语句,直接进入下次循环. 
Example 10-20 break和continue命令在循环中的效果
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 LIMIT=19  # 上限
 4 
 5 echo
 6 echo "Printing Numbers 1 through 20 (but not 3 and 11)."
 7 
 8 a=0
 9 
10 while [ $a -le "$LIMIT" ]
11 do
12  a=$(($a+1))
13 
14  if [ "$a" -eq 3 ] || [ "$a" -eq 11 ]  # 除了3和11.
15  then
16    continue      # 跳过本次循环剩下的语句.
17  fi
18 
19  echo -n "$a "   # 在$a等于3和11的时候,这句将不会执行.
20 done 
21 
22 # 练习:
23 # 为什么循环会打印出20?
24 
25 echo; echo
26 
27 echo Printing Numbers 1 through 20, but something happens after 2.
28 
29 ##################################################################
30 
31 # Same loop, but substituting 'break' for 'continue'.
31 # 同样的循环, 但是用'break'来代替'continue'.
32 
33 a=0
34 
35 while [ "$a" -le "$LIMIT" ]
36 do
37  a=$(($a+1))
38 
39  if [ "$a" -gt 2 ]
40  then
41    break  # 将会跳出整个循环.
42  fi
43 
44  echo -n "$a "
45 done
46 
47 echo; echo; echo
48 
49 exit 0
################################End Script######################################### 
 break命令可以带一个参数.一个不带参数的break循环只能退出最内层的循环,而break N
 可以退出N层循环.
Example 10-21 多层循环的退出
################################Start Script#######################################
 1 #!/bin/bash
 2 # break-levels.sh: 退出循环.
 3 
 4 # "break N" 退出N层循环.
 5 
 6 for outerloop in 1 2 3 4 5
 7 do
 8   echo -n "Group $outerloop:   "
 9 
10   # --------------------------------------------------------
11   for innerloop in 1 2 3 4 5
12   do
13     echo -n "$innerloop "
14 
15     if [ "$innerloop" -eq 3 ]
16     then
17       break  # 试试 break 2 来看看发生什么.
18              # (内部循环和外部循环都被退出了.)
19     fi
20   done
21   # --------------------------------------------------------
22 
23   echo
24 done  
25 
26 echo
27 
28 exit 0
################################End Script######################################### 
 continue命令也可以带一个参数.一个不带参数的continue命令只去掉本次循环的剩余代码
 .而continue N将会把N层循环剩余的代码都去掉,但是循环的次数不变.
Example 10-22 多层循环的continue
################################Start Script#######################################
 1 #!/bin/bash
 2 # "continue N" 命令, 将让N层的循环全部被continue.
 3 
 4 for outer in I II III IV V           # 外部循环
 5 do
 6   echo; echo -n "Group $outer: "
 7 
 8   # --------------------------------------------------------------------
 9   for inner in 1 2 3 4 5 6 7 8 9 10  # 内部循环
10   do
11 
12     if [ "$inner" -eq 7 ]
13     then
14       continue 2  # continue 2层, 也就是到outer循环上.
15                   # 将"continue 2"替换为一个单独的"continue"
16                   # 来看一下一个正常循环的行为.
17     fi  
18 
19     echo -n "$inner "  # 7 8 9 10 将不会被echo
20   done  
21   # --------------------------------------------------------------------
22 #译者注:如果在此处添加echo的话,当然也不会输出.
23 done
24 
25 echo; echo
26 
27 # 练习:
28 # 准备一个有意义的"continue N"的使用,放在脚本中.
29 
30 exit 0
################################End Script######################################### 
Example 10-23 在实际的任务中使用"continue N"
################################Start Script#######################################
 1 # Albert Reiner 给出了一个关于使用"continue N"的例子:
 2 # ---------------------------------------------------
 3 
 4 #  Suppose I have a large number of jobs that need to be run, with
 5 #+ any data that is to be treated in files of a given name pattern in a
 6 #+ directory. There are several machines that access this directory, and
 7 #+ I want to distribute the work over these different boxen. Then I
 8 #+ usually nohup something like the following on every box:
 9 
10 while true
11 do
12   for n in .iso.*
13   do
14     [ "$n" = ".iso.opts" ] && continue
15     beta=${n#.iso.}
16     [ -r .Iso.$beta ] && continue
17     [ -r .lock.$beta ] && sleep 10 && continue
18     lockfile -r0 .lock.$beta || continue
19     echo -n "$beta: " `date`
20     run-isotherm $beta
21     date
22     ls -alF .Iso.$beta
23     [ -r .Iso.$beta ] && rm -f .lock.$beta
24     continue 2
25   done
26   break
27 done
28 
29 #  The details, in particular the sleep N, are particular to my
30 #+ application, but the general pattern is:
31 
32 while true
33 do
34   for job in {pattern}
35   do
36     {job already done or running} && continue
37     {mark job as running, do job, mark job as done}
38     continue 2
39   done
40   break        # Or something like `sleep 600' to avoid termination.
41 done
42 
43 #  This way the script will stop only when there are no more jobs to do
44 #+ (including jobs that were added during runtime). Through the use
45 #+ of appropriate lockfiles it can be run on several machines
46 #+ concurrently without duplication of calculations [which run a couple
47 #+ of hours in my case, so I really want to avoid this]. Also, as search
48 #+ always starts again from the beginning, one can encode priorities in
49 #+ the file names. Of course, one could also do this without `continue 2',
50 #+ but then one would have to actually check whether or not some job
51 #+ was done (so that we should immediately look for the next job) or not
52 #+ (in which case we terminate or sleep for a long time before checking
53 #+ for a new job).
################################End Script#########################################
 注意:continue N结构如果被用在一个有意义的上下文中的话,往往都很难理解,并且技巧性
  很高.所以最好的方法就是尽量避免它. 
注意事项:
[1]  这两个命令是shell的内建命令,而不像其它的循环命令那样,比如while和case,这两个
  是关键字. 
  
10.4 测试与分支(case和select结构)
---------------------------------
case和select结构在技术上说不是循环,因为它们并不对可执行的代码块进行迭代.但是和循环
相似的是,它们也依靠在代码块的顶部或底部的条件判断来决定程序的分支. 
在代码块中控制程序分支 
case (in) / esac
 在shell中的case同C/C++中的switch结构是相同的.它允许通过判断来选择代码块中多条
 路径中的一条. 
 case "$variable" in 
 "$condition1")
 command...
 ;; 
 "$condition1")
 command...
 ;; 
 esac 
 注意: 对变量使用""并不是强制的,因为不会发生单词分离.
   每句测试行,都以右小括号)结尾.
   每个条件块都以两个分号结尾;;.
   case块的结束以esac(case的反向拼写)结尾. 
Example 10-24 使用case
################################Start Script#######################################
 1 #!/bin/bash
 2 # 测试字符串范围
 3 
 4 echo; echo "Hit a key, then hit return."
 5 read Keypress
 6 
 7 case "$Keypress" in
 8   [[:lower:]]   ) echo "Lowercase letter";;
 9   [[:upper:]]   ) echo "Uppercase letter";;
10   [0-9]         ) echo "Digit";;
11   *             ) echo "Punctuation, whitespace, or other";;
12 esac      #  Allows ranges of characters in [square brackets],
12 esac      #  允许字符串的范围出现在[]中,
13           #+ or POSIX ranges in [[double square brackets.
13           #+ 或者POSIX范围在[[中.
14 
15 #  在这个例子的第一个版本中,
16 #+ 测试大写和小写字符串使用的是
17 #+ [a-z] 和 [A-Z].
18 #  这种用法将不会在某些特定的场合或Linux发行版中正常工作.
19 #  POSIX 更具可移植性.
20 #  感谢Frank Wang 指出这点.
21 
22 #  练习:
23 #  -----
24 #  就像这个脚本所表现的,它只允许单个按键,然后就结束了.
25 #  修改这个脚本,让它能够接受重复输入,
26 #+ 报告每个按键,并且只有在"X"被键入时才结束.
27 #  暗示: 将这些代码都用"while"循环圈起来.
28 
29 exit 0
################################End Script######################################### 
Example 10-25 使用case来创建菜单
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # 未经处理的地址资料
 4 
 5 clear # 清屏.
 6 
 7 echo "          Contact List"
 8 echo "          ------- ----"
 9 echo "Choose one of the following persons:" 
10 echo
11 echo "[E]vans, Roland"
12 echo "[J]ones, Mildred"
13 echo "[S]mith, Julie"
14 echo "[Z]ane, Morris"
15 echo
16 
17 read person
18 
19 case "$person" in
20 # 注意,变量是被引用的.
21 
22   "E" | "e" )
23   # 接受大写或小写输入.
24   echo
25   echo "Roland Evans"
26   echo "4321 Floppy Dr."
27   echo "Hardscrabble, CO 80753"
28   echo "(303) 734-9874"
29   echo "(303) 734-9892 fax"
30   echo "revans@zzy.net"
31   echo "Business partner & old friend"
32   ;;
33 # 注意,在每个选项后边都需要以;;结尾.
34 
35   "J" | "j" )
36   echo
37   echo "Mildred Jones"
38   echo "249 E. 7th St., Apt. 19"
39   echo "New York, NY 10009"
40   echo "(212) 533-2814"
41   echo "(212) 533-9972 fax"
42   echo "milliej@loisaida.com"
43   echo "Ex-girlfriend"
44   echo "Birthday: Feb. 11"
45   ;;
46 
47 # 后边的Smith和Zane的信息在这里就省略了.
48 
49           * )
50    # 默认选项.
51    # 空输入(敲RETURN).
52    echo
53    echo "Not yet in database."
54   ;;
55 
56 esac
57 
58 echo
59 
60 #  练习:
61 #  -----
62 #  修改这个脚本,让它能够接受多输入,
63 #+ 并且能够显示多个地址.
64 
65 exit 0
################################End Script######################################### 
 一个case的特殊用法,用来测试命令行参数.
################################Start Script#######################################
 1 #! /bin/bash
 2 
 3 case "$1" in
 4 "") echo "Usage: ${0##*/} <filename>"; exit $E_PARAM;;  # 没有命令行参数,
 5                                                         # 或者第一个参数为空.
 6 # Note that ${0##*/} is ${var##pattern} param substitution. Net result is $0.
 6 # 注意:${0##*/} 是${var##pattern} 这种模式的替换. 得到的结果是$0.
 7 
 8 -*) FILENAME=./$1;;   #  如果传递进来的文件名参数($1)以一个破折号开头,
 9                       #+ 那么用./$1来代替
10                       #+ 这样后边的命令将不会把它作为一个选项来解释.
11 
12 * ) FILENAME=$1;;     # 否则, $1.
13 esac
################################End Script######################################### 
 这是一个更容易懂的命令行参数处理的一个例子.
################################Start Script#######################################
 1 #! /bin/bash
 2 
 3 
 4 while [ $# -gt 0 ]; do    # 直到你用完所有的参数...
 5   case "$1" in
 6     -d|--debug)
 7               # "-d" or "--debug" parameter?
 8               DEBUG=1
 9               ;;
10     -c|--conf)
11               CONFFILE="$2"
12               shift
13               if [ ! -f $CONFFILE ]; then
14                 echo "Error: Supplied file doesn't exist!"
15                 exit $E_CONFFILE     # 文件没发现错误.
16               fi
17               ;;
18   esac
19   shift       # 检查剩下的参数.
20 done
21 
22 #  来自Stefano Falsetto的 "Log2Rot" 脚本,
23 #+ 他的"rottlog" 包的一部分.
24 #  授权使用.
################################End Script######################################### 
Example 10-26 使用命令替换来产生case变量
################################Start Script#######################################
 1 #!/bin/bash
 2 # case-cmd.sh: 使用命令替换来产生"case"变量
 3 
 4 case $( arch ) in   # "arch" 返回机器的类型.
 5                     # 等价于 'uname -m' ...
 6 i386 ) echo "80386-based machine";;
 7 i486 ) echo "80486-based machine";;
 8 i586 ) echo "Pentium-based machine";;
 9 i686 ) echo "Pentium2+-based machine";;
10 *    ) echo "Other type of machine";;
11 esac
12 
13 exit 0
################################End Script######################################### 
 case结构也可以过滤globbing模式的字符串.
Example 10-27 简单字符串匹配
################################Start Script#######################################
 1 #!/bin/bash
 2 # match-string.sh: 简单字符串匹配
 3 
 4 match_string ()
 5 {
 6   MATCH=0
 7   NOMATCH=90
 8   PARAMS=2     # 函数需要2个参数.
 9   BAD_PARAMS=91
10 
11   [ $# -eq $PARAMS ] || return $BAD_PARAMS
12 
13   case "$1" in
14   "$2") return $MATCH;;
15   *   ) return $NOMATCH;;
16   esac
17 
18 }  
19 
20 
21 a=one
22 b=two
23 c=three
24 d=two
25 
26 
27 match_string $a     # 参数个数错误.
28 echo $?             # 91
29 
30 match_string $a $b  # 不匹配
31 echo $?             # 90
32 
33 match_string $b $d  # 匹配
34 echo $?             # 0
35 
36 
37 exit 0 
################################End Script######################################### 
Example 10-28 检查是否是字母输入
################################Start Script#######################################
  1 #!/bin/bash
  2 # isalpha.sh: 使用"case"结构来过滤字符串.
  3 
  4 SUCCESS=0
  5 FAILURE=-1
  6 
  7 isalpha ()  # 检查输入的*第一个字符*是不是字母表上的字符.
  8 {
  9 if [ -z "$1" ]                # 没有参数传进来?
 10 then
 11   return $FAILURE
 12 fi
 13 
 14 case "$1" in
 15 [a-zA-Z]*) return $SUCCESS;;  # 以一个字母开头?
 16 *        ) return $FAILURE;;
 17 esac
 18 }             # 同C语言的"isalpha()"函数相比较.
 19 
 20 
 21 isalpha2 ()   # 测试是否*整个字符串*为字母表字符.
 22 {
 23   [ $# -eq 1 ] || return $FAILURE
 24 
 25   case $1 in
 26   *[!a-zA-Z]*|"") return $FAILURE;;
 27                *) return $SUCCESS;;
 28   esac
 29 }
 30 
 31 isdigit ()    # 测试是否*整个字符串*都是数字.
 32 {             # 换句话说就是测试是否是整数变量.
 33   [ $# -eq 1 ] || return $FAILURE
 34 
 35   case $1 in
 36   *[!0-9]*|"") return $FAILURE;;
 37             *) return $SUCCESS;;
 38   esac
 39 }
 40 
 41 
 42 
 43 check_var ()  # 测试 isalpha ().
 44 {
 45 if isalpha "$@"
 46 then
 47   echo "\"$*\" begins with an alpha character."
 48   if isalpha2 "$@"
 49   then        # 不需要测试第一个字符是否是non-alpha.
 50     echo "\"$*\" contains only alpha characters."
 51   else
 52     echo "\"$*\" contains at least one non-alpha character."
 53   fi  
 54 else
 55   echo "\"$*\" begins with a non-alpha character."
 56               # 如果没有参数传递进来,也是"non-alpha".
 57 fi
 58 
 59 echo
 60 
 61 }
 62 
 63 digit_check ()  # 测试 isdigit ().
 64 {
 65 if isdigit "$@"
 66 then
 67   echo "\"$*\" contains only digits [0 - 9]."
 68 else
 69   echo "\"$*\" has at least one non-digit character."
 70 fi
 71 
 72 echo
 73 
 74 }
 75 
 76 a=23skidoo
 77 b=H3llo
 78 c=-What?
 79 d=What?
 80 e=`echo $b`   # 命令替换.
 81 f=AbcDef
 82 g=27234
 83 h=27a34
 84 i=27.34
 85 
 86 check_var $a
 87 check_var $b
 88 check_var $c
 89 check_var $d
 90 check_var $e
 91 check_var $f
 92 check_var     # 没有参数传进来,将发生什么?
 93 #
 94 digit_check $g
 95 digit_check $h
 96 digit_check $i
 97 
 98 
 99 exit 0        # S.C改进过这个脚本.
100 
101 # Exercise:
102 # --------
103 #  编写一个 'isfloat ()'函数来测试浮点数.
104 #  暗示: 这个函数基本上与'isdigit ()'一样,
105 #+ 但是要添加一部分小数点的处理.
################################End Script######################################### 
select
 select结构是建立菜单的另一种工具,这种结构是从ksh中引入的. 
 select variable [in list]
 do
 command...
 break
 done 
 提示用户选择的内容比如放在变量列表中.注意:select命令使用PS3提示符[默认为(#? )]
 但是可以修改PS3.
Example 10-29 用select来创建菜单
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 PS3='Choose your favorite vegetable: ' # 设置提示符字串.
 4 
 5 echo
 6 
 7 select vegetable in "beans" "carrots" "potatoes" "onions" "rutabagas"
 8 do
 9   echo
10   echo "Your favorite veggie is $vegetable."
11   echo "Yuck!"
12   echo
13   break  # 如果这里没有'break'会发生什么?
14 done
15 
16 exit 0
################################End Script######################################### 
 如果忽略了in list列表,那么select命令将使用传递到脚本的命令行参数,或者是函数参数
 前提是将select写到这个函数中. 
 与for variable [in list]结构在忽略[in list]时的行为相比较.
Example 10-30 用函数中select结构来创建菜单
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 PS3='Choose your favorite vegetable: '
 4 
 5 echo
 6 
 7 choice_of()
 8 {
 9 select vegetable
10 # [in list] 被忽略, 所以'select'用传递给函数的参数.
11 do
12   echo
13   echo "Your favorite veggie is $vegetable."
14   echo "Yuck!"
15   echo
16   break
17 done
18 }
19 
20 choice_of beans rice carrots radishes tomatoes spinach
21 #         $1    $2   $3      $4       $5       $6
22 #         传递给choice_of() 函数的参数
23 
24 exit 0
################################End Script#########################################
 参见Example 34-3. 
第11章 内部命令与内建
======================
内建命令指的就是包含在Bash工具集中的命令.这主要是考虑到执行效率的问题--内建命令将
比外部命令的执行得更快,外部命令通常需要fork出一个单独的进程来执行.另外一部分原因
是特定的内建命令需要直接存取shell内核部分. 
当一个命令或者是shell本身需要初始化(或者创建)一个新的子进程来执行一个任务的时候,这
种行为被称为forking.这个新产生的进程被叫做子进程,并且这个进程是从父进程中分离出来
的.当子进程执行它的任务时,同时父进程也在运行. 
注意:当父进程取得子进程的进程ID的时候,父进程可以传递给子进程参数,而反过来则不行.
这将产生不可思议的并且很难追踪的问题. 
Example 11-1 一个fork出多个自己实例的脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 # spawn.sh
 3 
 4 
 5 PIDS=$(pidof sh $0)  # 这个脚本不同实例的进程ID.
 6 P_array=( $PIDS )    # 把它们放到数组里(为什么?).
 7 echo $PIDS           # 显示父进程和子进程的进程ID.
 8 let "instances = ${#P_array[*]} - 1"  # 计算元素个数,至少为1.
 9                                       # 为什么减1?
10 echo "$instances instance(s) of this script running."
11 echo "[Hit Ctl-C to exit.]"; echo
12 
13 
14 sleep 1              # 等.
15 sh $0                # 再来一次.
16 
17 exit 0               # 没必要: 脚本永远不会走到这里.
18                      # 为什么走不到这里?
19 
20 #  在使用Ctl-C退出之后,
21 #+ 是否所有产生的进程都会被kill掉?
22 #  如果是这样的话, 为什么?
23 
24 # 注意:
25 # ----
26 # 小心,不要让这个脚本运行太长时间.
27 # 它最后将吃掉你大部分的系统资源.
28 
29 #  对于用脚本产生大量的自身实例来说,
30 #+ 是否有适当的脚本技术.
31 #  为什么是为什么不是?
################################End Script#########################################
一般的,脚本中的内建命令在执行时将不会fork出一个子进程.但是脚本中的外部或过滤命令
通常会fork一个子进程. 
一个内建命令通常与一个系统命令同名,但是Bash在内部重新实现了这些命令.比如,Bash的
echo命令与/bin/echo就不尽相同,虽然它们的行为绝大多数情况下是一样的.
1 #!/bin/bash
2 
3 echo "This line uses the \"echo\" builtin."
4 /bin/echo "This line uses the /bin/echo system command." 
关键字的意思就是保留字.对于shell来说关键字有特殊的含义,并且用来构建shell的语法结构.
比如,"for","while","do"和"!"都是关键字.与内建命令相同的是,关键字也是Bash的骨干部分,
但是与内建命令不同的是,关键字自身并不是命令,而是一个比较大的命令结构的一部分.[1] 
I/O类 
echo
 打印(到stdout)一个表达式或变量(见Example 4-1).
 1 echo Hello
 2 echo $a 
 echo需要使用-e参数来打印转移字符.见Example 5-2.
 一般的每个echo命令都会在终端上新起一行,但是-n选项将会阻止新起一行. 
 注意:echo命令可以用来作为一系列命令的管道输入.
 1 if echo "$VAR" | grep -q txt   # if [[ $VAR = *txt* ]]
 2 then
 3   echo "$VAR contains the substring sequence \"txt\""
 4 fi 
 注意:echo命令与命令替换相组合可以用来设置一个变量.
 a=`echo "HELLO" | tr A-Z a-z`
 参见Example 12-19,Example 12-3,Example 12-42,和Example 12-43. 
 注意:echo `command`将会删除任何有命令产生的换行符. 
 $IFS(内部域分隔符)一般都会将\n(换行符)包含在它的空白字符集合中.Bash因此会根据
 参数中的换行来分离命令的输出.然后echo将以空格代替换行来输出这些参数. 
 bash$ ls -l /usr/share/apps/kjezz/sounds
 -rw-r--r--    1 root     root         1407 Nov  7  2000 reflect.au
 -rw-r--r--    1 root     root          362 Nov  7  2000 seconds.au 
  
 bash$ echo `ls -l /usr/share/apps/kjezz/sounds`
 total 40 -rw-r--r-- 1 root root 716 Nov 7 2000 reflect.au -rw-r--r-- 1 root root 362 Nov 7 2000 seconds.au
   
 所以,我们怎么才能在一个需要echo出来的字符串中嵌入换行呢?
################################Start Script#######################################
 1 # 嵌入一个换行?
 2 echo "Why doesn't this string \n split on two lines?"
 3 # 上边这句的\n将被打印出来.达不到换行的目的.
 4 
 5 # 让我们在试试其他方法.
 6 
 7 echo
 8       
 9 echo $"A line of text containing
10 a linefeed."
11 # 打印出2个独立的行,(潜入换行成功了).
12 # 但是,"$"前缀是否是必要的?
13 
14 echo
15 
16 echo "This string splits
17 on two lines."
18 # 不用非得有"$"前缀.
19 
20 echo
21 echo "---------------"
22 echo
23 
24 echo -n $"Another line of text containing
25 a linefeed."
26 # 打印出2个独立的行,(潜入换行成功了).
27 # 即使-n选项,也没能阻止换行(译者:-n 阻止了第2个换行)
28 
29 echo
30 echo
31 echo "---------------"
32 echo
33 echo
34 
35 # 然而,下边的代码就没能像期望的那样运行.
36 # Why not? Hint: Assignment to a variable.
36 # 为什么失败? 提示: 因为分配到了变量.
37 string1=$"Yet another line of text containing
38 a linefeed (maybe)."
39 
40 echo $string1
41 # Yet another line of text containing a linefeed (maybe).
42 #                                    ^
43 # 换行变成了空格.
44 
45 # Thanks, Steve Parker, for pointing this out.
################################End Script#########################################
 注意: 这个命令是shell的一个内建命令,与/bin/echo不同,虽然行为相似.
 bash$ type -a echo
 echo is a shell builtin
 echo is /bin/echo 
printf
 printf命令,格式化输出,是echo命令的增强.它是C语言printf()库函数的一个有限的变形,
 并且在语法上有些不同. 
 printf format-string... parameter...
 这是Bash的内建版本,与/bin/printf或/usr/bin/printf命令不同.想更深入的了解,请
 察看printf(系统命令)的man页. 
 注意:老版本的Bash可能不支持printf.
Example 11-2 printf
################################Start Script#######################################
 1 #!/bin/bash
 2 # printf demo
 3 
 4 PI=3.14159265358979
 5 DecimalConstant=31373
 6 Message1="Greetings,"
 7 Message2="Earthling."
 8 
 9 echo
10 
11 printf "Pi to 2 decimal places = %1.2f" $PI
12 echo
13 printf "Pi to 9 decimal places = %1.9f" $PI  # 都能正确地结束.
14 
15 printf "\n"                                  # 打印一个换行,
16                                              # 等价于 'echo' . . .
17 
18 printf "Constant = \t%d\n" $DecimalConstant  # 插入一个 tab (\t).
19 
20 printf "%s %s \n" $Message1 $Message2
21 
22 echo
23 
24 # ==========================================#
25 # 模仿C函数, sprintf().
26 # 使用一个格式化的字符串来加载一个变量.
27 
28 echo 
29 
30 Pi12=$(printf "%1.12f" $PI)
31 echo "Pi to 12 decimal places = $Pi12"
32 
33 Msg=`printf "%s %s \n" $Message1 $Message2`
34 echo $Msg; echo $Msg
35 
36 #  向我们看到的一样,现在'sprintf'函数可以
37 #+ 作为一个可被加载的模块
38 #+ 但这是不可移植的.
39 
40 exit 0
################################End Script######################################### 
 使用printf的最主要的应用就是格式化错误消息.
  1 E_BADDIR=65
  2 
  3 var=nonexistent_directory
  4 
  5 error()
  6 {
  7   printf "$@" >&2
  8   # 格式化传递进来的位置参数,并把它们送到stderr.
  9   echo
 10   exit $E_BADDIR
 11 }
 12 
 13 cd $var || error $"Can't cd to %s." "$var"
 14 
 15 # Thanks, S.C. 
read
 从stdin中读取一个变量的值,也就是与键盘交互取得变量的值.使用-a参数可以取得数组
 变量(见Example 26-6).
Example 11-3 使用read,变量分配
################################Start Script#######################################
 1 #!/bin/bash
 2 # "Reading" 变量.
 3 
 4 echo -n "Enter the value of variable 'var1': "
 5 # -n选项,阻止换行.
 6 
 7 read var1
 8 # 注意在var1前面没有'$',因为变量正在被设置.
 9 
10 echo "var1 = $var1"
11 
12 
13 echo
14 
15 # 一个'read'命令可以设置多个变量.
16 echo -n "Enter the values of variables 'var2' and 'var3' (separated by a space or tab): "
17 read var2 var3
18 echo "var2 = $var2      var3 = $var3"
19 # 如果你只输入了一个值,那么其他的变量还是未设置(null).
20 
21 exit 0
################################End Script######################################### 
 一个不带变量参数的read命令,将把来自键盘的输入存入到专用变量$REPLY中.
Example 11-4 当使用一个不带变量参数的read命令时,将会发生什么?
################################Start Script#######################################
 1 #!/bin/bash
 2 # read-novar.sh
 3 
 4 echo
 5 
 6 # -------------------------- #
 7 echo -n "Enter a value: "
 8 read var
 9 echo "\"var\" = "$var""
10 # 到这里为止,都与期望的相同.
11 # -------------------------- #
12 
13 echo
14 
15 # ------------------------------------------------------------------- #
16 echo -n "Enter another value: "
17 read           #  没有变量分配给'read'命令,因此...
18                #+ 输入将分配给默认变量,$REPLY.
19 var="$REPLY"
20 echo "\"var\" = "$var""
21 # 这部分代码和上边的代码等价.
22 # ------------------------------------------------------------------- #
23 
24 echo
25 
26 exit 0
################################End Script######################################### 
 通常情况下,在使用read命令时,输入一个\然后回车,将会阻止产生一个新行.-r选项将会
 让\转义.
Example 11-5 read命令的多行输入
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 echo
 4 
 5 echo "Enter a string terminated by a \\, then press <ENTER>."
 6 echo "Then, enter a second string, and again press <ENTER>."
 7 read var1     # "\"将会阻止产生新行,当read $var1时.
 8               #     first line \
 9               #     second line
10 
11 echo "var1 = $var1"
12 #     var1 = first line second line
13 
14 #  For each line terminated by a "\"
14 #  对于每个一个"\"结尾的行
15 #+ 你都会看到一个下一行的提示符,让你继续向var1输入内容.
16 
17 echo; echo
18 
19 echo "Enter another string terminated by a \\ , then press <ENTER>."
20 read -r var2  # -r选项将会让"\"转义.
21               #     first line \
22 
23 echo "var2 = $var2"
24 #     var2 = first line \
25 
26 # 第一个<ENTER>就会结束var2变量的录入.
27 
28 echo 
29 
30 exit 0
################################End Script######################################### 
 read命令有些有趣的选项,这些选项允许打印出一个提示符,然后在不输入<ENTER>的情况
 下,可以读入你的按键字符.
  1 # Read a keypress without hitting ENTER.
  1 # 不敲回车,读取一个按键字符.
  2 
  3 read -s -n1 -p "Hit a key " keypress
  4 echo; echo "Keypress was "\"$keypress\""."
  5 
  6 # -s 选项意味着不打印输入.
  7 # -n N 选项意味着直接受N个字符的输入.
  8 # -p 选项意味着在读取输入之前打印出后边的提示符.
  9 
 10 # 使用这些选项是有技巧的,因为你需要使用正确的循序来使用它们. 
 read的-n选项也可以检测方向键,和一些控制按键.
Example 11-6 检测方向键
################################Start Script#######################################
 1 #!/bin/bash
 2 # arrow-detect.sh: 检测方向键,和一些非打印字符的按键.
 3 # Thank you, Sandro Magi告诉了我怎么做. 
 4 
 5 # --------------------------------------------
 6 # 按键产生的字符编码.
 7 arrowup='\[A'
 8 arrowdown='\[B'
 9 arrowrt='\[C'
10 arrowleft='\[D'
11 insert='\[2'
12 delete='\[3'
13 # --------------------------------------------
14 
15 SUCCESS=0
16 OTHER=65
17 
18 echo -n "Press a key...  "
19 # 如果不是上边列表所列出的按键,可能还是需要按回车.(译者:因为一般按键是一个字符)
20 read -n3 key                      # 读3个字符.
21 
22 echo -n "$key" | grep "$arrowup"  #检查输入字符是否匹配.
23 if [ "$?" -eq $SUCCESS ]
24 then
25   echo "Up-arrow key pressed."
26   exit $SUCCESS
27 fi
28 
29 echo -n "$key" | grep "$arrowdown"
30 if [ "$?" -eq $SUCCESS ]
31 then
32   echo "Down-arrow key pressed."
33   exit $SUCCESS
34 fi
35 
36 echo -n "$key" | grep "$arrowrt"
37 if [ "$?" -eq $SUCCESS ]
38 then
39   echo "Right-arrow key pressed."
40   exit $SUCCESS
41 fi
42 
43 echo -n "$key" | grep "$arrowleft"
44 if [ "$?" -eq $SUCCESS ]
45 then
46   echo "Left-arrow key pressed."
47   exit $SUCCESS
48 fi
49 
50 echo -n "$key" | grep "$insert"
51 if [ "$?" -eq $SUCCESS ]
52 then
53   echo "\"Insert\" key pressed."
54   exit $SUCCESS
55 fi
56 
57 echo -n "$key" | grep "$delete"
58 if [ "$?" -eq $SUCCESS ]
59 then
60   echo "\"Delete\" key pressed."
61   exit $SUCCESS
62 fi
63 
64 
65 echo " Some other key pressed."
66 
67 exit $OTHER
68 
69 #  练习:
70 #  -----
71 #  1) 通过使用'case'结构来代替'if'结构
72 #+    来简化这个脚本.
73 #  2) Add detection of the "Home," "End," "PgUp," and "PgDn" keys.
73 #  2) 添加"Home," "End," "PgUp," 和 "PgDn"这些按键的检查.
################################End Script#########################################
 注意: 对read命令来说,-n 选项将不会检测ENTER(新行)键. 
 read命令的-t选项允许时间输入(见Example 9-4). 
 read命令也可以从重定向的文件中读入变量的值.如果文件中的内容超过一行,那么只有第
 一行被分配到这个变量中.如果read命令有超过一个参数,那么每个变量都会从文件中取得
 以定义的空白分隔的字符串作为变量的值.小心!
Example 11-7 通过文件重定向来使用read
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 read var1 <data-file
 4 echo "var1 = $var1"
 5 # var1将会把data-file的第一行的全部内容都作为它的值.
 6 
 7 read var2 var3 <data-file
 8 echo "var2 = $var2   var3 = $var3"
 9 # 注意,这里"read"命令将会产生一种不直观的行为.
10 # 1) 重新从文件的开头开始读入变量.
11 # 2) 每个变量都设置成了以空白分割的字符串,
12 #    而不是之前的以整行的内容作为变量的值.
13 # 3) 而最后一个变量将会取得第一行剩余的全部部分(不管是否以空白分割).
14 # 4) 如果需要赋值的变量的个数比文件中第一行一空白分割的字符串的个数多的话,
15 #    那么这些变量将会被赋空值.
16 
17 echo "------------------------------------------------"
18 
19 # 如何用循环来解决上边所提到的问题:
20 while read line
21 do
22   echo "$line"
23 done <data-file
24 # Thanks, Heiner Steven for pointing this out.
25 
26 echo "------------------------------------------------"
27 
28 # 使用$IFS (内部域分隔变量)来将每行的输入单独的放到"read"中,
29 # 如果你不想使用默认空白的话.
30 
31 echo "List of all users:"
32 OIFS=$IFS; IFS=:       # /etc/passwd 使用 ":" 作为域分隔符.
33 while read name passwd uid gid fullname ignore
34 do
35   echo "$name ($fullname)"
36 done </etc/passwd   # I/O 重定向.
37 IFS=$OIFS              # 恢复原始的 $IFS.
38 # 这个代码片段也是Heiner Steven写的.
39 
40 
41 
42 #  在循环内部设置$IFS变量
43 #+ 而不用把原始的$IFS
44 #+ 保存到临时变量中.
45 #  Thanks, Dim Segebart, for pointing this out.
46 echo "------------------------------------------------"
47 echo "List of all users:"
48 
49 while IFS=: read name passwd uid gid fullname ignore
50 do
51   echo "$name ($fullname)"
52 done </etc/passwd   # I/O 重定向.
53 
54 echo
55 echo "\$IFS still $IFS"
56 
57 exit 0
################################End Script######################################### 
 注意:管道输出到一个read命令中,使用管道echo输出到read会失败.
  然而使用管道cat输出看起来能够正常运行.
 1 cat file1 file2 |
 2 while read line
 3 do
 4 echo $line
 5 done 
 但是,像Bjon Eriksson指出的:
Example 11-8 管道输出到read中的问题
################################Start Script#######################################
 1 #!/bin/sh
 2 # readpipe.sh
 3 # 这个例子是Bjon Eriksson捐献的.
 4 
 5 last="(null)"
 6 cat $0 |
 7 while read line
 8 do
 9     echo "{$line}"
10     last=$line
11 done
12 printf "\nAll done, last:$last\n"
13 
14 exit 0  # 代码结束.
15         # 下边是这个脚本的部分输出.
16         # 打印出了多余的大括号.
17 
18 #############################################
19 
20 ./readpipe.sh 
21 
22 {#!/bin/sh}
23 {last="(null)"}
24 {cat $0 |}
25 {while read line}
26 {do}
27 {echo "{$line}"}
28 {last=$line}
29 {done}
30 {printf "nAll done, last:$lastn"}
31 
32 
33 All done, last:(null)
34 
35 变量(last)是设置在子shell中的而没设在外边.
################################End Script######################################### 
 在许多linux发行版上,gendiff脚本通常在/usr/bin下,将find的输出使用管道传递到一个
 while循环中.
 1 find $1 \( -name "*$2" -o -name ".*$2" \) -print |
 2 while read f; do
 3 . . . 
文件系统类 
cd
 cd,修改目录命令,在脚本中用得最多的时候就是,命令需要在指定目录下运行时,需要用cd
 修改当前工作目录.
 1 (cd /source/directory && tar cf - . ) | (cd /dest/directory && tar xpvf -)
 [之前有个例子,Alan Cox写的] 
 -P(physical)选项的作用是忽略符号连接. 
 cd - 将把工作目录改为$OLDPWD,就是之前的工作目录. 
 注意:当我们用两个/来作为cd命令的参数时,结果却出乎我们的意料.
 bash$ cd //
 bash$ pwd
 // 
 输出应该,并且当然是/.无论在命令行下还是在脚本中,这都是个问题. 
pwd
 打印当前的工作目录.这将给用户(或脚本)当前的工作目录(见Example 11-9).使用这个
 命令的结果和从内键变量$PWD中读取的值是相同的. 
pushd, popd, dirs
 这几个命令可以使得工作目录书签化,就是可以按顺序向前或向后移动工作目录.
 压栈的动作可以保存工作目录列表.选项可以允许对目录栈作不同的操作. 
 pushd dir-name 把路径dir-name压入目录栈,同时修改当前目录到dir-name. 
 popd 将目录栈中最上边的目录弹出,同时修改当前目录到弹出来的那个目录. 
 dirs 列出所有目录栈的内容(与$DIRSTACK便两相比较).一个成功的pushd或者popd将会
  自动的调用dirs命令. 
 对于那些并没有对当前工作目录做硬编码,并且需要对当前工作目录做灵活修改的脚本来说
 ,使用这些命令是再好不过的了.注意内建$DIRSTACK数组变量,这个变量可以在脚本内存取,
 并且它们保存了目录栈的内容. 
Example 11-9 修改当前的工作目录
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 dir1=/usr/local
 4 dir2=/var/spool
 5 
 6 pushd $dir1
 7 # 将会自动运行一个 'dirs' (把目录栈的内容列到stdout上).
 8 echo "Now in directory `pwd`." # Uses back-quoted 'pwd'.
 9 
10 # 现在对'dir1'做一些操作.
11 pushd $dir2
12 echo "Now in directory `pwd`."
13 
14 # 现在对'dir2'做一些操作.
15 echo "The top entry in the DIRSTACK array is $DIRSTACK."
16 popd
17 echo "Now back in directory `pwd`."
18 
19 # 现在,对'dir1'做更多的操作.
20 popd
21 echo "Now back in original working directory `pwd`."
22 
23 exit 0
24 
25 # 如果你不使用 'popd'将会发生什么 -- 然后退出这个脚本?
26 # 你最后将落在那个目录中?为什么?
################################End Script######################################### 
变量类 
let
 let命令将执行变量的算术操作.在许多情况下,它被看作是复杂的expr版本的一个简化版.
Example 11-10 用"let"命令来作算术操作.
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 echo
 4 
 5 let a=11            # 与 'a=11' 相同
 6 let a=a+5           # 等价于let "a = a + 5"
 7                     # (双引号和空格是这句话更具可读性.)
 8 echo "11 + 5 = $a"  # 16
 9 
10 let "a <<= 3"       # 等价于let "a = a << 3"
11 echo "\"\$a\" (=16) left-shifted 3 places = $a"
12                     # 128
13 
14 let "a /= 4"        # 等价于let "a = a / 4"
15 echo "128 / 4 = $a" # 32
16 
17 let "a -= 5"        # 等价于let "a = a - 5"
18 echo "32 - 5 = $a"  # 27
19 
20 let "a *=  10"      # 等价于let "a = a * 10"
21 echo "27 * 10 = $a" # 270
22 
23 let "a %= 8"        # 等价于let "a = a % 8"
24 echo "270 modulo 8 = $a  (270 / 8 = 33, remainder $a)"
25                     # 6
26 
27 echo
28 
29 exit 0
################################End Script######################################### 
eval
 eval arg1 [arg2] ... [argN] 
 将表达式中的参数,或者表达式列表,组合起来,并且评估它们.包含在表达式中的任何变量
 都将被扩展.结果将会被转化到命令中.这对于从命令行或者脚本中产生代码是很有用的.
 bash$ process=xterm
 bash$ show_process="eval ps ax | grep $process"
 bash$ $show_process
 1867 tty1     S      0:02 xterm
 2779 tty1     S      0:00 xterm
 2886 pts/1    S      0:00 grep xterm 
Example 11-11 显示eval命令的效果
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 y=`eval ls -l`  #  与 y=`ls -l` 很相似
 4 echo $y         #+ 但是换行符将被删除,因为echo的变量未被""引用.
 5 echo
 6 echo "$y"       #  用""将变量引用,换行符就不会被空格替换了.
 7 
 8 echo; echo
 9 
10 y=`eval df`     #  与 y=`df` 很相似
11 echo $y         #+ 换行符又被空格替换了.
12 
13 #  当没有LF(换行符)出现时,对于使用"awk"这样的工具来说,
14 #+ 可能分析输出的结果更容易一些.
15 
16 echo
17 echo "==========================================================="
18 echo
19 
20 # Now, showing how to "expand" a variable using "eval" . . .
20 # 现在,来看一下怎么用"eval"命令来扩展一个变量. . .
21 
22 for i in 1 2 3 4 5; do
23   eval value=$i
24   #  value=$i 将具有同样的效果. "eval"并不非得在这里使用.
25   #  一个缺乏特殊含义的变量将被评估为自身 --
26   #+ 也就是说,这个变量除了能够被扩展成自身所表示的字符,不能扩展成任何其他的含义.
27   echo $value
28 done
29 
30 echo
31 echo "---"
32 echo
33 
34 for i in ls df; do
35   value=eval $i
36   #  value=$i has an entirely different effect here.
36   #  value=$i 在这里就与上边这句有了本质上的区别.
37   #  "eval" 将会评估命令 "ls" 和 "df" . . .
38   #  术语 "ls" 和 "df" 就具有特殊含义,
39   #+ 因为它们被解释成命令,
40   #+ 而不是字符串本身.
41   echo $value
42 done
43 
44 
45 exit 0
################################End Script######################################### 
Example 11-12 强制登出(log-off)
################################Start Script#######################################
 1 #!/bin/bash
 2 # 结束ppp进程来强制登出log-off.
 3 
 4 # 脚本应该以根用户的身份来运行.
 5 
 6 killppp="eval kill -9 `ps ax | awk '/ppp/ { print $1 }'`"
 7 #                     -------- ppp 的进程ID       -------  
 8 
 9 $killppp                  # 这个变量现在成为了一个命令.
10 
11 
12 # 下边的命令必须以根用户的身份来运行.
13 
14 chmod 666 /dev/ttyS3      # 恢复读写权限,否则什么?
15 #  因为在ppp上执行一个SIGKILL将会修改串口的权限,
16 #+ 我们把权限恢复到之前的状态.
17 
18 rm /var/lock/LCK..ttyS3   # 删除串口琐文件.为什么?
19 
20 exit 0
21 
22 # 练习:
23 # -----
24 # 1) 编写一个脚本来验证是否跟用户正在运行它.
25 # 2) 做一个检查,检查一下将要杀掉的进程
26 #+   再杀掉这个进程之前,它是否正在运行.
27 # 3) 基于'fuser'来编写达到这个目的的另一个版本的脚本
28 #+      if [ fuser -s /dev/modem ]; then . . .
################################End Script######################################### 
Example 11-13 另一个"rot13"的版本
################################Start Script#######################################
 1 #!/bin/bash
 2 # 使用'eval'的一个"rot13"的版本,(译者:rot13就是把26个字母,从中间分为2瓣,各13个)
 3 # 与脚本"rot13.sh" 比较一下.
 4 
 5 setvar_rot_13()              # "rot13" 函数
 6 {
 7   local varname=$1 varvalue=$2
 8   eval $varname='$(echo "$varvalue" | tr a-z n-za-m)'
 9 }
10 
11 
12 setvar_rot_13 var "foobar"   # 用"foobar" 传递到rot13函数中.
13 echo $var                    # 结果是sbbone
14 
15 setvar_rot_13 var "$var"     # 传递"sbbone" 到rot13函数中.
16                              # 又变成了原始值.
17 echo $var                    # foobar
18 
19 # 这个例子是Segebart Chazelas编写的.
20 # 作者又修改了一下.
21 
22 exit 0
################################End Script######################################### 
 Rory Winston捐献了下编的脚本,关于使用eval命令.
Example 11-14 在Perl脚本中使用eval命令来强制变量替换
################################Start Script#######################################
 1 In the Perl script "test.pl":
 2         ...  
 3         my $WEBROOT = <WEBROOT_PATH>;
 4         ...
 5 
 6 To force variable substitution try:
 7         $export WEBROOT_PATH=/usr/local/webroot
 8         $sed 's/<WEBROOT_PATH>/$WEBROOT_PATH/' < test.pl > out
 9 
10 But this just gives:
11         my $WEBROOT = $WEBROOT_PATH;
12 
13 However:
14         $export WEBROOT_PATH=/usr/local/webroot
15         $eval sed 's%\<WEBROOT_PATH\>%$WEBROOT_PATH%' < test.pl > out
16 #        ====
17 
18 That works fine, and gives the expected substitution:
19         my $WEBROOT = /usr/local/webroot;
20 
21 
22 ### Correction applied to original example by Paulo Marcel Coelho Aragao.
################################End Script######################################### 
 eval命令是有风险的,如果有更合适的方法来实现功能的话,尽量要避免使用它.
 eval命令将执行命令的内容,如果命令中有rm -rf*这种东西,可能就不是你想要的了.
 如果在一个不熟悉的人编写的脚本中使用eval命令将是危险的. 
set
 set命令用来修改内部脚本变量的值.一个作用就是触发选项标志位来帮助决定脚本的行
 为.另一个应用就是以一个命令的结果(set `command`)来重新设置脚本的位置参数.脚本
 将会从命令的输出中重新分析出位置参数.
Example 11-15 使用set来改变脚本的位置参数
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # script "set-test"
 4 
 5 # 使用3个命令行参数来调用这个脚本,
 6 # 比如, "./set-test one two three".
 7 
 8 echo
 9 echo "Positional parameters before  set \`uname -a\` :" #uname命令打印操作系统名
10 echo "Command-line argument #1 = $1"
11 echo "Command-line argument #2 = $2"
12 echo "Command-line argument #3 = $3"
13 
14 
15 set `uname -a` # 把`uname -a`的命令输出设置
16                # 为新的位置参数.
17 
18 echo $_        # 这要看你的unmae -a输出了,这句打印出的就是输出的最后一个单词.
19 # 在脚本中设置标志.
20 
21 echo "Positional parameters after  set \`uname -a\` :"
22 # $1, $2, $3, 等等. 这些位置参数将被重新初始化为`uname -a`的结果
23 echo "Field #1 of 'uname -a' = $1"
24 echo "Field #2 of 'uname -a' = $2"
25 echo "Field #3 of 'uname -a' = $3"
26 echo ---
27 echo $_        # ---
28 echo
29 
30 exit 0
################################End Script######################################### 
 不使用任何选项或参数来调用set命令的话,将会列出所有的环境变量和其他所有的已经
 初始化过的命令.
 bash$ set
 AUTHORCOPY=/home/bozo/posts
 BASH=/bin/bash
 BASH_VERSION=$'2.05.8(1)-release'
 ...
 XAUTHORITY=/home/bozo/.Xauthority
 _=/etc/bashrc
 variable22=abc
 variable23=xzy 
 使用参数--来调用set命令的话,将会明确的分配位置参数.如果--选项后边没有跟变量名
 的话,那么结果就使所有位置参数都比unset了. 
Example 11-16 重新分配位置参数
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 variable="one two three four five"
 4 
 5 set -- $variable
 6 # 将位置参数的内容设为变量"$variable"的内容.
 7 
 8 first_param=$1
 9 second_param=$2
10 shift; shift        # Shift past first two positional params.
11 remaining_params="$*"
12 
13 echo
14 echo "first parameter = $first_param"             # one
15 echo "second parameter = $second_param"           # two
16 echo "remaining parameters = $remaining_params"   # three four five
17 
18 echo; echo
19 
20 # 再来一次.
21 set -- $variable
22 first_param=$1
23 second_param=$2
24 echo "first parameter = $first_param"             # one
25 echo "second parameter = $second_param"           # two
26 
27 # ======================================================
28 
29 set --
30 # Unsets positional parameters if no variable specified.
30 # 如果没指定变量,那么将会unset所有的位置参数.
31 
32 first_param=$1
33 second_param=$2
34 echo "first parameter = $first_param"             # (null value)
35 echo "second parameter = $second_param"           # (null value)
36 
37 exit 0
################################End Script#########################################
 见Example 10-2,和Example 12-51. 
unset
 unset命令用来删除一个shell变量,效果就是把这个变量设为null.注意:这个命令对位置
 参数无效.
 bash$ unset PATH 
 bash$ echo $PATH 
 bash$ 
Example 11-17 Unset一个变量
################################Start Script#######################################
 1 #!/bin/bash
 2 # unset.sh: Unset一个变量.
 3 
 4 variable=hello                       # 初始化.
 5 echo "variable = $variable"
 6 
 7 unset variable                       # Unset.
 8                                      # 与 variable= 的效果相同.
 9 echo "(unset) variable = $variable"  # $variable 设为 null.
10 
11 exit 0
################################End Script######################################### 
export
 export命令将会使得被export的变量在运行的脚本(或shell)的所有的子进程中都可用.
 不幸的是,没有办法将变量export到父进程(就是调用这个脚本或shell的进程)中.
 关于export命令的一个重要的使用就是用在启动文件中,启动文件是用来初始化并且
 设置环境变量,让用户进程可以存取环境变量.
Example 11-18 使用export命令传递一个变量到一个内嵌awk的脚本中
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 #  这是"求列的和"脚本的另外一个版本(col-totaler.sh)
 4 #+ 那个脚本可以把目标文件中的指定的列上的所有数字全部累加起来,求和.
 5 #  这个版本将把一个变量通过export的形式传递到'awk'中 . . .
 6 #+ 并且把awk脚本放到一个变量中.
 7 
 8 
 9 ARGS=2
10 E_WRONGARGS=65
11 
12 if [ $# -ne "$ARGS" ] # 检查命令行参数的个数.
13 then
14    echo "Usage: `basename $0` filename column-number"
15    exit $E_WRONGARGS
16 fi
17 
18 filename=$1
19 column_number=$2
20 
21 #===== 上边的这部分,与原始脚本完全一样 =====#
22 
23 export column_number
24 # 将列号通过export出来,这样后边的进程就可用了.
25 
26 
27 # -----------------------------------------------
28 awkscript='{ total += $ENVIRON["column_number"] }
29 END { print total }'
30 # 是的,一个变量可以保存一个awk脚本.
31 # -----------------------------------------------
32 
33 # 现在,运行awk脚本.
34 awk "$awkscript" "$filename"
35 
36 # Thanks, Stephane Chazelas.
37 
38 exit 0
################################End Script######################################### 
 注意:可以在一个操作中同时赋值和export变量,如: export var1=xxx. 
 然而,像Greg Keraunen指出的,在某些情况下使用上边这种形式,将与先设置变量,然后
 export变量效果不同. 
 bash$ export var=(a b); echo ${var[0]}
 (a b) 
  
 bash$ var=(a b); export var; echo ${var[0]}
 a 
declare, typeset
 declare和typeset命令被用来指定或限制变量的属性. 
readonly
 与declare -r作用相同,设置变量的只读属性,也可以认为是设置常量.设置了这种属性之后
 如果你还要修改它,那么你将得到一个错误消息.这种情况与C语言中的const常量类型的情
 况是相同的. 
getopts
 可以说这是分析传递到脚本的命令行参数的最强力工具.这个命令与getopt外部命令,和
 C语言中的库函数getopt的作用是相同的.它允许传递和连接多个选项[2]到脚本中,并能分
 配多个参数到脚本中. 
 getopts结构使用两个隐含变量.$OPTIND是参数指针(选项索引),和$OPTARG(选项参数)
 (可选的)可以在选项后边附加一个参数.在声明标签中,选项名后边的冒号用来提示
 这个选项名已经分配了一个参数. 
 getopts结构通常都组成一组放在一个while循环中,循环过程中每次处理一个选项和参数,
 然后增加隐含变量$OPTIND的值,再进行下一次的处理. 
 注意: 1.通过命令行传递到脚本中的参数前边必须加上一个减号(-).这是一个前缀,这样
   getopts命令将会认为这个参数是一个选项.事实上,getopts不会处理不带"-"前缀
   的参数,如果第一个参数就没有"-",那么将结束选项的处理. 
    2.使用getopts的while循环模版还是与标准的while循环模版有些不同.没有标准
   while循环中的[]判断条件. 
    3.getopts结构将会取代getopt外部命令. 
################################Start Script#######################################
 1 while getopts ":abcde:fg" Option
 2 # Initial declaration.
 2 # 开始的声明.
 3 # a, b, c, d, e, f, 和 g 被认为是选项(标志).
 4 # e选项后边的:提示,这个选项带一个参数.
 5 do
 6   case $Option in
 7     a ) # Do something with variable 'a'.
 7     a ) # 对选项'a'作些操作.
 8     b ) # 对选项'b'作些操作.
 9     ...
10     e)  # Do something with 'e', and also with $OPTARG,
10     e)  # 对选项'e'作些操作, 同时处理一下$OPTARG,
11         # which is the associated argument passed with option 'e'.
11         # 这个变量里边将保存传递给选项"e"的参数.
12     ...
13     g ) # 对选项'g'作些操作.
14   esac
15 done
16 shift $(($OPTIND - 1))
17 # 将参数指针向下移动.
18 
19 # 所有这些远没有它看起来的那么复杂.<嘿嘿>
20        
################################End Script######################################### 
Example 11-19 使用getopts命令来读取传递给脚本的选项/参数.
(我测试的结果与说明不同,我使用 ./scriptname -mnp,但是$OPTIND的值居然是1 1 2)
################################Start Script#######################################
 1 #!/bin/bash
 2 # 练习 getopts 和 OPTIND
 3 # 在Bill Gradwohl的建议下,这个脚本于 10/09/03 被修改.
 4 
 5 
 6 # 这里我们将学习 'getopts'如何处理脚本的命令行参数.
 7 # 参数被作为"选项"(标志)被解析,并且分配参数.
 8 
 9 # 试一下通过如下方法来调用这个脚本
10 # 'scriptname -mn'
11 # 'scriptname -oq qOption' (qOption 可以是任意的哪怕有些诡异字符的字符串.)
12 # 'scriptname -qXXX -r'
13 #
14 # 'scriptname -qr'    - 意外的结果, "r" 将被看成是选项 "q" 的参数.
15 # 'scriptname -q -r'  - 意外的结果, 同上.
16 # 'scriptname -mnop -mnop'  - 意外的结果
17 # (OPTIND is unreliable at stating where an option came from).
18 #
19 #  如果一个选项需要一个参数("flag:"),那么它应该
20 #+ 取得在命令行上挨在它后边的任何字符.
21 
22 NO_ARGS=0 
23 E_OPTERROR=65
24 
25 if [ $# -eq "$NO_ARGS" ]  # 不带命令行参数就调用脚本?
26 then
27   echo "Usage: `basename $0` options (-mnopqrs)"
28   exit $E_OPTERROR        # 如果没有参数传进来,那就退出,并解释用法.
29 fi  
30 # 用法: 脚本名 -选项名
31 # 注意: 破折号(-)是必须的
32 
33 
34 while getopts ":mnopq:rs" Option
35 do
36   case $Option in
37     m     ) echo "Scenario #1: option -m-   [OPTIND=${OPTIND}]";;
38     n | o ) echo "Scenario #2: option -$Option-   [OPTIND=${OPTIND}]";;
39     p     ) echo "Scenario #3: option -p-   [OPTIND=${OPTIND}]";;
40     q     ) echo "Scenario #4: option -q-\
41  with argument \"$OPTARG\"   [OPTIND=${OPTIND}]";;
42     #  注意,选项'q'必须分配一个参数,
43     #+ 否则默认将失败.
44     r | s ) echo "Scenario #5: option -$Option-";;
45     *     ) echo "Unimplemented option chosen.";;   # DEFAULT
46   esac
47 done
48 
49 shift $(($OPTIND - 1))
50 #  将参数指针减1,这样它将指向下一个参数.
51 #  $1 现在引用的是命令行上的第一个非选项参数
52 #+ 如果有一个这样的参数存在的话.
53 
54 exit 0
55 
56 #   像 Bill Gradwohl 所说,<rojy bug>
57 #  "The getopts mechanism allows one to specify:  scriptname -mnop -mnop
58 #+  but there is no reliable way to differentiate what came from where
59 #+  by using OPTIND."
################################End Script######################################### 
脚本行为 
source, . (点命令)
 这个命令在命令行上执行的时候,将会执行一个脚本.在一个文件内一个source file-name
 将会加载file-name文件.source一个文件(或点命令)将会在脚本中引入代码,并附加到脚
 本中(与C语言中的#include指令的效果相同).最终的结果就像是在使用"sourced"行上插
 入了相应文件的内容.这在多个脚本需要引用相同的数据,或函数库时非常有用.
Example 11-20 "Including"一个数据文件
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 . data-file    # 加载一个数据文件.
 4 # 与"source data-file"效果相同,但是更具可移植性.
 5 
 6 #  文件"data-file"必须存在于当前工作目录,
 7 #+ 因为这个文件时使用'basename'来引用的.
 8 
 9 # 现在,引用这个数据文件中的一些数据.
10 
11 echo "variable1 (from data-file) = $variable1"
12 echo "variable3 (from data-file) = $variable3"
13 
14 let "sum = $variable2 + $variable4"
15 echo "Sum of variable2 + variable4 (from data-file) = $sum"
16 echo "message1 (from data-file) is \"$message1\""
17 # 注意 :                            将双引号转义
18 
19 print_message This is the message-print function in the data-file.
20 
21 
22 exit 0
################################End Script#########################################
 Example 11-20使用的data-file.见上边,这个文件必须和上边的脚本放在同一目录下.
################################Start Script#######################################
 1 # 这是需要被脚本加载的data file.
 2 # 这种文件可以包含变量,函数,等等.
 3 # 在脚本中可以通过'source'或者'.'命令来加载.
 4 
 5 # 让我们初始化一些变量.
 6 
 7 variable1=22
 8 variable2=474
 9 variable3=5
10 variable4=97
11 
12 message1="Hello, how are you?"
13 message2="Enough for now. Goodbye."
14 
15 print_message ()
16 {
17 # Echo出传递进来的任何消息.
18 
19   if [ -z "$1" ]
20   then
21     return 1
22     # 如果没有参数的话,出错.
23   fi
24 
25   echo
26 
27   until [ -z "$1" ]
28   do
29     # 循环处理传递到函数中的参数.
30     echo -n "$1"
31     # 每次Echo 一个参数, -n禁止换行.
32     echo -n " "
33     # 在参数间插入空格.
34     shift
35     # 下一个.
36   done  
37 
38   echo
39 
40   return 0
41 }  
################################End Script######################################### 
 如果引入的文件本身就是一个可执行脚本的话,那么它将运行起来,当它return的时候,控制
 权又重新回到了引用它的脚本中.一个用source引入的脚本可以使用return 命令来达到这
 个目的. 
 也可以向需要source的脚本中传递参数.这些参数在source脚本中被认为是位置参数.
 1 source $filename $arg1 arg2 
 你甚至可以在脚本文件中source脚本文件自身,虽然看不出有什么实际的应用价值.
Example 11-21 一个没什么用的,source自身的脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 # self-source.sh: 一个脚本递归的source自身.
 3 # 来自于"Stupid Script Tricks," 卷 II.
 4 
 5 MAXPASSCNT=100    # source自身的最大数量.
 6 
 7 echo -n  "$pass_count  "
 8 #  在第一次运行的时候,这句只不过echo出2个空格,
 9 #+ 因为$pass_count还没被初始化.
10 
11 let "pass_count += 1"
12 #  假定这个为初始化的变量 $pass_count
13 #+ 可以在第一次运行的时候+1.
14 #  这句可以正常工作于Bash和pdksh,但是
15 #+ 它依赖于不可移植(并且可能危险)的行为.
16 #  更好的方法是在使用$pass_count之前,先把这个变量初始化为0.
17 
18 while [ "$pass_count" -le $MAXPASSCNT ]
19 do
20   . $0   # 脚本"sources" 自身, 而不是调用自己.
21          # ./$0 (应该能够正常递归) 但是不能在这正常运行. 为什么?
22 done  
23 
24 #  这里发生的动作并不是真正的递归,
25 #+ 因为脚本成功的展开了自己,换句话说,
26 #+ 在每次循环的过程中
27 #+ 在每个'source'行(第20行)上
28 #  都产生了新的代码.
29 #
30 #  当然,脚本会把每个新'sourced'进来的文件的"#!"行
31 #+ 都解释成注释,而不会把它看成是一个新的脚本.
32 
33 echo
34 
35 exit 0   # 最终的效果就是从1数到100.
36          # 让人印象深刻.
37 
38 # 练习:
39 # -----
40 # 使用这个小技巧编写一些真正能干些事情的脚本.
################################End Script######################################### 
exit
 绝对的停止一个脚本的运行.exit命令有可以随便找一个整数变量作为退出脚本返回shell
 时的退出码.使用exit 0对于退出一个简单脚本来说是种好习惯,表明成功运行. 
 注意: 如果不带参数的使用exit来退出,那么退出码将是脚本中最后一个命令的退出码.
  等价于exit $?. 
exec
 这个shell内建命令将使用一个特定的命令来取代当前进程.一般的当shell遇到一个命令,
 它会fork off一个子进程来真正的运行命令.使用exec内建命令,shell就不会fork了,并
 且命令的执行将会替换掉当前shell.因此,当我们在脚本中使用它时,当命令实行完毕,
 它就会强制退出脚本.[3]
Example 11-22 exec的效果
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 exec echo "Exiting \"$0\"."   # 脚本将在此退出.
 4 
 5 # ----------------------------------
 6 # 下边的部分将执行不到.
 7 
 8 echo "This echo will never echo."
 9 
10 exit 99                       #  脚本不会在这退出.
11                               #  脚本退出后检查一下退出码
12                               #+ 使用'echo $?'命令.
13                               #  肯定不是99.
################################End Script######################################### 
Example 11-23 一个exec自身的脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 # self-exec.sh
 3 
 4 echo
 5 
 6 echo "This line appears ONCE in the script, yet it keeps echoing."
 7 echo "The PID of this instance of the script is still $$."
 8 #     上边这句用来根本没产生子进程.
 9 
10 echo "==================== Hit Ctl-C to exit ===================="
11 
12 sleep 1
13 
14 exec $0   #  产生了本脚本的另一个实例,
15           #+ 并且这个实例代替了之前的那个.
16 
17 echo "This line will never echo!"  # 当然会这样.
18 
19 exit 0
################################End Script#########################################
 exec命令还能用于重新分配文件描述符.比如: exec <zzz-file将会用zzz-file来代替
 stdin. 
 注意: find命令的 -exec选项与shell内建的exec命令是不同的. 
shopt
 这个命令允许shell在空闲时修改shell选项(见Example 24-1和Example 24-2).它经常出
 现在启动脚本中,但是在一般脚本中也可用.需要Bash 2.0版本以上.
 1 shopt -s cdspell
 2 # Allows minor misspelling of directory names with 'cd'
 2 # 使用'cd'命令时,允许产生少量的拼写错误.
 3 
 4 cd /hpme  # 噢! 应该是'/home'.
 5 pwd       # /home
 6           # 拼写错误被纠正了. 
caller
 将caller命令放到函数中,将会在stdout上打印出函数调用者的信息.
  1 #!/bin/bash
  2 
  3 function1 ()
  4 {
  5   # 在 function1 () 内部.
  6   caller 0   # 显示调用者信息.
  7 }
  8 
  9 function1    # 脚本的第9行.
 10 
 11 # 9 main test.sh
 12 # ^                 函数调用者所在的行号.
 13 #   ^^^^            从脚本的"main"部分调用的.
 14 #        ^^^^^^^    调用脚本的名字
 15 
 16 caller 0     # 没效果,因为这个命令不再函数中. 
 caller命令也可以返回在一个脚本中被source的另一个脚本的信息.象函数一样,这是一个
 "子例程调用",你会发现这个命令在调试的时候特别有用. 
命令类 
ture
 一个返回成功(就是返回0)退出码的命令,但是除此之外什么事也不做.
 1 # 死循环
 2 while true   # 这里的true可以用":"替换
 3 do
 4    operation-1
 5    operation-2
 6    ...
 7    operation-n
 8    # 需要一种手段从循环中跳出来,或者是让这个脚本挂起.
 9 done 
flase
 一个返回失败(非0)退出码的命令,但是除此之外什么事也不做.
  1 # 测试 "false" 
  2 if false
  3 then
  4   echo "false evaluates \"true\""
  5 else
  6   echo "false evaluates \"false\""
  7 fi
  8 # 失败会显示"false"
  9 
 10 
 11 # while "false" 循环 (空循环)
 12 while false
 13 do
 14    # 这里边的代码将不会走到.
 15    operation-1
 16    operation-2
 17    ...
 18    operation-n
 19    # 什么事都没发生!
 20 done   
type[cmd]
 与which扩展命令很相像,type cmd将给出"cmd"的完整路径.与which命令不同的是,type命
 令是Bash内建命令.一个很有用的选项是-a选项,使用这个选项可以鉴别所识别的参数是关
 键字还是内建命令,也可以定位同名的系统命令.
 bash$ type '['
 [ is a shell builtin
 bash$ type -a '['
 [ is a shell builtin
 [ is /usr/bin/[ 
hash[cmds]
 在shell的hash表中[4],记录指定命令的路径名,所以在shell或脚本中在调用这个命令的
 话,shell或脚本将不需要再在$PATH中重新搜索这个命令了.如果不带参数的调用hash命
 令,它将列出所有已经被hash的命令.-r选项会重新设置hash表. 
bind
 bind内建命令用来显示或修改readline[5]的键绑定. 
help
 获得shell内建命令的一个小的使用总结.这与whatis命令比较象,但是help是内建命令.
 bash$ help exit
 exit: exit [n]
    Exit the shell with a status of N.  If N is omitted, the exit status
    is that of the last command executed. 
11.1 作业控制命令
-----------------
下边的作业控制命令需要一个"作业标识符"作为参数.见这章结尾的表. 
jobs
 在后台列出所有正在运行的作业,给出作业号. 
 注意: 进程和作业的概念太容易混淆了.特定的内建命令,比如kill,disown和wait即可以
  接受一个作业号作为参数也可以接受一个作为参数.但是fg,bg和jobs命令只能接受
  作业号作为参数.
  bash$ sleep 100 &
  [1] 1384 
  bash $ jobs
  [1]+  Running                 sleep 100 & 
  注意: "1"是作业号(作业是被当前shell所维护的),而"1384"是进程号(进程是被系统
   维护的).为了kill掉作业/进程,或者使用 kill %1命令或者使用kill 1384命令,
   这两个命令都可以. 
   感谢,S.C. 
disown
 从shell的当前作业表中,删除作业. 
fg,bg
 fg命令可以把一个在后台运行的作业放到前台来运行.而bg命令将会重新启动一个挂起的
 作业,并且在后台运行它.如果使用fg或者bg命令的时候没指定作业号,那么默认将对当前
 正在运行的作业做操作. 
wait
 停止脚本的运行,直到后台运行的所有作业都结束为止,或者直到指定作业号或进程号为选
 项的作业结束为止. 
 你可以使用wait命令来防止在后台作业没完成(这会产生一个孤儿进程)之前退出脚本. 
Example 11-24 在继续处理之前,等待一个进程的结束
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 ROOT_UID=0   # 只有$UID 为0的用户才拥有root权限.
 4 E_NOTROOT=65
 5 E_NOPARAMS=66
 6 
 7 if [ "$UID" -ne "$ROOT_UID" ]
 8 then
 9   echo "Must be root to run this script."
10   # "Run along kid, it's past your bedtime."
11   exit $E_NOTROOT
12 fi  
13 
14 if [ -z "$1" ]
15 then
16   echo "Usage: `basename $0` find-string"
17   exit $E_NOPARAMS
18 fi
19 
20 
21 echo "Updating 'locate' database..."
22 echo "This may take a while."
23 updatedb /usr &     # 必须使用root身份来运行.
24 
25 wait
26 # 将不会继续向下运行,除非 'updatedb'命令执行完成.
27 # 你希望在查找文件名之前更新database.
28 
29 locate $1
30 
31 #  如果没有'wait'命令的话,而且在比较糟的情况下,
32 #+ 脚本可能在'updatedb'命令还在运行的时候退出,
33 #+ 这将会导致'updatedb'成为一个孤儿进程.
34 
35 exit 0
################################End Script######################################### 
 当然,wait 也可以接受一个作业标识符作为参数,比如,wait %1或wait $PPID.见"作业标识
 符表". 
 注意: 在一个脚本中,使用一个后台运行的命令(使用&)可能会使这个脚本挂起,直到敲
  回车,挂起才会被恢复.看起来只有这个命令的结果需要输出到stdout的时候才会发
  生这种现象.这会是一个很烦人的现象.
    1 #!/bin/bash
    2 # test.sh    
    3 
    4 ls -l &
    5 echo "Done." 
  bash$ ./test.sh
  Done.
  [bozo@localhost test-scripts]$ total 1
  -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh
  _
                
  看起来在这个后台运行命令的后边放上一个wait命令可能会解决这个问题.
    1 #!/bin/bash
    2 # test.sh    
    3 
    4 ls -l &
    5 echo "Done."
    6 wait 
  bash$ ./test.sh
  Done.
  [bozo@localhost test-scripts]$ total 1
  -rwxr-xr-x    1 bozo     bozo           34 Oct 11 15:09 test.sh
        
  如果把这个后台运行命令的输出重定向到文件中或者重定向到/dev/null中,也能解决
  这个问题. 
suspend
 这个命令的效果与Control-Z很相像,但是它挂起的是这个shell(这个shell的父进程应该
 在合适的时候重新恢复它). 
logout
 退出一个登陆的shell,也可以指定一个退出码. 
times
 给出执行命令所占的时间,使用如下形式输出:
  0m0.020s 0m0.020s
 这是一种很有限的能力,因为这不常出现于shell脚本中. 
kill
 通过发送一个适当的结束信号,来强制结束一个进程(见Example 13-6).
Example 11-25 一个结束自身的脚本.
################################Start Script#######################################
 1 #!/bin/bash
 2 # self-destruct.sh
 3 
 4 kill $$  # 脚本将在此处结束自己的进程.
 5          # Recall that "$$" is the script's PID.
 5          # 回忆一下,"$$"就是脚本的PID.
 6 
 7 echo "This line will not echo."
 8 # 而且shell将会发送一个"Terminated"消息到stdout.
 9 
10 exit 0
11 
12 #  在脚本结束自身进程之后,
13 #+ 它返回的退出码是什么?
14 #
15 # sh self-destruct.sh
16 # echo $?
17 # 143
18 #
19 # 143 = 128 + 15
20 #             结束信号
################################End Script#########################################
 注意: kill -l将列出所有信号. kill -9 是"必杀"命令,这个命令将会结束哪些顽固的
  不想被kill掉的进程.有时候kill -15也可以干这个活.一个僵尸进程不能被登陆的
  用户kill掉, -- 因为你不能杀掉一些已经死了的东西 -- ,但是init进程迟早会
  把它清除干净.僵尸进程就是子进程已经结束掉,而父进程却没kill掉这个子进程,
  那么这个子进程就成为僵尸进程. 
command
 command命令会禁用别名和函数的查找.它只查找内部命令以及搜索路径中找到的脚本或可
 执行程序.(译者,只在要执行的命令与函数或别名同名时使用,因为函数的优先级比内建命
 令的优先级高) 
 (译者:注意一下bash执行命令的优先级:
  1.别名
  2.关键字
  3.函数
  4.内置命令
  5.脚本或可执行程序($PATH)
 ) 
 注意: 当象运行的命令或函数与内建命令同名时,由于内建命令比外部命令的优先级高,而
  函数比内建命令优先级高,所以bash将总会执行优先级比较高的命令.这样你就没有选
  择的余地了.所以Bash提供了3个命令来让你有选择的机会.command命令就是这3个命
  令之一.
  另外两个是builtin和enable. 
builtin
 在"builtin"后边的命令将只调用内建命令.暂时的禁用同名的函数或者是同名的扩展命令. 
enable
 这个命令或者禁用内建命令或者恢复内建命令.如: enable -n kill将禁用kill内建命令,
 所以当我们调用kill时,使用的将是/bin/kill外部命令. 
 -a选项将会恢复相应的内建命令,如果不带参数的话,将会恢复所有的内建命令.
 选项-f filename将会从适当的编译过的目标文件[6]中以共享库(DLL)的形式来加载一个
 内建命令. 
autoload
 这是从ksh的autoloader命令移植过来的.一个带有"autoload"声明的函数,在它第一次被
 调用的时候才会被加载.[7] 这样做会节省系统资源. 
 注意: autoload命令并不是Bash安装时候的核心命令的一部分.这个命令需要使用命令
  enable -f(见上边enable命令)来加载.
  
Table 11-1 作业标识符
==========================================================
 记法  | 含义
==========================================================
 %N    | 作业号[N]
==========================================================
 %S    | 以字符串S开头的被(命令行)调用的作业
==========================================================
 %?S   | 包含字符串S的被(命令行)调用的作业
==========================================================
 %%    | 当前作业(前台最后结束的作业,或后台最后启动的作业)
==========================================================
 %+    | 当前作业(前台最后结束的作业,或后台最后启动的作业)
==========================================================
 %-    | 最后的作业
==========================================================
 $!    | 最后的后台进程
========================================================== 
注意事项:
[1]  一个例外就是time命令,Bash官方文档说这个命令是一个关键字.
[2]  一个选项就是一个行为上比较象标志位的参数,可以用来打开或关闭脚本的某些行为.
  而和某个特定选项相关的参数就是用来控制这个选项功能是开启还是关闭的.
[3]  除非exec被用来重新分配文件描述符.
[4]  hash是一种处理存储在表中数据的方法,这种方法就是为表中的数据建立查找键.
  而数据项本身是不规则的,这样就可以通过一个简单的数学算法来产生一个数字,
  这个数字被用来作为查找键. 
  使用hash的一个最有利的地方就是提高了速度.而缺点就是会产生"冲撞" -- 也就是
  说,可能会有多个数据元素使用同一个主键. 
  关于hash的例子见 Example A-21 和 Example A-22.
[5]  在一个交互的shell中,readline库就是Bash用来读取输入的.
  (译者: 比如默认的Emacs风格的输入,当然也可以改为vi风格的输入)
[6]  一些可加载的内建命令的C源代码都放在/usr/share/doc/bash-?.??/functions下.
  注意: enable命令的-f选项并不是对所有系统都支持的(看移没移植上).
[7]  typeset -fu可以达到和autoload命令相同的作用. 
  
第12章 外部过滤器,程序和命令
=============================
标准的 UNIX 命令使得 shell 脚本更加灵活.通过简单的编程结构把shell指令和系统命令结
合起来,这才是脚本能力的所在. 
12.1 基本命令
-------------
新手必须要掌握的初级命令 
ls
 基本的列出所有文件的命令.但是往往就是因为这个命令太简单,所以我们总是低估它.比如
 ,用 -R 选项,这是递归选项,ls 将会以目录树的形式列出所有文件, 另一个很有用的选项
 是 -S ,将会按照文件尺寸列出所有文件, -t, 将会按照修改时间来列出文件,-i 选项会显
 示文件的inode(见 Example 12-4). 
Example 12-1 使用ls命令来创建一个烧录CDR的内容列表
################################Start Script#######################################
 1 #!/bin/bash
 2 # ex40.sh (burn-cd.sh)
 3 # 自动刻录CDR的脚本.
 4 
 5 
 6 SPEED=2          # 如果你的硬件支持的话,你可以选用更高的速度.
 7 IMAGEFILE=cdimage.iso
 8 CONTENTSFILE=contents
 9 DEVICE=cdrom
10 # DEVICE="0,0"     为了使用老版本的CDR
11 DEFAULTDIR=/opt  # 这是包含需要被刻录内容的目录.
12                  # 必须保证目录存在.
13                  # 小练习: 测试一下目录是否存在.
14 
15 # Uses Joerg Schilling's "cdrecord" package:
15 # 使用 Joerg Schilling 的 "cdrecord"包:
16 # http://www.fokus.fhg.de/usr/schilling/cdrecord.html
17 
18 #  如果一般用户调用这个脚本的话,可能需要root身份
19 #+ chmod u+s /usr/bin/cdrecord
20 #  当然, 这会产生安全漏洞, 虽然这是一个比较小的安全漏洞.
21 
22 if [ -z "$1" ]
23 then
24   IMAGE_DIRECTORY=$DEFAULTDIR
25   # 如果命令行没指定的话, 那么这个就是默认目录.
26 else
27     IMAGE_DIRECTORY=$1
28 fi
29 
30 # 创建一个内容列表文件.
31 ls -lRF $IMAGE_DIRECTORY > $IMAGE_DIRECTORY/$CONTENTSFILE
32 #  "l" 选项将给出一个"长"文件列表.
33 #  "R" 选项将使这个列表递归.
34 #  "F" 选项将标记出文件类型 (比如: 目录是以 /结尾, 而可执行文件以 *结尾).
35 echo "Creating table of contents."
36 
37 # 在烧录到CDR之前创建一个镜像文件.
38 mkisofs -r -o $IMAGEFILE $IMAGE_DIRECTORY
39 echo "Creating ISO9660 file system image ($IMAGEFILE)."
40 
41 # 烧录CDR.
42 echo "Burning the disk."
43 echo "Please be patient, this will take a while."
44 cdrecord -v -isosize speed=$SPEED dev=$DEVICE $IMAGEFILE
45 
46 exit $?
################################End Script######################################### 
cat, tac
 cat, 是单词 concatenate的缩写, 把文件的内容输出到stdout. 当与重定向操作符 (> 或
  >>)结合使用时, 一般都是用来将多个文件连接起来. 
 1 # Uses of 'cat'
 2 cat filename                          # 打印出文件内容.
 3 
 4 cat file.1 file.2 file.3 > file.123   # 把3个文件连接到一个文件中. 
 cat 命令的 -n 选项是为了在目标文件中的所有行前边插入行号. -b 选项 与 -n 选项一
 样, 区别是不对空行进行编号. -v 选项可以使用 ^ 标记法 来echo 出不可打印字符.-s选
 项可以把多个空行压缩成一个空行.
 见 Example 12-25 和 Example 12-21. 
 注意: 在一个 管道 中, 可能有一种把stdin 重定向  到一个文件中的更有效的办法, 这
  种方法比 cat文件的方法更有效率. 
 1 cat filename | tr a-z A-Z
 2 
 3 tr a-z A-Z < filename   #  效果相同,但是处理更少,
 4                         #+ 并且连管道都省掉了. 
 tac 命令, 就是 cat的反转, 将从文件的结尾列出文件. 
rev
 把每一行中的内容反转, 并且输出到 stdout上. 这个命令与 tac命令的效果是不同的, 因
 为它并不反转行序, 而是把每行的内容反转. 
 bash$ cat file1.txt
 This is line 1.
 This is line 2. 
 bash$ tac file1.txt
 This is line 2.
 This is line 1. 
 bash$ rev file1.txt
 .1 enil si sihT
 .2 enil si sihT 
cp
 这是文件拷贝命令. cp file1 file2 把 file1 拷贝到 file2, 如果存在 file2 的话,那
 file2 将被覆盖 (见 Example 12-6). 
 注意: 特别有用的选项就是 -a  归档 选项 (为了copy一个完整的目录树), -u 是更新选
  项, 和 -r 与 -R  递归选项. 
 1 cp -u source_dir/* dest_dir
 2 #  "Synchronize" dest_dir to source_dir把源目录"同步"到目标目录上,
 3 #+  也就是拷贝所有更新的文件和之前不存在的文件. 
mv
 这是文件移动命令. 它等价于 cp 与 rm 命令的组合. 它可以把多个文件移动到目录中,甚
 至将目录重命名. 想查看 mv 在脚本中使用的例子, 见 Example 9-18 和 Example A-2. 
 注意: 当使用非交互脚本时,可以使用 mv 的-f  (强制) 选项来避免用户的输入. 
 当一个目录被移动到一个已存在的目录时,那么它将成为目标目录的子目录. 
 bash$ mv source_directory target_directory 
 bash$ ls -lF target_directory
 total 1
 drwxrwxr-x    2 bozo  bozo      1024 May 28 19:20 source_directory/ 
rm
 删除(清除)一个或多个文件. -f  选项将强制删除文件,即使这个文件是只读的.并且可以
 用来避免用户输入(在非交互脚本中使用). 
 注意: rm 将无法删除以破折号开头的文件.
 bash$ rm -badname
 rm: invalid option -- b
 Try `rm --help' for more information. 
 解决这个问题的一个方法就是在要删除的文件的前边加上"./".
 bash$ rm ./-badname 
 另一种解决的方法是 在文件名前边加上 " -- ".
 bash$ rm -- -badname 
 注意: 当使用递归参数 -r时, rm 命令将会删除整个目录树. 如果不慎使用 rm -rf *那整
  个目录树就真的完了. 
rmdir
 删除目录. 但是只有这个目录中没有文件 -- 当然会包含不可见的  点文件  [1]  -- 的
 时候这个命令才会成功. 
mkdir
 生成目录, 创建一个空目录. 比如, mkdir -p project/programs/December  将会创建出
 这个指定的目录, 即使project目录和programs目录都不存在. -p 选项将会自动产生必要
 的父目录, 这样也就同时创建了多个目录. 
chmod
 修改一个现存文件的属性 (见 Example 11-12).
 1 chmod +x filename
 2 # 使得文件filename对所有用户都可执行.
 3 
 4 chmod u+s filename
 5 # 设置"filename"文件的"suid"位.
 6 # 这样一般用户就可以执行"filename", 他将拥有和文件宿主相同的权限.
 7 # (这并不适用于shell 脚本) 
 1 chmod 644 filename
 2 # Makes "filename" readable/writable to owner, readable to
 3 # 设置文件宿主的 r/w 权限,并对一般用户
 3 # 设置读权限.
 4 # (8进制模式). 
 1 chmod 1777 directory-name
 2 # 对这个目录设置r/w 和可执行权限, 并开放给所有人.
 3 # 同时设置 "粘贴位".
 4 # 这意味着,　只有目录宿主,
 5 # 文件宿主, 当然, 还有root
 6 # 可以删除这个目录中的任何特定的文件. 
chattr
 修改文件属性. 这个命令与上边的 chmod 命令相类似, 但是有不同的选项和不同的调用语
 法, 并且这个命令只能工作在ext2文件系统中. 
 chattr  命令的一个特别有趣的选项是i. chattr +i filename 将使得这个文件被标记为
 永远不变. 这个文件将不能被修改, 连接, 或删除, 即使是root也不行. 这个文件属性只
 能被root设置和删除. 类似的, a 选项将会把文件标记为只能追加数据. 
 root# chattr +i file1.txt 
 root# rm file1.txt 
 rm: remove write-protected regular file `file1.txt'? y
 rm: cannot remove `file1.txt': Operation not permitted 
 如果文件设置了s(安全)属性, 那么当这个文件被删除时,这个文件所在磁盘的块将全部被0
 填充. 
 如果文件设置了u(不可删除)属性, 那么当这个文件被删除后, 这个文件的内容还可以被恢
 复(不可删除). 
 如果文件设置了c(压缩)属性, 那么当这个文件在进行写操作时,它将自动被压缩,并且在
 读的时候, 自动解压. 
 注意: 使用命令chattr do设置的属性, 将不会显示在文件列表中(ls -l). 
ln
 创建文件链接, 前提是这个文件是存在的. "链接"  就是一个文件的引用, 也就是这个文
 件的另一个名字. ln 命令允许对同一个文件引用多个链接,并且是避免混淆的一个很好的
 方法 (见 Example 4-6). 
 ln 对于文件来说只不过是创建了一个引用, 一个指针而已, 因为创建出来的连接文件只有
 几个字节. 
 绝大多数使用ln 命令时使用是 -s 选项, 可以称为符号链接, 或软链接.使用 -s 选项的
 一个优点是它可以穿越文件系统来链接目录. 
 关于使用这个命令的语法还是有点小技巧的. 比如: ln -s oldfile newfile 将对老文件
 产生一个新的文件链接. 
 注意: 如果之前就存在newfile的话, 那么将会产生一个错误消息. 
  使用链接中的哪种类型?
  就像 John Macdonald 解释的那样: 
  不论是那种类型的链接, 都提供了一种双向引用的手段 -- 也就是说, 不管你用文件
  的那个名字对文件内容进行修改, 你修改的效果都即会反映到原始名字的文件, 也会
  反映到链接名字的文件.当你工作在更高层次的时候, 才会发生软硬链接的不同. 硬链
  接的优点是, 原始文件与链接文件之间是相互独立的 -- 如果你删除或者重命名老文
  件, 那么这种操作将不会影响硬链接的文件, 硬链接的文件讲还是原来文件的内容. 
  然而如果你使用软链接的, 当你把老文件删除或重命名后, 软链接将再也找不到原来
  文件的内容了. 而软链接的优点是它可以跨越文件系统(因为它只不过是文件名的一个
  引用, 而并不是真正的数据). 与硬链接的另一个不同是, 一个符号链接可以指向一个
  目录. 
 链接给出了一种可以用多个名字来调用脚本的能力(当然这也适用于任何可执行的类型), 
 并且脚本的行为将依赖于脚本是如何被调用的. 
Example 12-2 Hello or Good-bye
################################Start Script#######################################
 1 #!/bin/bash
 2 # hello.sh: 显示"hello" 还是 "goodbye"
 3 #+          依赖于脚本是如何被调用的.
 4 
 5 # 在当前目录下($PWD)为这个脚本创建一个链接:
 6 #    ln -s hello.sh goodbye
 7 # 现在, 通过如下两种方法来调用这个脚本:
 8 # ./hello.sh
 9 # ./goodbye
10 
11 
12 HELLO_CALL=65
13 GOODBYE_CALL=66
14 
15 if [ $0 = "./goodbye" ]
16 then
17   echo "Good-bye!"
18   # 当然, 在这里你也可以添加一些其他的 goodbye类型的命令.Some other goodbye-type commands, as appropriate.
19   exit $GOODBYE_CALL
20 fi
21 
22 echo "Hello!"
23 # 当然, 在这里你也可以添加一些其他的 hello类型的命令.
24 exit $HELLO_CALL
################################End Script######################################### 
man, info
 These 这两个命令用来查看系统命令或安装工具的手册和信息.当两者都可用时, info 页
 一般比 man也会包含更多的细节描述. 
注意事项:
[1]  Dotfiles 就是文件名以"."开头的文件, 比如 ~/.Xdefaults. 这样的文件在一般的 l
  s 命令使用中将不会被显示出来 (当然 ls -a 将会显示它们), 并且它们也不会被一
  个意外的 rm -rf *删除. 在用户的home目录中,Dotfiles 一般被用来当作安装和配置
  文件. 
12.2 复杂命令
-------------
更高级的用户命令 
find
 -exec COMMAND \; 
 在每一个find 匹配到的文件执行 COMMAND 命令. 命令序列以 ; 结束( ";" 是 转义符 以
 保证 shell 传递到find命令中的字符不会被解释为其他的特殊字符). 
 bash$ find ~/ -name '*.txt'
 /home/bozo/.kde/share/apps/karm/karmdata.txt
 /home/bozo/misc/irmeyc.txt
 /home/bozo/test-scripts/1.txt 
 如果 COMMAND 中包含 {}, 那么 find  命令将会用所有匹配文件的路径名来替换 "{}" . 
 1 find ~/ -name 'core*' -exec rm {} \;
 2 # 从用户的 home 目录中删除所有的 core dump文件. 
  1 find /home/bozo/projects -mtime 1
  2 #  列出最后一天被修改的
  3 #+ 在/home/bozo/projects目录树下的所有文件.
  4 #
  5 #  mtime = last modification time of the target file
  6 #  ctime = last status change time (via 'chmod' or otherwise)
  7 #  atime = last access time
  8 
  9 DIR=/home/bozo/junk_files
 10 find "$DIR" -type f -atime +5 -exec rm {} \;
 11 #                                      ^^
 12 #  大括号就是"find"命令用来替换目录的地方.
 13 #
 14 #  删除至少5天内没被存取过的
 15 #+ "/home/bozo/junk_files" 中的所有文件.
 16 #
 17 #  "-type filetype", where
 18 #  f = regular file
 19 #  d = directory, etc.
 20 #  ('find' 命令的 man页有完整的选项列表.) 
  1 find /etc -exec grep '[0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*[.][0-9][0-9]*' {} \;
  2 
  3 # 在/etc 目录中的文件找到所所有包含 IP 地址(xxx.xxx.xxx.xxx) 的文件.
  4 # 可能会查找到一些多余的匹配. 我们如何去掉它们呢?
  5 
  6 # 或许可以使用如下方法:
  7 
  8 find /etc -type f -exec cat '{}' \; | tr -c '.[:digit:]' '\n' \
  9 | grep '^[^.][^.]*\.[^.][^.]*\.[^.][^.]*\.[^.][^.]*$'
 10 #
 11 #  [:digit:] 是一种字符类.is one of the character classes
 12 #+ 关于字符类的介绍见 POSIX 1003.2 标准化文档. 
 13 
 14 # Thanks, Stéphane Chazelas. 
 注意: find 命令的 -exec 选项不应该与shell中的内建命令 exec 相混淆. 
Example 12-3 删除当前目录下文件名中包含一些特殊字符(包括空白)的文件..
################################Start Script#######################################
 1 #!/bin/bash
 2 # badname.sh
 3 # 删除当前目录下文件名中包含一些特殊字符的文件.
 4 
 5 for filename in *
 6 do
 7   badname=`echo "$filename" | sed -n /[\+\{\;\"\\\=\?~\(\)\<\>\&\*\|\$]/p`
 8 # badname=`echo "$filename" | sed -n '/[+{;"\=?~()<>&*|$]/p'`  这句也行.
 9 # 删除文件名包含这些字符的文件:     + { ; " \ = ? ~ ( ) < > & * | $
10 #
11   rm $badname 2>/dev/null
12 #             ^^^^^^^^^^^ 错误消息将被抛弃.
13 done
14 
15 # 现在, 处理文件名中以任何方式包含空白的文件.
16 find . -name "* *" -exec rm -f {} \;
17 # "find"命令匹配到的目录名将替换到{}的位置.
18 # '\' 是为了保证 ';'被正确的转义, 并且放到命令的结尾.
19 
20 exit 0
21 
22 #---------------------------------------------------------------------
23 # 这行下边的命令将不会运行, 因为 "exit" 命令.
24 
25 # 这句是上边脚本的一个可选方法:
26 find . -name '*[+{;"\\=?~()<>&*|$ ]*' -exec rm -f '{}' \;
27 # (Thanks, S.C.)
################################End Script######################################### 
Example 12-4 通过文件的 inode 号来删除文件
################################Start Script#######################################
 1 #!/bin/bash
 2 # idelete.sh: 通过文件的inode号来删除文件.
 3 
 4 #  当文件名以一个非法字符开头的时候, 这就非常有用了,
 5 #+ 比如 ? 或 -.
 6 
 7 ARGCOUNT=1                      # 文件名参数必须被传递到脚本中.
 8 E_WRONGARGS=70
 9 E_FILE_NOT_EXIST=71
10 E_CHANGED_MIND=72
11 
12 if [ $# -ne "$ARGCOUNT" ]
13 then
14   echo "Usage: `basename $0` filename"
15   exit $E_WRONGARGS
16 fi  
17 
18 if [ ! -e "$1" ]
19 then
20   echo "File \""$1"\" does not exist."
21   exit $E_FILE_NOT_EXIST
22 fi  
23 
24 inum=`ls -i | grep "$1" | awk '{print $1}'`
25 # inum = inode (索引节点) 号.
26 # --------------------------------------------------------
27 # 每个文件都有一个inode号, 这个号用来记录文件物理地址信息.
28 # --------------------------------------------------------
29 
30 echo; echo -n "Are you absolutely sure you want to delete \"$1\" (y/n)? "
31 # 'rm' 命令的 '-v' 选项也会问这句话.
32 read answer
33 case "$answer" in
34 [nN]) echo "Changed your mind, huh?"
35       exit $E_CHANGED_MIND
36       ;;
37 *)    echo "Deleting file \"$1\".";;
38 esac
39 
40 find . -inum $inum -exec rm {} \;
41 #                           ^^
42 #        大括号就是"find"命令
43 #+       用来替换文本输出的地方.
44 echo "File "\"$1"\" deleted!"
45 
46 exit 0
################################End Script#########################################
 见 Example 12-27, Example 3-4, 和 Example 10-9 这些例子展示了使用 find 命令. 对
 于这个复杂而有强大的命令来说, 查看man页可以获得更多的细节. 
xargs
 这是给命令传递参数的一个过滤器, 也是组合多个命令的一个工具.它把一个数据流分割为
 一些足够小的块, 以方便过滤器和命令进行处理. 由此这个命令也是后置引用的一个强有
 力的替换. 在一般使用过多参数的命令替换失败的时候,用xargs 来替换它一般都能成功. 
 [1] 通常情况下, xargs 从管道或者stdin中读取数据, 但是它也能够从文件的输出中读取
 数据. 
 xargs的默认命令是 echo. 这意味着通过管道传递给xargs的输入将会包含换行和空白, 不
 过通过xargs的处理, 换行和空白将被空格取代. 
 bash$ ls -l
 total 0
 -rw-rw-r--    1 bozo  bozo         0 Jan 29 23:58 file1
 -rw-rw-r--    1 bozo  bozo         0 Jan 29 23:58 file2 
  
 bash$ ls -l | xargs
 total 0 -rw-rw-r-- 1 bozo bozo 0 Jan 29 23:58 file1 -rw-rw-r-- 1 bozo bozo 0 Jan 29 23:58 file2 
  
 bash$ find ~/mail -type f | xargs grep "Linux"
 ./misc:User-Agent: slrn/0.9.8.1 (Linux)
 ./sent-mail-jul-2005: hosted by the Linux Documentation Project.
 ./sent-mail-jul-2005: (Linux Documentation Project Site, rtf version)
 ./sent-mail-jul-2005: Subject: Criticism of Bozo's Windows/Linux article
 ./sent-mail-jul-2005: while mentioning that the Linux ext2/ext3 filesystem
 . . . 
 ls | xargs -p -l gzip 使用gzips 压缩当前目录下的每个文件, 一次压缩一个, 并且在
 每次压缩前都提示用户. 
 注意: 一个有趣的 xargs  选项是 -n NN, NN 是限制每次传递进来参数的个数.
  ls | xargs -n 8 echo 以每行8列的形式列出当前目录下的所有文件. 
 注意: 另一个有用的选项是 -0, 使用 find -print0 或 grep -lZ 这两种组合方式. 这允
  许处理包含空白或引号的参数. 
 find / -type f -print0 | xargs -0 grep -liwZ GUI | xargs -0 rm -f 
 grep -rliwZ GUI / | xargs -0 rm -f 
 上边两行都可用来删除任何包含 "GUI" 的文件. (Thanks, S.C.) 
Example 12-5 Logfile: 使用 xargs 来监控系统 log
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # 从 /var/log/messagesGenerates 的尾部开始
 4 # 产生当前目录下的一个lof 文件.
 5 
 6 # 注意: 如果这个脚本被一个一般用户调用的话,
 7 # /var/log/messages 必须是全部可读的.
 8 #         #root chmod 644 /var/log/messages
 9 
10 LINES=5
11 
12 ( date; uname -a ) >>logfile
13 # 时间和机器名
14 echo --------------------------------------------------------------------- >>logfile
15 tail -$LINES /var/log/messages | xargs |  fmt -s >>logfile
16 echo >>logfile
17 echo >>logfile
18 
19 exit 0
20 
21 #  注意:
22 #  -----
23 #  像 Frank Wang 所指出,
24 #+ 在原文件中的任何不匹配的引号(包括单引号和双引号)
25 #+ 都会给xargs造成麻烦.
26 #
27 #  他建议使用下边的这行来替换上边的第15行:
28 #     tail -$LINES /var/log/messages | tr -d "\"'" | xargs | fmt -s >>logfile
29 
30 
31 
32 #  练习:
33 #  -----
34 #  修改这个脚本, 使得这个脚本每个20分钟
35 #+ 就跟踪一下 /var/log/messages 的修改记录.
36 #  提示: 使用 "watch" 命令. 
################################End Script#########################################
 在find命令中, 一对大括号就一个文本替换的位置.
Example 12-6 把当前目录下的文件拷贝到另一个文件中
################################Start Script#######################################
 1 #!/bin/bash
 2 # copydir.sh
 3 
 4 #  拷贝 (verbose) 当前目录($PWD)下的所有文件到
 5 #+ 命令行中指定的另一个目录下.
 6 
 7 E_NOARGS=65
 8 
 9 if [ -z "$1" ]   # 如果没有参数传递进来那就退出.
10 then
11   echo "Usage: `basename $0` directory-to-copy-to"
12   exit $E_NOARGS
13 fi  
14 
15 ls . | xargs -i -t cp ./{} $1
16 #            ^^ ^^      ^^
17 #  -t 是 "verbose" (输出命令行到stderr) 选项.
18 #  -i 是"替换字符串"选项.
19 #  {} 是输出文本的替换点.
20 #  这与在"find"命令中使用{}的情况很相像.
21 #
22 #  列出当前目录下的所有文件(ls .),
23 #+ 将 "ls" 的输出作为参数传递到 "xargs"(-i -t 选项) 中,
24 #+ 然后拷贝(cp)这些参数({})到一个新目录中($1).
25 #
26 #  最终的结果和下边的命令等价,
27 #+   cp * $1
28 #+ 除非有文件名中嵌入了"空白"字符.
29 
30 exit 0
################################End Script######################################### 
Example 12-7 通过名字Kill进程
################################Start Script#######################################
 1 #!/bin/bash
 2 # kill-byname.sh: 通过名字kill进程.
 3 # 与脚本kill-process.sh相比较.
 4 
 5 #  例如,
 6 #+ 试一下 "./kill-byname.sh xterm" --
 7 #+ 并且查看你系统上的所有xterm都将消失.
 8 
 9 #  警告:
10 #  -----
11 #  这是一个非常危险的脚本.
12 #  运行它的时候一定要小心. (尤其是以root身份运行时)
13 #+ 因为运行这个脚本可能会引起数据丢失或产生其他一些不好的效果.
14 
15 E_BADARGS=66
16 
17 if test -z "$1"  # 没有参数传递进来?
18 then
19   echo "Usage: `basename $0` Process(es)_to_kill"
20   exit $E_BADARGS
21 fi
22 
23 
24 PROCESS_NAME="$1"
25 ps ax | grep "$PROCESS_NAME" | awk '{print $1}' | xargs -i kill {} 2&>/dev/null
26 #                                                       ^^      ^^
27 
28 # -----------------------------------------------------------
29 # 注意:
30 # -i 参数是xargs命令的"替换字符串"选项.
31 # 大括号对的地方就是替换点.
32 # 2&>/dev/null 将会丢弃不需要的错误消息.
33 # -----------------------------------------------------------
34 
35 exit $?
################################End Script######################################### 
Example 12-8 使用xargs分析单词出现的频率
################################Start Script#######################################
 1 #!/bin/bash
 2 # wf2.sh: Crude word frequency analysis on a text file.
 3 
 4 # 使用 'xargs' 将文本行分解为单词.
 5 # 于后边的 "wf.sh" 脚本相比较.
 6 
 7 
 8 # 检查命令行上输入的文件.
 9 ARGS=1
10 E_BADARGS=65
11 E_NOFILE=66
12 
13 if [ $# -ne "$ARGS" ]
14 # 纠正传递到脚本中的参数个数?
15 then
16   echo "Usage: `basename $0` filename"
17   exit $E_BADARGS
18 fi
19 
20 if [ ! -f "$1" ]       # 检查文件是否存在.
21 then
22   echo "File \"$1\" does not exist."
23   exit $E_NOFILE
24 fi
25 
26 
27 
28 #################################################################
29 cat "$1" | xargs -n1 | \
30 #  列出文件, 每行一个单词.
31 tr A-Z a-z | \
32 #  将字符转换为小写.
33 sed -e 's/\.//g'  -e 's/\,//g' -e 's/ /\
34 /g' | \
35 #  过滤掉句号和逗号,
36 #+ 并且将单词间的空格修改为换行,
37 sort | uniq -c | sort -nr
38 #  最后统计出现次数,把数字显示在第一列,然后显示单词,并按数字排序.
39 #################################################################
40 
41 #  这个例子的作用与"wf.sh"的作用是一样的,
42 #+ 但是这个例子比较臃肿, 并且运行起来更慢一些(为什么?).
43 
44 exit 0
################################End Script######################################### 
expr
 通用求值表达式: 通过给定的操作(参数必须以空格分开)连接参数,并对参数求值.可以使
 算术操作, 比较操作, 字符串操作或者是逻辑操作. 
 expr 3 + 5 
  返回 8
 expr 5 % 3 
  返回 2
 expr 1 / 0 
  返回错误消息, expr: division by zero 
  不允许非法的算术操作.
 expr 5 \* 3 
  返回 15 
  在算术表达式expr中使用乘法操作时, 乘法符号必须被转义.
 y=`expr $y + 1` 
  增加变量的值, 与 let y=y+1 和 y=$(($y+1)) 的效果相同. 这是使用算术表达式的
  一个例子.
 z=`expr substr $string $position $length` 
  在位置$position上提取$length长度的子串. 
Example 12-9 使用 expr
################################Start Script#######################################
  1 #!/bin/bash
  2 
  3 # 展示一些 'expr'的使用
  4 # =====================
  5 
  6 echo
  7 
  8 # 算术 操作
  9 # ---- ----
 10 
 11 echo "Arithmetic Operators"
 12 echo
 13 a=`expr 5 + 3`
 14 echo "5 + 3 = $a"
 15 
 16 a=`expr $a + 1`
 17 echo
 18 echo "a + 1 = $a"
 19 echo "(incrementing a variable)"
 20 
 21 a=`expr 5 % 3`
 22 # 取模操作
 23 echo
 24 echo "5 mod 3 = $a"
 25 
 26 echo
 27 echo
 28 
 29 # 逻辑 操作
 30 # ---- ----
 31 
 32 #  true返回 1 ,false 返回 0 ,
 33 #+ 而Bash的使用惯例则相反.
 34 
 35 echo "Logical Operators"
 36 echo
 37 
 38 x=24
 39 y=25
 40 b=`expr $x = $y`         # 测试相等.
 41 echo "b = $b"            # 0  ( $x -ne $y )
 42 echo
 43 
 44 a=3
 45 b=`expr $a \> 10`
 46 echo 'b=`expr $a \> 10`, therefore...'
 47 echo "If a > 10, b = 0 (false)"
 48 echo "b = $b"            # 0  ( 3 ! -gt 10 )
 49 echo
 50 
 51 b=`expr $a \< 10`
 52 echo "If a < 10, b = 1 (true)"
 53 echo "b = $b"            # 1  ( 3 -lt 10 )
 54 echo
 55 # Note escaping of operators.
 56 
 57 b=`expr $a \<= 3`
 58 echo "If a <= 3, b = 1 (true)"
 59 echo "b = $b"            # 1  ( 3 -le 3 )
 60 # 也有 "\>=" 操作 (大于等于).
 61 
 62 
 63 echo
 64 echo
 65 
 66 
 67 
 68 # 字符串 操作
 69 # ------ ----
 70 
 71 echo "String Operators"
 72 echo
 73 
 74 a=1234zipper43231
 75 echo "The string being operated upon is \"$a\"."
 76 
 77 # 长度: 字符串长度
 78 b=`expr length $a`
 79 echo "Length of \"$a\" is $b."
 80 
 81 # 索引: 从字符串的开头查找匹配的子串,
 82 #       并取得第一个匹配子串的位置.
 83 b=`expr index $a 23`
 84 echo "Numerical position of first \"2\" in \"$a\" is \"$b\"."
 85 
 86 # substr: 从指定位置提取指定长度的字串.
 87 b=`expr substr $a 2 6`
 88 echo "Substring of \"$a\", starting at position 2,\
 89 and 6 chars long is \"$b\"."
 90 
 91 
 92 #  'match' 操作的默认行为就是
 93 #+ 从字符串的开始进行搜索,并匹配第一个匹配的字符串.
 94 #
 95 #        使用正则表达式
 96 b=`expr match "$a" '[0-9]*'`               #  数字的个数.
 97 echo Number of digits at the beginning of \"$a\" is $b.
 98 b=`expr match "$a" '\([0-9]*\)'`           #  注意需要转义括号
 99 #                   ==      ==              + 这样才能触发子串的匹配.
100 echo "The digits at the beginning of \"$a\" are \"$b\"."
101 
102 echo
103 
104 exit 0
################################End Script#########################################
 注意: ":" 操作可以替换 match. 比如, b=`expr $a : [0-9]*`与上边所使用的 b=`expr 
  match $a [0-9]*` 完全等价. 
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 echo
 4 echo "String operations using \"expr \$string : \" construct"
 5 echo "==================================================="
 6 echo
 7 
 8 a=1234zipper5FLIPPER43231
 9 
10 echo "The string being operated upon is \"`expr "$a" : '\(.*\)'`\"."
11 #     转义括号对操作.                                   ==  ==
12 
13 #       ***************************
14 #+              转移括号对
15 #+           用来匹配一个子串
16 #       ***************************
17 
18 
19 #  如果不转义括号的话...
20 #+ 那么 'expr' 将把string操作转换为一个整数.
21 
22 echo "Length of \"$a\" is `expr "$a" : '.*'`."   # 字符串长度
23 
24 echo "Number of digits at the beginning of \"$a\" is `expr "$a" : '[0-9]*'`."
25 
26 # ------------------------------------------------------------------------- #
27 
28 echo
29 
30 echo "The digits at the beginning of \"$a\" are `expr "$a" : '\([0-9]*\)'`."
31 #                                                             ==      ==
32 echo "The first 7 characters of \"$a\" are `expr "$a" : '\(.......\)'`."
33 #         =====                                          ==       ==
34 # 再来一个, 转义括号对强制一个子串匹配.
35 #
36 echo "The last 7 characters of \"$a\" are `expr "$a" : '.*\(.......\)'`."
37 #         ====                  end of string operator  ^^
38 #  (最后这个模式的意思是忽略前边的任何字符,直到最后7个字符,
39 #+  最后7个点就是需要匹配的任意7个字符的字串)
40 
41 echo
42 
43 exit 0
################################End Script######################################### 
上边的脚本展示了expr是如何使用转义的括号对  -- \( ... \) -- 和 正则表达式 一起来分
析和匹配子串. 下边是另外一个例子, 这次的例子是真正的应用用例. 
1 # 去掉字符串开头和结尾的空白.
2 LRFDATE=`expr "$LRFDATE" : '[[:space:]]*\(.*\)[[:space:]]*$'`
3 
4 #  来自于 Peter Knowle的 "booklistgen.sh" 脚本
5 #+ 用来将文件转换为Sony Librie格式.
6 #  (http://booklistgensh.peterknowles.com) 
Perl, sed, 和 awk 是更强大的字符串分析工具. 在脚本中嵌入一段比较短的 sed 或 awk
操作 (见 Section 33.2) 比使用 expr 更加有吸引力. 
见 Section 9.2 将会有更多使用 expr 进行字符串操作的例子. 
注意事项: 
[1]  即使在不必非得强制使用 xargs 的时候, 使用 xargs 也可以明显地提高多文件批处
  理执行命令的速度. 
[]     
    
高级Bash脚本编程指南(三)（下）
文章整理: 文章来源: 网络 
12.3 时间/日期 命令
-------------------
时间/日期 和计时 
date
 直接调用, date 就会打印日期和时间到 stdout 上. 这个命令有趣的地方在于它的格式化
 和分析选项上. 
Example 12-10 使用 date 命令
################################Start Script#######################################
 1 #!/bin/bash
 2 # 练习 'date' 命令
 3 
 4 echo "The number of days since the year's beginning is `date +%j`."
 5 # 需要在调用格式的前边加上一个 '+' 号.
 6 # %j 给出今天是本年度的第几天.
 7 
 8 echo "The number of seconds elapsed since 01/01/1970 is `date +%s`."
 9 #  %s 将产生从 "UNIX 元年" 到现在为止的秒数,yields number of seconds since "UNIX epoch" began,
10 #+ 但是这东西有用么?
11 
12 prefix=temp
13 suffix=$(date +%s)  # 'date'命令的 "+%s" 选项是 GNU-特性.
14 filename=$prefix.$suffix
15 echo $filename
16 #  这是一种非常好的产生 "唯一" 的临时文件的办法,
17 #+ 甚至比使用 $$ 都强.
18 
19 # 如果想了解 'date' 命令的更多选项, 请查阅这个命令的 man 页.
20 
21 exit 0
################################End Script#########################################
 -u 选项将给出 UTC (译者: UTC 是协调世界时英文缩写) 时间(Universal Coordinated T
 ime). 
 bash$ date
 Fri Mar 29 21:07:39 MST 2002 
  
 bash$ date -u
 Sat Mar 30 04:07:42 UTC 2002 
 date 命令有许多的输出选项. 比如 %N 将以10亿分之一为单位表示当前时间. 这个选项的
 一个有趣的用法就是用来产生一个6位的随机数. 
 1 date +%N | sed -e 's/000$//' -e 's/^0//'
 2            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
 3 # 去掉开头和结尾的0. 
 当然,还有许多其它的选项 (请查看 man date). 
  1 date +%j
  2 # 显示今天是本年度的第几天(从1月1日开始计算).
  3 
  4 date +%k%M
  5 # 显示当前小时数和分钟数.
  6 
  7 
  8 
  9 #  'TZ' 参数允许改变当前的默认时区.
 10 date                 # Mon Mar 28 21:42:16 MST 2005
 11 TZ=EST date          # Mon Mar 28 23:42:16 EST 2005
 12 # Thanks, Frank Kannemann and Pete Sjoberg, for the tip.
 13 
 14 
 15 SixDaysAgo=$(date --date='6 days ago')
 16 OneMonthAgo=$(date --date='1 month ago')  # 4周前(不是一个月).
 17 OneYearAgo=$(date --date='1 year ago') 
 参见 Example 3-4. 
zdump
 查看特定时区的当前时间. 
 bash$ zdump EST
 EST  Tue Sep 18 22:09:22 2001 EST 
time  
 输出统计出来的命令执行的时间.
 time ls -l / 给出的输出大概是如下格式: 
   
 0.00user 0.01system 0:00.05elapsed 16%CPU (0avgtext+0avgdata 0maxresident)k
 0inputs+0outputs (149major+27minor)pagefaults 0swaps 
 参见前边章节所讲的一个类似的命令 times .  
 注意: 在Bash的  2.0版本 中, time 成为了shell的一个保留字, 并且在一个带有管道的
  命令行中,这个命令的行为有些小的变化. 
touch
 这是一个用来更新文件被存取或修改的时间的工具,这个时间可以是当前系统的时间,也可
 以是指定的时间, 这个命令也用来产生一个新文件.命令 touch zzz 将产生一个以zzz为名
 字的0字节长度文件, 当然前提是zzz文件不存在. 为了存储时间信息, 就需要一个时间戳
 为空的文件, 比如当你想跟踪一个工程的修改时间的时候,这就非常有用了.  
 注意: touch 命令等价于 : >> newfile  或 >> newfile (对于一个普通文件). 
at
 at 命令是一个作业控制命令, 用来在指定时间执行给定的命令集合.它有点像 cron 命令,
 然而, at 命令主要还是用来执行那种一次性执行的命令集合. 
 at 2pm January 15 将会提示让你输入需要在这个时间你要执行的命令序列. 这些命令应
 该是可以和shell脚本兼容的,因为, 实际上, 在一个可执行的脚本中, 用户每次只能敲一
 行. 输入以 Ctl-D 结束. 
 你可以使用-f选项或者使用 (<)重定向操作符, 来让 at  命令从一个文件中读取命令
 集合. 这个文件其实就一个可执行的的脚本, 虽然它是一个不可交互的脚本. 在文件中包
 含一个 run-parts 命令, 对于执行一套不同的脚本来说是非常聪明的做法. 
 bash$ at 2:30 am Friday < at-jobs.list
 job 2 at 2000-10-27 02:30 
batch
 batch 作业控制命令与 at 命令的行为很相像, 但 batch 命令被用来在系统平均载量降到
 0.8 以下时执行一次性的任务. 与 at 命令相似的是, 它也可以使用 -f 选项来从文件中
 读取命令. 
cal
 从stdout中输出一个格式比较整齐的日历. 也可以指定年和月来显示那个月的日历. 
sleep
 这个命令与一个等待循环的效果一样. 你可以指定需要暂停的秒数, 这段时间将什么都不
 干.当一个后台运行的进程需要偶尔检测一个事件时,这个功能很有用. 也可用于计时. 参
 见 Example 29-6. 
 1 sleep 3     # Pauses 3 seconds. 
 注意: sleep 命令默认为秒, 但是你也可以指定天数, 小时数或分钟数.
 1 sleep 3 h   # Pauses 3 hours! 
 注意: 如果你想每隔一段时间来运行一个命令的话, 那么 watch 命令将比 sleep 命令好
  得多. 
usleep
 Microsleep 睡眠微秒( "u"  会被希腊人读成 "mu", 或者是 micro- 前缀). 与上边的 sl
 eep 命令作用相同, 但这个命令是以百万分之一秒为单位的. 当需要精确计时, 或者需要
 非常频繁的监控一个正在运行的进程的时候, 这个命令非常有用. 
 1 usleep 30     # 暂停 30 microseconds. 
 这个命令是 Red Hat initscripts / rc-scripts 包的一部分. 
 注意: 事实上 usleep 命令并不能提供非常精确的计时, 所以如果你需要一个实时的任务
  的话, 这个命令并不适合. 
hwclock, clock 
 hwclock 命令可以存取或调整硬件时钟. 这个命令的一些选项需要 root 权限. 在系统启
 动的时候, /etc/rc.d/rc.sysinit 这个启动文件,会使用 hwclock 来从硬件时钟中读取
 并设置系统时间.clock at bootup. 
 clock 命令与 hwclock命令完全相同. 
12.4 文本处理命令
-----------------
处理文本和文本文件的命令 
sort
 文件排序, 通常用在管道中当过滤器来使用. 这个命令可以依据指定的关键字或指定的字
 符位置, 对文件行进行排序. 使用 -m 选项, 它将会合并预排序的输入文件. 想了解这个
 命令的全部参数请参考这个命令的 info 页. 见 Example 10-9, Example 10-10, 和 
 Example A-8. 
tsort
 拓扑排序 ,读取以空格分隔的有序对, 并且依靠输入模式进行排序. 
uniq
 这个过滤器将会删除一个已排序文件中的重复行.这个命令经常出现在 sort命令的管道后
 边. 
 1 cat list-1 list-2 list-3 | sort | uniq > final.list
 2 # 将3个文件连接起来,
 3 # 将它们排序,
 4 # 删除其中重复的行,
 5 # 最后将结果重定向到一个文件中. 
 -c选项的意思是在输出行前面加上每行在输入文件中出现的次数. 
 bash$ cat testfile
 This line occurs only once.
 This line occurs twice.
 This line occurs twice.
 This line occurs three times.
 This line occurs three times.
 This line occurs three times. 
 bash$ uniq -c testfile
    1 This line occurs only once.
    2 This line occurs twice.
    3 This line occurs three times. 
 bash$ sort testfile | uniq -c | sort -nr
    3 This line occurs three times.
    2 This line occurs twice.
    1 This line occurs only once. 
 sort INPUTFILE | uniq -c | sort -nr  命令 先对 INPUTFILE 排序, 然后统计 每行出
 现的次数, 最后的(-nr 选项将会产生一个数字的反转排序). 这种命令模版一般都用来分
 析 log 文件或者用来分析字典列表, 或者用在那些需要检查文本词汇结构的地方. 
Example 12-11 分析单词出现的频率
################################Start Script#######################################
 1 #!/bin/bash
 2 # wf.sh: 分析文本文件中自然词汇出现的频率.
 3 # "wf2.sh" 是一个效率更高的版本.
 4 
 5 
 6 # 从命令行中检查输入的文件.
 7 ARGS=1
 8 E_BADARGS=65
 9 E_NOFILE=66
10 
11 if [ $# -ne "$ARGS" ]  # 检验传递到脚本中参数的个数.
12 then
13   echo "Usage: `basename $0` filename"
14   exit $E_BADARGS
15 fi
16 
17 if [ ! -f "$1" ]       # 检查传入的文件参数是否存在.
18 then
19   echo "File \"$1\" does not exist."
20   exit $E_NOFILE
21 fi
22 
23 
24 
25 ########################################################
26 # main ()
27 sed -e 's/\.//g'  -e 's/\,//g' -e 's/ /\
28 /g' "$1" | tr 'A-Z' 'a-z' | sort | uniq -c | sort -nr
29 #                           =========================
30 #                               检查单词出现的频率
31 
32 #  过滤掉句号和逗号,
33 #+ 并且把单词间的空格转化为换行,
34 #+ 然后转化为小写,
35 #+ 最后统计出现的频率并按频率排序.
36 
37 #  Arun Giridhar 建议将上边的代码修改为:
38 #  . . . | sort | uniq -c | sort +1 [-f] | sort +0 -nr
39 #  这句添加了第2个排序主键, 所以
40 #+ 这个与上边等价的例子将按照字母顺序进行排序.
41 #  就像他所解释的:
42 #  "这是一个有效的根排序, 首先对频率最少的
43 #+ 列进行排序
44 #+ (单词或者字符串, 忽略大小写)
45 #+ 然后对频率最高的列进行排序."
46 #
47 #  像 Frank Wang 所解释的那样, 上边的代码等价于:
48 #+       . . . | sort | uniq -c | sort +0 -nr
49 #+ 用下边这行也行:
50 #+       . . . | sort | uniq -c | sort -k1nr -k
51 ########################################################
52 
53 exit 0
54 
55 # 练习:
56 # -----
57 # 1) 使用 'sed' 命令来过滤其他的标点符号,
58 #+   比如分号.
59 # 2) 修改这个脚本, 添加能够过滤多个空格或者
60 #    空白的能力.
################################End Script######################################### 
 bash$ cat testfile
 This line occurs only once.
 This line occurs twice.
 This line occurs twice.
 This line occurs three times.
 This line occurs three times.
 This line occurs three times. 
 bash$ ./wf.sh testfile
    6 this
    6 occurs
    6 line
    3 times
    3 three
    2 twice
    1 only
    1 once 
expand, unexpand
 expand 将会把每个tab转化为一个空格.这个命令经常用在管道中.
 unexpand 将会把每个空格转化为一个tab.效果与 expand 相反. 
cut
 一个从文件中提取特定域的工具. 这个命令与 awk 中使用的 print $N命令很相似, 但是
 更受限. 在脚本中使用cut命令会比使用 awk 命令来得容易一些. 最重要的选项就是 -d 
 (字段定界符) 和 -f (域分隔符) 选项. 
 使用 cut 来获得所有mount上的文件系统的列表:
 1 cut -d ' ' -f1,2 /etc/mtab 
 使用 cut 命令列出 OS 和 kernel的版本:
 1 uname -a | cut -d" " -f1,3,11,12 
 使用 cut 命令从 e-mail 中提取消息头:
 bash$ grep '^Subject:' read-messages | cut -c10-80
 Re: Linux suitable for mission-critical apps?
 MAKE MILLIONS WORKING AT HOME!!!
 Spam complaint
 Re: Spam complaint 
 使用 cut 命令来分析一个文件:
  1 # 列出所有在/etc/passwd中的用户.
  2 
  3 FILENAME=/etc/passwd
  4 
  5 for user in $(cut -d: -f1 $FILENAME)
  6 do
  7   echo $user
  8 done
  9 
 10 # Thanks, Oleg Philon for suggesting this. 
 cut -d ' ' -f2,3 filename 等价于 awk -F'[ ]' '{ print $2, $3 }' filename
 注意: 
  你甚至可以指定换行符作为字段定界符. 这个小伎俩实际上就是在命令行上插入一个
  换行(RETURN).(译者: linux使用lf作为换行符的). 
  bash$ cut -d'
  ' -f3,7,19 testfile
  This is line 3 of testfile.
  This is line 7 of testfile.
  This is line 19 of testfile. 
  Thank you, Jaka Kranjc, for pointing this out. 
 参见 Example 12-43. 
paste
 将多个文件,以每个文件一列的形式合并到一个文件中, 合并后的文件没列就是原来的一个
 文件.对于创建系统log文件来说, 使用 cut 命令与 paste 命令相结合是非常有用的. 
join
 这个命令与 paste 命令属于同类命令, 但是它能够完成某些特殊的目地. 这个强力工具能
 够以一种特殊的形式来合并2个文件, 这种特殊的形式本质上就是一个关联数据库的简单版
 本. 
 join 命令只能够操作2个文件, 它可以将那些具有特定标记域(通常是一个数字标签)的行
 合并起来, 并且将结果输出到stdout. 被加入的文件应该事先根据标记域进行排序以便于
 能够正确的匹配. 
 1 File: 1.data
 2 
 3 100 Shoes
 4 200 Laces
 5 300 Socks 
 1 File: 2.data
 2 
 3 100 $40.00
 4 200 $1.00
 5 300 $2.00 
 bash$ join 1.data 2.data
 File: 1.data 2.data 
 100 Shoes $40.00
 200 Laces $1.00
 300 Socks $2.00 
 注意: 在输出中标记域将只会出现一次. 
head
 将一个文件的头打印到stdout上 ( 默认为10行, 可以自己修改 ). 这个命令也有一些有趣
 的选项. 
Example 12-12 那个文件是脚本?
################################Start Script#######################################
 1 #!/bin/bash
 2 # script-detector.sh: 在一个目录中检查所有的脚本文件.
 3 
 4 TESTCHARS=2    # 测试前两个字节.
 5 SHABANG='#!'   # 脚本都是以 "sha-bang." 开头的.
 6 
 7 for file in *  # 遍历当前目录下的所有文件.
 8 do
 9   if [[ `head -c$TESTCHARS "$file"` = "$SHABANG" ]]
10   #      head -c2                      #!
11   #  '-c' 选项将从文件头输出指定个数的字符,
12   #+ 而不是默认的行数.
13   then
14     echo "File \"$file\" is a script."
15   else
16     echo "File \"$file\" is *not* a script."
17   fi
18 done
19   
20 exit 0
21 
22 #  练习:
23 #  -----
24 #  1) 将这个脚本修改为可以指定目录
25 #+    来扫描目录下的脚本.
26 #+    (而不是只搜索当前目录).
27 #
28 #  2) 就目前看来, 这个脚本将不能正确识别出
29 #+    Perl, awk, 和其他一些脚本语言的脚本文件.
30 #     修正这个问题.
################################End Script######################################### 
Example 12-13 产生10进制随机数
################################Start Script#######################################
 1 #!/bin/bash
 2 # rnd.sh: 输出一个10进制随机数
 3 
 4 # Script by Stephane Chazelas.
 5 
 6 head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
 7 
 8 
 9 # =================================================================== #
10 
11 # 分析
12 # ----
13 
14 # head:
15 # -c4 选项将取得前4个字节.
16 
17 # od:
18 # -N4 选项将限制输出为4个字节.
19 # -tu4 选项将使用无符号10进制格式来输出.
20 
21 # sed: 
22 # -n 选项, 使用 "s" 命令与 "p" 标志组合的方式,
23 # 将会只输出匹配的行.
24 
25 
26 
27 # 本脚本作者解释 'sed' 命令的行为如下.
28 
29 # head -c4 /dev/urandom | od -N4 -tu4 | sed -ne '1s/.* //p'
30 # ----------------------------------> |
31 
32 # 假设一直处理到 "sed"命令时的输出--> |
33 # 为 0000000 1198195154\n
34 
35 #  sed 命令开始读取字串: 0000000 1198195154\n.
36 #  这里它发现一个换行符,
37 #+ 所以 sed 准备处理第一行 (0000000 1198195154).
38 #  sed命令开始匹配它的 <range> 和 <action>. 第一个匹配的并且只有这一个匹配的:
39 
40 #   range     action
41 #   1         s/.* //p
42 
43 #  因为行号在range中, 所以 sed 开始执行 action:
44 #+ 替换掉以空格结束的最长的字符串, 在这行中这个字符串是
45 #  ("0000000 ") ,用空字符串(//)将这个匹配到的字串替换掉, 如果成功, 那就打印出结果
46 #  ("p" 在这里是 "s" 命令的标志, 这与单独的 "p" 命令是不同的).
47 
48 #  sed 命令现在开始继续读取输入. (注意在继续之前, 
49 #+ continuing, 如果没使用 -n 选项的话, sed 命令将再次
50 #+ 将这行打印一遍).
51 
52 # 现在, sed 命令读取剩余的字符串, 并且找到文件的结尾.
53 # sed 命令开始处理第2行(这行也被标记为 '$'
54 # 因为这已经是最后一行).
55 # 所以这行没被匹配到 <range> 中, 这样sed命令就结束了.
56 
57 #  这个 sed 命令的简短的解释是:
58 #  "在第一行中删除第一个空格左边全部的字符,
59 #+ 然后打印出来."
60 
61 # 一个更好的来达到这个目的的方法是:
62 #           sed -e 's/.* //;q'
63 
64 # 这里, <range> 和 <action> 分别是 (也可以写成
65 #           sed -e 's/.* //' -e q):
66 
67 #   range                    action
68 #   nothing (matches line)   s/.* //
69 #   nothing (matches line)   q (quit)
70 
71 #  这里, sed 命令只会读取第一行的输入.
72 #  将会执行2个命令, 并且会在退出之前打印出(已经替换过的)这行(因为 "q" action),
73 #+ 因为没使用 "-n" 选项.
74 
75 # =================================================================== #
76 
77 # 也可以使用如下一个更简单的语句来代替:
78 #           head -c4 /dev/urandom| od -An -tu4
79 
80 exit 0
################################End Script#########################################
 参见 Example 12-35. 
tail
 将一个文件的结尾输出到 stdout  中(默认为 10 行). 通常用来跟踪一个系统 logfile 
 的修改状况, 使用 -f 选项的话, tail 命令将会继续显示添加到文件中的行. 
Example 12-14 使用 tail 命令来监控系统log
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 filename=sys.log
 4 
 5 cat /dev/null > $filename; echo "Creating / cleaning out file."
 6 #  如果文件不存在的话就创建文件,
 7 #+ 然后将这个文件清空.
 8 #  : > filename   和   > filename 也可以完成这个工作.
 9 
10 tail /var/log/messages > $filename  
11 # /var/log/messages 必须具有全局可读权限才行.
12 
13 echo "$filename contains tail end of system log."
14 
15 exit 0
################################End Script######################################### 
 注意:
  为了列出一个文本文件中的指定行数, 可以将 head 命令的输出通过 管道 传递到 
  tail -1 中 . 比如 head -8 database.txt | tail -1 将会列出 database.txt 文
  件的第8行. 
  下边是将一个文本文件中指定范围的所有行都保存到一个变量中:
  1 var=$(head -$m $filename | tail -$n)
  2 
  3 # filename = 文件名
  4 # m = 从文件开头到想取得的指定范围的行数的最后一行
  5 # n = 取得指定范围的行数 (从块结尾开始截断) 
 参见 Example 12-5, Example 12-35 和 Example 29-6. 
grep
 使用 正则表达式 的一个多用途文本搜索工具. 这个命令本来是 ed 行编辑器中的一个命
 令/过滤器: g/re/p -- global - regular expression - print. 
 grep pattern [file...]
 在文件中搜索所有 pattern 出现的位置, pattern 既可以是要搜索的字符串,也可以是一
 个正则表达式. 
 bash$ grep '[rst]ystem.$' osinfo.txt
 The GPL governs the distribution of the Linux operating system. 
 如果没有指定文件参数, grep  通常用在管道中对 stdout 进行过滤. 
 bash$ ps ax | grep clock
 765 tty1     S      0:00 xclock
 901 pts/1    S      0:00 grep clock 
 -i 选项在搜索时忽略大小写. 
 -w 选项用来匹配整词. 
 -l 选项仅列出符合匹配的文件, 而不列出匹配行. 
 -r (递归) 选项不仅在当前工作目录下搜索匹配, 而且搜索子目录. 
 -n 选项列出所有匹配行, 并显示行号.
 bash$ grep -n Linux osinfo.txt
 2:This is a file containing information about Linux.
 6:The GPL governs the distribution of the Linux operating system. 
 -v (或者--invert-match) 选项将会显示所有不匹配的行.
 1 grep pattern1 *.txt | grep -v pattern2
 2 
 3 # 匹配在"*.txt"中所有包含 "pattern1"的行,
 4 # 而不显示匹配包含 "pattern2"的行.  
 -c (--count) 选项将只会显示匹配到的行数的总数,而不会列出具体的匹配.
  1 grep -c txt *.sgml   # (在 "*.sgml" 文件中, 匹配"txt"的行数的总数.)
  2 
  3 
  4 #   grep -cz .
  5 #            ^ 点
  6 # 意思是计数 (-c) 所有以空字符分割(-z) 的匹配 "."的项
  7 # "."是正则表达式的一个符号, 表达匹配任意一个非空字符(至少要包含一个字符).
  8 # 
  9 printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz .     # 3
 10 printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '$'   # 5
 11 printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -cz '^'   # 5
 12 #
 13 printf 'a b\nc  d\n\n\n\n\n\000\n\000e\000\000\nf' | grep -c '$'    # 9
 14 # 默认情况下, 是使用换行符(\n)来分隔匹配项.
 15 
 16 # 注意  -z 选项是 GNU "grep" 特定的选项.
 17 
 18 
 19 # Thanks, S.C. 
 当有多个文件参数的时候, grep 将会指出哪个文件中包含具体的匹配. 
 bash$ grep Linux osinfo.txt misc.txt
 osinfo.txt:This is a file containing information about Linux.
 osinfo.txt:The GPL governs the distribution of the Linux operating system.
 misc.txt:The Linux operating system is steadily gaining in popularity. 
 注意: 如果在 grep 命令只搜索一个文件的时候, 那么可以简单的把 /dev/null 作为第2
  个文件参数传给 grep . 
  bash$ grep Linux osinfo.txt /dev/null
  osinfo.txt:This is a file containing information about Linux.
  osinfo.txt:The GPL governs the distribution of the Linux operating system. 
 如果存在一个成功的匹配, 那么 grep  命令将会返回 0 作为 退出状态  ,这样就可以将 
 grep 命令的结果放在脚本的条件测试中来使用, 尤其和 -q (禁止输出)选项组合时特别有
 用.
  1 SUCCESS=0                      # 如果 grep 匹配成功
  2 word=Linux
  3 filename=data.file
  4 
  5 grep -q "$word" "$filename"    # "-q" 选项将使得什么都不输出到 stdout 上.
  6 
  7 if [ $? -eq $SUCCESS ]
  8 # if grep -q "$word" "$filename"   这句话可以代替行 5 - 7.
  9 then
 10   echo "$word found in $filename"
 11 else
 12   echo "$word not found in $filename"
 13 fi 
 Example 29-6 展示了如何使用 grep 命令来在一个系统 logfile 中进行一个单词的模式
 匹配. 
Example 12-15 在一个脚本中模仿 "grep" 的行为
################################Start Script#######################################
 1 #!/bin/bash
 2 # grp.sh: 一个非常粗糙的 'grep' 的实现.
 3 
 4 E_BADARGS=65
 5 
 6 if [ -z "$1" ]    # 检查传递给脚本的参数.
 7 then
 8   echo "Usage: `basename $0` pattern"
 9   exit $E_BADARGS
10 fi  
11 
12 echo
13 
14 for file in *     # 遍历 $PWD 下的所有文件.
15 do
16   output=$(sed -n /"$1"/p $file)  # 命令替换.
17 
18   if [ ! -z "$output" ]           # 如果"$output" 不加双引号将会发生什么?
19   then
20     echo -n "$file: "
21     echo $output
22   fi              #  sed -ne "/$1/s|^|${file}: |p"  这句与上边这段等价.
23 
24   echo
25 done  
26 
27 echo
28 
29 exit 0
30 
31 # 练习:
32 # -----
33 # 1) 在任何给定的文件中,如果有超过一个匹配的话, 在输出中添加新行.
34 # 2) 添加一些特征.
################################End Script#########################################
 如何使用 grep 命令来搜索两个(或两个以上)独立的模式? 如果你想显示在一个或多个文
 件中既匹配"pattern1" 又匹配 "pattern2"的所有匹配行又该如何做呢?(译者: 这是取交
 集的情况, 如果取并集该怎么办呢?) 
 一个方法是通过 管道 来将 grep pattern1 的结果传递到 grep pattern2 中 . 
 例如, 给定如下文件: 
 1 # Filename: tstfile
 2 
 3 This is a sample file.
 4 This is an ordinary text file.
 5 This file does not contain any unusual text.
 6 This file is not unusual.
 7 Here is some text. 
 现在, 让我们在这个文件中搜索既包含 "file" 又包含 "text" 的所有行
 bash$ grep file tstfile
 # Filename: tstfile
 This is a sample file.
 This is an ordinary text file.
 This file does not contain any unusual text.
 This file is not unusual. 
 bash$ grep file tstfile | grep text
 This is an ordinary text file.
 This file does not contain any unusual text. 
 -- 
 egrep  - 扩展的 grep - 这个命令与 grep -E 等价. 这个命令用起来有些不同, 由于正
 则表达式扩展, 将会使得搜索更具灵活性. 
 fgrep - 快速的 grep  - 这个命令与 grep -F 等价. 这是一种按照字符串字面意思进行
 的搜索(即不允许使用正则表达式), 这样有时候会使搜索变得容易一些. 
 注意: 在某些linux发行版中, egrep 和 fgrep 都是 grep 命令的符号连接或者是别名, 
  只不过调用的时候分别使用 -E 和 -F 选项罢了. 
Example 12-16 在1913年的韦氏词典中查找定义
################################Start Script#######################################
 1 #!/bin/bash
 2 # dict-lookup.sh
 3 
 4 #  这个脚本在1913年的韦氏词典中查找定义.
 5 #  这本公共词典可以通过不同的
 6 #+ 站点来下载,包括
 7 #+ Project Gutenberg (http://www.gutenberg.org/etext/247).
 8 #
 9 #  在通过本脚本使用之前,
10 #+ 先要将这本字典由 DOS 格式转换为 UNIX格式(只以 LF 作为行结束符).
11 #  将这个文件存储为纯文本形式, 并且保证是未压缩的 ASCII 格式.
12 #  将DEFAULT_DICTFILE 变量以 path/filename 形式设置好.
13 
14 
15 E_BADARGS=65
16 MAXCONTEXTLINES=50                        # 显示的最大行数.
17 DEFAULT_DICTFILE="/usr/share/dict/webster1913-dict.txt"
18                                           # 默认的路径和文件名.
19                                           # 在必要的时候可以进行修改.
20 #  注意:
21 #  -----
22 #  这个特定的1913年版的韦氏词典
23 #+ 在每个入口都是以大写字母开头的
24 #+ (剩余的字符都是小写).
25 #  只有每部分的第一行是以这种形式开始的,
26 #+ 这也就是为什么搜索算法是下边的这个样子.
27 
28 
29 
30 if [[ -z $(echo "$1" | sed -n '/^[A-Z]/p') ]]
31 #  必须指定一个要查找的单词,
32 #+ 并且这个单词必须以大写字母开头.
33 then
34   echo "Usage: `basename $0` Word-to-define [dictionary-file]"
35   echo
36   echo "Note: Word to look up must start with capital letter,"
37   echo "with the rest of the word in lowercase."
38   echo "--------------------------------------------"
39   echo "Examples: Abandon, Dictionary, Marking, etc."
40   exit $E_BADARGS
41 fi
42 
43 
44 if [ -z "$2" ]                            #  也可以指定不同的词典
45                                           #+ 作为这个脚本的第2个参数传递进来.
46 then
47   dictfile=$DEFAULT_DICTFILE
48 else
49   dictfile="$2"
50 fi
51 
52 # ---------------------------------------------------------
53 Definition=$(fgrep -A $MAXCONTEXTLINES "$1 \\" "$dictfile")
54 #                                   以 "Word \..." 这种形式定义
55 #
56 #  当然, 即使搜索一个特别大的文本文件的时候
57 #+ "fgrep" 也是足够快的.
58 
59 
60 # 现在, 剪掉定义块.
61 
62 echo "$Definition" |
63 sed -n '1,/^[A-Z]/p' |
64 #  从输出的第一行
65 #+ 打印到下一部分的第一行.
66 sed '$d' | sed '$d'
67 #  删除输出的最后两行Delete last two lines of output
68 #+ (空行和下一部分的第一行).
69 # ---------------------------------------------------------
70 
71 exit 0
72 
73 # 练习:
74 # -----
75 # 1)  修改这个脚本, 让它具备能够处理任何字符形式的输入
76 #   + (大写, 小写, 或大小写混合), 然后将其转换为
77 #   + 能够处理的统一形式.
78 #
79 # 2)  将这个脚本转化为一个 GUI 应用,
80 #   + 使用一些比如像 "gdialog"的东西 .  .  .
81 #     这样的话, 脚本将不再从命令行中
82 #   + 取得这些参数.
83 #
84 # 3)  修改这个脚本让它具备能够分析另外一个
85 #   + 公共词典的能力,比如 U.S. Census Bureau Gazetteer.
################################End Script#########################################
 agrep (近似 grep) 扩展了 grep 近似匹配的能力. 搜索的字符串可能会与最终匹配结果
 所找到字符串有些不同.这个工具并不是核心 Linux 发行版的一部分. 
 注意: 为了搜索压缩文件, 应使用 zgrep, zegrep, 或 zfgrep. 这些命令也可以对未压缩
  的文件进行搜索, 只不过会比一般的 grep, egrep, 和 fgrep 慢上一些. 当然, 在你
  要搜索的文件中如果混合了压缩和未压缩的文件的话, 那么使用这些命令是非常方便
  的. 
  如果要搜索 bzipped  类型的文件, 使用 bzgrep. 
look
 命令 look 与命令 grep 很相似, 但是这个命令只能做字典查询, 也就是它所搜索的文件
 必须已经排过序的单词列表. 默认情况下, 如果没有指定搜索那个文件, 那就默认搜索
 /usr/dict/words文件(译者: 感觉好像应该是/usr/share/dict/words), 当然也可以指定
 其他目录下的文件进行搜索. 
Example 12-17 检查列表中单词的正确性
################################Start Script#######################################
 1 #!/bin/bash
 2 # lookup: 对指定数据文件中的每个单词都做一遍字典查询..
 3 
 4 file=words.data  # 指定的要搜索的数据文件.
 5 
 6 echo
 7 
 8 while [ "$word" != end ]  # 数据文件中最后一个单词.
 9 do
10   read word      # 从数据文件中读, 因为在循环的后边重定向了.
11   look $word > /dev/null  # 不想将字典文件中的行显示出来.
12   lookup=$?      #  'look' 命令的退出状态.
13 
14   if [ "$lookup" -eq 0 ]
15   then
16     echo "\"$word\" is valid."
17   else
18     echo "\"$word\" is invalid."
19   fi  
20 
21 done <"$file"    # 将 stdin 重定向到 $file, 所以 "reads" 来自于 $file.
22 
23 echo
24 
25 exit 0
26 
27 # ----------------------------------------------------
28 # 下边的代码行将不会执行, 因为上边已经有 "exit"命令了.
29 
30 
31 # Stephane Chazelas 建议使用下边更简洁的方法:
32 
33 while read word && [[ $word != end ]]
34 do if look "$word" > /dev/null
35    then echo "\"$word\" is valid."
36    else echo "\"$word\" is invalid."
37    fi
38 done <"$file"
39 
40 exit 0
################################End Script######################################### 
sed, awk
 这个两个命令都是独立的脚本语言, 尤其适合分析文本文件和命令输出. 既可以单独使用,
 也可以结合管道和在shell脚本中使用. 
sed
 非交互式的 "流编辑器", 在批量模式下, 允许使用许多 ex 命令.你会发现它在shell脚本
 中非常有用. 
awk
 可编程的文件提取器和文件格式化工具, 在结构化的文本文件中,处理或提取特定域(特定
 列)具有非常好的表现.它的语法与 C 语言很类似. 
wc
 wc 可以统计文件或 I/O 流中的单词数量.
 bash $ wc /usr/share/doc/sed-4.1.2/README
 13  70  447 README
 [13 lines  70 words  447 characters] 
 wc -w 统计单词数量. 
 wc -l 统计行数量. 
 wc -c 统计字节数量. 
 wc -m 统计字符数量. 
 wc -L 给出文件中最长行的长度. 
 使用 wc 命令来统计当前工作目录下有多少个 .txt 文件.
 1 $ ls *.txt | wc -l
 2 # 因为列出的文件名都是以换行符区分的,所以使用 -l 来统计.
 3 
 4 # 另一种达到这个目的的方法:
 5 #      find . -maxdepth 1 -name \*.txt -print0 | grep -cz .
 6 #      (shopt -s nullglob; set -- *.txt; echo $#)
 7 
 8 # Thanks, S.C. 
 使用 wc 命令来统计所有以 d - h 开头的文件的大小.
 bash$ wc [d-h]* | grep total | awk '{print $3}'
 71832 
 使用 wc 命令来查看指定文件中包含 "Linux" 的行一共有多少.
 bash$ grep Linux abs-book.sgml | wc -l
 50 
 参见 Example 12-35 和 Example 16-8. 
 某些命令的某些选项其实已经包含了 wc 命令的部分功能.
 1 ... | grep foo | wc -l
 2 # 这个命令使用得非常频繁, 但事实上它有更简便的写法.
 3 
 4 ... | grep -c foo
 5 # 只要使用 grep 命令的 "-c" (或 "--count")选项就能达到同样的目的.
 6 
 7 # Thanks, S.C. 
tr
 字符转换过滤器. 
 注意: 必须使用引用或中括号, 这样做才是合理的. 引用可以阻止 shell 重新解释出现在
   tr 命令序列中的特殊字符.中括号应该被引用起来防止被shell扩展. 
 无论 tr "A-Z" "*" <filename  还是 tr A-Z \* <filename 都可以将 filename 中的大
 写字符修改为星号(写到 stdout).但是在某些系统上可能就不能正常工作了, 而 tr A-Z '
 [**]' 在任何系统上都可以正常工作. 
 -d 选项删除指定范围的字符.
 1 echo "abcdef"                 # abcdef
 2 echo "abcdef" | tr -d b-d     # aef
 3 
 4 
 5 tr -d 0-9 <filename
 6 # 删除 "filename" 中所有的数字. 
 --squeeze-repeats (或 -s) 选项用来在重复字符序列中除去除第一个字符以外的所有字
 符. 这个选项在删除多余的whitespace 的时候非常有用.
 bash$ echo "XXXXX" | tr --squeeze-repeats 'X'
 X 
 -c "complement"  选项将会 反转 匹配的字符集. 通过这个选项, tr 将只会对那些 不 
 匹配的字符起作用.
 bash$ echo "acfdeb123" | tr -c b-d +
 +c+d+b++++ 
 注意 tr 命令支持 POSIX 字符类. [1]
 bash$ echo "abcd2ef1" | tr '[:alpha:]' -
 ----2--1 
Example 12-18 转换大写: 把一个文件的内容全部转换为大写.
################################Start Script#######################################
 1 #!/bin/bash
 2 # 把一个文件的内容全部转换为大写.
 3 
 4 E_BADARGS=65
 5 
 6 if [ -z "$1" ]  # 检查命令行参数.
 7 then
 8   echo "Usage: `basename $0` filename"
 9   exit $E_BADARGS
10 fi  
11 
12 tr a-z A-Z <"$1"
13 
14 # 与上边的作用相同, 但是使用了 POSIX 字符集标记方法:
15 #        tr '[:lower:]' '[:upper:]' <"$1"
16 # Thanks, S.C.
17 
18 exit 0
19 
20 #  练习:
21 #  重写这个脚本, 通过选项可以控制脚本或者
22 #+ 转换为大写或者转换为小写.
################################End Script######################################### 
Example 12-19 转换小写: 将当前目录下的所有文全部转换为小写.
################################Start Script#######################################
 1 #!/bin/bash
 2 #
 3 #  将当前目录下的所有文全部转换为小写.
 4 #
 5 #  灵感来自于 John Dubois 的脚本,
 6 #+ 转换为 Bash 脚本,
 7 #+ 然后被本书作者精简了一下.
 8 
 9 
10 for filename in *                # 遍历当前目录下的所有文件.
11 do
12    fname=`basename $filename`
13    n=`echo $fname | tr A-Z a-z`  # 将名字修改为小写.
14    if [ "$fname" != "$n" ]       # 只对那些文件名不是小写的文件进行重命名.
15    then
16      mv $fname $n
17    fi  
18 done   
19 
20 exit $?
21 
22 
23 # 下边的代码将不会被执行, 因为上边的 "exit".
24 #-------------------------------------------#
25 # 删除上边的内容,来运行下边的内容.
26 
27 # 对于那些文件名中包含空白和新行的文件, 上边的脚本就不能工作了.
28 # Stephane Chazelas 因此建议使用下边的方法:
29 
30 
31 for filename in *    # 不必非得使用 basename 命令,
32                      # 因为 "*" 不会返回任何包含 "/" 的文件.
33 do n=`echo "$filename/" | tr '[:upper:]' '[:lower:]'`
34 #                             POSIX 字符集标记法.
35 #                    添加的斜线是为了在文件名结尾换行不会被
36 #                    命令替换删掉.
37    # 变量替换:
38    n=${n%/}          # 从文件名中将上边添加在结尾的斜线删除掉.
39    [[ $filename == $n ]] || mv "$filename" "$n"
40                      # 检查文件名是否已经是小写.
41 done
42 
43 exit $?
################################End Script######################################### 
Example 12-20 Du: DOS 到 UNIX 文本文件的转换.
################################Start Script#######################################
 1 #!/bin/bash
 2 # Du.sh: DOS 到 UNIX 文本文件的转换.
 3 
 4 E_WRONGARGS=65
 5 
 6 if [ -z "$1" ]
 7 then
 8   echo "Usage: `basename $0` filename-to-convert"
 9   exit $E_WRONGARGS
10 fi
11 
12 NEWFILENAME=$1.unx
13 
14 CR='\015'  # 回车Carriage return.
15            # 015 是 8 进制的 ASCII 码的回车.
16            # DOS 中文本文件的行结束符是 CR-LF.
17            # UNIX 中文本文件的行结束符只是 LF.
18 
19 tr -d $CR < $1 > $NEWFILENAME
20 # 删除回车并且写到新文件中.
21 
22 echo "Original DOS text file is \"$1\"."
23 echo "Converted UNIX text file is \"$NEWFILENAME\"."
24 
25 exit 0
26 
27 # 练习:
28 # -----
29 # 修改上边的脚本完成从UNIX 到 DOS 的转换.
################################End Script######################################### 
Example 12-21 rot13: rot13, 弱智加密.
################################Start Script#######################################
 1 #!/bin/bash
 2 # rot13.sh: 典型的 rot13 算法,
 3 #           使用这种方法加密可能可以愚弄一下3岁小孩.
 4 
 5 # 用法: ./rot13.sh filename
 6 # 或    ./rot13.sh <filename
 7 # 或    ./rot13.sh and supply keyboard input (stdin)
 8 
 9 cat "$@" | tr 'a-zA-Z' 'n-za-mN-ZA-M'   # "a" 变为 "n", "b" 变为 "o", 等等.
10 #  'cat "$@"' 结构
11 #+ 允许从stdin或者从文件中获得输入.
12 
13 exit 0
################################End Script######################################### 
Example 12-22 Generating "Crypto-Quote" Puzzles
################################Start Script#######################################
 1 #!/bin/bash
 2 # crypto-quote.sh: 加密
 3 
 4 #  使用单码替换(单一字母替换法)来进行加密.
 5 #  The result is similar to the "Crypto Quote" puzzles
 6 #+ seen in the Op Ed pages of the Sunday paper. <rojy bug>(不太了解这句的内容, 应该是有特定的含义)
 7 
 8 
 9 key=ETAOINSHRDLUBCFGJMQPVWZYXK
10 # "key" 不过是一个乱序的字母表.
11 # 修改 "key" 就会修改加密的结果.
12 
13 # The 'cat "$@"' construction gets input either from stdin or from files.
14 # 如果使用stdin, 那么要想结束输入就使用 Control-D.
15 # 否则就要在命令行上指定文件名.
16 
17 cat "$@" | tr "a-z" "A-Z" | tr "A-Z" "$key"
18 #        |   转化为大写   |     加密
19 # 小写, 大写, 或混合大小写, 都可以正常工作.
20 # 但是传递进来的非字母字符将不会起任何变化.
21 
22 
23 # 用下边的语句试试这个脚本:
24 # "Nothing so needs reforming as other people's habits."
25 # --Mark Twain
26 #
27 # 输出为:
28 # "CFPHRCS QF CIIOQ MINFMBRCS EQ FPHIM GIFGUI'Q HETRPQ."
29 # --BEML PZERC
30 
31 # 解密:
32 # cat "$@" | tr "$key" "A-Z"
33 
34 
35 #  这个简单的密码可以轻易的被一个12岁的小孩
36 #+ 用铅笔和纸破解.
37 
38 exit 0
39 
40 #  练习:
41 #  -----
42 #  修改这个脚本, 让它可以用命令行参数
43 #+ 来决定加密或解密.
################################End Script######################################### 
 注意: tr 的不同版本
  tr 工具在历史上有2个重要版本. BSD 版本不需要使用中括号 (tr a-z A-Z), 但是 
  SysV 版本则需要中括号 (tr '[a-z]' '[A-Z]'). GNU 版本的 tr 命令与 BSD 版本比
  较相像, 所以使用中括号来引用字符范围是强制性的(译者: 感觉这句说反了, 读者可
  自行参照原文). 
fold
 将输入按照指定宽度进行折行. 这里有一个非常有用的选项 -s ,这个选项可以使用空格进
 行断行.(译者: 事实上只有外文才需要使用空格断行, 中文是不需要的) (参见 Example
  12-23 和 Example A-1). 
fmt
 一个简单的文件格式器, 通常用在管道中, 将一个比较长的文本行输出进行折行. 
Example 12-23 格式化文件列表.
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 WIDTH=40                    # 设为 40 列宽.
 4 
 5 b=`ls /usr/local/bin`       # 取得文件列表...
 6 
 7 echo $b | fmt -w $WIDTH
 8 
 9 # 也可以使用如下方法,作用相同
10 #    echo $b | fold - -s -w $WIDTH
11  
12 exit 0
################################End Script#########################################
 参见 Example 12-5. 
 注意: 如果想找到一个更强力的 fmt 工具可以选择 Kamil Toman 的 par  工具, 这个工
  具可以从后边的这个网址取得http://www.cs.berkeley.edu/~amc/Par/. 
col
    这个命令用来滤除标准输入的反向换行符号. 这个工具还可以将空白用等价的 tab 来替
 换. col 工具最主要的应用还是从特定的文本处理工具中过滤输出, 比如 groff 和 tbl.
 (译者: 主要用来将man页转化为文本) 
column
 列格式化工具. 这个过滤工具将会将列类型的文本转化为"易于打印"的表格式进行输出, 
 通过在合适的位置插入tab. 
Example 12-24 使用 column 来格式化目录列表
################################Start Script#######################################
 1 #!/bin/bash
 2 # 这是"column" man页中的一个例子, 作者对这个例子做了很小的修改.
 3 
 4 
 5 (printf "PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n" \
 6 ; ls -l | sed 1d) | column -t
 7 
 8 #  管道中的 "sed 1d" 删除输出的第一行,
 9 #+ 第一行将是 "total        N",
10 #+ 其中 "N" 是 "ls -l" 找到的文件总数.
11 
12 # "column" 中的 -t 选项用来转化为易于打印的表形式.
13 
14 exit 0
################################End Script######################################### 
colrm
 列删除过滤器. 这个工具将会从文件中删除指定的列(列中的字符串)并且写到文件中, 如
 果指定的列不存在,那么就回到 stdout. colrm 2 4 <filename 将会在filename文件中对
 每行删除第2到第4列之间的所有字符. 
 注意: 如果这个文件包含tab和不可打印字符, 那将会引起不可预期的行为. 在这种情况下
  , 应该通过管道的手段使用 expand 和 unexpand 命令来预处理 colrm. 
nl
 计算行号过滤器. nl filename  将会在 stdout 中列出文件的所有内容, 但是会在每个非
 空行的前面加上连续的行号. 如果没有 filename 参数, 那么就操作 stdin. 
 nl 命令的输出与 cat -n 非常相似, 然而, 默认情况下 nl 不会列出空行. 
Example 12-25 nl: 一个自己计算行号的脚本.
################################Start Script#######################################
 1 #!/bin/bash
 2 # line-number.sh
 3 
 4 # 这个脚本将会 echo 自身两次, 并显示行号.
 5 
 6 # 'nl' 命令显示的时候你将会看到, 本行是第4行, 因为它不计空行.
 7 # 'cat -n' 命令显示的时候你将会看到, 本行是第6行.
 8 
 9 nl `basename $0`
10 
11 echo; echo  # 下边, 让我们试试 'cat -n'
12 
13 cat -n `basename $0`
14 # 区别就是 'cat -n' 对空行也进行计数.
15 # 注意 'nl -ba' 也会这么做.
16 
17 exit 0
18 # -----------------------------------------------------------------
################################End Script######################################### 
pr
 格式化打印过滤器. 这个命令会将文件(或stdout)分页, 将它们分成合适的小块以便于硬
 拷贝打印或者在屏幕上浏览.使用这个命令的不同的参数可以完成好多任务, 比如对行和列
 的操作,加入行, 设置页边, 计算行号, 添加页眉, 合并文件等等. pr  命令集合了许多命
 令的功能, 比如 nl, paste, fold, column, 和 expand. 
 pr -o 5 --width=65 fileZZZ | more  这个命令对fileZZZ进行了比较好的分页,并且打印
 到屏幕上.文件的缩进被设置为5, 总宽度设置为65. 
 一个特定的使用选项 -d, 强制隔行打印 (与 sed -G 效果相同). 
gettext
 GNU gettext 包是专门用来将程序的输出翻译或者本地化为不同国家语言的工具集.在最开
 始的时候仅仅支持C 语言, 现在已经支持了相当数量的其它程序语言和脚本语言. 
 要想查看 gettext  程序 如何在shell脚本中工作. 参见 info 页. 
msgfmt
    一个产生2进制消息目录的程序. 这个命令主要用来 本地化. 
iconv
 一个可以将文件转化为不同编码格式(字符集)的工具. 这个命令主要用来 本地化.
  1 # 将字符符串由 UTF-8 格式转换为 UTF-16 并且打印到 BookList 中
  2 function write_utf8_string {
  3     STRING=$1
  4     BOOKLIST=$2
  5     echo -n "$STRING" | iconv -f UTF8 -t UTF16 | cut -b 3- | tr -d \\n >> "$BOOKLIST"
  6 }
  7 
  8 #  来自于 Peter Knowles' "booklistgen.sh" 脚本
  9 #+ 目的是把文件转换为 Sony Librie 格式.
 10 #  (http://booklistgensh.peterknowles.com) 
recode
 可以认为这个命令时上边 iconv 命令的一个空想家版本. 这个非常灵活的并可以把整个文
 件都转换为不同编码格式的工具并不是Linux 标准安装的一部分. 
TeX, gs
 TeX 和 Postscript  都是文本标记语言, 用来对打印和格式化的视频显示进行预拷贝. 
 TeX 是 Donald Knuth 精心制作的排版系统. 通常情况下, 通过编写脚本的手段来把所有
 的选项和参数封装起来一起传到标记语言中是一件很方便的事情. 
 Ghostscript  (gs) 是一个 遵循 GPL 的Postscript 解释器. 
enscript
 将纯文本文件转换为 PostScript 的工具
 比如, enscript filename.txt -p filename.ps  产生一个 PostScript 输出文件 
 filename.ps. 
groff, tbl, eqn
 另一种文本标记和显示格式化语言是 groff. 这是一个对传统 UNIX roff/troff 显示和排
 版包的 GNU 增强版本.Man页  使用的就是 groff. 
 tbl 表处理工具可以认为是 groff 的一部分, 它的功能就是将表标记转化到 groff 
 命令中. 
 eqn 等式处理工具也是 groff 的一部分, 它的功能是将等式标记转化到 groff 命令中. 
Example 12-26 manview: 查看格式化的man页
################################Start Script#######################################
 1 #!/bin/bash
 2 # manview.sh: 将man页源文件格式化以方便查看.
 3 
 4 #  当你想阅读man页的时候, 这个脚本就有用了.
 5 #  它允许你在运行的时候查看
 6 #+ 中间结果.
 7 
 8 E_WRONGARGS=65
 9 
10 if [ -z "$1" ]
11 then
12   echo "Usage: `basename $0` filename"
13   exit $E_WRONGARGS
14 fi
15 
16 # ---------------------------
17 groff -Tascii -man $1 | less
18 # 来自于 groff man页.
19 # ---------------------------
20 
21 #  如果man业中包括表或者等式,
22 #+ 那么上边的代码就够呛了.
23 #  下边的这行代码可以解决上边的这个问题.
24 #
25 #   gtbl < "$1" | geqn -Tlatin1 | groff -Tlatin1 -mtty-char -man
26 #
27 #   Thanks, S.C.
28 
29 exit 0
################################End Script######################################### 
lex, yacc
 lex 是用于模式匹配的词汇分析产生程序. 在Linux系统上这个命令已经被 flex 取代了.
 yacc 工具基于一系列的语法规范生成语法分析程序. 在Linux系统上这个命令已经被 
 bison 取代了. 
注意事项:
[1]  对于 GNU 版本的 tr 命令来说这是唯一一处比那些商业 UNIX 系统上的一般版本合适
  的地方. 
12.5 文件与归档命令
-------------------
归档命令 
tar
    标准的 UNIX 归档工具. [1] 起初这只是一个 磁带 归档 程序, 而现在这个工具已经被开
 发为通用打包程序, 它能够处理所有设备的所有类型的归档文件, 包括磁带设备, 正常文
 件, 甚至是 stdout (参见Example 3-4). GNU 的tar工具现在可以接受不同种类的压缩过
 滤器, 比如tar czvf archive_name.tar.gz *, 并且可以递归的处理归档文件, 还可以用 
 gzip 压缩目录下的所有文件, 除了当前目录下($PWD)的 点文件 . [2] 
 一些有用的 tar 命令选项: 
  1.  -c 创建 (一个新的归档文件)
  2.  -x 解压文件 (从存在的归档文件中)
  3.  --delete 删除文件 (从存在的归档文件中)
  注意: 这个选项不能用于磁带类型设备.
  4.  -r 将文件添加到现存的归档文件的尾部
  5.  -A 将 tar 文件添加到现存的归档文件的尾部
  6.  -t 列出现存的归档文件中包含的内容
  7.  -u 更新归档文件
  8.  -d 使用指定的文件系统 比较归档文件
  9.  -z 用 gzip 压缩归档文件
  (压缩还是解压, 依赖于是否组合了 -c 或 -x)选项
 10.  -j 用 bzip2 压缩归档文件 
 注意: 如果想从损坏的用 gzip 压缩过的 tar 文件中取得数据, 那将是很困难的. 所有当
  我们归档重要的文件的时候, 一定要保留多个备份. 
shar
 Shell 归档工具. 存在于 shell 归档文件中的所有文件都是未经压缩的, 并且本质上是一
 个shell 脚本,以 #!/bin/sh 开头, 并且包含所有必要的解档命令. Shar 归档文件  至今
 还在 Internet 新闻组中使用, 否则的话 shar早就被 tar/gzip 所取代了. unshar 命令
 用来解档 shar 归档文件. 
ar
 创建和操作归档文件的工具, 主要在对2进制目标文件打包成库时才会用到. 
rpm
 Red Hat 包管理器, 或者说 rpm 工具提供了一种对源文件或2进制文件进行打包的方法. 
 除此之外, 它还包括安装命令, 并且还检查包的完整性. 
 一个简单的 rpm -i package_name.rpm  命令对于安装一个包来说就足够了, 虽然这个命
 令还有好多其它的选项. 
 注意: rpm -qf 列出一个文件属于那个包.
   bash$ rpm -qf /bin/ls
   coreutils-5.2.1-3 
 注意: rpm -qa 将会列出给定系统上所有安装了的 rpm 包. rpm -qa package_name 命令
  将会列出于给定名字匹配的包.
   bash$ rpm -qa
   redhat-logos-1.1.3-1
   glibc-2.2.4-13
   cracklib-2.7-12
   dosfstools-2.7-1
   gdbm-1.8.0-10
   ksymoops-2.4.1-1
   mktemp-1.5-11
   perl-5.6.0-17
   reiserfs-utils-3.x.0j-2
   ...
   
   
   bash$ rpm -qa docbook-utils
   docbook-utils-0.6.9-2
   
   
   bash$ rpm -qa docbook | grep docbook
   docbook-dtd31-sgml-1.0-10
   docbook-style-dsssl-1.64-3
   docbook-dtd30-sgml-1.0-10
   docbook-dtd40-sgml-1.0-11
   docbook-utils-pdf-0.6.9-2
   docbook-dtd41-sgml-1.0-10
   docbook-utils-0.6.9-2 
cpio
 这个特殊的归档拷贝命令(拷贝输入和输出)现在已经很少能见到了, 因为它已经被 tar/gz
 ip 所替代了.现在这个命令只在一些比较特殊的地方还在使用,比如拷贝一个目录树. 
Example 12-27 使用 cpio 来拷贝一个目录树
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # 使用 'cpio' 拷贝目录树.
 4 
 5 # 使用 'cpio' 的优点:
 6 #   加速拷贝. 比通过管道使用 'tar' 命令快一些.
 7 #   很适合拷贝一些 'cp' 命令
 8 #+  搞不定的的特殊文件(比如名字叫 pipes 的文件, 等等)
 9 
10 ARGS=2
11 E_BADARGS=65
12 
13 if [ $# -ne "$ARGS" ]
14 then
15   echo "Usage: `basename $0` source destination"
16   exit $E_BADARGS
17 fi  
18 
19 source=$1
20 destination=$2
21 
22 find "$source" -depth | cpio -admvp "$destination"
23 #               ^^^^^         ^^^^^
24 # 阅读 'find' 和 'cpio' 的man 页来了解这些选项的意义.
25 
26 
27 # 练习:
28 # -----
29 
30 #  添加一些代码来检查 'find | cpio' 管道命令的退出码($?)
31 #+ 并且如果出现错误的时候输出合适的错误码.
32 
33 exit 0
################################End Script######################################### 
rpm2cpio
 这个命令可以从 rpm 归档文件中解出一个 cpio 归档文件. 
Example 12-28 解包一个 rpm 归档文件 
################################Start Script#######################################
 1 #!/bin/bash
 2 # de-rpm.sh: 解包一个 'rpm' 归档文件
 3 
 4 : ${1?"Usage: `basename $0` target-file"}
 5 # 必须指定 'rpm' 归档文件名作为参数.
 6 
 7 
 8 TEMPFILE=$$.cpio                         # Tempfile 必须是一个"唯一"的名字.
 9                                          # $$ 是这个脚本的进程 ID.
10 
11 rpm2cpio < $1 > $TEMPFILE                # 将 rpm 归档文件转换为 cpio 归档文件.
12 cpio --make-directories -F $TEMPFILE -i  # 解包 cpio 归档文件.
13 rm -f $TEMPFILE                          # 删除 cpio 归档文件.
14 
15 exit 0
16 
17 #  练习:
18 #  添加一些代码来检查    1) "target-file" 是否存在
19 #+                       2) 这个文件是否是一个 rpm 归档文件.
20 #  暗示:                    分析 'file' 命令的输出.
################################End Script######################################### 
压缩命令 
gzip
 标准的 GNU/UNIX 压缩工具, 取代了比较差的 compress 命令. 相应的解压命令是gunzip,
  gzip -d 是等价的. 
 zcat 过滤器可以将一个 gzip 文件解压到 stdout, 所以尽可能的使用管道和重定向. 这
 个命令事实上就是一个可以工作于压缩文件(包括一些的使用老的 compress 工具压缩的文
 件)的 cat 命令. zcat 命令等价于 gzip -dc. 
 注意: 在某些商业的 UNIX 系统上, zcat  与 uncompress -c 等价, 并且不能工作于 
  gzip  文件. 
 参见 Example 7-7. 
bzip2
 用来压缩的一个可选的工具, 通常比 gzip 命令压缩率更高(所以更慢), 适用于比较大的
 文件. 相应的解压命令是 bunzip2. 
 注意: 新版本的 tar 命令已经直接支持 bzip2 了. 
compress, uncompress
 这是一个老的, 私有的压缩工具, 一般的商业 UNIX 发行版都会有这个工具. 更有效率的 
 gzip 工具早就把这个工具替换掉了. Linux 发行版一般也会包含一个兼容的 compress 命
 令, 虽然 gunzip 也可以加压用 compress 工具压缩的文件. 
 注意: znew 命令可以将 compress 压缩的文件转换为 gzip 压缩的文件. 
sq
 另一种压缩工具, 一个只能工作于排过序的 ASCII 单词列表的过滤器.这个命令使用过滤
 器标准的调用语法, sq < input-file >  output-file. 速度很快, 但是效率远不及 
 gzip. 相应的解压命令为 unsq, 调用方法与 sq 相同. 
 注意: sq 的输出可以通过管道传递给 gzip 以便于进一步的压缩. 
zip, unzip
 跨平台的文件归档和压缩工具, 与 DOS 下的 pkzip.exe 兼容. zip 归档文件看起来在互
 联网上比 tar 包更流行. 
unarc, unarj, unrar
 这些 Linux 工具可以用来解档那些用 DOS 下的 arc.exe, arj.exe, 和 rar.exe 程序进
 行归档的文件. 
文件信息
file
 确定文件类型的工具. 命令 file file-name 将会用 ascii 文本或数据的形式返回 
 file-name 文件的详细描述. 这个命令会使用 /usr/share/magic, /etc/magic, 或 
 /usr/lib/magic 中定义的 魔法数字  来标识包含某种魔法数字的文件, 上边所举出的这
 3个文件需要依赖于具体的 Linux/UNIX 发行版. 
 -f 选项将会让 file 命令运行于批处理模式, 也就是说它会分析 -f 后边所指定的文件, 
 从中读取需要处理的文件列表, 然后依次执行 file 命令. -z 选项, 当对压缩过的目标文
 件使用时, 将会强制分析压缩的文件类型. 
  bash$ file test.tar.gz
  test.tar.gz: gzip compressed data, deflated, last modified: Sun Sep 16 13:34:51 2001, os: Unix
  
  bash file -z test.tar.gz
  test.tar.gz: GNU tar archive (gzip compressed data, deflated, last modified: Sun Sep 16 13:34:51 2001, os: Unix) 
  1 # 在给定的目录中找出sh和Bash脚本文件:
  2 
  3 DIRECTORY=/usr/local/bin
  4 KEYWORD=Bourne
  5 # Bourne 和 Bourne-Again shell 脚本
  6 
  7 file $DIRECTORY/* | fgrep $KEYWORD
  8 
  9 # 输出:
 10 
 11 # /usr/local/bin/burn-cd:          Bourne-Again shell script text executable
 12 # /usr/local/bin/burnit:           Bourne-Again shell script text executable
 13 # /usr/local/bin/cassette.sh:      Bourne shell script text executable
 14 # /usr/local/bin/copy-cd:          Bourne-Again shell script text executable
 15 # . . . 
Example 12-29 从 C 文件中去掉注释
################################Start Script#######################################
 1 #!/bin/bash
 2 # strip-comment.sh: 去掉C 程序中的注释 (/* 注释 */) 
 3 
 4 E_NOARGS=0
 5 E_ARGERROR=66
 6 E_WRONG_FILE_TYPE=67
 7 
 8 if [ $# -eq "$E_NOARGS" ]
 9 then
10   echo "Usage: `basename $0` C-program-file" >&2 # 将错误消息发到 stderr.
11   exit $E_ARGERROR
12 fi  
13 
14 # 检查文件类型是否正确.
15 type=`file $1 | awk '{ print $2, $3, $4, $5 }'`
16 # "file $1" echoe 出文件类型 . . .
17 # 然后 awk 会删掉第一个域,  就是文件名 . . .
18 # 然后结果将会传递到变量 "type" 中.
19 correct_type="ASCII C program text"
20 
21 if [ "$type" != "$correct_type" ]
22 then
23   echo
24   echo "This script works on C program files only."
25   echo
26   exit $E_WRONG_FILE_TYPE
27 fi  
28 
29 
30 # 相当隐秘的 sed 脚本:
31 #--------
32 sed '
33 /^\/\*/d
34 /.*\*\//d
35 ' $1
36 #--------
37 # 如果你花上几个小时来学习 sed 语法的话, 上边这个命令还是很好理解的.
38 
39 
40 #  如果注释和代码在同一行上, 上边的脚本就不行了.
41 #+ 所以需要添加一些代码来处理这种情况.
42 #  这是一个很重要的练习.
43 
44 #  当然, 上边的代码也会删除带有 "*/" 的非注释行 --
45 #+ 这也不是一个令人满意的结果.
46 
47 exit 0
48 
49 
50 # ----------------------------------------------------------------
51 # 下边的代码不会执行, 因为上边已经 'exit 0' 了.
52 
53 # Stephane Chazelas 建议使用下边的方法:
54 
55 usage() {
56   echo "Usage: `basename $0` C-program-file" >&2
57   exit 1
58 }
59 
60 WEIRD=`echo -n -e '\377'`   # or WEIRD=$'\377'
61 [[ $# -eq 1 ]] || usage
62 case `file "$1"` in
63   *"C program text"*) sed -e "s%/\*%${WEIRD}%g;s%\*/%${WEIRD}%g" "$1" \
64      | tr '\377\n' '\n\377' \
65      | sed -ne 'p;n' \
66      | tr -d '\n' | tr '\377' '\n';;
67   *) usage;;
68 esac
69 
70 #  如果是下列的这些情况, 还是很糟糕:
71 #  printf("/*");
72 #  or
73 #  /*  /* buggy embedded comment */
74 #
75 #  为了处理上边所有这些特殊情况(字符串中的注释, 含有 \", \\" ...
76 #+ 的字符串中的注释) 唯一的方法还是写一个 C 分析器
77 #+ (或许可以使用lex 或者 yacc ?).
78 
79 exit 0
################################End Script######################################### 
which
 which command-xxx 将会给出 "command-xxx" 的完整路径. 当你想在系统中准确定位一个
 特定的命令或工具的时候, 这个命令就非常有用了. 
 $bash which rm
  /usr/bin/rm 
whereis
 与上边的 which 很相似, whereis command-xxx 不只会给出 "command-xxx" 的完整路径,
  而且还会给出这个命令的 man页 的完整路径. 
 $bash whereis rm
  rm: /bin/rm /usr/share/man/man1/rm.1.bz2 
whatis
 whatis filexxx 将会在 whatis 数据库中查询 "filexxx". 当你想确认系统命令和重要的
 配置文件的时候, 这个命令就非常重要了. 可以把这个命令认为是一个简单的 man 命令. 
 $bash whatis whatis
  whatis               (1)  - search the whatis database for complete words 
Example 12-30 Exploring /usr/X11R6/bin
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # 在 /usr/X11R6/bin 中的所有神秘的2进制文件都是什么东西?
 4 
 5 DIRECTORY="/usr/X11R6/bin"
 6 # 也试试 "/bin", "/usr/bin", "/usr/local/bin", 等等.
 7 
 8 for file in $DIRECTORY/*
 9 do
10   whatis `basename $file`   # 将会 echo 出这个2进制文件的信息.
11 done
12 
13 exit 0
14 
15 # 你可能希望将这个脚本的输出重定向, 像这样:
16 # ./what.sh >>whatis.db
17 # 或者一页一页的在 stdout 上查看,
18 # ./what.sh | less
################################End Script#########################################
 参见 Example 10-3. 
vdir
 显示详细的目录列表. 与 ls -l 的效果类似.
 这是一个 GNU fileutils. 
  bash$ vdir
  total 10
  -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
  -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
  -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo
  
  bash ls -l
  total 10
  -rw-r--r--    1 bozo  bozo      4034 Jul 18 22:04 data1.xrolo
  -rw-r--r--    1 bozo  bozo      4602 May 25 13:58 data1.xrolo.bak
  -rw-r--r--    1 bozo  bozo       877 Dec 17  2000 employment.xrolo 
locate, slocate
 locate 命令将会在预先建立好的档案数据库中查询文件. slocate 命令是 locate 的安全
 版本( locate 命令可能已经被关联到 slocate 命令上了). 
 $bash locate hickson
  /usr/lib/xephem/catalogs/hickson.edb 
readlink
 显示符号连接所指向的文件. 
  bash$ readlink /usr/bin/awk
  ../../bin/gawk 
strings
 使用 strings 命令在二进制或数据文件中找出可打印字符. 它将在目标文件中列出所有找
 到的可打印字符的序列. 这个命令对于想进行快速查找一个 n 个字符的打印检查来说是很
 方便的,也可以用来检查一个未知格式的图片文件 (strings image-file | more 可能会搜
 索出像 JFIF 这样的字符串, 那么这就意味着这个文件是一个 jpeg  格式的图片文件). 
 在脚本中, 你可能会使用 grep 或 sed 命令来分析 strings 命令的输出. 参见 
 Example 10-7  和 Example 10-9. 
Example 12-31 一个"改进过"的 strings  命令
################################Start Script#######################################
 1 #!/bin/bash
 2 # wstrings.sh: "word-strings" (增强的 "strings" 命令)
 3 #
 4 #  这个脚本将会过滤 "strings" 命令的输出.
 5 #+ 通过排除标准单词列表的形式检查来过滤输出.
 6 #  这将有效的过滤掉无意义的字符,
 7 #+ 并且指挥输出可以识别的字符.
 8 
 9 # ===========================================================
10 #                 脚本参数的标准检查
11 ARGS=1
12 E_BADARGS=65
13 E_NOFILE=66
14 
15 if [ $# -ne $ARGS ]
16 then
17   echo "Usage: `basename $0` filename"
18   exit $E_BADARGS
19 fi
20 
21 if [ ! -f "$1" ]                      # 检查文件是否存在.
22 then
23     echo "File \"$1\" does not exist."
24     exit $E_NOFILE
25 fi
26 # ===========================================================
27 
28 
29 MINSTRLEN=3                           #  最小的字符串长度.
30 WORDFILE=/usr/share/dict/linux.words  #  字典文件.
31                                       #  也可以指定一个不同的
32                                       #+ 单词列表文件,
33                                       #+ 但这种文件必须是以每个单词一行的方式进行保存.
34 
35 
36 wlist=`strings "$1" | tr A-Z a-z | tr '[:space:]' Z | \
37 tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '`
38 
39 # 将'strings' 命令的输出通过管道传递到多个 'tr' 命令中.
40 #  "tr A-Z a-z"  全部转换为小写字符.
41 #  "tr '[:space:]'"  转换空白字符为多个 Z.
42 #  "tr -cs '[:alpha:]' Z"  将非字母表字符转换为多个 Z,
43 #+ 然后去除多个连续的 Z.
44 #  "tr -s '\173-\377' Z"  把所有z后边的字符都转换为 Z.
45 #+ 并且去除多余重复的Z.(注意173(123 ascii "{")和377(255 ascii 最后一个字符)都是8进制)
46 #+ 这样处理之后, 我们所有之前需要处理的令我们头痛的字符
47 #+ 就全都转换为字符 Z 了.
48 #  最后"tr Z ' '" 将把所有的 Z 都转换为空格,
49 #+ 这样我们在下边循环中用到的变量 wlist 中的内容就全部以空格分隔了.
50 
51 #  ****************************************************************
52 #  注意, 我们使用管道来将多个 'tr' 的输出传递到下一个 'tr' 时 
53 #+ 每次都使用了不同的参数.
54 #  ****************************************************************
55 
56 
57 for word in $wlist                    # 重要:
58                                       # $wlist 这里不能使用双引号.
59                                       # "$wlist" 不能正常工作.
60                                       # 为什么不行?
61 do
62 
63   strlen=${#word}                     # 字符串长度.
64   if [ "$strlen" -lt "$MINSTRLEN" ]   # 跳过短的字符串.
65   then
66     continue
67   fi
68 
69   grep -Fw $word "$WORDFILE"          #  只匹配整个单词.
70 #      ^^^                            #  "固定字符串" 和
71                                       #+ "整个单词" 选项. 
72 
73 done  
74 
75 
76 exit $?
################################End Script######################################### 
比较命令 
diff, patch
 diff: 一个非常灵活的文件比较工具. 这个工具将会以一行接一行的形式来比较目标文件.
  在某些应用中, 比如说比较单词词典, 在通过管道将结果传递给 diff 命令之前, 使用诸
 如 sort 和 uniq 命令来对文件进行过滤将是非常有用的.diff file-1 file-2 将会输出
 2个文件不同的行,并会通过符号标识出每个不同行所属的文件. 
 diff 命令的 --side-by-side 选项将会把2个比较中的文件全部输出, 按照左右分隔的形
 式, 并会把不同的行标记出来. -c 和 -u 选项也会使得 diff 命令的输出变得容易解释
 一些. 
 还有一些 diff 命令的变种, 比如 sdiff, wdiff, xdiff, 和 mgdiff. 
 注意: 如果比较的两个文件是完全一样的话, 那么 diff 命令会返回 0 作为退出码, 如果
  不同的话就返回 1 作为退出码. 这样 diff 命令就可以用在 shell 脚本的测试结构
  中了. (见下边) 
 diff 命令的一个重要用法就是产生区别文件, 这个文件将用作 patch 命令的 -e 选项的
 参数, -e 选项接受 ed 或 ex 脚本. 
 patch: 灵活的版本工具.给出一个用 diff 命令产生的区别文件, patch 命令可以将一个
 老版本的包更新为一个新版本的包. 因为你发布一个小的区别文件远比重新发布一个大的
 软件包来的容易得多.对于频繁更新的 Linux 内核来说, 使用补丁包的形式来发布将是一
 种很好的方法. 
    1 patch -p1 <patch-file
    2 # 在'patch-file'中取得所有的修改列表
    3 # 然后把它们应用于其中索引到的文件上.
    4 # 那么这个包就被更新为新版本了. 
 更新 kernel: 
    1 cd /usr/src
    2 gzip -cd patchXX.gz | patch -p0
    3 #  使用'patch'来更新内核源文件.
    4 # 来自于匿名作者(Alan Cox?)的
    5 # Linux 内核文档 "README". 
 注意: diff 命令也可以递归的比较目录下的所有文件(包含子目录). 
   bash$ diff -r ~/notes1 ~/notes2
   Only in /home/bozo/notes1: file02
   Only in /home/bozo/notes1: file03
   Only in /home/bozo/notes2: file04 
 注意: 使用 zdiff 来比较 gzip 文件. 
diff3
 一个 diff 命令的扩展版本, 可以同时比较3个文件. 如果成功执行那么这个命令就返回0,
  但是不幸的是这个命令不给出比较结果的信息. 
  bash$ diff3 file-1 file-2 file-3
  ====
  1:1c
    This is line 1 of "file-1".
  2:1c
    This is line 1 of "file-2".
  3:1c
    This is line 1 of "file-3" 
sdiff
 比较 和/或 编辑2个文件, 将它们合并到一个输出文件中. 因为这个命令的交互特性, 所
 以在脚本中很少使用这个命令. 
cmp
 cmp 命令是上边 diff 命令的一个简单版本. diff  命令会报告两个文件的不同之处, 而 
 cmp 命令仅仅指出那些位置有不同, 而不会显示不同的具体细节. 
 注意: 与 diff 一样,如果两个文件相同 cmp  返回0作为退出码, 如果不同返回1. 这样就
  可以用在 shell 脚本的测试结构中了. 
Example 12-32 在一个脚本中使用 cmp 来比较2个文件.
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 ARGS=2  # 脚本需要2个参数.
 4 E_BADARGS=65
 5 E_UNREADABLE=66
 6 
 7 if [ $# -ne "$ARGS" ]
 8 then
 9   echo "Usage: `basename $0` file1 file2"
10   exit $E_BADARGS
11 fi
12 
13 if [[ ! -r "$1" || ! -r "$2" ]]
14 then
15   echo "Both files to be compared must exist and be readable."
16   exit $E_UNREADABLE
17 fi
18 
19 cmp $1 $2 &> /dev/null  # /dev/null 将会禁止 "cmp" 命令的输出.
20 #   cmp -s $1 $2  与上边这句结果相同 ("-s" 选项是安静标志)
21 #   Thank you  Anders Gustavsson for pointing this out.
22 #
23 # 用 'diff' 命令也可以, 比如,   diff $1 $2 &> /dev/null
24 
25 if [ $? -eq 0 ]         # 测试 "cmp" 命令的退出码.
26 then
27   echo "File \"$1\" is identical to file \"$2\"."
28 else  
29   echo "File \"$1\" differs from file \"$2\"."
30 fi
31 
32 exit 0
################################End Script#########################################
 注意: 用 zcmp 处理 gzip 文件. 
comm
 多功能的文件比较工具. 使用这个命令之前必须先排序. 
 comm -options  first-file  second-file 
 comm file-1 file-2 将会输出3列: 
  * 第 1 列 = 只在 file-1 中存在的行
  * 第 2 列 = 只在 file-2 中存在的行
  * 第 2 列 = 两边相同的行. 
 下列选项可以禁止1列或多列的输出. 
  * -1 禁止显示第一栏 (译者: 在 File1 中的行)
  * -2 禁止显示第二栏 (译者: 在 File2 中的行)
  * -3 禁止显示第三栏 (译者: File1 和 File2 公共的行)
  * -12 禁止第一列和第二列, (就是说选项可以组合). 
一般工具 
basename
 从文件名中去掉路径信息, 只打印出文件名. 结构 basename $0 可以让脚本知道它自己的
 名字, 也就是, 它被调用的名字. 可以用来显示用法信息, 比如如果你调用脚本的时候缺
 少参数, 可以使用如下语句:
    1 echo "Usage: `basename $0` arg1 arg2 ... argn" 
dirname
 从带路径的文件名中去掉文件名, 只打印出路径信息. 
 注意: basename 和 dirname  可以操作任意字符串. 参数可以不是一个真正存在的文件, 
  甚至可以不是一个文件名.(参见 Example A-7). 
Example 12-33 basename 和 dirname
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 a=/home/bozo/daily-journal.txt
 4 
 5 echo "Basename of /home/bozo/daily-journal.txt = `basename $a`"
 6 echo "Dirname of /home/bozo/daily-journal.txt = `dirname $a`"
 7 echo
 8 echo "My own home is `basename ~/`."         # `basename ~` also works.
 9 echo "The home of my home is `dirname ~/`."  # `dirname ~`  also works.
10 
11 exit 0
################################End Script######################################### 
split, csplit
 将一个文件分割为几个小段的工具. 这些命令通常用来将大的文件分割, 并备份到软盘上,
  或者是为了切成合适的尺寸用 email 上传. 
 csplit 根据 上下文 来切割文件, 切割的位置将会发生在模式匹配的地方. 
sum, cksum, md5sum, sha1sum
 这些都是用来产生 checksum 的工具. checksum 的目的是用来检验文件的完整性, 是对文
 件的内容进行数学计算而得到的. 出于安全目的一个脚本可能会有一个 checksum 列表, 
 这样可以确保关键系统文件的内容不会被修改或损坏. 对于需要安全性的应用来说, 应该
 使用 md5sum (message digest 5  checksum) 命令, 或者更好的更新的 sha1sum 
 (安全 Hash 算法). 
  bash$ cksum /boot/vmlinuz
  1670054224 804083 /boot/vmlinuz
  
  bash$ echo -n "Top Secret" | cksum
  3391003827 10
  
  
  
  bash$ md5sum /boot/vmlinuz
  0f43eccea8f09e0a0b2b5cf1dcf333ba  /boot/vmlinuz
  
  bash$ echo -n "Top Secret" | md5sum
  8babc97a6f62a4649716f4df8d61728f  - 
 注意: cksum 命令将会显示目标的尺寸(字节), 目标可以使文件或 stdout.
  md5sum 和 sha1sum 命令在它们收到 stdout 的输入时候, 显示一个 dash . 
Example 12-34 检查文件完整性 
################################Start Script#######################################
  1 #!/bin/bash
  2 # file-integrity.sh: 检查一个给定目录下的文件
  3 #                    是否被改动了.
  4 
  5 E_DIR_NOMATCH=70
  6 E_BAD_DBFILE=71
  7 
  8 dbfile=File_record.md5
  9 # 存储记录的文件名 (数据库文件).
 10 
 11 
 12 set_up_database ()
 13 {
 14   echo ""$directory"" > "$dbfile"
 15   # 把目录名写到文件的第一行.
 16   md5sum "$directory"/* >> "$dbfile"
 17   # 在文件中附上  md5 checksums 和 filenames.
 18 }
 19 
 20 check_database ()
 21 {
 22   local n=0
 23   local filename
 24   local checksum
 25 
 26   # ------------------------------------------- #
 27   #  这个文件检查其实是不必要的,
 28   #+ 但是能安全一些.
 29 
 30   if [ ! -r "$dbfile" ]
 31   then
 32     echo "Unable to read checksum database file!"
 33     exit $E_BAD_DBFILE
 34   fi
 35   # ------------------------------------------- #
 36 
 37   while read record[n]
 38   do
 39 
 40     directory_checked="${record[0]}"
 41     if [ "$directory_checked" != "$directory" ]
 42     then
 43       echo "Directories do not match up!"
 44       # 换个目录试一下.
 45       exit $E_DIR_NOMATCH
 46     fi
 47 
 48     if [ "$n" -gt 0 ]   # 不是目录名.
 49     then
 50       filename[n]=$( echo ${record[$n]} | awk '{ print $2 }' )
 51       #  md5sum 向后写记录,
 52       #+ 先写 checksum, 然后写 filename.
 53       checksum[n]=$( md5sum "${filename[n]}" )
 54 
 55 
 56       if [ "${record[n]}" = "${checksum[n]}" ]
 57       then
 58         echo "${filename[n]} unchanged."
 59 
 60       elif [ "`basename ${filename[n]}`" != "$dbfile" ]
 61              #  跳过checksum 数据库文件,
 62              #+ 因为在每次调用脚本它都会被修改.
 63       #  ---
 64       #  这不幸的意味着当我们在 $PWD中运行这个脚本
 65       #+ 时, 修改这个 checksum 数
 66       #+ 据库文件将不会被检测出来.
 67       #  练习: 修复这个问题.
 68  then
 69           echo "${filename[n]} : CHECKSUM ERROR!"
 70         # 因为最后的检查, 文件已经被修改.
 71       fi
 72 
 73       fi
 74 
 75 
 76 
 77     let "n+=1"
 78   done <"$dbfile"       # 从 checksum 数据库文件中读.
 79 
 80 }  
 81 
 82 # =================================================== #
 83 # main ()
 84 
 85 if [ -z  "$1" ]
 86 then
 87   directory="$PWD"      #  如果没制定参数,
 88 else                    #+ 那么就使用当前的工作目录.
 89   directory="$1"
 90 fi  
 91 
 92 clear                   # 清屏.
 93 echo " Running file integrity check on $directory"
 94 echo
 95 
 96 # ------------------------------------------------------------------ #
 97   if [ ! -r "$dbfile" ] # 是否需要建立数据库文件?
 98   then
 99     echo "Setting up database file, \""$directory"/"$dbfile"\"."; echo
100     set_up_database
101   fi  
102 # ------------------------------------------------------------------ #
103 
104 check_database          # 调用主要处理函数.
105 
106 echo 
107 
108 #  你可能想把这个脚本的输出重定向到文件中,
109 #+ 尤其在这个目录中有很多文件的时候.
110 
111 exit 0
112 
113 #  如果要对数量非常多的文件做完整性检查,
114 #+ 可以考虑一下 "Tripwire" 包,
115 #+ http://sourceforge.net/projects/tripwire/.
116 
################################End Script#########################################
 参见 Example A-19 和 Example 33-14 , 这两个例子展示了 md5sum 命令的用法. 
 注意: 已经有 128-bit md5sum 被破解的报告了,所以现在更安全的 160-bit sha1sum 是
  非常受欢迎的, 并且已经被加入到 checksum 工具包中. 
  一些安全顾问认为即使是 sha1sum 也是会被泄漏的. 所以, 下一个工具是什么呢? 
  -- 512-bit 的 checksum 工具? 
   bash$ md5sum testfile
   e181e2c8720c60522c4c4c981108e367  testfile
   
   
   bash$ sha1sum testfile
   5d7425a9c08a66c3177f1e31286fa40986ffc996  testfile 
shred
 用随机字符填充文件, 使得文件无法恢复, 这样就可以保证文件安全的被删除. 这个命令
 的效果与 Example 12-55 一样, 但是使用这个命令是一种更优雅更彻底的方法. 
 这是一个 GNU fileutils. 
 注意: 即使使用了 shred 命令, 高级的(forensic)辩论技术还是能够恢复文件的内容. 
编码和解码 
uuencode
 这个工具用来把二进制文件编码成 ASCII 字符串,这个工具适用于编码e-mail消息体,或者
 新闻组消息. 
uudecode
 这个工具用来把 uuencode 后的 ASCII 字符串恢复为二进制文件. 
Example 12-35 Uudecod 编码后的文件
################################Start Script#######################################
 1 #!/bin/bash
 2 # 在当前目录下 uudecode 所有用 uuencode 编码的文件.
 3 
 4 lines=35        # 允许读头部的 35 行(范围很宽).
 5 
 6 for File in *   # Test 所有 $PWD 下的文件.
 7 do
 8   search1=`head -$lines $File | grep begin | wc -w`
 9   search2=`tail -$lines $File | grep end | wc -w`
10   #  Uuencode 过的文件在文件开始的地方有个 "begin",
11   #+ 在文件结尾的地方有个 "end".
12   if [ "$search1" -gt 0 ]
13   then
14     if [ "$search2" -gt 0 ]
15     then
16       echo "uudecoding - $File -"
17       uudecode $File
18     fi  
19   fi
20 done  
21 
22 #  小心不要让这个脚本运行自己,
23 #+ 因为它也会把自身也认为是一个 uuencoded 文件,
24 #+ 这都是因为这个脚本自身也包含 "begin" 和 "end".
25 
26 #  练习:
27 #  -----
28 #  修改这个脚本, 让它可以检查一个新闻组的每个文件,
29 #+ 并且如果下一个没找的话就跳过.
30 
31 exit 0
################################End Script######################################### 
 注意: fold -s 命令在处理从 Usenet 新闻组下载下来的长的uudecode 文本消息的时候可
  能会有用(可能在管道中). 
mimencode, mmencode
 mimencode 和 mmencode 命令处理多媒体编码的 email 附件. 虽然 mail 用户代理 
 (比如 pine 或 kmail) 通常情况下都会自动处理, 但是这些特定的工具允许从命令行或
 shell脚本中来手动操作这些附件. 
crypt
 这个工具曾经是标准的 UNIX 文件加密工具. [3]  政府由于政策上的动机规定禁止加密软
 件的输出, 这样导致了 crypt 命令从 UNIX 世界消失, 并且在大多数的 Linux 发行版中
 也没有这个命令. 幸运的是, 程序员们想出了一些替代它的方法, 在这些方法中有作者自
 己的 cruft (参见 Example A-4). 
一些杂项工具 
mktemp
 使用一个"唯一"的文件名来创建一个 临时文件  [4]  . 如果不带参数的在命令行下调用
 这个命令时, 将会在 /tmp 目录下产生一个零长度的文件. 
  bash$ mktemp
  /tmp/tmp.zzsvql3154 
    1 PREFIX=filename
    2 tempfile=`mktemp $PREFIX.XXXXXX`
    3 #                        ^^^^^^ 在这个临时的文件名中
    4 #+                              至少需要6个占位符.
    5 #  如果没有指定临时文件的文件名,
    6 #+ 那么默认就是 "tmp.XXXXXXXXXX".
    7 
    8 echo "tempfile name = $tempfile"
    9 # tempfile name = filename.QA2ZpY
   10 #                 或者一些其他的相似的名字...
   11 
   12 #  使用 600 为文件权限
   13 #+ 来在当前工作目录下创建一个这样的文件.
   14 #  这样就不需要 "umask 177" 了.
   15 #  但不管怎么说, 这也是一个好的编程风格. 
make
 build 和 compile 二进制包的工具. 当源文件被增加或修改时就会触发一些操作, 这个工
 具用来控制这些操作. 
 make 命令将会检查 Makefile, makefile 是文件的依赖和操作列表. 
install
 特殊目的的文件拷贝命令, 与 cp 命令相似, 但是具有设置拷贝文件的权限和属性的能力.
  这个命令看起来是为了安装软件包所定制的, 而且就其本身而言, 这个命令经常出现在 
 Makefile 中(在 make install : 区中). 在安装脚本中也会看到这个命令的使用. 
dos2unix
 这个工具是由 Benjamin Lin 和其同事编写的, 目的是将 DOS 格式的文本文件 
 (以 CR-LF 为行结束符) 转换为 UNIX 格式 (以 LF 为行结束符), 反过来也一样. 
ptx
 ptx [targetfile] 命令将会输出目标文件的序列改变的索引(交叉引用列表). 如果必要的
 话, 这个命令可以在管道中进行更深层次的过滤和格式化. 
more, less
 分页显示文本文件或 stdout, 一次一屏.可以用来过滤 stdout 的输出 . . . 或一个脚本
 的输出. 
 more 命令的一个有趣的应用就是测试一个命令序列的执行, 来避免可能发生的糟糕的
 结果. 
    1 ls /home/bozo | awk '{print "rm -rf " $1}' | more
    2 #                                            ^^^^
    3    
    4 # 检测下边(灾难性的)命令行的效果:
    5 #      ls /home/bozo | awk '{print "rm -rf " $1}' | sh
    6 #      推入 shell 中执行 . . . 
注意事项:
[1]  在这里所讨论的一个归档文件, 只不过是存储在一个单一位置上的一些相关文件的
  集合.
[2]  tar czvf archive_name.tar.gz *  可以 包含当前工作目录下的点文件. 这是一个
  未文档化的 GNU tar 的"特征".
[3]  这是一个对称的块密码, 过去曾在单系统或本地网络中用来加密文件, 用来对抗 
  "public key" 密码类, pgp 就是一个众所周知的例子.
[4]  使用 -d 选项可以创建一个临时的目录. 
  
12.6 通讯命令
-------------
 下边命令中的某几个命令你会在 "追踪垃圾邮件" 练习中找到其用法, 用来进行网络数
据的转换和分析. 
信息与统计 
host
 通过名字或 IP 地址来搜索一个互联网主机的信息, 使用 DNS. 
  bash$ host surfacemail.com
  surfacemail.com. has address 202.92.42.236 
ipcalc
 显示一个主机 IP 信息. 使用 -h 选项, ipcalc 将会做一个 DNS 的反向查询, 通过 IP
 地址找到主机(服务器)名. 
  bash$ ipcalc -h 202.92.42.236
  HOSTNAME=surfacemail.com 
nslookup
 通过 IP 地址在一个主机上做一个互联网的 "名字服务查询". 事实上这与 ipcalc -h 或
 dig -x 等价. 这个命令既可以交互运行也可以非交互运行, 换句话说, 就是在脚本中运
 行. 
 nslookup 命令据说已经慢慢被"忽视"了, 但是它还是有它的用处. 
  bash$ nslookup -sil 66.97.104.180
  nslookup kuhleersparnis.ch
  Server:         135.116.137.2
  Address:        135.116.137.2#53 
  Non-authoritative answer:
  Name:   kuhleersparnis.ch 
dig
 域信息查询. 与 nslookup 很相似, dig 在一个主机上做一个互联网的 "名字服务查询".
 这个命令既可以交互运行也可以非交互运行, 换句话说, 就是在脚本中运行. 
 下边是一些 dig 命令有趣的选项, +time=N 选项用来设置查询超时为 N 秒, +nofail 
 选项用来持续查询服务器直到收到一个响应, -x 选项会做反向地址查询. 
 比较下边这3个命令的输出, dig -x , ipcalc -h 和 nslookup. 
  bash$ dig -x 81.9.6.2
  ;; Got answer:
  ;; ->>HEADER<<- opcode: QUERY, status: NXDOMAIN, id: 11649
  ;; flags: qr rd ra; QUERY: 1, ANSWER: 0, AUTHORITY: 1, ADDITIONAL: 0 
  ;; QUESTION SECTION:
  ;2.6.9.81.in-addr.arpa.         IN      PTR 
  ;; AUTHORITY SECTION:
  6.9.81.in-addr.arpa.    3600    IN      SOA     ns.eltel.net. noc.eltel.net.
  2002031705 900 600 86400 3600 
  ;; Query time: 537 msec
  ;; SERVER: 135.116.137.2#53(135.116.137.2)
  ;; WHEN: Wed Jun 26 08:35:24 2002
  ;; MSG SIZE  rcvd: 91 
Example 12-36 查找滥用的连接来报告垃圾邮件发送者
################################Start Script#######################################
 1 #!/bin/bash
 2 # spam-lookup.sh: 查找滥用的连接来报告垃圾邮件发送者.
 3 # 感谢 Michael Zick.
 4 
 5 # 检查命令行参数.
 6 ARGCOUNT=1
 7 E_WRONGARGS=65
 8 if [ $# -ne "$ARGCOUNT" ]
 9 then
10   echo "Usage: `basename $0` domain-name"
11   exit $E_WRONGARGS
12 fi
13 
14 
15 dig +short $1.contacts.abuse.net -c in -t txt
16 # 也试试:
17 #     dig +nssearch $1
18 #     尽量找到 "可信赖的名字服务器" 并且显示 SOA 记录.
19 
20 # 下边这句也可以:
21 #     whois -h whois.abuse.net $1
22 #           ^^ ^^^^^^^^^^^^^^^  指定主机.
23 #     使用这个命令也可以查找多个垃圾邮件发送者, 比如:"
24 #     whois -h whois.abuse.net $spamdomain1 $spamdomain2 . . .
25 
26 
27 #  练习:
28 #  -----
29 #  扩展这个脚本的功能,
30 #+ 让它可以自动发送 e-mail 来通知
31 #+ 需要对此负责的 ISP 的联系地址.
32 #  暗示: 使用 "mail" 命令.
33 
34 exit $?
35 
36 # spam-lookup.sh chinatietong.com
37 #                一个已知的垃圾邮件域.(译者: 中国铁通. . .)
38 
39 # "crnet_mgr@chinatietong.com"
40 # "crnet_tec@chinatietong.com"
41 # "postmaster@chinatietong.com"
42 
43 
44 #  如果想找到这个脚本的一个更详尽的版本,
45 #+ 请访问 SpamViz 的主页, http://www.spamviz.net/index.html.
################################End Script######################################### 
Example 12-37 分析一个垃圾邮件域<rojy bug>
################################Start Script#######################################
  1 #! /bin/bash
  2 # is-spammer.sh: 鉴别一个垃圾邮件域
  3 
  4 # $Id: is-spammer, v 1.4 2004/09/01 19:37:52 mszick Exp $
  5 # 上边这行是 RCS ID 信息.
  6 #
  7 #  这是附件中捐献脚本 is_spammer.bash
  8 #+ 的一个简单版本.
  9 
 10 # is-spammer <domain.name>
 11 
 12 # 使用外部程序: 'dig'
 13 # 测试版本: 9.2.4rc5
 14 
 15 # 使用函数.
 16 # 使用 IFS 来分析分配在数组中的字符串.
 17 # 检查 e-mail 黑名单.
 18 
 19 # 使用来自文本体中的 domain.name:
 20 # http://www.good_stuff.spammer.biz/just_ignore_everything_else
 21 #                       ^^^^^^^^^^^
 22 # 或者使用来自任意 e-mail 地址的 domain.name:
 23 # Really_Good_Offer@spammer.biz
 24 #
 25 # 并将其作为这个脚本的唯一参数.
 26 #(另: 你的 Inet 连接应该保证连接)
 27 #
 28 # 这样, 在上边两个实例中调用这个脚本:
 29 #       is-spammer.sh spammer.biz
 30 
 31 
 32 # Whitespace == :Space:Tab:Line Feed:Carriage Return:
 33 WSP_IFS=$'\x20'$'\x09'$'\x0A'$'\x0D'
 34 
 35 # No Whitespace == Line Feed:Carriage Return
 36 No_WSP=$'\x0A'$'\x0D'
 37 
 38 # 域分隔符为点分10进制 ip 地址
 39 ADR_IFS=${No_WSP}'.'
 40 
 41 # 取得 dns 文本资源记录.
 42 # get_txt <error_code> <list_query>
 43 get_txt() {
 44 
 45     # 分析在"."中分配的 $1.
 46     local -a dns
 47     IFS=$ADR_IFS
 48     dns=( $1 )
 49     IFS=$WSP_IFS
 50     if [ "${dns[0]}" == '127' ]
 51     then
 52         # 查看此处是否有原因.
 53         echo $(dig +short $2 -t txt)
 54     fi
 55 }
 56 
 57 # 取得 dns 地址资源记录.
 58 # chk_adr <rev_dns> <list_server>
 59 chk_adr() {
 60     local reply
 61     local server
 62     local reason
 63 
 64     server=${1}${2}
 65     reply=$( dig +short ${server} )
 66 
 67     # 假设应答可能是一个错误码 . . .
 68     if [ ${#reply} -gt 6 ]
 69     then
 70         reason=$(get_txt ${reply} ${server} )
 71         reason=${reason:-${reply}}
 72     fi
 73     echo ${reason:-' not blacklisted.'}
 74 }
 75 
 76 # 需要从名字中取得 IP 地址.
 77 echo 'Get address of: '$1
 78 ip_adr=$(dig +short $1)
 79 dns_reply=${ip_adr:-' no answer '}
 80 echo ' Found address: '${dns_reply}
 81 
 82 # 一个可用的应答至少是4个数字加上3个点.
 83 if [ ${#ip_adr} -gt 6 ]
 84 then
 85     echo
 86     declare query
 87 
 88     # 分析点中的分配.
 89     declare -a dns
 90     IFS=$ADR_IFS
 91     dns=( ${ip_adr} )
 92     IFS=$WSP_IFS
 93 
 94     # Reorder octets into dns query order.
 95     rev_dns="${dns[3]}"'.'"${dns[2]}"'.'"${dns[1]}"'.'"${dns[0]}"'.'
 96 
 97 # 参见: http://www.spamhaus.org (Conservative, well maintained)
 98     echo -n 'spamhaus.org says: '
 99     echo $(chk_adr ${rev_dns} 'sbl-xbl.spamhaus.org')
100 
101 # 参见: http://ordb.org (Open mail relays)
102     echo -n '   ordb.org  says: '
103     echo $(chk_adr ${rev_dns} 'relays.ordb.org')
104 
105 # 参见: http://www.spamcop.net/ (你可以在这里报告 spammer)
106     echo -n ' spamcop.net says: '
107     echo $(chk_adr ${rev_dns} 'bl.spamcop.net')
108 
109 # # # 其他的黑名单操作 # # #
110 
111 # 参见: http://cbl.abuseat.org.
112     echo -n ' abuseat.org says: '
113     echo $(chk_adr ${rev_dns} 'cbl.abuseat.org')
114 
115 # 参见: http://dsbl.org/usage (Various mail relays)
116     echo
117     echo 'Distributed Server Listings'
118     echo -n '       list.dsbl.org says: '
119     echo $(chk_adr ${rev_dns} 'list.dsbl.org')
120 
121     echo -n '   multihop.dsbl.org says: '
122     echo $(chk_adr ${rev_dns} 'multihop.dsbl.org')
123 
124     echo -n 'unconfirmed.dsbl.org says: '
125     echo $(chk_adr ${rev_dns} 'unconfirmed.dsbl.org')
126 
127 else
128     echo
129     echo 'Could not use that address.'
130 fi
131 
132 exit 0
133 
134 # 练习:
135 # -----
136 
137 # 1) 检查脚本的参数,
138 #    并且如果必要的话使用合适的错误消息退出.
139 
140 # 2) 检查调用这个脚本的时候是否在线,
141 #    并且如果必要的话使用合适的错误消息退出.
142 
143 # 3) Substitute generic variables for "hard-coded" BHL domains.
144 
145 # 4) 通过对 'dig' 命令使用 "+time=" 选项
146      来给这个脚本设置一个暂停.
################################End Script#########################################
 想获得比上边这个脚本更详细的版本, 参见 Example A-27. 
traceroute
 跟踪包发送到远端主机过程中的路由信息. 这个命令在 LAN, WAN, 或者在 Internet 上都
 可以正常工作. 远端主机可以通过 IP 地址来指定. 这个命令的输出也可以通过管道中的 
 grep 或 sed 命令来过滤. 
  bash$ traceroute 81.9.6.2
  traceroute to 81.9.6.2 (81.9.6.2), 30 hops max, 38 byte packets
  1  tc43.xjbnnbrb.com (136.30.178.8)  191.303 ms  179.400 ms  179.767 ms
  2  or0.xjbnnbrb.com (136.30.178.1)  179.536 ms  179.534 ms  169.685 ms
  3  192.168.11.101 (192.168.11.101)  189.471 ms  189.556 ms *
  ... 
ping
 广播一个 "ICMP ECHO_REQUEST" 包到其他主机上, 既可以是本地网络也可以使远端网络.
 这是一个测试网络连接的诊断工具, 应该小心使用. 
 一个成功的 ping 返回的 退出码 为 0. 可以用在脚本的测试语句中. 
  bash$ ping localhost
  PING localhost.localdomain (127.0.0.1) from 127.0.0.1 : 56(84) bytes of data.
  64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=0 ttl=255 time=709 usec
  64 bytes from localhost.localdomain (127.0.0.1): icmp_seq=1 ttl=255 time=286 usec 
  --- localhost.localdomain ping statistics ---
  2 packets transmitted, 2 packets received, 0% packet loss
  round-trip min/avg/max/mdev = 0.286/0.497/0.709/0.212 ms 
whois
 执行DNS (域名系统) 查询lookup. -h 选项允许指定需要查询的特定的 whois 服务器. 
 参见 Example 4-6 和 Example 12-36. 
finger
 取得网络上的用户信息. 另外这个命令可以显示一个用户的~/.plan, ~/.project, 和 
 ~/.forward 文件, 如果存在的话. 
  bash$ finger
  Login  Name           Tty      Idle  Login Time   Office     Office Phone
  bozo   Bozo Bozeman   tty1        8  Jun 25 16:59
  bozo   Bozo Bozeman   ttyp0          Jun 25 16:59
  bozo   Bozo Bozeman   ttyp1          Jun 25 17:07
  
  
  
  bash$ finger bozo
  Login: bozo                             Name: Bozo Bozeman
  Directory: /home/bozo                   Shell: /bin/bash
  Office: 2355 Clown St., 543-1234
  On since Fri Aug 31 20:13 (MST) on tty1    1 hour 38 minutes idle
  On since Fri Aug 31 20:13 (MST) on pts/0   12 seconds idle
  On since Fri Aug 31 20:13 (MST) on pts/1
  On since Fri Aug 31 20:31 (MST) on pts/2   1 hour 16 minutes idle
  No mail.
  No Plan. 
 处于安全上的考虑, 许多网络都禁用了 finger 以及和它相关的幽灵进程. [1] 
chfn
 修改 finger 命令所显示出来的用户信息. 
vrfy
 验证一个互联网的 e-mail 地址. 
远端主机接入 
sx, rx
 sx 和 rx 命令使用 xmodem 协议, 设置服务来向远端主机传输文件和接收文件. 这些都
 是通讯安装包的一般部分, 比如 minicom. 
sz, rz
 sz 和 rz 命令使用 zmodem 协议, 设置服务来向远端主机传输文件和接收文件. zmodem
 协议在某些方面比 xmodem强, 比如使用更快的的传输波特率, 并且可以对中断的文件进
 行续传.与 sx 一样 rx, 这些都是通讯安装包的一般部分. 
ftp
 向远端服务器上传或下载的工具和协议. 一个ftp会话可以写到脚本中自动运行. (见 
 Example 17-6, Example A-4, 和 Example A-13). 
uucp, uux, cu
 uucp: UNIX 到 UNIX 拷贝. 这是一个通讯安装包, 目的是为了在 UNIX 服务器之间传输
 文件. 使用 shell 脚本来处理 uucp 命令序列是一种有效的方法. 
 因为互联网和电子邮件的出现, uucp 现在看起来已经很落伍了, 但是这个命令在互联网
 连接不可用或者不适合使用的地方, 这个命令还是可以完美的运行. uucp 的优点就是它
 的容错性, 即使有一个服务将拷贝操作中断了, 那么当连接恢复的时候, 这个命令还是
 可以在中断的地方续传. 
 --- 
 uux: UNIX 到 UNIX 执行. 在远端系统上执行一个命令.这个命令是 uucp 包的一部分. 
 --- 
 cu: Call Up 一个远端系统并且作为一个简单终端进行连接. 这是一个 telnet 的缩减
 版本. 这个命令是 uucp 包的一部分. 
telnet
 连接远端主机的工具和协议. 
 注意:telnet 协议本身包含安全漏洞, 因此我们应该适当的避免使用. 
wget
 wget 工具使用非交互的形式从 web 或 ftp 站点上取得或下载文件. 在脚本中使用正好. 
    1 wget -p http://www.xyz23.com/file01.html
    2 #  The -p or --page-requisite 选项将会使得 wget 取得显示指定页时
    3 #+ 所需要的所有文件.(译者: 比如内嵌图片和样式表等).
    4 
    5 wget -r ftp://ftp.xyz24.net/~bozo/project_files/ -O $SAVEFILE
    6 #  -r 选项将会递归的从指定站点
    7 #+ 上下载所有连接. 
Example 12-38 获得一份股票报价
################################Start Script#######################################
 1 #!/bin/bash
 2 # quote-fetch.sh: 下载一份股票报价.
 3 
 4 
 5 E_NOPARAMS=66
 6 
 7 if [ -z "$1" ]  # 必须指定需要获取的股票(代号).
 8   then echo "Usage: `basename $0` stock-symbol"
 9   exit $E_NOPARAMS
10 fi
11 
12 stock_symbol=$1
13 
14 file_suffix=.html
15 # 获得一个 HTML 文件, 所以要正确命名它.
16 URL='http://finance.yahoo.com/q?s='
17 # Yahoo 金融板块, 后缀是股票查询.
18 
19 # -----------------------------------------------------------
20 wget -O ${stock_symbol}${file_suffix} "${URL}${stock_symbol}"
21 # -----------------------------------------------------------
22 
23 
24 # 在 http://search.yahoo.com 上查询相关材料:
25 # -----------------------------------------------------------
26 # URL="http://search.yahoo.com/search?fr=ush-news&p=${query}"
27 # wget -O "$savefilename" "${URL}"
28 # -----------------------------------------------------------
29 # 保存相关 URL 的列表.
30 
31 exit $?
32 
33 # 练习:
34 # -----
35 #
36 # 1) 添加一个测试来验证用户正在线.
37 #    (暗示: 对 "ppp" 或 "connect" 来分析 'ps -ax' 的输出.
38 #
39 # 2) 修改这个脚本, 让这个脚本具有获得本地天气预报的能力,
40 #+   将用户的 zip code 作为参数.
################################End Script#########################################
 参见 Example A-29 和 Example A-30. 
lynx
 lynx 是一个网页浏览器, 也是一个文件浏览器. 它可以(通过使用 -dump 选项)在脚本中
 使用. 它的作用是可以从 Web 或 ftp 站点上非交互的获得文件. 
    1 lynx -dump http://www.xyz23.com/file01.html >$SAVEFILE 
 使用 -traversal 选项, lynx 将从参数中指定的 HTTP URL 开始, 遍历指定服务器上的
 所有链接. 如果与 -crawl 选项一起用的话, 将会把每个输出的页面文本都放到一个 log
 文件中. 
rlogin
 远端登陆, 在远端的主机上开启一个会话. 这个命令存在安全隐患, 所以要使用 ssh 来
 代替. 
rsh
 远端 shell, 在远端的主机上执行命令. 这个命令存在安全隐患, 所以要使用 ssh 来代
 替. 
rcp
 远端拷贝, 在网络上的不同主机间拷贝文件. 
rsync
 远端同步, 在网络上的不同主机间(同步)更新文件. 
  bash$ rsync -a ~/sourcedir/*txt /node1/subdirectory/ 
Example 12-39 更新 Fedora 4 <rojy bug>  
################################Start Script#######################################
  1 #!/bin/bash
  2 # fc4upd.sh
  3 
  4 # 脚本作者: Frank Wang.
  5 # 本书作者作了少量修改.
  6 # 授权在本书中使用.
  7 
  8 
  9 #  使用 rsync 命令从镜像站点上下载 Fedora 4 的更新.
 10 #  为了节省空间, 如果有多个版本存在的话,
 11 #+ 只下载最新的包.
 12 
 13 URL=rsync://distro.ibiblio.org/fedora-linux-core/updates/
 14 # URL=rsync://ftp.kddilabs.jp/fedora/core/updates/
 15 # URL=rsync://rsync.planetmirror.com/fedora-linux-core/updates/
 16 
 17 DEST=${1:-/var/www/html/fedora/updates/}
 18 LOG=/tmp/repo-update-$(/bin/date +%Y-%m-%d).txt
 19 PID_FILE=/var/run/${0##*/}.pid
 20 
 21 E_RETURN=65        # 某些意想不到的错误.
 22 
 23 
 24 # 一搬 rsync 选项
 25 # -r: 递归下载
 26 # -t: 保存时间
 27 # -v: verbose
 28 
 29 OPTS="-rtv --delete-excluded --delete-after --partial"
 30 
 31 # rsync include 模式
 32 # Leading slash causes absolute path name match.
 33 INCLUDE=(
 34     "/4/i386/kde-i18n-Chinese*" 
 35 #   ^                         ^
 36 # 双引号是必须的, 用来防止file globbing.
 37 ) 
 38 
 39 
 40 # rsync exclude 模式
 41 # 使用 "#" 临时注释掉一些不需要的包.
 42 EXCLUDE=(
 43     /1
 44     /2
 45     /3
 46     /testing
 47     /4/SRPMS
 48     /4/ppc
 49     /4/x86_64
 50     /4/i386/debug
 51    "/4/i386/kde-i18n-*"
 52    "/4/i386/openoffice.org-langpack-*"
 53    "/4/i386/*i586.rpm"
 54    "/4/i386/GFS-*"
 55    "/4/i386/cman-*"
 56    "/4/i386/dlm-*"
 57    "/4/i386/gnbd-*"
 58    "/4/i386/kernel-smp*"
 59 #  "/4/i386/kernel-xen*" 
 60 #  "/4/i386/xen-*" 
 61 )
 62 
 63 
 64 init () {
 65     # 让管道命令返回可能的 rsync 错误, 比如, 网络延时(stalled network).
 66     set -o pipefail
 67 
 68     TMP=${TMPDIR:-/tmp}/${0##*/}.$$     # 保存精炼的下载列表.
 69     trap "{
 70         rm -f $TMP 2>/dev/null
 71     }" EXIT                             # 删除存在的临时文件.
 72 }
 73 
 74 
 75 check_pid () {
 76 # 检查进程是否存在.
 77     if [ -s "$PID_FILE" ]; then
 78         echo "PID file exists. Checking ..."
 79         PID=$(/bin/egrep -o "^[[:digit:]]+" $PID_FILE)
 80         if /bin/ps --pid $PID &>/dev/null; then
 81             echo "Process $PID found. ${0##*/} seems to be running!"
 82            /usr/bin/logger -t ${0##*/} \
 83                  "Process $PID found. ${0##*/} seems to be running!"
 84             exit $E_RETURN
 85         fi
 86         echo "Process $PID not found. Start new process . . ."
 87     fi
 88 }
 89 
 90 
 91 #  根据上边的模式,
 92 #+ 设置整个文件的更新范围, 从 root 或 $URL 开始.
 93 set_range () {
 94     include=
 95     exclude=
 96     for p in "${INCLUDE[@]}"; do
 97         include="$include --include \"$p\""
 98     done
 99 
100     for p in "${EXCLUDE[@]}"; do
101         exclude="$exclude --exclude \"$p\""
102     done
103 }
104 
105 
106 # 获得并提炼 rsync 更新列表.
107 get_list () {
108     echo $$ > $PID_FILE || {
109         echo "Can't write to pid file $PID_FILE"
110         exit $E_RETURN
111     }
112 
113     echo -n "Retrieving and refining update list . . ."
114 
115     # 获得列表 -- 为了作为单个命令来运行 rsync 需要 'eval'.
116     # $3 和 $4 是文件创建的日期和时间.
117     # $5 是完整的包名字.
118     previous=
119     pre_file=
120     pre_date=0
121     eval /bin/nice /usr/bin/rsync \
122         -r $include $exclude $URL | \
123         egrep '^dr.x|^-r' | \
124         awk '{print $3, $4, $5}' | \
125         sort -k3 | \
126         { while read line; do
127             # 获得这段运行的秒数, 过滤掉不用的包.
128             cur_date=$(date -d "$(echo $line | awk '{print $1, $2}')" +%s)
129             #  echo $cur_date
130 
131             # 取得文件名.
132             cur_file=$(echo $line | awk '{print $3}')
133             #  echo $cur_file
134 
135             # 如果可能的话, 从文件名中取得 rpm 的包名字.
136             if [[ $cur_file == *rpm ]]; then
137                 pkg_name=$(echo $cur_file | sed -r -e \
138                     's/(^([^_-]+[_-])+)[[:digit:]]+\..*[_-].*$/\1/')
139             else
140                 pkg_name=
141             fi
142             # echo $pkg_name
143 
144             if [ -z "$pkg_name" ]; then   #  如果不是一个 rpm 文件,
145                 echo $cur_file >> $TMP    #+ 然后添加到下载列表里.
146             elif [ "$pkg_name" != "$previous" ]; then   # 发现一个新包.
147                 echo $pre_file >> $TMP                  # 输出最新的文件.
148                 previous=$pkg_name                      # 保存当前状态.
149                 pre_date=$cur_date
150                 pre_file=$cur_file
151             elif [ "$cur_date" -gt "$pre_date" ]; then  #  如果是相同的包, 但是更新一些,
152                 pre_date=$cur_date                      #+ 那么就更新最新的.
153                 pre_file=$cur_file
154             fi
155             done
156             echo $pre_file >> $TMP                      #  TMP 现在包含所有
157                                                         #+ 提炼过的列表.
158             # echo "subshell=$BASH_SUBSHELL"
159 
160     }       # 这里的打括号是为了让最后这句"echo $pre_file >> $TMP"
161             # 也能与整个循环一起放到同一个子 shell ( 1 )中.
162 
163     RET=$?  # 取得管道命令的返回码.
164 
165     [ "$RET" -ne 0 ] && {
166         echo "List retrieving failed with code $RET"
167         exit $E_RETURN
168     }
169 
170     echo "done"; echo
171 }
172 
173 # 真正的 rsync 的下载部分.
174 get_file () {
175 
176     echo "Downloading..."
177     /bin/nice /usr/bin/rsync \
178         $OPTS \
179         --filter "merge,+/ $TMP" \
180         --exclude '*'  \
181         $URL $DEST     \
182         | /usr/bin/tee $LOG
183 
184     RET=$?
185 
186         #  --filter merge,+/ is crucial for the intention. 
187         #  + modifier means include and / means absolute path.
188         #  Then sorted list in $TMP will contain ascending dir name and 
189         #+ prevent the following --exclude '*' from "shortcutting the circuit." 
190 
191     echo "Done"
192 
193     rm -f $PID_FILE 2>/dev/null
194 
195     return $RET
196 }
197 
198 # -------
199 # Main
200 init
201 check_pid
202 set_range
203 get_list
204 get_file
205 RET=$?
206 # -------
207 
208 if [ "$RET" -eq 0 ]; then
209     /usr/bin/logger -t ${0##*/} "Fedora update mirrored successfully."
210 else
211     /usr/bin/logger -t ${0##*/} "Fedora update mirrored with failure code: $RET"
212 fi
213 
214 exit $RET
################################End Script#########################################
 使用 rcp, rsync, 和其他一些有安全问题的类似工具, 并将这些工具用在 shell 脚本中
 是不明智的. 应该考虑使用 ssh, scp, 或者一个 expect 脚本来代替这些不安全的工具. 
ssh
 安全 shell, 登陆远端主机并在其上运行命令. 这个工具具有身份认证和加密的功能, 可
 以安全的替换 telnet, rlogin, rcp, 和 rsh 等工具. 参见 man页 来获取详细信息. 
Example 12-40 使用 ssh
################################Start Script#######################################
 1 #!/bin/bash
 2 # remote.bash: 使用 ssh.
 3 
 4 # 这个例子是 Michael Zick 编写的.
 5 # 授权使用.
 6 
 7 
 8 #   假设:
 9 #   -----
10 #   fd-2(文件描述符2) 并没有被抛弃 ( '2>/dev/null' ).
11 #   ssh/sshd 假设 stderr ('2') 将会被显示给用户.
12 #
13 #   sshd 正运行在你的机器上.
14 #   对于大多数 '标准' 的发行版, 是应该有的,
15 #+  并且没有一些稀奇古怪的 ssh-keygen.
16 
17 # 在你的机器上从命令行中试一下 ssh:
18 #
19 # $ ssh $HOSTNAME
20 # 不同特殊的准备, 你将被要求输入你的密码.
21 #   输入密码
22 #   完成后,  $ exit
23 #
24 # 好使了么? 如果好使了, 你可以做好准备来获取更多的乐趣了.
25 
26 # 在你的机器上用 'root'身份来试试 ssh:
27 #
28 #   $  ssh -l root $HOSTNAME
29 #   当询问密码时, 输入 root 的密码, 别输入你的密码.
30 #          Last login: Tue Aug 10 20:25:49 2004 from localhost.localdomain
31 #   完成后键入 'exit'.
32 
33 #  上边的动作将会给你一个交互的shell.
34 #  在 'single command' 模式下建立 sshd 是可能的, <rojy bug>
35 #+ 不过这已经超出本例的范围了.
36 #  唯一需要注意的事情是下面都可以工作在
37 #+ 'single command' 模式.
38 
39 
40 # 一个基本的写输出(本地)命令.
41 
42 ls -l
43 
44 # 现在在远端机器上使用同样的基本命令.
45 # 使用一套不同的 'USERNAME' 和 'HOSTNAME' :
46 USER=${USERNAME:-$(whoami)}
47 HOST=${HOSTNAME:-$(hostname)}
48 
49 #  现在在远端主机上运行上边的命令行命令,
50 #+ 当然, 所有的传输都被加密了.
51 
52 ssh -l ${USER} ${HOST} " ls -l "
53 
54 #  期望的结果就是在远端主机上列出你的
55 #+ username 主目录的所有文件.
56 #  如果想看点不一样的, 那就
57 #+ 在别的地方运行这个脚本, 别再你的主目录上运行这个脚本.
58 
59 #  换句话说, Bash 命令已经作为一个引用行
60 #+ 被传递到远端的shell 中了,这样就可以在远端的机器上运行它了.
61 #  在这种情况下, sshd 代表你运行了 ' bash -c "ls -l" '.
62 
63 #  对于每个命令行如果想不输入密码的话,
64 #+ 对于这种类似的议题, 可以参阅
65 #+    man ssh
66 #+    man ssh-keygen
67 #+    man sshd_config.
68 
69 exit 0
################################End Script######################################### 
 注意: 在循环中, ssh 可能会引起意想不到的异常行为. 根据comp.unix 上的shell文档
   Usenet post , ssh 继承了循环的标准输入.为了解决这个问题, 使用 ssh 的 -n
   或者 -f 选项. 
   感谢 Jason Bechtel, 指出这点. 
scp
 安全拷贝, 在功能上与 rcp 很相似, 就是在2个不同的网络主机之间拷贝文件, 但是要通
 过鉴权的方式, 并且使用与 ssh 类似的安全层. 
Local Network 
write
 这是一个端到端通讯的工具. 这个工具可以从你的终端上(console 或者 xterm)发送整行
 到另一个用户的终端上. mesg 命令当然也可以用来对于一个终端的写权限 
 因为 write 是需要交互的, 所以这个命令通常不使用在脚本中. 
netconfig
 用来配置网络适配器(使用 DHCP)的命令行工具. 这个命令对于红帽发行版来说是内置的.
  
Mail 
mail
 发送或读取 e-mail 消息. 
 如果把这个命令行的 mail 客户端当成一个脚本中的命令来使用的话, 效果非常好. 
Example 12-41 一个可以mail自己的脚本
################################Start Script#######################################
 1 #!/bin/sh
 2 # self-mailer.sh: mail自己的脚本
 3 
 4 adr=${1:-`whoami`}     # 如果不指定的话, 默认是当前用户.
 5 #  键入 'self-mailer.sh wiseguy@superdupergenius.com'
 6 #+ 发送这个脚本到这个地址.
 7 #  如果只键入 'self-mailer.sh' (不给参数) 的话, 那么这脚本就会被发送给
 8 #+ 调用者, 比如 bozo@localhost.localdomain.
 9 #
10 #  如果想了解 ${parameter:-default} 结构的更多细节,
11 #+ 请参见第9章 变量重游中的
12 #+ 第3节 参数替换.
13 
14 # ============================================================================
15   cat $0 | mail -s "Script \"`basename $0`\" has mailed itself to you." "$adr"
16 # ============================================================================
17 
18 # --------------------------------------------
19 #  来自 self-mailing 脚本的一份祝福.
20 #  一个喜欢恶搞的家伙运行了这个脚本,
21 #+ 这导致了他自己收到了这份mail.
22 #  显然的, 有些人确实没什么事好做,
23 #+ 就只能浪费他们自己的时间玩了.
24 # --------------------------------------------
25 
26 echo "At `date`, script \"`basename $0`\" mailed to "$adr"."
27 
28 exit 0
################################End Script######################################### 
mailto
 与 mail 命令很相似, mailto 命令可以使用命令行或在脚本中发送 e-mail 消息. 然而,
 mailto 命令也允许发送 MIME (多媒体) 消息. 
vacation
 这个工具可以自动回复 e-mail 给发送者, 表示邮件的接受者正在度假暂时无法收到邮件.
 这个工具与 sendmail 一起运行于网络上, 并且这个工具不支持拨号的 POPmail 帐号. 
注意事项:
[1]  一个幽灵进程指的是并未附加在终端会话中的后台进程. 幽灵进程 在指定的时间执
  行指定的服务, 或者由特定的事件出发来执行指定的服务. 
12.7 终端控制命令
-----------------
影响控制台或终端的命令 
tput
 初始化终端或者从 terminfo data 中取得终端信息. 不同的选项允许特定的终端操作. 
 tput clear 与下边的 clear 等价. tput reset 与下边的 reset 等价. tput sgr0 也可
 以重置终端, 但是并不清除屏幕. 
  bash$ tput longname
  xterm terminal emulator (XFree86 4.0 Window System) 
 使用 tput cup X Y 将会把光标移动到当前终端的(X,Y)坐标上. 使用这个命令之前一边
 都要先使用一下 clear 命令, 把屏幕清除一下. 
 注意: stty 提供了一个更强力的命令专门用来设置如何控制终端. 
infocmp
 这个命令会打印出大量的当前终端的信息. 事实上它是引用了 terminfo 数据库. 
  bash$ infocmp
  #       通过来自于文件的 infocmp 显示出来:
  /usr/share/terminfo/r/rxvt
  rxvt|rxvt terminal emulator (X Window System), 
    am, bce, eo, km, mir, msgr, xenl, xon, 
    colors#8, cols#80, it#8, lines#24, pairs#64, 
    acsc=``aaffggjjkkllmmnnooppqqrrssttuuvvwwxxyyzz{{||}}~~, 
    bel=^G, blink=\E[5m, bold=\E[1m,
    civis=\E[?25l, 
    clear=\E[H\E[2J, cnorm=\E[?25h, cr=^M, 
    ... 
reset
 重置终端参数并且清除屏幕. 与 clear 命令一样, 光标和提示符将会重新出现在终端的
 左上角. 
clear
 clear 命令只不过是简单的清除控制台或者 xterm 的屏幕. 光标和提示符将会重新出现
 在屏幕或者 xterm window 的左上角. 这个命令既可以用在命令行中也可以用在脚本中. 
 参见 Example 10-25. 
script
 这个工具将会记录(保存到一个文件中)所有的用户在控制台下的或在 xterm window下的
 按键信息. 这其实就是创建了一个会话记录. 
12.8 数学计算命令
-----------------
"Doing the numbers" 
factor
 将一个正数分解为多个素数. 
  bash$ factor 27417
  27417: 3 13 19 37 
bc
 Bash 不能处理浮点运算, 并且缺乏特定的一些操作,这些操作都是一些重要的计算功能.
 幸运的是, bc 可以解决这个问题. 
 bc 不仅仅是个多功能灵活的精确的工具, 而且它还提供许多编程语言才具备的一些方便
 的功能. 
 bc 比较类似于 C 语言的语法. 
 因为它是一个完整的 UNIX 工具, 所以它可以用在管道中, bc 在脚本中也是很常用的. 
 这里有一个简单的使用 bc 命令的模版可以用来在计算脚本中的变量. 用在命令替换中. 
     variable=$(echo "OPTIONS; OPERATIONS" | bc) 
Example 12-42 按月偿还贷款
################################Start Script#######################################
 1 #!/bin/bash
 2 # monthlypmt.sh: 计算按月偿还贷款的数量.
 3 
 4 
 5 #  这份代码是一份修改版本, 原始版本在 "mcalc" (贷款计算)包中,
 6 #+ 这个包的作者是 Jeff Schmidt 和 Mendel Cooper (本书作者).
 7 #   http://www.ibiblio.org/pub/Linux/apps/financial/mcalc-1.6.tar.gz  [15k]
 8 
 9 echo
10 echo "Given the principal, interest rate, and term of a mortgage,"
11 echo "calculate the monthly payment."
12 
13 bottom=1.0
14 
15 echo
16 echo -n "Enter principal (no commas) "
17 read principal
18 echo -n "Enter interest rate (percent) "  # 如果是 12%, 那就键入 "12", 别输入 ".12".
19 read interest_r
20 echo -n "Enter term (months) "
21 read term
22 
23 
24  interest_r=$(echo "scale=9; $interest_r/100.0" | bc) # 转换成小数.
25                  # "scale" 指定了有效数字的个数.
26   
27 
28  interest_rate=$(echo "scale=9; $interest_r/12 + 1.0" | bc)
29  
30 
31  top=$(echo "scale=9; $principal*$interest_rate^$term" | bc)
32 
33  echo; echo "Please be patient. This may take a while."
34 
35  let "months = $term - 1"
36 # ==================================================================== 
37  for ((x=$months; x > 0; x--))
38  do
39    bot=$(echo "scale=9; $interest_rate^$x" | bc)
40    bottom=$(echo "scale=9; $bottom+$bot" | bc)
41 #  bottom = $(($bottom + $bot"))
42  done
43 # ==================================================================== 
44 
45 # -------------------------------------------------------------------- 
46 #  Rick Boivie 给出了一个对上边循环的修改,
47 #+ 这个修改更加有效率, 将会节省大概 2/3 的时间.
48 
49 # for ((x=1; x <= $months; x++))
50 # do
51 #   bottom=$(echo "scale=9; $bottom * $interest_rate + 1" | bc)
52 # done
53 
54 
55 #  然后他又想出了一个更加有效率的版本,
56 #+ 将会节省 95% 的时间!
57 
58 # bottom=`{
59 #     echo "scale=9; bottom=$bottom; interest_rate=$interest_rate"
60 #     for ((x=1; x <= $months; x++))
61 #     do
62 #          echo 'bottom = bottom * interest_rate + 1'
63 #     done
64 #     echo 'bottom'
65 #     } | bc`       # 在命令替换中嵌入一个 'for 循环'.
66 # --------------------------------------------------------------------------
67 #  On the other hand, Frank Wang suggests:
68 #  bottom=$(echo "scale=9; ($interest_rate^$term-1)/($interest_rate-1)" | bc)
69 
70 #  因为 . . .
71 #  在循环后边的算法
72 #+ 事实上是一个等比数列的求和公式.
73 #  求和公式是 e0(1-q^n)/(1-q),
74 #+ e0 是第一个元素 并且 q=e(n+1)/e(n)
75 #+ 和 n 是元素的数量.
76 # --------------------------------------------------------------------------
77 
78 
79  # let "payment = $top/$bottom"
80  payment=$(echo "scale=2; $top/$bottom" | bc)
81  # 使用2位有效数字来表示美元和美分.
82  
83  echo
84  echo "monthly payment = \$$payment"  # 在总和的前边显示美元符号.
85  echo
86 
87 
88  exit 0
89 
90 
91  # 练习:
92  #   1) 处理输入允许本金总数中的逗号.
93  #   2) 处理输入允许按照百分号和小数点的形式输入利率.
94  #   3) 如果你真正想好好编写这个脚本,
95  #      那么就扩展这个脚本让它能够打印出完整的分期付款表.
################################End Script######################################### 
Example 12-43 数制转换
################################Start Script#######################################
  1 #!/bin/bash
  2 ##########################################################################
  3 # 脚本       : base.sh - 用不同的数值来打印数字 (Bourne Shell)
  4 # 作者       : Heiner Steven (heiner.steven@odn.de)
  5 # 日期       : 07-03-95
  6 # 类型       : 桌面
  7 # $Id: base.sh,v 1.2 2000/02/06 19:55:35 heiner Exp $
  8 # ==> 上边这行是 RCS ID 信息.
  9 ##########################################################################
 10 # 描述
 11 #
 12 # Changes
 13 # 21-03-95 stv fixed error occuring with 0xb as input (0.2)
 14 ##########################################################################
 15 
 16 # ==> 在本书中使用这个脚本通过了作者的授权.
 17 # ==> 注释是本书作者添加的.
 18 
 19 NOARGS=65
 20 PN=`basename "$0"`          # 程序名
 21 VER=`echo '$Revision: 1.2 $' | cut -d' ' -f2`  # ==> VER=1.2
 22 
 23 Usage () {
 24     echo "$PN - print number to different bases, $VER (stv '95)
 25 usage: $PN [number ...]
 26 
 27 If no number is given, the numbers are read from standard input.
 28 A number may be
 29     binary (base 2)  starting with 0b (i.e. 0b1100)
 30     octal (base 8)  starting with 0  (i.e. 014)
 31     hexadecimal (base 16) starting with 0x (i.e. 0xc)
 32     decimal   otherwise (i.e. 12)" >&2
 33     exit $NOARGS 
 34 }   # ==> 打印出用法信息的函数.
 35 
 36 Msg () {
 37     for i   # ==> 省略 [list] .
 38     do echo "$PN: $i" >&2
 39     done
 40 }
 41 
 42 Fatal () { Msg "$@"; exit 66; }
 43 
 44 PrintBases () {
 45     # 决定数值的数制
 46     for i      # ==> 省略 [list]...
 47     do         # ==> 所以是对命令行参数进行操作.
 48  case "$i" in
 49      0b*)  ibase=2;; # 2进制
 50      0x*|[a-f]*|[A-F]*) ibase=16;; # 16进制
 51      0*)   ibase=8;; # 8进制
 52      [1-9]*)  ibase=10;; # 10进制
 53      *)
 54   Msg "illegal number $i - ignored"
 55   continue;;
 56  esac
 57 
 58  # 去掉前缀, 将16进制数字转换为大写(bc需要大写)
 59  number=`echo "$i" | sed -e 's:^0[bBxX]::' | tr '[a-f]' '[A-F]'`
 60  # ==>使用":" 作为sed分隔符, 而不使用"/".
 61 
 62  # 将数字转换为10进制
 63  dec=`echo "ibase=$ibase; $number" | bc`  # ==> 'bc' 是个计算工具.
 64  case "$dec" in
 65      [0-9]*) ;;    # 数字没问题
 66      *)  continue;;   # 错误: 忽略
 67  esac
 68 
 69  # 在一行上打印所有的转换后的数字.
 70  # ==> 'here document' 提供命令列表给'bc'.
 71  echo `bc <<!
 72      obase=16; "hex="; $dec
 73      obase=10; "dec="; $dec
 74      obase=8;  "oct="; $dec
 75      obase=2;  "bin="; $dec
 76 !
 77     ` | sed -e 's: : :g'
 78 
 79     done
 80 }
 81 
 82 while [ $# -gt 0 ]
 83 # ==>  这里必须使用一个 "while 循环",
 84 # ==>+ 因为所有的 case 都可能退出循环或者
 85 # ==>+ 结束脚本.
 86 # ==> (感谢, Paulo Marcel Coelho Aragao.)
 87 do
 88     case "$1" in
 89  --)     shift; break;;
 90  -h)     Usage;;                 # ==> 帮助信息.
 91  -*)     Usage;;
 92          *)     break;;   # 第一个数字
 93     esac   # ==> 对于非法输入更严格检查是非常有用的.
 94     shift
 95 done
 96 
 97 if [ $# -gt 0 ]
 98 then
 99     PrintBases "$@"
100 else     # 从标准输入中读取
101     while read line
102     do
103  PrintBases $line
104     done
105 fi
106 
107 
108 exit 0
################################End Script#########################################
 调用 bc 的另一种可选的方法就是使用 here document ,并把它嵌入到 命令替换 块中.
 当一个脚本需要将一个选项列表和多个命令传递到 bc 中时, 这种方法就显得非常合适. 
    1 variable=`bc << LIMIT_STRING
    2 options
    3 statements
    4 operations
    5 LIMIT_STRING
    6 `
    7 
    8 ...or...
    9 
   10 
   11 variable=$(bc << LIMIT_STRING
   12 options
   13 statements
   14 operations
   15 LIMIT_STRING
   16 ) 
Example 12-44 使用 "here document" 来调用 bc
################################Start Script#######################################
 1 #!/bin/bash
 2 # 使用命令替换来调用 'bc' 
 3 # 并与 'here document' 相结合.
 4 
 5 
 6 var1=`bc << EOF
 7 18.33 * 19.78
 8 EOF
 9 `
10 echo $var1       # 362.56
11 
12 
13 #  $( ... ) 这种标记法也可以.
14 v1=23.53
15 v2=17.881
16 v3=83.501
17 v4=171.63
18 
19 var2=$(bc << EOF
20 scale = 4
21 a = ( $v1 + $v2 )
22 b = ( $v3 * $v4 )
23 a * b + 15.35
24 EOF
25 )
26 echo $var2       # 593487.8452
27 
28 
29 var3=$(bc -l << EOF
30 scale = 9
31 s ( 1.7 )
32 EOF
33 )
34 # 返回弧度为1.7的正弦.
35 # "-l" 选项将会调用 'bc' 算数库.
36 echo $var3       # .991664810
37 
38 
39 # 现在, 在函数中试一下...
40 hyp=             # 声明全局变量.
41 hypotenuse ()    # 计算直角三角形的斜边.
42 {
43 hyp=$(bc -l << EOF
44 scale = 9
45 sqrt ( $1 * $1 + $2 * $2 )
46 EOF
47 )
48 # 不幸的是, 不能从bash 函数中返回浮点值.
49 }
50 
51 hypotenuse 3.68 7.31
52 echo "hypotenuse = $hyp"    # 8.184039344
53 
54 
55 exit 0
################################End Script######################################### 
Example 12-45 计算圆周率
################################Start Script#######################################
  1 #!/bin/bash
  2 # cannon.sh: 通过开炮来取得近似的圆周率值.
  3 
  4 # 这事实上是一个"Monte Carlo"蒙特卡洛模拟的非常简单的实例:
  5 #+ 蒙特卡洛模拟是一种由现实事件抽象出来的数学模型,
  6 #+ 由于要使用随机抽样统计来估算数学函数, 所以使用伪随机数来模拟真正的随机.
  7 
  8 #  想象有一个完美的正方形土地, 边长为10000个单位.
  9 #  在这块土地的中间有一个完美的圆形湖,
 10 #+ 这个湖的直径是10000个单位.
 11 #  这块土地的绝大多数面积都是水, 当然只有4个角上有一些土地.
 12 #  (可以把这个湖想象成为使这个正方形的内接圆.)
 13 #
 14 #  我们将使用老式的大炮和铁炮弹
 15 #+ 向这块正方形的土地上开炮.
 16 #  所有的炮弹都会击中这块正方形土地的某个地方.
 17 #+ 或者是打到湖上, 或者是打到4个角的土地上.
 18 #  因为这个湖占据了这个区域大部分地方,
 19 #+ 所以大部分的炮弹都会"扑通"一声落到水里.
 20 #  而只有很少的炮弹会"砰"的一声落到4个
 21 #+ 角的土地上.
 22 #
 23 #  如果我们发出的炮弹足够随机的落到这块正方形区域中的话,
 24 #+ 那么落到水里的炮弹与打出炮弹的总数的比率,
 25 #+ 大概非常接近于 PI/4.
 26 #
 27 #  原因是所有的炮弹事实上都
 28 #+ 打在了这个土地的右上角,
 29 #+ 也就是, 笛卡尔坐标系的第一象限.
 30 #  (之前的解释只是一个简化.)
 31 #
 32 #  理论上来说, 如果打出的炮弹越多, 就越接近这个数字.
 33 #  然而, 对于shell 脚本来说一定会作些让步的,
 34 #+ 因为它肯定不能和那些内建就支持浮点运算的编译语言相比.
 35 #  当然就会降低精度.
 36 
 37 
 38 DIMENSION=10000  # 这块土地的边长.
 39                  # 这也是所产生的随机整数的上限.
 40 
 41 MAXSHOTS=1000    # 开炮次数.
 42                  # 10000 或更多次的话, 效果应该更好, 但有点太浪费时间了.
 43 PMULTIPLIER=4.0  # 接近于 PI 的比例因子.
 44 
 45 get_random ()
 46 {
 47 SEED=$(head -1 /dev/urandom | od -N 1 | awk '{ print $2 }')
 48 RANDOM=$SEED                                  #  来自于 "seeding-random.sh"
 49                                               #+ 的例子脚本.
 50 let "rnum = $RANDOM % $DIMENSION"             #  范围小于 10000.
 51 echo $rnum
 52 }
 53 
 54 distance=        # 声明全局变量.
 55 hypotenuse ()    # 从 "alt-bc.sh" 例子来的,
 56 {                # 计算直角三角形的斜边的函数.
 57 distance=$(bc -l << EOF
 58 scale = 0
 59 sqrt ( $1 * $1 + $2 * $2 )
 60 EOF
 61 )
 62 #  设置 "scale" 为 0 , 好让结果四舍五入为整数值,
 63 #+ 这是这个脚本中必须折中的一个地方.
 64 #  不幸的是, 这将降低模拟的精度.
 65 }
 66 
 67 
 68 # main() {
 69 
 70 # 初始化变量.
 71 shots=0
 72 splashes=0
 73 thuds=0
 74 Pi=0
 75 
 76 while [ "$shots" -lt  "$MAXSHOTS" ]           # 主循环.
 77 do
 78 
 79   xCoord=$(get_random)                        # 取得随机的 X 与 Y 坐标.
 80   yCoord=$(get_random)
 81   hypotenuse $xCoord $yCoord                  #  直角三角形斜边 =
 82                                               #+ distance.
 83   ((shots++))
 84 
 85   printf "#%4d   " $shots
 86   printf "Xc = %4d  " $xCoord
 87   printf "Yc = %4d  " $yCoord
 88   printf "Distance = %5d  " $distance         #  到湖中心的
 89                                               #+ 距离 --
 90                                               #  起始坐标点 --
 91                                               #+  (0,0).
 92 
 93   if [ "$distance" -le "$DIMENSION" ]
 94   then
 95     echo -n "SPLASH!  "
 96     ((splashes++))
 97   else
 98     echo -n "THUD!    "
 99     ((thuds++))
100   fi
101 
102   Pi=$(echo "scale=9; $PMULTIPLIER*$splashes/$shots" | bc)
103   # 将比例乘以 4.0.
104   echo -n "PI ~ $Pi"
105   echo
106 
107 done
108 
109 echo
110 echo "After $shots shots, PI looks like approximately $Pi."
111 # 如果不太准的话, 那么就提高一下运行的次数. . .
112 # 可能是由于运行错误和随机数随机程度不高造成的.
113 echo
114 
115 # }
116 
117 exit 0
118 
119 #  要想知道一个shell脚本到底适不适合作为
120 #+ 一种需要对复杂和精度都有要求的计算应用的模拟的话.
121 #
122 #  一般至少需要两个判断条件.
123 #  1) 作为一种概念的验证: 来显示它可以做到.
124 #  2) 在使用真正的编译语言来实现一个算法之前,
125 #+    使用脚本来测试和验证这个算法.
################################End Script######################################### 
dc
 dc (桌面计算器desk calculator) 工具是面向栈的并且使用 RPN (逆波兰表达式 
 "Reverse Polish Notation" 又叫"后缀表达式"). 与 bc 命令很相像 , 但是这个工具
 具备好多只有编程语言才具备的能力. 
 (译者注: 正常表达式  逆波兰表达式
    a+b    a,b,+
    a+(b-c)   a,b,c,-,+
    a+(b-c)*d  a,d,b,c,-,*,+
 ) 
    绝大多数人都避免使用这个工具, 因为它需要非直觉的 RPN 输入. 但是, 它却有特定的
 用途. 
Example 12-46 将10进制数字转换为16进制数字
################################Start Script#######################################
 1 #!/bin/bash
 2 # hexconvert.sh: 将10进制数字转换为16进制数字
 3 
 4 E_NOARGS=65 # 缺命令行参数错误.
 5 BASE=16     # 16进制.
 6 
 7 if [ -z "$1" ]
 8 then
 9   echo "Usage: $0 number"
10   exit $E_NOARGS
11   # 需要一个命令行参数.
12 fi
13 # 练习: 添加命令行参数检查.
14 
15 
16 hexcvt ()
17 {
18 if [ -z "$1" ]
19 then
20   echo 0
21   return    # 如果没有参数传递到这个函数中就 "return" 0.
22 fi
23 
24 echo ""$1" "$BASE" o p" | dc
25 #                 "o" 设置输出的基数(数制).
26 #                   "p" 打印栈顶.
27 # 察看 dc 的 man 页来了解其他的选项.
28 return
29 }
30 
31 hexcvt "$1"
32 
33 exit 0
################################End Script#########################################
 通过仔细学习 dc 命令的 info 页, 可以更深入的理解这个复杂的命令. 但是, 有一些
 精通 dc巫术 的小组经常会炫耀他们使用这个强大而又晦涩难懂的工具时的一些技巧, 
 并以此为乐. 
  bash$ echo "16i[q]sa[ln0=aln100%Pln100/snlbx]sbA0D68736142snlbxq" | dc"
  Bash 
Example 12-47 因子分解
################################Start Script#######################################
 1 #!/bin/bash
 2 # factr.sh: 分解约数
 3 
 4 MIN=2       # 如果比这个数小就不行了.
 5 E_NOARGS=65
 6 E_TOOSMALL=66
 7 
 8 if [ -z $1 ]
 9 then
10   echo "Usage: $0 number"
11   exit $E_NOARGS
12 fi
13 
14 if [ "$1" -lt "$MIN" ]
15 then
16   echo "Number to factor must be $MIN or greater."
17   exit $E_TOOSMALL
18 fi  
19 
20 # 练习: 添加类型检查 (防止非整型的参数).
21 
22 echo "Factors of $1:"
23 # ---------------------------------------------------------------------------------
24 echo "$1[p]s2[lip/dli%0=1dvsr]s12sid2%0=13sidvsr[dli%0=1lrli2+dsi!>.]ds.xd1<2" | dc
25 # ---------------------------------------------------------------------------------
26 # 上边这行代码是 Michel Charpentier 编写的<charpov@cs.unh.edu>.
27 # 在此使用经过授权 (thanks).
28 
29  exit 0
################################End Script######################################### 
awk
 在脚本中使用浮点运算的另一种方法是使用 awk  内建的数学运算函数, 可以用在shell 
 wrapper中. 
Example 12-48 计算直角三角形的斜边
################################Start Script#######################################
 1 #!/bin/bash
 2 # hypotenuse.sh: 返回直角三角形的斜边.
 3 #               ( 直角边长的平方和,然后对和取平方根)
 4 
 5 ARGS=2                # 需要将2个直角边作为参数传递进来.
 6 E_BADARGS=65          # 错误的参数值.
 7 
 8 if [ $# -ne "$ARGS" ] # 测试传递到脚本中的参数值.
 9 then
10   echo "Usage: `basename $0` side_1 side_2"
11   exit $E_BADARGS
12 fi
13 
14 
15 AWKSCRIPT=' { printf( "%3.7f\n", sqrt($1*$1 + $2*$2) ) } '
16 #              命令 / 传递给awk的参数
17 
18 
19 # 现在, 将参数通过管道传递给awk.
20 echo -n "Hypotenuse of $1 and $2 = "
21 echo $1 $2 | awk "$AWKSCRIPT"
22 
23 exit 0
################################End Script######################################### 
12.9 混杂命令
-------------
一些不好归类的命令 
jot, seq
 这些工具通过用户指定的范围和增量来产生一系列的整数.
 每个产生出来的整数一般都占一行, 但是可以使用 -s 选项来改变这种设置. 
  bash$ seq 5
  1
  2
  3
  4
  5
  
  
  
  bash$ seq -s : 5
  1:2:3:4:5 
 jot 和 seq  命令都经常用在 for 循环中. 
Example 12-49 使用 seq 来产生循环参数
################################Start Script#######################################
 1 #!/bin/bash
 2 # 使用 "seq"
 3 
 4 echo
 5 
 6 for a in `seq 80`  # 或者   for a in $( seq 80 )
 7 # 与  " for a in 1 2 3 4 5 ... 80 "相同  (少敲了好多字!).
 8 # 也可以使用 'jot' (如果系统上有的话).
 9 do
10   echo -n "$a "
11 done      # 1 2 3 4 5 ... 80
12 # 这也是一个通过使用命令的输出
13 # 来产生 "for"循环中 [list] 列表的例子.
14 
15 echo; echo
16 
17 
18 COUNT=80  # 当然, 'seq' 也可以使用一个可替换的参数.
19 
20 for a in `seq $COUNT`  # 或者   for a in $( seq $COUNT )
21 do
22   echo -n "$a "
23 done      # 1 2 3 4 5 ... 80
24 
25 echo; echo
26 
27 BEGIN=75
28 END=80
29 
30 for a in `seq $BEGIN $END`
31 #  传给 "seq" 两个参数, 从第一个参数开始增长,
32 #+ 一直增长到第二个参数为止.
33 do
34   echo -n "$a "
35 done      # 75 76 77 78 79 80
36 
37 echo; echo
38 
39 BEGIN=45
40 INTERVAL=5
41 END=80
42 
43 for a in `seq $BEGIN $INTERVAL $END`
44 #  传给 "seq" 三个参数从第一个参数开始增长,
45 #+ 并以第二个参数作为增量,
46 #+ 一直增长到第三个参数为止.
47 do
48   echo -n "$a "
49 done      # 45 50 55 60 65 70 75 80
50 
51 echo; echo
52 
53 exit 0
################################End Script######################################### 
 一个简单些的例子:
  1 #  产生10个连续扩展名的文件,
  2 #+ 名字分别是 file.1, file.2 . . . file.10.
  3 COUNT=10
  4 PREFIX=file
  5 
  6 for filename in `seq $COUNT`
  7 do
  8   touch $PREFIX.$filename
  9   #  或者, 你可以做一些其他的操作,
 10   #+ 比如 rm, grep, 等等.
 11 done 
Example 12-50 字母统计
################################Start Script#######################################
 1 #!/bin/bash
 2 # letter-count.sh: 统计一个文本文件中字母出现的次数.
 3 # 由 Stefano Palmeri 编写.
 4 # 经过授权使用在本书中.
 5 # 本书作者做了少许修改.
 6 
 7 MINARGS=2          # 本脚本至少需要2个参数.
 8 E_BADARGS=65
 9 FILE=$1
10 
11 let LETTERS=$#-1   # 制定了多少个字母 (作为命令行参数).
12                    # (从命令行参数的个数中减1.)
13 
14 
15 show_help(){
16     echo
17            echo Usage: `basename $0` file letters  
18            echo Note: `basename $0` arguments are case sensitive.
19            echo Example: `basename $0` foobar.txt G n U L i N U x.
20     echo
21 }
22 
23 # 检查参数个数.
24 if [ $# -lt $MINARGS ]; then
25    echo
26    echo "Not enough arguments."
27    echo
28    show_help
29    exit $E_BADARGS
30 fi  
31 
32 
33 # 检查文件是否存在.
34 if [ ! -f $FILE ]; then
35     echo "File \"$FILE\" does not exist."
36     exit $E_BADARGS
37 fi
38 
39 
40 
41 # 统计字母出现的次数.
42 for n in `seq $LETTERS`; do
43       shift
44       if [[ `echo -n "$1" | wc -c` -eq 1 ]]; then             #  检查参数.
45              echo "$1" -\> `cat $FILE | tr -cd  "$1" | wc -c` #  统计.
46       else
47              echo "$1 is not a  single char."
48       fi  
49 done
50 
51 exit $?
52 
53 #  这个脚本在功能上与 letter-count2.sh 完全相同,
54 #+ 但是运行得更快.
55 #  为什么?
################################End Script######################################### 
getopt
 getopt 命令将会分析以破折号开头的命令行选项. 这个外部命令与Bash的内建命令 
 getopts 作用相同. 通过使用 -l 标志, getopt 可以处理长(多字符)选项, 并且也允许参
 数重置. 
Example 12-51 使用getopt来分析命令行选项
################################Start Script#######################################
 1 #!/bin/bash
 2 # 使用 getopt.
 3 
 4 # 尝试使用下边的不同的方法来调用这脚本:
 5 #   sh ex33a.sh -a
 6 #   sh ex33a.sh -abc
 7 #   sh ex33a.sh -a -b -c
 8 #   sh ex33a.sh -d
 9 #   sh ex33a.sh -dXYZ
10 #   sh ex33a.sh -d XYZ
11 #   sh ex33a.sh -abcd
12 #   sh ex33a.sh -abcdZ
13 #   sh ex33a.sh -z
14 #   sh ex33a.sh a
15 # 解释上面每一次调用的结果.
16 
17 E_OPTERR=65
18 
19 if [ "$#" -eq 0 ]
20 then   # 脚本需要至少一个命令行参数.
21   echo "Usage $0 -[options a,b,c]"
22   exit $E_OPTERR
23 fi  
24 
25 set -- `getopt "abcd:" "$@"`
26 # 为命令行参数设置位置参数.
27 # 如果使用 "$*" 来代替 "$@" 的话会发生什么?
28 
29 while [ ! -z "$1" ]
30 do
31   case "$1" in
32     -a) echo "Option \"a\"";;
33     -b) echo "Option \"b\"";;
34     -c) echo "Option \"c\"";;
35     -d) echo "Option \"d\" $2";;
36      *) break;;
37   esac
38 
39   shift
40 done
41 
42 #  通常来说在脚本中使用内建的 'getopts' 命令,
43 #+ 会比使用 'getopt' 好一些.
44 #  参见 "ex33.sh".
45 
46 exit 0
################################End Script#########################################
 参见 Example 9-12 , 这是对 getopt 命令的一个简单模拟. 
run-parts
 run-parts 命令 [1] 将会执行目标目录中所有的脚本, 这些将本会以 ASCII 的循序进行
 排列. 当然, 这些脚本都需要具有可执行权限. 
 cron 幽灵进程 会调用 run-parts 来运行 /etc/cron.* 下的所有脚本. 
yes
 yes 命令的默认行为是向 stdout 中连续不断的输出字符 y,每个y占一行.使用control-c
 来结束运行. 如果想换一个输出字符的话, 可以使用 yes 其他的字符串, 这样就会连续
 不同的输出你指定的字符串. 那么这样的命令究竟能做什么呢? 在命令行或者脚本中, 
 yes的输出可以通过重定向或管道来传递给一些需要用户输入进行交互的命令. 事实上, 
 这个命令可以说是 expect 命令(译者注: 这个命令本书未介绍, 一个自动实现交互的命
 令)的一个简化版本. 
 yes | fsck /dev/hda1 将会以非交互的形式运行fsck(因为需要用户输入的 y 全由yes
 命令搞定了)(小心使用!). 
 yes | rm -r dirname 与 rm -rf dirname 效果相同(小心使用!). 
 注意: 当用 yes 的管道形式来使用一些可能具有潜在危险的系统命令的时候一定要深思
  熟虑, 比如 fsck 或 fdisk. 可能会产生一些意外的副作用. 
banner
 将会把字符串用一个 ASCII 字符(默认是 '#')来画出来(就是将多个'#'拼出一副字符的
 图形).可以作为硬拷贝重定向到打印机上(译者注: 可以使用-w 选项设置宽度). 
printenv
 对于某个特定的用户, 显示出所有的 环境变量. 
  bash$ printenv | grep HOME
  HOME=/home/bozo 
lp
 lp 和 lpr 命令将会把文件发送到打印队列中, 并且作为硬拷贝来打印. [2] 这些命令
 会纪录它们名字的起始位置并传递到行打印机的另一个位置.<rojy bug> 
 bash$ lp file1.txt 或者 bash lp <file1.txt 
 通常情况下都是将pr的格式化的输出传递到 lp. 
 bash$ pr -options file1.txt | lp 
 格式化的包, 比如 groff 和 Ghostscript 就可以将它们的输出直接发送给 lp. 
 bash$ groff -Tascii file.tr | lp 
 bash$ gs -options | lp file.ps 
 还有一些相关的命令, 比如 lpq, 可以查看打印队列, lprm, 可以用来从打印队列中删
 除作业. 
tee
 [UNIX 从管道行业借来的主意.] 
 这是一个重定向操作, 但是有些不同. 就像管道中的"三通"一样, 这个命令可以将命令或
 者管道命令的输出抽出到一个文件中,而且并不影响结果. 当你想将一个正在运行的进程
 的输出保存到文件中时, 或者为了debug而保存输出记录的时候, 这个命令就非常有用了. 
                              (重定向)
                             |----> to file
                             |
   ==========================|====================
   command ---> command ---> |tee ---> command ---> ---> output of pipe
   =============================================== 
   1 cat listfile* | sort | tee check.file | uniq > result.file
 (在对排序的结果进行 uniq (去掉重复行) 之前,文件 check.file 中保存了排过序的
 "listfiles".) 
mkfifo
 这个不大引人注意的命令可以创建一个命名管道, 并产生一个临时的先进先出的buffer
 用来在两个进程间传输数据. [3] 典型的使用是一个进程向FIFO中写数据, 另一个进程读
 出来. 参见 Example A-15. 
pathchk
 这个命令用来检查文件名的有效性. 如果文件名超过了最大允许长度(255 个字符), 或者
 它所在的一个或多个路径搜索不到, 那么就会产生一个错误结果. 
 不幸的是,并不能够返回一个可识别的错误码, 因此它在脚本中几乎没有什么用. 一般都
 使用文件测试操作. 
dd
 这也是一个不太出名的工具, 但却是一个令人恐惧的 "数据复制" 命令. 最开始, 这个命
 令是被用来在UNIX 微机和IBM大型机之间通过磁带来交换数据, 这个命令现在仍然有它的
 用途. dd 命令只不过是简单的拷贝一个文件 (或者 stdin/stdout), 但是它会做一些转
 换. 下边是一些可能的转换, 比如 ASCII/EBCDIC, [4]  大写/小写, 在输入和输出之间
 的字节对的交换, 还有对输入文件做一些截头去尾的工作. dd --help  列出了所有转换,
 还有这个强力工具的一些其他选项. 
    1 # 将一个文件转换为大写:
    2 
    3 dd if=$filename conv=ucase > $filename.uppercase
    4 #                    lcase   # 转换为小写 
Example 12-52 一个拷贝自身的脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 # self-copy.sh
 3 
 4 # 这个脚本将会拷贝自身.
 5 
 6 file_subscript=copy
 7 
 8 dd if=$0 of=$0.$file_subscript 2>/dev/null
 9 # 阻止dd产生的消息:            ^^^^^^^^^^^
10 
11 exit $?
################################End Script######################################### 
Example 12-53 练习dd
################################Start Script#######################################
 1 #!/bin/bash
 2 # exercising-dd.sh
 3 
 4 # 由Stephane Chazelas编写.
 5 # 本文作者做了少量修改.
 6 
 7 input_file=$0   # 脚本本身.
 8 output_file=log.txt
 9 n=3
10 p=5
11 
12 dd if=$input_file of=$output_file bs=1 skip=$((n-1)) count=$((p-n+1)) 2> /dev/null
13 # 从脚本中把位置n到p的字符提取出来.
14 
15 # -------------------------------------------------------
16 
17 echo -n "hello world" | dd cbs=1 conv=unblock 2> /dev/null
18 # 垂直的 echo "hello world" .
19 
20 exit 0
################################End Script#########################################
 为了展示dd的多种用途, 让我们使用它来记录按键. 
Example 12-54 记录按键
################################Start Script#######################################
 1 #!/bin/bash
 2 # dd-keypress.sh: 记录按键, 不需要按回车.
 3 
 4 
 5 keypresses=4                      # 记录按键的个数.
 6 
 7 
 8 old_tty_setting=$(stty -g)        # 保存老的终端设置.
 9 
10 echo "Press $keypresses keys."
11 stty -icanon -echo                # 禁用标准模式.
12                                   # 禁用本地 echo.
13 keys=$(dd bs=1 count=$keypresses 2> /dev/null)
14 # 如果不指定输入文件的话, 'dd' 使用标准输入.
15 
16 stty "$old_tty_setting"           # 恢复老的终端设置.
17 
18 echo "You pressed the \"$keys\" keys."
19 
20 # 感谢 Stephane Chazelas, 演示了这种方法.
21 exit 0
################################End Script#########################################
 dd 命令可以在数据流上做随即存取. 
    1 echo -n . | dd bs=1 seek=4 of=file conv=notrunc
    2 # "conv=notrunc" 选项意味着输出文件不能被截短.
    3 
    4 # Thanks, S.C. 
 dd 命令可以将数据或磁盘镜像拷贝到设备中, 也可以从设备中拷贝数据或磁盘镜像, 比
 如说磁盘或磁带设备都可以 (Example A-5). 通常用来创建启动盘. 
 dd if=kernel-image of=/dev/fd0H1440 
 同样的, dd 可以拷贝软盘的整个内容(甚至是其他操作系统的磁盘格式) 到硬盘驱动器上
 (以镜像文件的形式). 
 dd if=/dev/fd0 of=/home/bozo/projects/floppy.img 
 dd 命令还有一些其他用途, 包括可以初始化临时交换文件 (Example 28-2) 和 ramdisks
 (内存虚拟硬盘) (Example 28-3). 它甚至可以做一些对整个硬盘分区的底层拷贝, 虽然
 不建议这么做. 
 一些(可能是比较无聊的)人总会想一些关于 dd 命令的有趣的应用. 
Example 12-55 安全的删除一个文件
################################Start Script#######################################
 1 #!/bin/bash
 2 # blot-out.sh: 删除一个文件所有的记录.
 3 
 4 #  这个脚本会使用随即字节交替的覆盖
 5 #+ 目标文件, 并且在最终删除这个文件之前清零.
 6 #  这么做之后, 即使你通过传统手段来检查磁盘扇区
 7 #+ 也不能把文件原始数据重新恢复.
 8 
 9 PASSES=7         #  破坏文件的次数.
10                  #  提高这个数字会减慢脚本运行的速度,
11                  #+ 尤其是对尺寸比较大的目标文件进行操作的时候.
12 BLOCKSIZE=1      #  带有 /dev/urandom 的 I/O 需要单位块尺寸,
13                  #+ 否则你可能会获得奇怪的结果.
14 E_BADARGS=70     #  不同的错误退出码.
15 E_NOT_FOUND=71
16 E_CHANGED_MIND=72
17 
18 if [ -z "$1" ]   # 没指定文件名.
19 then
20   echo "Usage: `basename $0` filename"
21   exit $E_BADARGS
22 fi
23 
24 file=$1
25 
26 if [ ! -e "$file" ]
27 then
28   echo "File \"$file\" not found."
29   exit $E_NOT_FOUND
30 fi  
31 
32 echo; echo -n "Are you absolutely sure you want to blot out \"$file\" (y/n)? "
33 read answer
34 case "$answer" in
35 [nN]) echo "Changed your mind, huh?"
36       exit $E_CHANGED_MIND
37       ;;
38 *)    echo "Blotting out file \"$file\".";;
39 esac
40 
41 
42 flength=$(ls -l "$file" | awk '{print $5}')  # 5 是文件长度.
43 pass_count=1
44 
45 chmod u+w "$file"   # Allow overwriting/deleting the file.
46 
47 echo
48 
49 while [ "$pass_count" -le "$PASSES" ]
50 do
51   echo "Pass #$pass_count"
52   sync         # 刷新buffer.
53   dd if=/dev/urandom of=$file bs=$BLOCKSIZE count=$flength
54                # 使用随机字节进行填充.
55   sync         # 再刷新buffer.
56   dd if=/dev/zero of=$file bs=$BLOCKSIZE count=$flength
57                # 用0填充.
58   sync         # 再刷新buffer.
59   let "pass_count += 1"
60   echo
61 done  
62 
63 
64 rm -f $file    # 最后, 删除这个已经被破坏得不成样子的文件.
65 sync           # 最后一次刷新buffer.
66 
67 echo "File \"$file\" blotted out and deleted."; echo
68 
69 
70 exit 0
71 
72 #  这是一种真正安全的删除文件的办法,
73 #+ 但是效率比较低, 运行比较慢.
74 #  GNU 的文件工具包中的 "shred" 命令,
75 #+ 也可以完成相同的工作, 不过更有效率.
76 
77 #  使用普通的方法是不可能重新恢复这个文件了.
78 #  然而 . . .
79 #+ 这个简单的例子是不能够抵抗
80 #+ 那些经验丰富并且正规的分析.
81 
82 #  这个脚本可能不会很好的运行在日志文件系统上.(译者注: JFS)
83 #  练习 (很难): 像它做的那样修正这个问题.
84 
85 
86 
87 #  Tom Vier的文件删除包可以更加彻底
88 #+ 的删除文件, 比这个简单的例子厉害得多.
89 #     http://www.ibiblio.org/pub/Linux/utils/file/wipe-2.0.0.tar.bz2
90 
91 #  如果想对安全删除文件这一论题进行深度的分析,
92 #+ 可以参见Peter Gutmann的页面,
93 #+     "Secure Deletion of Data From Magnetic and Solid-State Memory".
94 #       http://www.cs.auckland.ac.nz/~pgut001/pubs/secure_del.html
################################End Script######################################### 
od
 od(octal dump)过滤器, 将会把输入(或文件)转换为8进制或者其他进制. 在你需要查看
 或处理一些二进制数据文件或者一个不可读的系统设备文件的时候, 这个命令非常有用, 
 比如/dev/urandom,或者是一个二进制数据过滤器. 参见 Example 9-28 和 
 Example 12-13. 
hexdump
 对二进制文件进行 16进制, 8进制, 10进制, 或者 ASCII 码的查阅动作. 这个命令大体
 上与上边的od命令作用相同, 但是远不及 od 命令有用. 
objdump
 显示编译后的2进制文件或2进制可执行文件的信息, 以16进制的形式显示, 或者显示反汇
 编列表(使用-d选项). 
  bash$ objdump -d /bin/ls
  /bin/ls:     file format elf32-i386 
  Disassembly of section .init: 
  080490bc <.init>:
   80490bc:       55                      push   %ebp
   80490bd:       89 e5                   mov    %esp,%ebp
   . . . 
mcookie
 这个命令会产生一个"magic cookie", 这是一个128-bit (32-字符) 的伪随机16进制数字,
 这个数字一般都用来作为X server的鉴权"签名". 这个命令还可以用来在脚本中作为一
 种生成随机数的手段, 当然这是一种"小吃店"(虽然不太正统, 但是很方便)的风格. 
    1 random000=$(mcookie) 
 当然, 完成同样的目的还可以使用 md5 命令.
    1 # 产生关于脚本本身的 md5 checksum.
    2 random001=`md5sum $0 | awk '{print $1}'`
    3 # 使用 'awk' 来去掉文件名. 
 mcookie 还给出了产生"唯一"文件名的另一种方法. 
Example 12-56 文件名产生器
################################Start Script#######################################
 1 #!/bin/bash
 2 # tempfile-name.sh:  临时文件名产生器
 3 
 4 BASE_STR=`mcookie`   # 32-字符的 magic cookie.
 5 POS=11               # 字符串中随便的一个位置.
 6 LEN=5                # 取得 $LEN 长度连续的字符串.
 7 
 8 prefix=temp          #  最终的一个临时文件.
 9                      #  如果想让这个文件更加唯一,
10                      #+ 可以对这个前缀也使用下边的方法来生成.
11 
12 suffix=${BASE_STR:POS:LEN}
13                      # 提取从第11个字符之后的长度为5的字符串.
14 
15 temp_filename=$prefix.$suffix
16                      # 构造文件名.
17 
18 echo "Temp filename = "$temp_filename""
19 
20 # sh tempfile-name.sh
21 # Temp filename = temp.e19ea
22 
23 #  与使用 'date' 命令(参考 ex51.sh)来创建唯一文件名
24 #+ 的方法相比较.
25 
26 exit 0
################################End Script######################################### 
units
 这个工具用来在不同的计量单位之间互相转换. 当你在交互模式下正常调用时, 会发现在
 脚本中 units 也很有用. 
Example 12-57 将米转换为英里
################################Start Script#######################################
 1 #!/bin/bash
 2 # unit-conversion.sh
 3 
 4 
 5 convert_units ()  # 通过参数取得需要转换的单位.
 6 {
 7   cf=$(units "$1" "$2" | sed --silent -e '1p' | awk '{print $2}')
 8   # 除了真正需要转换的部分保留下来外,其他的部分都去掉.
 9   echo "$cf"
10 }  
11 
12 Unit1=miles
13 Unit2=meters
14 cfactor=`convert_units $Unit1 $Unit2`
15 quantity=3.73
16 
17 result=$(echo $quantity*$cfactor | bc)
18 
19 echo "There are $result $Unit2 in $quantity $Unit1."
20 
21 #  如果你传递了两个不匹配的单位会发生什么?
22 #+ 比如分别传入英亩和英里?
23 
24 exit 0
################################End Script######################################### 
m4
 一个隐藏的财宝, m4 是一个强力的宏处理过滤器, [5]  差不多可以说是一种语言了. 虽
 然最开始这个工具是用来作为 RatFor 的预处理器而编写的, 但是后来证明 m4  作为独
 立的工具也是非常有用的. 事实上, m4 结合了许多工具的功能, 比如 eval, tr, 和 awk,
 除此之外, 它还使得宏扩展变得容易. 
 在 2004年4月的 Linux Journal  的问题列表中有一篇关于 m4 命令用法得非常好的文章. 
Example 12-58 使用 m4
################################Start Script#######################################
 1 #!/bin/bash
 2 # m4.sh: 使用 m4 宏处理器
 3 
 4 # 字符操作
 5 string=abcdA01
 6 echo "len($string)" | m4                           # 7
 7 echo "substr($string,4)" | m4                      # A01
 8 echo "regexp($string,[0-1][0-1],\&Z)" | m4         # 01Z
 9 
10 # 算术操作
11 echo "incr(22)" | m4                               # 23
12 echo "eval(99 / 3)" | m4                           # 33
13 
14 exit 0
################################End Script######################################### 
doexec
 doexec 命令允许将一个随便的参数列表传递到一个二进制可执行文件中. 特别的, 甚至
 可以传递 arg[0] (相当于脚本中的 $0 ), 这样可以使用不同的名字来调用这个可执行
 文件, 并且通过不同的调用的名字, 可以让这个可执行文件执行不同的动作. 这也可以
 说是一种将参数传递到可执行文件中的比较绕圈子的做法. 
 比如, /usr/local/bin 目录可能包含一个 "aaa" 的二进制文件. 使用 
 doexec /usr/local/bin/aaa list  可以 列出 当前工作目录下所有以 "a" 开头的的文
 件, 而使用 doexec /usr/local/bin/aaa delete  将会删除这些文件. 
 注意: 可执行文件的不同行为必须定义在可执行文件自身的代码中, 可以使用如下的
  shell脚本作类比:
    1 case `basename $0` in
    2 "name1" ) do_something;;
    3 "name2" ) do_something_else;;
    4 "name3" ) do_yet_another_thing;;
    5 *       ) bail_out;;
    6 esac 
dialog
 dialog 工具集提供了一种从脚本中调用交互对话框的方法. dialog 的更好的变种版本是
  -- gdialog, Xdialog, 和 kdialog -- 事实上是调用的 X-Windows 的界面工具集. 参
 见 Example 33-19. 
sox
 sox 命令, "sound exchange" (声音转换)命令, 可以进行声音文件的转换. 事实上,可执
 行文件 /usr/bin/play (现在不建议使用) 只不过是 sox 的一个 shell 包装器而已. 
 举个例子, sox soundfile.wav soundfile.au 将会把一个 WAV 声音文件转换成一个 
 (Sun 音频格式) AU 声音文件. 
 Shell 脚本非常适合于使用 sox 的声音操作来批处理声音文件. 比如, 参见 
 Linux Radio Timeshift HOWTO 和 MP3do Project. 注意事项:
[1]  这个工具事实上是从 Debian Linux 发行版中的一个脚本借鉴过来的.
[2]  打印队列 就是"在线等待"打印的作业组.
[3]  对于本话题的一个完美的介绍, 请参见 Andy Vaught 的文章, 命名管道的介绍, 
  (http://www2.linuxjournal.com/lj-issues/issue41/2156.html), 这是
  Linux Journal (http://www.linuxjournal.com/)1997年9月的一个问题.
[4]  EBCDIC (发音是 "ebb-sid-ick") 是单词 (Extended Binary Coded Decimal 
  Interchange Code) 的首字母缩写. 这是 IBM 的数据格式, 现在已经不常见了. 
  dd 命令的 conv=ebcdic 选项的一个比较奇异的使用方法是对一个文件进行快速而
  且容易但不太安全的编码.
     1 cat $file | dd conv=swab,ebcdic > $file_encrypted
     2 # 编码 (看起来好像没什么用).      
     3 # 应该交换字节(swab), 有点晦涩.
     4 
     5 cat $file_encrypted | dd conv=swab,ascii > $file_plaintext
     6 # 解码.
[5]  宏 是一个符号常量, 将会被扩展成一个命令字符串或者一系列的参数操作.  
[]     
    
高级Bash脚本编程指南(四)
文章整理: 文章来源: 网络 
高级Bash脚本编程指南(四) 
  
  
第13章 系统与管理命令
======================
在/etc/rc.d目录中的启动和关机脚本中包含了好多有用的(和没用的)这些系统管理命令. 这些
命令通常总是被root用户使用, 用与系统维护或者是紧急文件系统修复.一定要小心使用这些工
具, 因为如果滥用的话, 它们会损坏你的系统. 
Users 和 Groups 类命令 
users
 显示所有的登录的用户. 这个命令与 who -q 基本一致. 
groups
 列出当前用户和他所属于的组. 这相当于 $GROUPS 内部变量, 但是这个命令将会给出组名
 字, 而不是数字. 
  bash$ groups
  bozita cdrom cdwriter audio xgrp
  
  bash$ echo $GROUPS
  501 
chown, chgrp
 chown 命令将会修改一个或多个文件的所有权. 对于root来说这是一种非常好的将文件的
 所有权从一个用户换到另一个用户的方法. 一个普通用户不能修改文件的所有权, 即使他
 是文件的宿主也不行. [1] 
  root# chown bozo *.txt 
 chgrp 将会修改一个或个文件党组所有权. 你必须是这些文件的宿主, 并且是目的组的成
 员(或者root), 这样才能使用这个操作. 
    1 chgrp --recursive dunderheads *.data
    2 #  "dunderheads"(译者: 晕,蠢才...) 组现在拥有了所有的"*.data"文件.
    3 #+ 包括所有$PWD目录下的子目录中的文件(--recursive的作用就是包含子目录). 
useradd, userdel
 useradd 管理命令将会在系统上添加一个用户帐号, 并且如果指定的话, 还会为特定的用
 户创建home目录. 相应的userdel 命令将会从系统上删除一个用户帐号, [2] 并且删除相
 应的文件. 
 注意: adduser命令与useradd是相同的, adduser通常都是一个符号链接. 
usermod
 修改用户帐号. 可以修改密码, 组身份, 截止日期, 或者给定用户帐号的其他的属性. 使
 用这个命令, 用户的密码可能会被锁定, 因为密码会影响到帐号的有效性. 
groupmod
 修改指定组. 组名字或者ID号都可以使用这个命令来修改. 
id
 id 将会列出当前进程的真实和有效用户ID, 还有用户的组ID. 这与Bash的内部变量 
 $UID, $EUID, 和 $GROUPS 很相像. 
  bash$ id
  uid=501(bozo) gid=501(bozo) groups=501(bozo),22(cdrom),80(cdwriter),81(audio)
  
  bash$ echo $UID
  501 
 注意: id 命令只有在有效ID与真实ID不符时才会显示有效id. 
 参见 Example 9-5. 
who
 显示系统上所有已经登录的用户. 
  bash$ who
  bozo  tty1     Apr 27 17:45
  bozo  pts/0    Apr 27 17:46
  bozo  pts/1    Apr 27 17:47
  bozo  pts/2    Apr 27 17:49 
 -m 选项将会只给出当前用户的详细信息. 将任意两个参数传递到who中 都等价于who -m, 
 就像 who am i 或者 who The Man. 
  bash$ who -m
  localhost.localdomain!bozo  pts/2    Apr 27 17:49 
 whoami 与who -m 很相似, 但是只列出用户名. 
  bash$ whoami
  bozo 
w
 显示所有的登录的用户和属于它们的进程. 这是一个who的扩展版本. w的输出可以通过管
 道传递到grep中, 这样就可以查找指定的用户或进程. 
  bash$ w | grep startx
  bozo  tty1     -                 4:22pm  6:41   4.47s  0.45s  startx 
logname
 显示当前用户的登录名(可以在/var/run/utmp中找到). 这与上边的whoami很相近. 
  bash$ logname
  bozo
  
  bash$ whoami
  bozo 
 然而... 
  bash$ su
  Password: ......
  
  bash# whoami
  root
  bash# logname
  bozo 
 注意: logname只会打印出登录的用户名, 而whoami 将会给出附着到当前进程的用户名. 
  就像我们上边看到的那样, 这两个名字有时会不同. 
su
 使用一个代替的用户来运行一个程序或脚本. su rjones 将会以 rjones 来启动一个
 shell. 一个不加参数的su默认就是root. 参见 Example A-15. 
sudo
 以root(或其他用户)的身份来运行一个命令. 这个命令可以运行在脚本中, 这样就允许以
 正规的用户身份来运行脚本. 
    1 #!/bin/bash
    2 
    3 # 一些命令.
    4 sudo cp /root/secretfile /home/bozo/secret
    5 # 一些命令. 
 文件 /etc/sudoers 持有允许调用sudo的用户名. 
passwd
 设置, 修改, 或者管理用户的密码.
 passwd 命令可以用在脚本中, 但可能你不想这么用. 
Example 13-1 设置一个新密码
################################Start Script#######################################
 1 #!/bin/bash
 2 #  setnew-password.sh: 只用于说明目的.
 3 #                      如果真正运行这个脚本并不是一个好主意.
 4 #  这个脚本必须以root身份运行.
 5 
 6 ROOT_UID=0         # Root 的 $UID 0.
 7 E_WRONG_USER=65    # 不是 root?
 8 
 9 E_NOSUCHUSER=70
10 SUCCESS=0
11 
12 
13 if [ "$UID" -ne "$ROOT_UID" ]
14 then
15   echo; echo "Only root can run this script."; echo
16   exit $E_WRONG_USER
17 else
18   echo
19   echo "You should know better than to run this script, root."
20   echo "Even root users get the blues... "
21   echo
22 fi  
23 
24 
25 username=bozo
26 NEWPASSWORD=security_violation
27 
28 # 检查bozo是否在这里.
29 grep -q "$username" /etc/passwd
30 if [ $? -ne $SUCCESS ]
31 then
32   echo "User $username does not exist."
33   echo "No password changed."
34   exit $E_NOSUCHUSER
35 fi  
36 
37 echo "$NEWPASSWORD" | passwd --stdin "$username"
38 #  'passwd'命令 '--stdin' 选项允许
39 #+ 从stdin(或者管道)中获得一个新的密码.
40 
41 echo; echo "User $username's password changed!"
42 
43 # 在脚本中使用'passwd'命令是很危险的.
44 
45 exit 0
################################End Script#########################################
 passwd 命令的 -l, -u, 和 -d 选项允许锁定, 解锁,和删除一个用户的密码. 只有root
 用户可以使用这些选项. 
ac
 显示用户登录的连接时间, 就像从 /var/log/wtmp 中读取一样. 这是GNU的一个统计工具. 
  bash$ ac
    total       68.08 
last
 用户最后登录的信息, 就像从/var/log/wtmp中读出来一样. 这个命令也可以用来显示远
 端登录.
 比如, 显示最后几次系统的重启信息: 
  bash$ last reboot
  reboot   system boot  2.6.9-1.667      Fri Feb  4 18:18          (00:02)    
  reboot   system boot  2.6.9-1.667      Fri Feb  4 15:20          (01:27)    
  reboot   system boot  2.6.9-1.667      Fri Feb  4 12:56          (00:49)    
  reboot   system boot  2.6.9-1.667      Thu Feb  3 21:08          (02:17)    
  . . . 
  wtmp begins Tue Feb  1 12:50:09 2005 
newgrp
 不用登出就可以修改用户的组ID. 并且允许存取新组的文件. 因为用户可能同时属于多个
 组, 这个命令很少被使用. 
终端类命令 
tty
 显示当前用户终端的名字. 注意每一个单独的xterm窗口都被算作一个不同的终端. 
  bash$ tty
  /dev/pts/1 
stty
 显示并(或)修改终端设置. 这个复杂命令可以用在脚本中, 并可以用来控制终端的行为和
 其显示输出的方法. 参见这个命令的info页, 并仔细学习它. 
Example 13-2 设置一个擦除字符
################################Start Script#######################################
 1 #!/bin/bash
 2 # erase.sh: 在读取输入时使用"stty"来设置一个擦除字符.
 3 
 4 echo -n "What is your name? "
 5 read name                      #  试试退格键
 6                                #+ 来删除输入的字符.
 7                                #  有什么问题?
 8 echo "Your name is $name."
 9 
10 stty erase '#'                 #  将 "hashmark" (#) 设置为退格字符.
11 echo -n "What is your name? "
12 read name                      #  使用#来删除最后键入的字符.
13 echo "Your name is $name."
14 
15 # 警告: 即使在脚本退出后, 新的键值还是保持设置.(译者: 使用stty erase '^?' 恢复)
16 
17 exit 0
################################End Script######################################### 
Example 13-3 关掉终端对于密码的echo
################################Start Script#######################################
 1 #!/bin/bash
 2 # secret-pw.sh: 保护密码不被显示
 3 
 4 echo
 5 echo -n "Enter password "
 6 read passwd
 7 echo "password is $passwd"
 8 echo -n "If someone had been looking over your shoulder, "
 9 echo "your password would have been compromised."
10 
11 echo && echo  # 在一个"与列表"中产生2个换行.
12 
13 
14 stty -echo    # 关闭屏幕的echo.
15 
16 echo -n "Enter password again "
17 read passwd
18 echo
19 echo "password is $passwd"
20 echo
21 
22 stty echo     # 恢复屏幕的echo.
23 
24 exit 0
25 
26 # 详细的阅读stty命令的info页, 以便于更好的掌握这个有用并且狡猾的工具.
################################End Script######################################### 
 一个具有创造性的stty命令的用法, 检测用户所按的键(不用敲回车). 
Example 13-4 按键检测
################################Start Script#######################################
 1 #!/bin/bash
 2 # keypress.sh: 检测用户按键 ("hot keys").
 3 
 4 echo
 5 
 6 old_tty_settings=$(stty -g)   # 保存老的设置(为什么?).
 7 stty -icanon
 8 Keypress=$(head -c1)          # 或者 $(dd bs=1 count=1 2> /dev/null)
 9                               # 在非GNU的系统上
10 
11 echo
12 echo "Key pressed was \""$Keypress"\"."
13 echo
14 
15 stty "$old_tty_settings"      # 恢复老的设置.
16 
17 # 感谢, Stephane Chazelas.
18 
19 exit 0
################################End Script#########################################
 参见 Example 9-3. 
 注意: 终端与模式terminals and modes
  一般情况下, 一个终端都是工作在canonical(标准)模式下. 当用户按键后, 事实上所
  产生的字符并没有马上传递到运行在当前终端上的程序. 终端上的一个本地的缓存保
  存了这些按键. 当用按下ENTER键的时候, 才会将所有保存的按键信息传递到运行的程
  序中. 这就意味着在终端内部存在一个基本的行编辑器.  
   bash$ stty -a
   speed 9600 baud; rows 36; columns 96; line = 0;
   intr = ^C; quit = ^\; erase = ^H; kill = ^U; eof = ^D; eol = <undef>; eol2 = <undef>;
   start = ^Q; stop = ^S; susp = ^Z; rprnt = ^R; werase = ^W; lnext = ^V; flush = ^O;
   ...
   isig icanon iexten echo echoe echok -echonl -noflsh -xcase -tostop -echoprt 
  在使用canonical模式的时候, 可以对本地终端行编辑器所定义的特殊按键进行重新定
  义. 
   bash$ cat > filexxx
   wha<ctl-W>I<ctl-H>foo bar<ctl-U>hello world<ENTER>
   <ctl-D>
   bash$ cat filexxx
   hello world  
   bash$ wc -c < filexxx
   12   
  控制终端的进程只保存了12个字符(11个字母加上一个换行), 虽然用户敲了26个按键. 
  在 non-canonical ("raw") 模式, 每次按键(包括特殊定义的按键, 比如 ctl-H)将会
  立即发送一个字符到控制进程. 
  Bash提示符禁用了icanon和echo, 因为它用自己的更好的行编辑器代替了终端的基本
  行编辑器. 比如, 当你在Bash提示符下敲ctl-A的时候, 终端将不会显示 ^A, 但是
  Bash将会获得\1字符, 然后解释这个字符, 这样光标就移动到行首了. 
  Stéphane Chazelas 
setterm
 设置特定的终端属性. 这个命令将向它的终端的stdout写一个字符串, 这个字符串将修改
 终端的行为. 
  bash$ setterm -cursor off
  bash$ 
 setterm 命令可以被用在脚本中来修改写到stdout的文本的外观, 虽然如果你仅仅只想完
 成这个目的, 还有特定的更好的工具可以用. 
    1 setterm -bold on
    2 echo bold hello
    3 
    4 setterm -bold off
    5 echo normal hello 
tset
 显示或初始化终端设置. 可以说这是stty的功能比较弱的版本. 
  
  bash$ tset -r
  Terminal type is xterm-xfree86.
  Kill is control-U (^U).
  Interrupt is control-C (^C).
  
setserial
 设置或者显示串口参数. 这个脚本只能被root用户来运行, 并且通常都在系统安装脚本
 中使用. 
    1 # 来自于 /etc/pcmcia/serial 脚本:
    2 
    3 IRQ=`setserial /dev/$DEVICE | sed -e 's/.*IRQ: //'`
    4 setserial /dev/$DEVICE irq 0 ; setserial /dev/$DEVICE irq $IRQ 
getty, agetty
 一个终端的初始化过程通常都是使用getty或agetty来建立, 这样才能让用户登录. 这些
 命令并不用在用户的shell脚本中. 它们的行为与stty很相似. 
mesg
 使能或禁用当前用户终端的存取权限. 禁用存取权限将会阻止网络上的另一用户向这个终
 端写消息. 
 注意: 当你正在编写文本文件的时候, 在文本中间突然来了一个莫名其妙的消息, 这对你
  来说是非常烦人的. 在多用户的网络环境下, 当你不想被打断的时候, 你可能因此希
  望禁用对你终端的写权限. 
wall
 这是一个缩写单词 "write all", 也就是, 向登录到网络上的任何终端的所有用户都发送
 一个消息. 最早这是一个管理员的工具, 很有用, 比如, 当系统有问题的时候, 管理可以
 警告系统上的所有人暂时离开 (参见 Example 17-1). 
  bash$ wall System going down for maintenance in 5 minutes!
  Broadcast message from bozo (pts/1) Sun Jul  8 13:53:27 2001... 
  System going down for maintenance in 5 minutes! 
 注意: 如果某个特定终端使用mesg来禁止了写权限, 那么wall将不会给它发消息. 
信息与统计类
uname
 输出系统的说明(OS, 内核版本, 等等.)到stdout. 使用 -a 选项, 将会给出详细的信息
 (参见 Example 12-5). 使用-s选项只会输出OS类型. 
  bash$ uname -a
  Linux localhost.localdomain 2.2.15-2.5.0 #1 Sat Feb 5 00:13:43 EST 2000 i686 unknown
  
  bash$ uname -s
  Linux 
arch
 显示系统的硬件体系结构. 等价于 uname -m. 参见 Example 10-26. 
  bash$ arch
  i686
  
  bash$ uname -m
  i686 
lastcomm
 给出前一个命令的信息, 存储在/var/account/pacct文件中. 命令名字与用户名字都可以
 使用选项来指定. 这是GNU的一个统计工具. 
lastlog
 列出系统上所有用户最后登录的时间. 存在/var/log/lastlog文件中. 
  bash$ lastlog
  root          tty1                      Fri Dec  7 18:43:21 -0700 2001
  bin                                     **Never logged in**
  daemon                                  **Never logged in**
  ...
  bozo          tty1                      Sat Dec  8 21:14:29 -0700 2001
  
  
  
  bash$ lastlog | grep root
  root          tty1                      Fri Dec  7 18:43:21 -0700 2001 
 注意: 如果用户对于/var/log/lastlog文件没有读权限的话, 那么调用这个命令就会失败. 
lsof
 列出打开的文件. 这个命令将会把所有当前打开的文件列出一份详细的表格, 包括文件的
 所有者信息, 尺寸, 与它们相关的信息等等. 当然, lsof也可以管道输出到 grep 和(或)
 awk来分析它的结果. 
  bash$ lsof
  COMMAND    PID    USER   FD   TYPE     DEVICE    SIZE     NODE NAME
  init         1    root  mem    REG        3,5   30748    30303 /sbin/init
  init         1    root  mem    REG        3,5   73120     8069 /lib/ld-2.1.3.so
  init         1    root  mem    REG        3,5  931668     8075 /lib/libc-2.1.3.so
  cardmgr    213    root  mem    REG        3,5   36956    30357 /sbin/cardmgr
  ... 
strace
 为了跟踪系统和信号的诊断和调试工具. 调用它最简单的方法就是strace COMMAND. 
  bash$ strace df
  execve("/bin/df", ["df"], [/* 45 vars */]) = 0
  uname({sys="Linux", node="bozo.localdomain", ...}) = 0
  brk(0)                                  = 0x804f5e4
  ... 
 这是 Solaris truss命令的Linux的等价工具. 
nmap
 网络端口扫描器. 这个命令将会扫描一个服务器来定位打开的端口, 并且定位这些端口相
 关的服务. 这是一个防止网络被黑客入侵的一个重要的安全工具. 
    1 #!/bin/bash
    2 
    3 SERVER=$HOST                           # localhost.localdomain (127.0.0.1).
    4 PORT_NUMBER=25                         # SMTP 端口.
    5 
    6 nmap $SERVER | grep -w "$PORT_NUMBER"  # 这个指定端口打开了么?
    7 #              grep -w 匹配整个单词,
    8 #+             这样就不会匹配类似于1025这种含有25的端口了.
    9 
   10 exit 0
   11 
   12 # 25/tcp     open        smtp 
nc
 nc(netcat)工具是一个完整的工具包, 可以使用它来连接和监听TCP和UDP端口. 它可以用
 来作为诊断和测试工具, 也可以用来作为基于脚本的HTTP客户端和服务器的组件. 
  bash$ nc localhost.localdomain 25
  220 localhost.localdomain ESMTP Sendmail 8.13.1/8.13.1; Thu, 31 Mar 2005 15:41:35 -0700 
Example 13-5 Checking a remote server for identd<rojy bug>
################################Start Script#######################################
 1 #! /bin/sh
 2 ## Duplicate DaveG's ident-scan thingie using netcat. Oooh, he'll be p*ssed.
 3 ## Args: target port [port port port ...]
 4 ## Hose stdout _and_ stderr together.
 5 ##
 6 ##  优点: runs slower than ident-scan, giving remote inetd less cause
 7 ##+ for alarm, and only hits the few known daemon ports you specify.
 8 ##  缺点: requires numeric-only port args, the output sleazitude,
 9 ##+ and won't work for r-services when coming from high source ports.
10 # 脚本作者: Hobbit <hobbit@avian.org>
11 # 授权使用在本书中.
12 
13 # ---------------------------------------------------
14 E_BADARGS=65       # 至少需要两个参数.
15 TWO_WINKS=2        # 需要睡多长时间.
16 THREE_WINKS=3
17 IDPORT=113         # Authentication "tap ident" port.
18 RAND1=999
19 RAND2=31337
20 TIMEOUT0=9
21 TIMEOUT1=8
22 TIMEOUT2=4
23 # ---------------------------------------------------
24 
25 case "${2}" in
26   "" ) echo "Need HOST and at least one PORT." ; exit $E_BADARGS ;;
27 esac
28 
29 # Ping 'em once and see if they *are* running identd.
30 nc -z -w $TIMEOUT0 "$1" $IDPORT || { echo "Oops, $1 isn't running identd." ; exit 0 ; }
31 #  -z scans for listening daemons.
32 #     -w $TIMEOUT = How long to try to connect.
33 
34 # Generate a randomish base port.
35 RP=`expr $$ % $RAND1 + $RAND2`
36 
37 TRG="$1"
38 shift
39 
40 while test "$1" ; do
41   nc -v -w $TIMEOUT1 -p ${RP} "$TRG" ${1} < /dev/null > /dev/null &
42   PROC=$!
43   sleep $THREE_WINKS
44   echo "${1},${RP}" | nc -w $TIMEOUT2 -r "$TRG" $IDPORT 2>&1
45   sleep $TWO_WINKS
46 
47 # 这个脚本看起来是不是一个瘸腿脚本, 或者其它更差的什么东西?
48 # ABS Guide 作者注释: "并不是真的那么差,
49 #+                            事实上相当清楚."
50 
51   kill -HUP $PROC
52   RP=`expr ${RP} + 1`
53   shift
54 done
55 
56 exit $?
57 
58 #  注意事项:
59 #  ---------
60 
61 #  尝试注释一下第30行的程序, 并且使用"localhost.localdomain 25"
62 #+ 作为参数来运行这个脚本.
63 
64 #  For more of Hobbit's 'nc' example scripts,
65 #+ look in the documentation:
66 #+ the /usr/share/doc/nc-X.XX/scripts directory.
################################End Script#########################################
 并且, 当然, 这里还有Dr. Andrew Tridgell在BistKeeper事件中臭名卓著的一行脚本: 
    1 echo clone | nc thunk.org 5000 > e2fsprogs.dat 
free
 使用表格形式来显示内存和缓存的使用情况. 这个命令的输出非常适合于使用 grep, awk 
 或者Perl来分析. procinfo命令将会显示free命令所能显示的所有信息, 而且更多. 
  bash$ free
      total       used       free     shared    buffers     cached
    Mem:         30504      28624       1880      15820       1608       16376
    -/+ buffers/cache:      10640      19864
    Swap:        68540       3128      65412 
 显示未使用的RAM内存: 
  bash$ free | grep Mem | awk '{ print $4 }'
  1880 
procinfo
 从/proc pseudo-filesystem中提取和显示所有信息和统计资料. 这个命令将给出更详细
 的信息. 
  bash$ procinfo | grep Bootup
  Bootup: Wed Mar 21 15:15:50 2001    Load average: 0.04 0.21 0.34 3/47 6829 
lsdev
 显示设备, 也就是显示安装的硬件. 
  bash$ lsdev
  Device            DMA   IRQ  I/O Ports
  ------------------------------------------------
  cascade             4     2 
  dma                          0080-008f
  dma1                         0000-001f
  dma2                         00c0-00df
  fpu                          00f0-00ff
  ide0                     14  01f0-01f7 03f6-03f6
  ... 
du
 递归的显示(磁盘)文件的使用状况. 除非指定, 默认是当前工作目录. 
  bash$ du -ach
  1.0k    ./wi.sh
  1.0k    ./tst.sh
  1.0k    ./random.file
  6.0k    .
  6.0k    total 
df
 使用列表的形式显示文件系统的使用状况. 
  bash$ df
  Filesystem           1k-blocks      Used Available Use% Mounted on
  /dev/hda5               273262     92607    166547  36% /
  /dev/hda8               222525    123951     87085  59% /home
  /dev/hda7              1408796   1075744    261488  80% /usr 
dmesg
 将所有的系统启动消息输出到stdout上. 方便出错,并且可以查出安装了哪些设备驱动和
 察看使用了哪些系统中断. dmesg命令的输出当然也可以在脚本中使用 grep, sed, 或 
 awk 来进行分析. 
  bash$ dmesg | grep hda
  Kernel command line: ro root=/dev/hda2
  hda: IBM-DLGA-23080, ATA DISK drive
  hda: 6015744 sectors (3080 MB) w/96KiB Cache, CHS=746/128/63
  hda: hda1 hda2 hda3 < hda5 hda6 hda7 > hda4 
stat
 显示一个或多个给定文件(也可以是目录文件或设备文件)的详细的统计信息. 
  bash$ stat test.cru
    File: "test.cru"
    Size: 49970        Allocated Blocks: 100          Filetype: Regular File
    Mode: (0664/-rw-rw-r--)         Uid: (  501/ bozo)  Gid: (  501/ bozo)
  Device:  3,8   Inode: 18185     Links: 1    
  Access: Sat Jun  2 16:40:24 2001
  Modify: Sat Jun  2 16:40:24 2001
  Change: Sat Jun  2 16:40:24 2001 
 如果目标文件不存在, stat 将会返回一个错误信息. 
  bash$ stat nonexistent-file
  nonexistent-file: No such file or directory 
vmstat
 显示虚拟内存的统计信息. 
  bash$ vmstat
  procs                      memory    swap          io system         cpu
  r  b  w   swpd   free   buff  cache  si  so    bi    bo   in    cs  us  sy id
  0  0  0      0  11040   2636  38952   0   0    33     7  271    88   8   3 89 
netstat
 显示当前网络的统计和信息, 比如路由表和激活的连接. 这个工具存取/proc/net(第27章)
 中的信息. 参见 Example 27-3.
 netstat -r 等价于 route 命令. 
  bash$ netstat
  Active Internet connections (w/o servers)
  Proto Recv-Q Send-Q Local Address           Foreign Address         State      
  Active UNIX domain sockets (w/o servers)
  Proto RefCnt Flags       Type       State         I-Node Path
  unix  11     [ ]         DGRAM                    906    /dev/log
  unix  3      [ ]         STREAM     CONNECTED     4514   /tmp/.X11-unix/X0
  unix  3      [ ]         STREAM     CONNECTED     4513
  . . . 
uptime
 显示系统运行的时间, 还有其他一些统计信息. 
  bash$ uptime
  10:28pm  up  1:57,  3 users,  load average: 0.17, 0.34, 0.27 
 注意: load average 如果小于或等于1, 那么就意味着系统会马上处理. 如果
  load average大于1, 那么就意味着进程需要排队. 如果load average大于3, 
  那么就意味着, 系统性能已经显著下降了. 
hostname
 显示系统的主机名字. 这个命令在 /etc/rc.d 安装脚本(/etc/rc.d/rc.sysinit 
 或类似的)中设置主机名. 等价于uname -n, 并且与$HOSTNAME内部变量很相像. 
  bash$ hostname
  localhost.localdomain
  
  bash$ echo $HOSTNAME
  localhost.localdomain 
 与 hostname 命令很相像的命令还有 domainname, dnsdomainname, nisdomainname, 和 
 ypdomainname 命令. 使用这些来显示或设置系统DNS 或者 NIS/YP 域名. 对于hostname
 命令来说使用不同的选项一样可以达到上边这些命令的目的. 
hostid
 显示主机的32位的16进制ID. 
  bash$ hostid
  7f0100 
 注意: 这个命令据说对于特定系统可以获得一个"唯一"的序号. 某些产品的注册过程可能
  会需要这个序号来作为用户的许可证. 不幸的是, hostid 只会使用字节转换的方法
  来用16进制显示机器的网络地址. 
  一个没有网络的Linux机器的典型的网络地址设置在/ect/hosts中. 
   bash$ cat /etc/hosts
   127.0.0.1               localhost.localdomain localhost 
  碰巧, 通过对127.0.0.1进行字节转换, 我们获得了 0.127.1.0, 用16进制表示就是
  007f0100, 这就是上边hostid返回的结果. 这样几乎所有的无网络的Linux机器都会
  得到这个hostid. 
sar
 sar (System Activity Reporter系统活动报告) 命令将会给出系统统计的一个非常详细的
 概要. Santa Cruz Operation("老" SCO)公司在1999年4月份以开源软件的形式发布了sar. 
 这个命令并不是基本Linux发行版的一部分, 但是你可以从Sebastien Godard 写的 
 sysstat utilities 包中获得这个工具. 
  bash$ sar
  Linux 2.4.9 (brooks.seringas.fr)  09/26/03 
 10:30:00          CPU     %user     %nice   %system   %iowait     %idle
 10:40:00          all      2.21     10.90     65.48      0.00     21.41
 10:50:00          all      3.36      0.00     72.36      0.00     24.28
 11:00:00          all      1.12      0.00     80.77      0.00     18.11
 Average:          all      2.23      3.63     72.87      0.00     21.27 
 14:32:30          LINUX RESTART 
 15:00:00          CPU     %user     %nice   %system   %iowait     %idle
 15:10:00          all      8.59      2.40     17.47      0.00     71.54
 15:20:00          all      4.07      1.00     11.95      0.00     82.98
 15:30:00          all      0.79      2.94      7.56      0.00     88.71
 Average:          all      6.33      1.70     14.71      0.00     77.26 
readelf
 显示指定的 elf 格式的2进制文件的统计信息. 这个工具是binutils工具包的一部分. 
  bash$ readelf -h /bin/bash
  ELF Header:
    Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
    Class:                             ELF32
    Data:                              2's complement, little endian
    Version:                           1 (current)
    OS/ABI:                            UNIX - System V
    ABI Version:                       0
    Type:                              EXEC (Executable file)
    . . . 
size
 size [/path/to/binary] 命令可以显示2进制可执行文件或归档文件每部分的尺寸. 这个
 工具主要是程序员使用. 
  bash$ size /bin/bash
  text    data     bss     dec     hex filename
   495971   22496   17392  535859   82d33 /bin/bash 
系统日志类
logger
 附加一个用户产生的消息到系统日之中 (/var/log/messages). 不是root用户也可以调用
 logger. 
    1 logger Experiencing instability in network connection at 23:10, 05/21.
    2 # 现在, 运行 'tail /var/log/messages'. 
 通过在脚本中调用一个logger命令, 就可以将调试信息写到/var/log/messages中. 
    1 logger -t $0 -i Logging at line "$LINENO".
    2 # "-t" 选项可以为长的入口指定标签.
    3 # "-i" 选项记录进程ID.
    4 
    5 # tail /var/log/message
    6 # ...
    7 # Jul  7 20:48:58 localhost ./test.sh[1712]: Logging at line 3. 
logrotate
 这个工具用来管理系统的log文件, 可以在合适的时候轮换, 压缩, 删除, 和(或)e-mail
 它们. 这个工具将从老的log文件中取得一些杂乱的记录保存在/var/log中. 通常使用 
 cron 来每天运行logrotate. 
 在/etc/logrotate.conf中添加合适的入口就可以管理自己的log文件了, 就像管理系统
 log文件一样. 
 注意: Stefano Falsetto 创造了rottlog, 他认为这是logrotate的改进版本. 
作业控制
ps
 进程统计: 通过进程所有者和PID(进程ID)来列出当前执行的进程. 通常都是使用ax选项
 来调用这个命令, 并且结果可以通过管道传递到 grep 或 sed 中来搜索特定的进程
 (参见 Example 11-12 和 Example 27-2). 
  bash$  ps ax | grep sendmail
  295 ?    S   0:00 sendmail: accepting connections on port 25 
 如果想使用"树"的形式来显示系统进程: ps afjx 或者 ps ax --forest. 
pgrep, pkill
 ps 命令与grep或kill结合使用. 
  bash$ ps a | grep mingetty
  2212 tty2     Ss+    0:00 /sbin/mingetty tty2
  2213 tty3     Ss+    0:00 /sbin/mingetty tty3
  2214 tty4     Ss+    0:00 /sbin/mingetty tty4
  2215 tty5     Ss+    0:00 /sbin/mingetty tty5
  2216 tty6     Ss+    0:00 /sbin/mingetty tty6
  4849 pts/2    S+     0:00 grep mingetty 
  bash$ pgrep mingetty
  2212 mingetty
  2213 mingetty
  2214 mingetty
  2215 mingetty
  2216 mingetty 
pstree
 使用"树"形式列出当前执行的进程. -p选项显示PID,和进程名字. 
top
 连续不断的显示cpu使用率最高的进程. -b 选项将会以文本方式显示, 以便于可以在脚本
 中分析或存取. 
  bash$ top -b
    8:30pm  up 3 min,  3 users,  load average: 0.49, 0.32, 0.13
  45 processes: 44 sleeping, 1 running, 0 zombie, 0 stopped
  CPU states: 13.6% user,  7.3% system,  0.0% nice, 78.9% idle
  Mem:    78396K av,   65468K used,   12928K free,       0K shrd,    2352K buff
  Swap:  157208K av,       0K used,  157208K free                   37244K cached 
    PID USER     PRI  NI  SIZE  RSS SHARE STAT %CPU %MEM   TIME COMMAND
    848 bozo      17   0   996  996   800 R     5.6  1.2   0:00 top
   1 root       8   0   512  512   444 S     0.0  0.6   0:04 init
   2 root       9   0     0    0     0 SW    0.0  0.0   0:00 keventd
    ...  
nice
 使用修改后的优先级来运行一个后台作业. 优先级从19(最低)到-20(最高). 只有root用
 户可以设置负的(比较高的)优先级. 相关的命令是renice, snice, 和skill. 
nohup
 保持一个命令的运行, 即使用户登出系统. 这个命令做为前台进程来运行, 除非前边加 &.
 如果你在脚本中使用nohup命令, 最好和wait 命令一起使用, 这样可以避免创建一个
 孤儿进程或僵尸进程. 
pidof
 取得一个正在运行的作业的进程ID(PID). 因为一些作业控制命令, 比如kill和renice只
 能使用进程的PID(而不是它的名字), 所以有时候必须的取得PID. pidof命令与$PPID内部
 变量非常相似. 
  bash$ pidof xclock
  880 
Example 13-6 pidof 帮助杀掉一个进程
################################Start Script#######################################
 1 #!/bin/bash
 2 # kill-process.sh
 3 
 4 NOPROCESS=2
 5 
 6 process=xxxyyyzzz  # 使用不存在的进程.
 7 # 只不过是为了演示...
 8 # ... 并不想在这个脚本中杀掉任何真正的进程.
 9 #
10 # 如果, 举个例子, 你想使用这个脚本来断线Internet,
11 #     process=pppd
12 
13 t=`pidof $process`       # 取得$process的pid(进程id).
14 # 'kill'必须使用pid(不能用程序名).
15 
16 if [ -z "$t" ]           # 如果没这个进程, 'pidof' 返回空.
17 then
18   echo "Process $process was not running."
19   echo "Nothing killed."
20   exit $NOPROCESS
21 fi  
22 
23 kill $t                  # 对于顽固的进程可能需要'kill -9'.
24 
25 # 这里需要做一个检查, 看看进程是否允许自身被kill.
26 # 或许另一个 " t=`pidof $process` " 或者 ...
27 
28 
29 # 整个脚本都可以使用下边这句来替换:
30 #    kill $(pidof -x process_name)
31 # 但是这就没有教育意义了.
32 
33 exit 0
################################End Script######################################### 
fuser
 取得一个正在存取某个或某些文件(或目录)的进程ID. 使用-k选项将会杀掉这些进程. 对
 于系统安全来说, 尤其是在脚本中想阻止未被授权的用户存取系统服务的时候, 这个命令
 就显得很有用了. 
  bash$ fuser -u /usr/bin/vim
  /usr/bin/vim:         3207e(bozo)
 
  bash$ fuser -u /dev/null
  /dev/null:            3009(bozo)  3010(bozo)  3197(bozo)  3199(bozo) 
 当正常的插入或删除保存的媒体, 比如CD ROM或者USB闪存设备的时候, fuser的应用也显
 得特别重要. 有时候当你想umount一个设备失败的时候(出现设备忙的错误消息), 这意味
 着某些用户或进程正在存取这个设备. 使用fuser -um /dev/device_name可以搞定这些, 
 这样你就可以杀掉所有相关的进程. 
  bash$ umount /mnt/usbdrive
  umount: /mnt/usbdrive: device is busy
  
  bash$ fuser -um /dev/usbdrive
  /mnt/usbdrive:        1772c(bozo)
  
  bash$ kill -9 1772
  bash$ umount /mnt/usbdrive 
 fuser 的-n选项可以获得正在存取某一端口的进程. 当和nmap命令组合使用的时候尤其
 有用. 
  root# nmap localhost.localdomain
  PORT     STATE SERVICE
  25/tcp   open  smtp
  
  root# fuser -un tcp 25
  25/tcp:               2095(root)
  
  root# ps ax | grep 2095 | grep -v grep
  2095 ?        Ss     0:00 sendmail: accepting connections 
cron
 管理程序调度器, 执行一些日常任务, 比如清除和删除系统log文件, 或者更新slocate命
 令的数据库. 这是at命令的超级用户版本(虽然每个用户都可以有自己的crontab文件, 并
 且这个文件可以使用crontab命令来修改). 它以幽灵进程T的身份来运行, 并且从
 /ect/crontab中获得执行的调度入口. 
 注意: 一些Linux的风格都使用crond, Matthew Dillon的cron. 
进程控制和启动类
init
 init 命令是所有进程的父进程. 在系统启动的最后一步调用, init 将会依据
 /etc/inittab来决定系统的运行级别. 只能使用root身份来运行它的别名telinit. 
telinit
 init命令的符号链接, 这是一种修改系统运行级别的一个手段, 通常在系统维护或者紧急
 的文件系统修复的时候才用. 只能使用root身份调用. 调用这个命令是非常危险的 - 在
 你使用之前确定你已经很好地了解它. 
runlevel
 显示当前和最后的运行级别, 也就是, 确定你的系统是否终止(runlevel 为0), 还是运行
 在单用户模式(1), 多用户模式(2), 或者是运行在X Windows(5), 还是正在重启(6). 这
 个命令将会存取/var/run/utmp文件. 
halt, shutdown, reboot
 设置系统关机的命令, 通常比电源关机的优先级高. 
service
 开启或停止一个系统服务. 启动脚本在/etc/init.d中, 并且/etc/rc.d在系统启动的时候
 使用这个命令来启动服务. 
  root# /sbin/service iptables stop
  Flushing firewall rules:                                   [  OK  ]
  Setting chains to policy ACCEPT: filter                    [  OK  ]
  Unloading iptables modules:                                [  OK  ] 
网络类 
ifconfig
 网络的接口配置和调试工具. 
  bash$ ifconfig -a
  lo        Link encap:Local Loopback
      inet addr:127.0.0.1  Mask:255.0.0.0
      UP LOOPBACK RUNNING  MTU:16436  Metric:1
      RX packets:10 errors:0 dropped:0 overruns:0 frame:0
      TX packets:10 errors:0 dropped:0 overruns:0 carrier:0
      collisions:0 txqueuelen:0 
      RX bytes:700 (700.0 b)  TX bytes:700 (700.0 b) 
 ifconfig 命令绝大多数情况都是在启动时候设置接口, 或者在重启的时候关闭它们. 
    1 # 来自于 /etc/rc.d/init.d/network 的代码片段
    2 
    3 # ...
    4 
    5 # 检查网络是否启动.
    6 [ ${NETWORKING} = "no" ] && exit 0
    7 
    8 [ -x /sbin/ifconfig ] || exit 0
    9 
   10 # ...
   11 
   12 for i in $interfaces ; do
   13   if ifconfig $i 2>/dev/null | grep -q "UP" >/dev/null 2>&1 ; then
   14     action "Shutting down interface $i: " ./ifdown $i boot
   15   fi
   16 # grep命令的GNU指定的 "-q" 的意思是"安静", 也就是不产生输出.
   17 # 这样, 后边重定向到/dev/null的操作就有点重复了.
   18        
   19 # ...
   20 
   21 echo "Currently active devices:"
   22 echo `/sbin/ifconfig | grep ^[a-z] | awk '{print $1}'`
   23 #                            ^^^^^  应该被引用防止globbing.
   24 #  下边这段也能工作.
   25 #    echo $(/sbin/ifconfig | awk '/^[a-z]/ { print $1 })'
   26 #    echo $(/sbin/ifconfig | sed -e 's/ .*//')
   27 #  Thanks, S.C.做了额外的注释. 
 参见 Example 29-6. 
iwconfig
 这是为了配置无线网络的命令集合. 可以说是上边的ifconfig的无线版本. 
route
 显示内核路由表信息, 或者查看内核路由表的修改. 
  bash$ route
  Destination     Gateway         Genmask         Flags   MSS Window  irtt Iface
  pm3-67.bozosisp *               255.255.255.255 UH       40 0          0 ppp0
  127.0.0.0       *               255.0.0.0       U        40 0          0 lo
  default         pm3-67.bozosisp 0.0.0.0         UG       40 0          0 ppp0 
chkconfig
 检查网络配置. 这个命令负责显示和管理在启动过程中所开启的网络服务(这些服务都是
 从/etc/rc?.d目录中开启的). 
 最开始是从IRIX到Red Hat Linux的一个接口, chkconfig在某些Linux发行版中并不是核
 心安装的一部分. 
  bash$ chkconfig --list
  atd             0:off   1:off   2:off   3:on    4:on    5:on    6:off
  rwhod           0:off   1:off   2:off   3:off   4:off   5:off   6:off
  ... 
tcpdump
 网络包的"嗅探器". 这是一个用来分析和调试网络上传输情况的工具, 它所使用的手段是
 把匹配指定规则的包头都显示出来. 
 显示主机bozoville和主机caduceus之间所有传输的ip包. 
  bash$ tcpdump ip host bozoville and caduceus 
 当然,tcpdump的输出可以被分析, 可以用我们之前讨论的文本处理工具来分析结果. 
文件系统类 
mount
 加载一个文件系统, 通常都用来安装外部设备, 比如软盘或CDROM. 文件/etc/fstab 将会
 提供一个方便的列表, 这个列表列出了所有可用的文件系统, 分区和设备, 另外还包括某
 些选项, 比如是否可以自动或者手动的mount. 文件/etc/mtab 显示了当前已经mount的文
 件系统和分区(包括虚拟的, 比如/proc). 
 mount -a 将会mount所有列在/ect/fstab中的文件系统和分区, 除了那些标记有非自动选
 项的. 在启动的时候, 在/etc/rc.d中的一个启动脚本(rc.sysinit或者一些相似的脚本)
 将会这么调用, mount所有可用的文件系统和分区. 
    1 mount -t iso9660 /dev/cdrom /mnt/cdrom
    2 # 加载 CDROM
    3 mount /mnt/cdrom
    4 # 方便的方法, 如果 /mnt/cdrom 包含在 /etc/fstab 中 
 这个多功能的命令甚至可以将一个普通文件mount到块设备中, 并且这个文件就好像一个
 文件系统一样. mount可以将文件与一个loopback设备相关联来达到这个目的.
 ccomplishes that by associating the file with a loopback device. 这种应用通常
 都是用来mount和检查一个ISO9660镜像,在这个镜像被烧录到CDR之前. [3] 
Example 13-7 检查一个CD镜像
################################Start Script#######################################
1 # 以root身份...
2 
3 mkdir /mnt/cdtest  # 如果没有的话,准备一个mount点.
4 
5 mount -r -t iso9660 -o loop cd-image.iso /mnt/cdtest   # mount这个镜像.
6 #                  "-o loop" option equivalent to "losetup /dev/loop0"
7 cd /mnt/cdtest     # 现在检查这个镜像.
8 ls -alR            # 列出目录树中的文件.
9                    # 等等.
################################End Script######################################### 
umount
 卸除一个当前已经mount的文件系统. 在正常删除之前已经mount的软盘和CDROM之前, 这
 个设备必须被unmount, 否则文件系统将会损坏. 
   1 umount /mnt/cdrom
   2 # 现在你可以按下退出按钮(指的是cdrom或软盘驱动器上的退出钮), 并安全的退出光盘. 
sync
 强制写入所有需要更新的buffer上的数据到硬盘上(同步带有buffer的驱动器). 如果不是
 严格必要的话,一个sync就可以保证系统管理员或者用户刚刚修改的数据会安全的在突然
 的断点中幸存下来. 在比较早以前, 在系统重启前都是使用 sync; sync (两次, 这样保
 证绝对可靠), 这是一种很有用的小心的方法. 
 有时候, 比如当你想安全删除一个文件的时候(参见 Example 12-55), 或者当磁盘灯开始
 闪烁的时候, 你可能需要强制马上进行buffer刷新. 
losetup
 建立和配置loopback设备. 
Example 13-8 在一个文件中创建文件系统
################################Start Script#######################################
1 SIZE=1000000  # 1M
2 
3 head -c $SIZE < /dev/zero > file  # 建立指定尺寸的文件.
4 losetup /dev/loop0 file           # 作为loopback设备来建立.
5 mke2fs /dev/loop0                 # 创建文件系统.
6 mount -o loop /dev/loop0 /mnt     # Mount它.
7 
8 # Thanks, S.C.
################################End Script######################################### 
mkswap
 创建一个交换分区或文件. 交换区域随后必须马上使用swapon来使能. 
swapon, swapoff
 使能/禁用 交换分区或文件. 这两个命令通常在启动和关机的时候才有效. 
mke2fs
 创建Linux ext2 文件系统. 这个命令必须以root身份调用. 
Example 13-9 添加一个新的硬盘驱动器
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # 在系统上添加第二块硬盘驱动器.
 4 # 软件配置. 假设硬件已经安装了.
 5 # 来自于本书作者的一篇文章.
 6 # 在"Linux Gazette"的问题#38上, http://www.linuxgazette.com.
 7 
 8 ROOT_UID=0     # 这个脚本必须以root身份运行.
 9 E_NOTROOT=67   # 非root用户将会产生这个错误.
10 
11 if [ "$UID" -ne "$ROOT_UID" ]
12 then
13   echo "Must be root to run this script."
14   exit $E_NOTROOT
15 fi  
16 
17 # 要非常谨慎的小心使用!
18 # 如果某步错了, 可能会彻底摧毁你当前的文件系统.
19 
20 
21 NEWDISK=/dev/hdb         # 假设/dev/hdb空白. 检查一下!
22 MOUNTPOINT=/mnt/newdisk  # 或者选择另外的mount点.
23 
24 
25 fdisk $NEWDISK
26 mke2fs -cv $NEWDISK1   # 检查坏块, 详细输出.
27 #  注意:    /dev/hdb1, *不是* /dev/hdb!
28 mkdir $MOUNTPOINT
29 chmod 777 $MOUNTPOINT  # 让所有用户都具有全部权限.
30 
31 
32 # 现在, 测试一下...
33 # mount -t ext2 /dev/hdb1 /mnt/newdisk
34 # 尝试创建一个目录.
35 # 如果工作起来了, umount它, 然后继续.
36 
37 # 最后一步:
38 # 将下边这行添加到/etc/fstab.
39 # /dev/hdb1  /mnt/newdisk  ext2  defaults  1 1
40 
41 exit 0
################################End Script#########################################
 参见 Example 13-8 和 Example 28-3. 
tune2fs
 调整ext2文件系统. 可以用来修改文件系统参数, 比如mount的最大数量. 必须以root身
 份调用. 
 注意: 这是一个非常危险的命令. 如果坏了, 你需要自己负责, 因为它可能会破坏你的文
  件系统. 
dumpe2fs
 打印(输出到stdout上)非常详细的文件系统信息. 必须以root身份调用. 
  root# dumpe2fs /dev/hda7 | grep 'ount count'
  dumpe2fs 1.19, 13-Jul-2000 for EXT2 FS 0.5b, 95/08/09
  Mount count:              6
  Maximum mount count:      20 
hdparm
 列出或修改硬盘参数. 这个命令必须以root身份调用, 如果滥用的话会有危险. 
fdisk
 在存储设备上(通常都是硬盘)创建和修改一个分区表. 必须以root身份使用. 
 注意: 谨慎使用这个命令. 如果出错, 会破坏你现存的文件系统. 
fsck, e2fsck, debugfs 
 文件系统的检查, 修复, 和除错命令集合. 
 fsck: 检查UNIX文件系统的前端工具(也可以调用其它的工具). 文件系统的类型一般都是
  默认的ext2. 
 e2fsck: ext2文件系统检查器. 
 debugfs: ext2文件系统除错器. 这个多功能但是危险的工具的用处之一就是(尝试)恢复
  删除的文件. 只有高级用户才能用. 
 上边的这几个命令都必须以root身份调用, 这些命令都很危险, 如果滥用的话会破坏文件
 系统. 
badblocks
 检查存储设备的坏块(物理损坏). 这个命令在格式化新安装的硬盘时或者测试备份的完整
 性的时候会被用到. [4] 举个例子, badblocks /dev/fd0 测试一个软盘. 
 badblocks可能会引起比较糟糕的结果(覆盖所有数据), 在只读模式下就不会发生这种情
 况.如果root用户拥有需要测试的设备(通常都是这种情况), 那么root用户必须调用这个
 命令. 
lsusb, usbmodules
 lsusb 命令会列出所有USB(Universal Serial Bus通用串行总线)总线和使用USB的设备. 
 usbmodules 命令会输出连接USB设备的驱动模块的信息. 
  root# lsusb
  Bus 001 Device 001: ID 0000:0000  
  Device Descriptor:
    bLength                18
    bDescriptorType         1
    bcdUSB               1.00
    bDeviceClass            9 Hub
    bDeviceSubClass         0 
    bDeviceProtocol         0 
    bMaxPacketSize0         8
    idVendor           0x0000 
    idProduct          0x0000
    . . . 
mkbootdisk
 创建启动软盘, 启动盘可以唤醒系统, 比如当MBR(master boot record主启动记录)坏掉
 的时候. mkbootdisk 命令其实是一个Bash脚本, 由Erik Troan所编写, 放在/sbin目录中. 
chroot
 修改ROOT目录. 一般的命令都是从$PATH中获得的, 相对的默认的根目录是 /. 这个命令
 将会把根目录修改为另一个目录(并且也将把工作目录修改到那). 出于安全目的, 这个命
 令时非常有用的, 举个例子, 当系统管理员希望限制一些特定的用户, 比如telnet上来的
 用户, 将他们限定到文件系统上一个安全的地方(这有时候被称为将一个guest用户限制在
 "chroot 监牢"中). 注意, 在使用chroot之后, 系统的二进制可执行文件的目录将不再
 可用了. 
 chroot /opt 将会使得原来的/usr/bin目录变为/opt/usr/bin. 同样,
 chroot /aaa/bbb /bin/ls 将会使得ls命令以/aaa/bbb作为根目录, 而不是以前的/. 
 如果使用alias XX 'chroot /aaa/bbb ls', 并把这句放到用户的~/.bashrc文件中的话, 
 这将可以有效地限制运行命令"XX"时, 命令"XX"可以使用文件系统的范围. 
 当从启动盘恢复的时候(chroot 到 /dev/fd0), 或者当系统从死机状态恢复过来并作为进
 入lilo的选择手段的时候, chroot命令都是非常方便的. 其它的应用还包括从不同的文件
 系统进行安装(一个rpm选项)或者从CDROM上运行一个只读文件系统. 只能以root身份调用,
 小心使用. 
 注意: 由于正常的$PATH将不再被关联了, 所以可能需要将一些特定的系统文件拷贝到
  chrooted目录中. 
lockfile
 这个工具是procmail包的一部分(www.procmail.org). 它可以创建一个锁定文件, 锁定文
 件是一种用来控制存取文件, 设备或资源的标记文件. 锁定文件就像一个标记一样被使用,
  如果特定的文件, 设备, 或资源正在被一个特定的进程所使用("busy"), 那么对于其它进
 程来说, 就只能受限进行存取(或者不能存取). 
    1 lockfile /home/bozo/lockfiles/$0.lock
    2 # 创建一个以脚本名字为前缀的写保护锁定文件. 
 锁定文件用在一些特定的场合, 比如说保护系统的mail目录以防止多个用户同时修改, 或
 者提示一个modem端口正在被存取, 或者显示Netscape的一个实例正在使用它的缓存. 脚本
 可以做一些检查工作, 比如说一个特定的进程可以创建一个锁定文件, 那么只要检查这个
 特定的进程是否在运行, 就可以判断出锁定文件是否存在了. 注意如果脚本尝试创建一个
 已经存在的锁定文件的话, 那么脚本很可能被挂起. 
 一般情况下, 应用创建或检查锁定文件都放在/var/lock目录中. [5] 脚本可以使用下面
 的方法来检测锁定文件是否存在. 
    1 appname=xyzip
    2 # 应用 "xyzip" 创建锁定文件 "/var/lock/xyzip.lock".
    3 
    4 if [ -e "/var/lock/$appname.lock" ]
    5 then
    6   ... 
flock<rojy bug>
 flock命令比lockfile命令用得少得多.Much less useful than the lockfile command 
 is flock. It sets an "advisory" lock on a file and then executes a command 
 while the lock is on. This is to prevent any other process from setting a lock 
 on that file until completion of the specified command. 
    1 flock $0 cat $0 > lockfile__$0
    2 #  Set a lock on the script the above line appears in,
    3 #+ while listing the script to stdout. 
 注意: 与lockfile不同, flock不会自动创建一个锁定文件. 
mknod
 创建块或者字符设备文件(当在系统上安装新硬盘时可能是必要的). MAKEDEV工具事实上
 具有nknod的全部功能, 而且更容易使用. 
MAKEDEV
 创建设备文件的工具. 必须在/dev目录下, 并且以root身份使用. 
  root# ./MAKEDEV
 这是mknod的高级版本. 
tmpwatch
 自动删除在指定时间内未被存取过的文件. 通常都是被cron调用, 用来删掉老的log文件. 
备份类
dump, restore
 dump 命令是一个精巧的文件系统备份工具, 通常都用在比较大的安装和网络上. [6] 它
 读取原始的磁盘分区并且以二进制形式来写备份文件. 需要备份的文件可以保存到各种各
 样的存储设备上, 包括磁盘和磁带. restore命令用来恢复dump所产生的备份. 
fdformat
 对软盘进行低级格式化. 
系统资源类 
ulimit
 设置使用系统资源的上限. 通常情况下都是使用-f选项来调用, -f用来设置文件尺寸的限
 制(ulimit -f 1000就是将文件大小限制为1M). -c(译者注: 这里应该是作者笔误, 作者
 写的是-t)选项来限制coredump(译者注: 核心转储, 程序崩溃时的内存状态写入文件)
 尺寸(ulimit -c 0 就是不要coredumps). 一般情况下, ulimit的值应该设置在
 /etc/profile 和(或)~/.bash_profile中(参见 Appendix G). 
 注意: Judicious 使用ulimit 可以保护系统免受可怕的fork炸弹的迫害. 
     1 #!/bin/bash
     2 # 这个脚本只是为了展示用.
     3 # 你要自己为运行这个脚本的后果负责 -- 它*将*凝固你的系统.
     4 
     5 while true  #  死循环.
     6 do
     7   $0 &      #  这个脚本调用自身 . . .
     8             #+ fork无限次 . . .
     9             #+ 直道系统完全不动, 因为所有的资源都耗尽了.
    10 done        #  这就是臭名卓著的 "sorcerer's appentice" 剧情.<rojy bug>(译者注:巫师的厢房?没看懂)
    11 
    12 exit 0      #  这里不会真正的推出, 因为这个脚本不会终止. 
  当这个脚本超过预先设置的限制时, 在/etc/profile中的 ulimit -Hu XX (XX 就是需
  要限制的用户进程) 可以终止这个脚本的运行. 
quota
 显示用户或组的磁盘配额. 
setquota
 从命令行中设置用户或组的磁盘配额. 
umask
 设定用户创建文件时权限的缺省mask(掩码). 也可以用来限制特定用户的默认文件属性. 
 所有用户创建的文件属性都是由umask所指定的. The (octal) 传递给umask的8进制的值定
 义了文件的权限. 比如, umask 022将会使得新文件的权限最多为755(777 与非 022) [7] 
 当然, 用户可以随后使用chmod来修改指定文件的属性. 用户一般都是将umask设置值的地
 方放在/etc/profile 和(或) ~/.bash_profile中 (参见 Appendix G). 
Example 13-10 使用umask来将输出文件隐藏起来
################################Start Script#######################################
 1 #!/bin/bash
 2 # rot13a.sh: 与"rot13.sh"脚本相同, 但是会将输出写道"安全"文件中.
 3 
 4 # 用法: ./rot13a.sh filename
 5 # 或     ./rot13a.sh <filename
 6 # 或     ./rot13a.sh 同时提供键盘输入(stdin)
 7 
 8 umask 177               #  文件创建掩码.
 9                         #  被这个脚本所创建的文件
10                         #+ 将具有600权限.
11 
12 OUTFILE=decrypted.txt   #  结果保存在"decrypted.txt"中
13                         #+ 这个文件只能够被
14                         #  这个脚本的调用者(or root)所读写.
15 
16 cat "$@" | tr 'a-zA-Z' 'n-za-mN-ZA-M' > $OUTFILE 
17 #    ^^ 从stdin 或文件中输入.         ^^^^^^^^^^ 输出重定向到文件中.
18 
19 exit 0
################################End Script######################################### 
rdev
 取得root device, swap space, 或 video mode的相关信息, 或者对它们进行修改. 通常
 说来rdev都是被lilo所使用, 但是在建立一个ram disk的时候, 这个命令也很有用. 小心
 使用, 这是一个危险的命令. 
模块类 
lsmod
 列出所有安装的内核模块. 
  bash$ lsmod
  Module                  Size  Used by
  autofs                  9456   2 (autoclean)
  opl3                   11376   0
  serial_cs               5456   0 (unused)
  sb                     34752   0
  uart401                 6384   0 [sb]
  sound                  58368   0 [opl3 sb uart401]
  soundlow                 464   0 [sound]
  soundcore               2800   6 [sb sound]
  ds                      6448   2 [serial_cs]
  i82365                 22928   2
  pcmcia_core            45984   0 [serial_cs ds i82365] 
 注意: 使用cat /proc/modules可以得到同样的结果. 
insmod
 强制一个内核模块的安装(如果可能的话, 使用modprobe来代替) 必须以root身份调用. 
rmmod
 强制卸载一个内核模块. 必须以root身份调用. 
modprobe
 模块装载器, 一般情况下都是在启动脚本中自动调用. 必须以root身份调用. 
depmod
 创建模块依赖文件, 一般都是在启动脚本中调用. 
modinfo
 输出一个可装载模块的信息. 
  bash$ modinfo hid
  filename:    /lib/modules/2.4.20-6/kernel/drivers/usb/hid.o
  description: "USB HID support drivers"
  author:      "Andreas Gal, Vojtech Pavlik <vojtech@suse.cz>"
  license:     "GPL" 
杂项类 
env
 使用设置过的或修改过(并不是修改整个系统环境)的环境变量来运行一个程序或脚本. 使
 用 [varname=xxx] 形式可以在脚本中修改环境变量. 如果没有指定参数, 那么这个命令
 将会列出所有设置的环境变量. 
 注意: 在Bash和其它的Bourne shell 衍生物中, 是可以在单一命令行上设置多个变量的. 
     1 var1=value1 var2=value2 commandXXX
     2 # $var1 和 $var2 只设置在'commandXXX'的环境中. 
 注意: 当不知道shell或解释器的路径的时候, 脚本的第一行(#!行)可以使用env. 
     1 #! /usr/bin/env perl
     2 
     3 print "This Perl script will run,\n";
     4 print "even when I don't know where to find Perl.\n";
     5 
     6 # 便于跨平台移植,
     7 # Perl程序可能没在期望的地方.
     8 # Thanks, S.C. 
ldd
 显示一个可执行文件的共享库的依赖关系. 
  bash$ ldd /bin/ls
  libc.so.6 => /lib/libc.so.6 (0x4000c000)
 /lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x80000000) 
watch 
 以指定的时间间隔来重复运行一个命令. 
 默认的时间间隔是2秒, 但时刻以使用-n选项来修改. 
    1 watch -n 5 tail /var/log/messages
    2 # 每隔5秒钟显示系统log文件的结尾, /var/log/messages. 
strip
 从可执行文件中去掉调试符号引用. 这样做可以减小尺寸, 但是就不能调试了. 
 这个命令一般都用在Makefile中, 但是很少用在shell脚本中. 
nm
 列出未strip过的编译后的2进制文件的符号. 
rdist
 远程文件分布客户机程序: 在远端服务器上同步, 克隆, 或者备份一个文件系统. 
13.1 分析一个系统脚本
---------------------
利用我们所学到的关于管理命令的知识, 让我们一起来练习分析一个系统脚本. 最简单并
且最短的系统脚本之一是killall, 这个脚本被用来在系统关机时挂起运行的脚本. 
Example 13-11 killall, 来自于 /etc/rc.d/init.d
################################Start Script#######################################
 1 #!/bin/sh
 2 
 3 # --> 本书作者所作的注释全部以"# -->"开头.
 4 
 5 # --> 这是由Miquel van Smoorenburg所编写的
 6 # --> 'rc'脚本包的一部分, <miquels@drinkel.nl.mugnet.org>.
 7 
 8 # --> 这个特殊的脚本看起来是是为Red Hat / FC所特定的,
 9 # --> (在其它的发行版中可能不会出现).
10 
11 #  停止所有正在运行的不必要的服务
12 #+ (there shouldn't be any, so this is just a sanity check)
13 
14 for i in /var/lock/subsys/*; do
15         # --> 标准的for/in循环, 但是由于"do"在同一行上,
16         # --> 所以必须添加";".
17         # 检查脚本是否在那.
18         [ ! -f $i ] && continue
19         # --> 这是一种使用"与列表"的聪明的方法, 等价于:
20         # --> if [ ! -f "$i" ]; then continue
21 
22         # 取得子系统的名字.
23         subsys=${i#/var/lock/subsys/}
24         # --> 匹配变量名, 在这里就是文件名.
25         # --> 与subsys=`basename $i`完全等价.
26  
27         # -->  从锁定文件名中获得
28         # -->+ (如果那里有锁定文件的话,
29         # -->+ 那就证明进程正在运行).
30         # -->  参考一下上边所讲的"锁定文件"的内容.
31 
32 
33         # 终止子系统.
34         if [ -f /etc/rc.d/init.d/$subsys.init ]; then
35            /etc/rc.d/init.d/$subsys.init stop
36         else
37            /etc/rc.d/init.d/$subsys stop
38         # -->  挂起运行的作业和幽灵进程.
39         # -->  注意"stop"只是一个位置参数,
40         # -->+ 并不是shell内建命令.
41         fi
42 done
################################End Script######################################### 
这个没有那么糟. 除了在变量匹配的地方玩了一点花样, 其它也没有别的材料了. 
练习 1. 在/etc/rc.d/init.d中, 分析halt脚本. 比脚本killall长一些, 但是概念上很相近. 
  对这个脚本做一个拷贝, 放到你的home目录下并且用它练习一下(不要以root身份运
  行它). 使用-vn标志来模拟运行一下(sh -vn scriptname). 添加详细的注释. 将
  "action"命令修改为"echos". 
练习 2. 察看/etc/rc.d/init.d下的更多更复杂的脚本. 看看你是不是能够理解其中的一些脚
  本. 使用上边的过程来分析这些脚本. 为了更详细的理解, 你可能也需要分析在
  usr/share/doc/initscripts-?.??目录下的文件sysvinitfile, 这些都是
  "initscript"文件的一部分. 
注意事项:
[1]  这是在Linux机器上或者在带有磁盘配额的UNIX系统上的真实情况.
[2]  如果正在被删除的特定的用户已经登录了主机, 那么 userdel 命令将会失败.
[3]  对于烧录CDR的更多的细节, 可以参见Alex Withers的文章, 创建CD, 在
  Linux Journal 的1999年的10月文章列表中.
[4]  mke2fs的-c选项也会进行坏块检查.
[5]  因为只有root用户才具有对/var/lock目录的写权限, 一般的用户脚本是不能在那里
  设置一个锁定文件的.
[6]  单用户的Linux系统的操作更倾向于使用简单的备份工具, 比如tar.
[7]  NAND(与非)是一种逻辑操作. 这种操作的效果和减法很相像. 
  
第14章 命令替换
================
命令替换将会重新分配一个命令[1]甚至是多个命令的输出; 它会将命令的输出如实地添加到
另一个上下文中. [2] 
使用命令替换的典型形式是使用后置引用(`...`). 后置引用形式的命令(就是被反引号括起来)
将会产生命令行文本. 
   1 script_name=`basename $0`
   2 echo "The name of this script is $script_name." 
这样的话, 命令的输出可以被当成传递到另一个命令的参数, 或者保存到变量中, 甚至可以用
来产生for循环的参数列表. 
   1 rm `cat filename`   # "filename" 包含了需要被删除的文件列表.
   2 #
   3 # S. C. 指出使用这种形式, 可能会产生"参数列表太长"的错误.
   4 # 更好的方法是              xargs rm -- < filename 
   5 # ( -- 同时覆盖了那些以"-"开头的文件所产生的特殊情况 )
   6 
   7 textfile_listing=`ls *.txt`
   8 # 变量中包含了当前工作目录下所有的*.txt文件.
   9 echo $textfile_listing
  10 
  11 textfile_listing2=$(ls *.txt)   # 这是命令替换的另一种形式.
  12 echo $textfile_listing2
  13 # 同样的结果.
  14 
  15 # 将文件列表放入到一个字符串中的一个可能的问题就是
  16 # 可能会混进一个新行.
  17 #
  18 # 一个安全的将文件列表传递到参数中的方法就是使用数组.
  19 #      shopt -s nullglob    # 如果不匹配, 那就不进行文件名扩展.
  20 #      textfile_listing=( *.txt )
  21 #
  22 # Thanks, S.C. 
注意: 命令替换将会调用一个subshell. 
注意: 命令替换可能会引起word splitting. 
   1 COMMAND `echo a b`     # 2个参数: a and b
   2 
   3 COMMAND "`echo a b`"   # 1个参数: "a b"
   4 
   5 COMMAND `echo`         # 无参数
   6 
   7 COMMAND "`echo`"       # 一个空的参数
   8 
   9 
  10 # Thanks, S.C. 
 即使没有引起word splitting, 命令替换也会去掉多余的新行. 
   1 # cd "`pwd`"  # 这句总会正常的工作.
   2 # 然而...
   3 
   4 mkdir 'dir with trailing newline
   5 '
   6 
   7 cd 'dir with trailing newline
   8 '
   9 
  10 cd "`pwd`"  # 错误消息:
  11 # bash: cd: /tmp/file with trailing newline: No such file or directory
  12 
  13 cd "$PWD"   # 运行良好.
  14 
  15 
  16 
  17 
  18 
  19 old_tty_setting=$(stty -g)   # 保存老的终端设置.
  20 echo "Hit a key "
  21 stty -icanon -echo           # 对终端禁用"canonical"模式.
  22                              # 这样的话, 也会禁用了*本地*的echo.
  23 key=$(dd bs=1 count=1 2> /dev/null)   # 使用'dd'命令来取得一个按键.
  24 stty "$old_tty_setting"      # 保存老的设置.
  25 echo "You hit ${#key} key."  # ${#variable} = number of characters in $variable
  26 #
  27 # 按键任何键除了回车, 那么输出就是"You hit 1 key."
  28 # 按下回车, 那么输出就是"You hit 0 key."
  29 # 新行已经被命令替换吃掉了.
  30 
  31 Thanks, S.C. 
注意: 当一个变量是使用命令替换的结果做为值的时候, 然后使用echo命令来输出这个变量
 (并且不引用这个变量, 就是不用引号括起来), 那么命令替换将会从最终的输出中删掉换
 行符. 这可能会引起一些异常情况. 
   1 dir_listing=`ls -l`
   2 echo $dir_listing     # 未引用, 就是没用引号括起来
   3 
   4 # 想打出来一个有序的目录列表.Expecting a nicely ordered directory listing.
   5 
   6 # 可惜, 下边将是我们所获得的:
   7 # total 3 -rw-rw-r-- 1 bozo bozo 30 May 13 17:15 1.txt -rw-rw-r-- 1 bozo
   8 # bozo 51 May 15 20:57 t2.sh -rwxr-xr-x 1 bozo bozo 217 Mar 5 21:13 wi.sh
   9 
  10 # 新行消失了.
  11 
  12 
  13 echo "$dir_listing"   # 用引号括起来
  14 # -rw-rw-r--    1 bozo       30 May 13 17:15 1.txt
  15 # -rw-rw-r--    1 bozo       51 May 15 20:57 t2.sh
  16 # -rwxr-xr-x    1 bozo      217 Mar  5 21:13 wi.sh 
命令替换甚至允许将整个文件的内容放到变量中, 可以使用重定向或者cat命令.
   1 variable1=`<file1`      #  将"file1"的内容放到"variable1"中.
   2 variable2=`cat file2`   #  将"file2"的内容放到"variable2"中.
   3                         #  但是这行将会fork一个新进程, This, however, forks a new process, 
   4                         #+ 所以这行代码将会比第一行代码执行得慢.
   5 
   6 #  注意:
   7 #  变量中是可以包含空白的,
   8 #+ 甚至是 (厌恶至极的), 控制字符. 
   1 #  摘录自系统文件, /etc/rc.d/rc.sysinit
   2 #+ (这是红帽安装中使用的)
   3 
   4 
   5 if [ -f /fsckoptions ]; then
   6         fsckoptions=`cat /fsckoptions`
   7 ...
   8 fi
   9 #
  10 #
  11 if [ -e "/proc/ide/${disk[$device]}/media" ] ; then
  12              hdmedia=`cat /proc/ide/${disk[$device]}/media`
  13 ...
  14 fi
  15 #
  16 #
  17 if [ ! -n "`uname -r | grep -- "-"`" ]; then
  18        ktag="`cat /proc/version`"
  19 ...
  20 fi
  21 #
  22 #
  23 if [ $usb = "1" ]; then
  24     sleep 5
  25     mouseoutput=`cat /proc/bus/usb/devices 2>/dev/null|grep -E "^I.*Cls=03.*Prot=02"`
  26     kbdoutput=`cat /proc/bus/usb/devices 2>/dev/null|grep -E "^I.*Cls=03.*Prot=01"`
  27 ...
  28 fi 
注意: 不要将一个非常长的文本文件的内容设置到一个变量中, 除非你有一个非常好的原因非
 要这么做不可. 不要将2进制文件的内容保存到变量中. 
Example 14-1 愚蠢的脚本策略
################################Start Script#######################################
 1 #!/bin/bash
 2 # stupid-script-tricks.sh: 朋友, 别在家这么做.
 3 # 来自于"Stupid Script Tricks," 卷I.
 4 
 5 
 6 dangerous_variable=`cat /boot/vmlinuz`   # 这是压缩过的Linux内核本身.
 7 
 8 echo "string-length of \$dangerous_variable = ${#dangerous_variable}"
 9 # 这个字符串变量的长度是 $dangerous_variable = 794151
10 # (不要使用'wc -c /boot/vmlinuz'来计算长度.)
11 
12 # echo "$dangerous_variable"
13 # 千万别尝试这么做! 这样将挂起这个脚本.
14 
15 
16 #  文档作者已经意识到将二进制文件设置到
17 #+ 变量中是一个没用的应用.
18 
19 exit 0
################################End Script#########################################
 注意, 在这里是不会发生缓冲区溢出错误. 因为这是一个解释型语言的实例, Bash就是一
 种解释型语言, 解释型语言会比编译型语言提供更多的对程序错误的保护措施. 
变量替换允许将一个循环的输出放入到一个变量中.这么做的关键就是将循环中echo命令的输
出全部截取. 
Example 14-2 从循环的输出中产生一个变量
################################Start Script#######################################
 1 #!/bin/bash
 2 # csubloop.sh: 从循环的输出中产生一个变量.
 3 
 4 variable1=`for i in 1 2 3 4 5
 5 do
 6   echo -n "$i"                 #  对于这里的命令替换来说
 7 done`                          #+ 这个'echo'命令是非常关键的.
 8 
 9 echo "variable1 = $variable1"  # variable1 = 12345
10 
11 
12 i=0
13 variable2=`while [ "$i" -lt 10 ]
14 do
15   echo -n "$i"                 # 再来一个, 'echo'是必须的.
16   let "i += 1"                 # 递增.
17 done`
18 
19 echo "variable2 = $variable2"  # variable2 = 0123456789
20 
21 #  这就证明了在一个变量声明中
22 #+ 嵌入一个循环是可行的.
23 
24 exit 0
################################End Script######################################### 
注意: 命令替换使得扩展有效的Bash工具集变为可能. 这样, 写一段小程序或者一段脚本就可
 以达到目的, 因为程序或脚本的输出会传到stdout上(就像一个标准的工具所做的那样), 
 然后重新将这些输出保存到变量中.(译者: 作者的意思就是在这种情况下写脚本和写程序
 作用是一样的.) 
   1 #include <stdio.h>
   2 
   3 /*  "Hello, world." C program  */  
   4 
   5 int main()
   6 {
   7   printf( "Hello, world." );
   8   return (0);
   9 } 
 bash$ gcc -o hello hello.c 
   1 #!/bin/bash
   2 # hello.sh  
   3 
   4 greeting=`./hello`
   5 echo $greeting 
 bash$ sh hello.sh
 Hello, world. 
注意: 对于命令替换来说,$(COMMAND) 形式已经取代了反引号"`". 
   1 output=$(sed -n /"$1"/p $file)   # 来自于 "grp.sh"例子.
   2        
   3 # 将一个文本的内容保存到变量中.
   4 File_contents1=$(cat $file1)      
   5 File_contents2=$(<$file2)        # Bash 也允许这么做. 
 $(...) 形式的命令替换在处理双反斜线(\\)时与`...`形式不同. 
  bash$ echo `echo \\`
  
  bash$ echo $(echo \\)
  
 $(...) 形式的命令替换是允许嵌套的. [3] 
   1 word_count=$( wc -w $(ls -l | awk '{print $9}') ) 
 或者, 可以更加灵活. . . 
Example 14-3 找anagram(回文构词法, 可以将一个有意义的单词, 变换为1个或多个有意义的单词, 但是还是原来的子母集合)
################################Start Script#######################################
 1 #!/bin/bash
 2 # agram2.sh
 3 # 关于命令替换嵌套的例子.
 4 
 5 #  使用"anagram"工具
 6 #+ 这是作者的"yawl"文字表包中的一部分.
 7 #  http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz
 8 #  http://personal.riverusers.com/~thegrendel/yawl-0.3.2.tar.gz
 9 
10 E_NOARGS=66
11 E_BADARG=67
12 MINLEN=7
13 
14 if [ -z "$1" ]
15 then
16   echo "Usage $0 LETTERSET"
17   exit $E_NOARGS         # 脚本需要一个命令行参数.
18 elif [ ${#1} -lt $MINLEN ]
19 then
20   echo "Argument must have at least $MINLEN letters."
21   exit $E_BADARG
22 fi
23 
24 
25 
26 FILTER='.......'         # 必须至少有7个字符.
27 #       1234567
28 Anagrams=( $(echo $(anagram $1 | grep $FILTER) ) )
29 #           |     |    嵌套的命令替换        | |
30 #        (              数组分配                 )
31 
32 echo
33 echo "${#Anagrams[*]}  7+ letter anagrams found"
34 echo
35 echo ${Anagrams[0]}      # 第一个anagram.
36 echo ${Anagrams[1]}      # 第二个anagram.
37                          # 等等.
38 
39 # echo "${Anagrams[*]}"  # 在一行上列出所有的anagram . . .
40 
41 #  考虑到后边还有"数组"作为单独的一章进行讲解,
42 #+ 这里就不深入了.
43 
44 # 可以参阅agram.sh脚本, 这也是一个找出anagram的例子.
45 
46 exit $?
################################End Script######################################### 
命令替换在脚本中使用的例子: 
1.  Example 10-7
2.  Example 10-26
3.  Example 9-28
4.  Example 12-3
5.  Example 12-19
6.  Example 12-15
7.  Example 12-49
8.  Example 10-13
9.  Example 10-10
10. Example 12-29 
11. Example 16-8  
12. Example A-17  
13. Example 27-2  
14. Example 12-42 
15. Example 12-43 
16. Example 12-44 
注意事项:
[1]  对于命令替换来说, 这个命令可以是外部的系统命令, 也可以是内部脚本的内建
  命令, 甚至是一个脚本函数.
[2]  从技术的角度来讲, 命令替换将会抽取出一个命令的输出, 然后使用=操作赋值到
  一个变量中.
[3]  事实上, 对于反引号的嵌套是可行的, 但是只能将内部的反引号转义才行, 就像
  John默认指出的那样. 
     1 word_count=` wc -w \`ls -l | awk '{print $9}'\` ` 
  
第15章 算术扩展
================
算术扩展提供了一种强力的工具, 可以在脚本中执行(整型)算法操作. 可以使用backticks, 
double parentheses, 或 let来将字符串转换为数字表达式. 
一些变化 
使用反引号的算术扩展(通常都是和expr一起使用) 
    1 z=`expr $z + 3`          # 'expr'命令将会执行这个扩展. 
使用双括号, 和let形式的算术扩展 
反引号形式的算术扩展已经被双括号形式所替代了 -- ((...)) 和 $((...)) -- 当然也可以
使用非常方便的let形式. 
    1 z=$(($z+3))
    2 z=$((z+3))                                  #  也正确.
    3                                             #  使用双括号的形式,
    4                                             #+ 参数解引用
    5                                             #+ 是可选的.
    6 
    7 # $((EXPRESSION)) is arithmetic expansion.  #  不要与命令
    8                                             #+ 替换相混淆.
    9 
   10 
   11 
   12 # 使用双括号的形式也可以不用给变量赋值.
   13 
   14   n=0
   15   echo "n = $n"                             # n = 0
   16 
   17   (( n += 1 ))                              # 递增.
   18 # (( $n += 1 )) is incorrect!
   19   echo "n = $n"                             # n = 1
   20 
   21 
   22 let z=z+3
   23 let "z += 3"  #  使用引用的形式, 允许在变量赋值的时候存在空格.
   24               #  'let'操作事实上执行得的是算术赋值,
   25               #+ 而不是算术扩展. 
下边是一些在脚本中使用算术扩展的例子: 
1.  Example 12-9
2.  Example 10-14
3.  Example 26-1
4.  Example 26-11
5.  Example A-17 
第16章 I/O 重定向
==================
默认情况下始终有3个"文件"处于打开状态, stdin (键盘), stdout (屏幕), and stderr 
(错误消息输出到屏幕上). 这3个文件和其他打开的文件都可以被重定向. 对于重定向简单的
解释就是捕捉一个文件, 命令, 程序, 脚本, 或者甚至是脚本中的代码块(参见 Example 3-1 
和 Example 3-2)的输出, 然后将这些输出作为输入发送到另一个文件, 命令, 程序, 或脚本
中.
每个打开的文件都会被分配一个文件描述符.[1]stdin, stdout, 和stderr的文件描述符分别
是0, 1, 和 2. 对于正在打开的额外文件, 保留了描述符3到9. 在某些时候将这些格外的文件
描述符分配给stdin, stdout, 或者是stderr作为临时的副本链接是非常有用的. [2] 在经过
复杂的重定向和刷新之后需要把它们恢复成正常的样子 (参见 Example 16-1). 
   1    COMMAND_OUTPUT >
   2       # 重定向stdout到一个文件.
   3       # 如果没有这个文件就创建, 否则就覆盖.
   4 
   5       ls -lR > dir-tree.list
   6       # 创建一个包含目录树列表的文件.
   7 
   8    : > filename
   9       # > 会把文件"filename"截断为0长度.
  10       # 如果文件不存在, 那么就创建一个0长度的文件(与'touch'的效果相同).
  11       # : 是一个占位符, 不产生任何输出.
  12 
  13    > filename    
  14       # > 会把文件"filename"截断为0长度.
  15       # 如果文件不存在, 那么就创建一个0长度的文件(与'touch'的效果相同).
  16       # (与上边的": >"效果相同, 但是在某些shell下可能不能工作.)
  17 
  18    COMMAND_OUTPUT >>
  19       # 重定向stdout到一个文件.
  20       # 如果文件不存在, 那么就创建它, 如果存在, 那么就追加到文件后边.
  21 
  22 
  23       # 单行重定向命令(只会影响它们所在的行):
  24       # --------------------------------------------------------------------
  25 
  26    1>filename
  27       # 重定向stdout到文件"filename".
  28    1>>filename
  29       # 重定向并追加stdout到文件"filename".
  30    2>filename
  31       # 重定向stderr到文件"filename".
  32    2>>filename
  33       # 重定向并追加stderr到文件"filename".
  34    &>filename
  35       # 将stdout和stderr都重定向到文件"filename".
  36 
  37       #==============================================================================
  38       # 重定向stdout, 一次一行.
  39       LOGFILE=script.log
  40 
  41       echo "This statement is sent to the log file, \"$LOGFILE\"." 1>$LOGFILE
  42       echo "This statement is appended to \"$LOGFILE\"." 1>>$LOGFILE
  43       echo "This statement is also appended to \"$LOGFILE\"." 1>>$LOGFILE
  44       echo "This statement is echoed to stdout, and will not appear in \"$LOGFILE\"."
  45       # 每行过后, 这些重定向命令会自动"reset".
  46 
  47 
  48 
  49       # 重定向stderr, 一次一行.
  50       ERRORFILE=script.errors
  51 
  52       bad_command1 2>$ERRORFILE       #  错误消息发到$ERRORFILE中.
  53       bad_command2 2>>$ERRORFILE      #  错误消息添加到$ERRORFILE中.
  54       bad_command3                    #  错误消息echo到stderr,
  55                                       #+ 并且不出现在$ERRORFILE中.
  56       # 每行过后, 这些重定向命令也会自动"reset".
  57       #==============================================================================
  58 
  59 
  60 
  61    2>&1
  62       # 重定向stderr到stdout.
  63       # 得到的错误消息与stdout一样, 发送到一个地方.
  64 
  65    i>&j
  66       # 重定向文件描述符i 到 j.
  67       # 指向i文件的所有输出都发送到j中去.
  68 
  69    >&j
  70       # 默认的, 重定向文件描述符1(stdout)到 j.
  71       # 所有传递到stdout的输出都送到j中去.
  72 
  73    0< FILENAME
  74     < FILENAME
  75       # 从文件中接受输入.
  76       # 与">"是成对命令, 并且通常都是结合使用.
  77       #
  78       # grep search-word <filename
  79 
  80 
  81    [j]<>filename
  82       # 为了读写"filename", 把文件"filename"打开, 并且分配文件描述符"j"给它.
  83       # 如果文件"filename"不存在, 那么就创建它.
  84       # 如果文件描述符"j"没指定, 那默认是fd 0, stdin.
  85       #
  86       # 这种应用通常是为了写到一个文件中指定的地方.
  87       echo 1234567890 > File    # 写字符串到"File".
  88       exec 3<> File             # 打开"File"并且给它分配fd 3.
  89       read -n 4 <&3             # 只读4个字符.
  90       echo -n . >&3             # 写一个小数点.
  91       exec 3>&-                 # 关闭fd 3.
  92       cat File                  # ==> 1234.67890
  93       # 随机存储.
  94 
  95 
  96 
  97    |
  98       # 管道.
  99       # 通用目的的处理和命令链工具.
 100       # 与">"很相似, 但是实际上更通用.
 101       # 对于想将命令, 脚本, 文件和程序串连起来的时候很有用.
 102       cat *.txt | sort | uniq > result-file
 103       # 对所有的.txt文件的输出进行排序, 并且删除重复行,
 104       # 最后将结果保存到"result-file"中. 
可以将输入输出重定向和(或)管道的多个实例结合到一起写在一行上. 
   1 command < input-file > output-file
   2 
   3 command1 | command2 | command3 > output-file
参见 Example 12-28 和 Example A-15. 
可以将多个输出流重定向到一个文件上. 
   1 ls -yz >> command.log 2>&1
   2 #  将错误选项"yz"的结果放到文件"command.log"中.
   3 #  因为stderr被重定向到这个文件中,
   4 #+ 所有的错误消息也就都指向那里了.
   5 
   6 #  注意, 下边这个例子就不会给出相同的结果.
   7 ls -yz 2>&1 >> command.log
   8 #  输出一个错误消息, 但是并不写到文件中.
   9 
  10 #  如果将stdout和stderr都重定向,
  11 #+ 命令的顺序会有些不同. 
关闭文件描述符 
n<&-  关闭输入文件描述符n.
0<&-, <&- 关闭stdin.
n>&-  关闭输出文件描述符n.
1>&-, >&- 关闭stdout. 
子进程继承了打开的文件描述符. 这就是为什么管道可以工作. 如果想阻止fd被继承, 那么可
以关掉它. 
   1 # 只重定向stderr到一个管道.
   2 
   3 exec 3>&1                              # 保存当前stdout的"值".
   4 ls -l 2>&1 >&3 3>&- | grep bad 3>&-    # 对'grep'关闭fd 3(但不关闭'ls').
   5 #              ^^^^   ^^^^
   6 exec 3>&-                              # 现在对于剩余的脚本关闭它.
   7 
   8 # Thanks, S.C. 
如果想了解关于I/O重定向更多的细节参见 附录 E. 
16.1. 使用exec
--------------
exec <filename 命令会将stdin重定向到文件中. 从这句开始, 后边的输入就都来自于这个文
件了, 而不是标准输入了(通常都是键盘输入). 这样就提供了一种按行读取文件的方法, 并且
可以使用sed 和/或 awk来对每一行进行分析. 
Example 16-1 使用exec重定向标准输入
################################Start Script#######################################
 1 #!/bin/bash
 2 # 使用'exec'重定向标准输入.
 3 
 4 
 5 exec 6<&0          # 将文件描述符#6与stdin链接起来.
 6                    # 保存了stdin.
 7 
 8 exec < data-file   # stdin被文件"data-file"所代替.
 9 
10 read a1            # 读取文件"data-file"的第一行.
11 read a2            # 读取文件"data-file"的第二行.
12 
13 echo
14 echo "Following lines read from file."
15 echo "-------------------------------"
16 echo $a1
17 echo $a2
18 
19 echo; echo; echo
20 
21 exec 0<&6 6<&-
22 #  现在将stdin从fd #6中恢复, 因为刚才我们把stdin重定向到#6了,
23 #+ 然后关闭fd #6 ( 6<&- ), 好让这个描述符继续被其他进程所使用.
24 #
25 # <&6 6<&-    这么做也可以.
26 
27 echo -n "Enter data  "
28 read b1  # 现在"read"已经恢复正常了, 就是从stdin中读取.
29 echo "Input read from stdin."
30 echo "----------------------"
31 echo "b1 = $b1"
32 
33 echo
34 
35 exit 0
################################End Script######################################### 
同样的, exec >filename 命令将会把stdout重定向到一个指定的文件中. 这样所有的命令输
出就都会发向那个指定的文件, 而不是stdout. 
Example 16-2 使用exec来重定向stdout
################################Start Script#######################################
 1 #!/bin/bash
 2 # reassign-stdout.sh
 3 
 4 LOGFILE=logfile.txt
 5 
 6 exec 6>&1           # 将fd #6与stdout相连接.
 7                     # 保存stdout.
 8 
 9 exec > $LOGFILE     # stdout就被文件"logfile.txt"所代替了.
10 
11 # ----------------------------------------------------------- #
12 # 在这块中所有命令的输出就都发向文件 $LOGFILE.
13 
14 echo -n "Logfile: "
15 date
16 echo "-------------------------------------"
17 echo
18 
19 echo "Output of \"ls -al\" command"
20 echo
21 ls -al
22 echo; echo
23 echo "Output of \"df\" command"
24 echo
25 df
26 
27 # ----------------------------------------------------------- #
28 
29 exec 1>&6 6>&-      # 恢复stdout, 然后关闭文件描述符#6.
30 
31 echo
32 echo "== stdout now restored to default == "
33 echo
34 ls -al
35 echo
36 
37 exit 0
################################End Script######################################### 
Example 16-3 使用exec在同一脚本中重定向stdin和stdout
################################Start Script#######################################
 1 #!/bin/bash
 2 # upperconv.sh
 3 # 将一个指定的输入文件转换为大写.
 4 
 5 E_FILE_ACCESS=70
 6 E_WRONG_ARGS=71
 7 
 8 if [ ! -r "$1" ]     # 判断指定的输入文件是否可读?
 9 then
10   echo "Can't read from input file!"
11   echo "Usage: $0 input-file output-file"
12   exit $E_FILE_ACCESS
13 fi                   #  即使输入文件($1)没被指定
14                      #+ 也还是会以相同的错误退出(为什么?).
15 
16 if [ -z "$2" ]
17 then
18   echo "Need to specify output file."
19   echo "Usage: $0 input-file output-file"
20   exit $E_WRONG_ARGS
21 fi
22 
23 
24 exec 4<&0
25 exec < $1            # 将会从输入文件中读取.
26 
27 exec 7>&1
28 exec > $2            # 将写到输出文件中.
29                      # 假设输出文件是可写的(添加检查?).
30 
31 # -----------------------------------------------
32     cat - | tr a-z A-Z   # 转换为大写.
33 #   ^^^^^                # 从stdin中读取.Reads from stdin.
34 #           ^^^^^^^^^^   # 写到stdout上.
35 # 然而, stdin和stdout都被重定向了.
36 # -----------------------------------------------
37 
38 exec 1>&7 7>&-       # 恢复 stout.
39 exec 0<&4 4<&-       # 恢复 stdin.
40 
41 # 恢复之后, 下边这行代码将会如期望的一样打印到stdout上.
42 echo "File \"$1\" written to \"$2\" as uppercase conversion."
43 
44 exit 0
################################End Script######################################### 
I/O重定向是一种避免可怕的子shell中不可存取变量问题的方法. 
Example 16-4 避免子shell
################################Start Script#######################################
 1 #!/bin/bash
 2 # avoid-subshell.sh
 3 # Matthew Walker提出的建议.
 4 
 5 Lines=0
 6 
 7 echo
 8 
 9 cat myfile.txt | while read line;  #  (译者注: 管道会产生子shell)
10                  do {
11                    echo $line
12                    (( Lines++ ));  #  增加这个变量的值
13                                    #+ 但是外部循环却不能存取.
14                                    #  子shell问题.
15                  }
16                  done
17 
18 echo "Number of lines read = $Lines"     # 0
19                                          # 错误!
20 
21 echo "------------------------"
22 
23 
24 exec 3<> myfile.txt
25 while read line <&3
26 do {
27   echo "$line"
28   (( Lines++ ));                   #  增加这个变量的值
29                                    #+ 现在外部循环就可以存取了.
30                                    #  没有子shell, 现在就没问题了.
31 }
32 done
33 exec 3>&-
34 
35 echo "Number of lines read = $Lines"     # 8
36 
37 echo
38 
39 exit 0
40 
41 # 下边这些行是脚本的结果, 脚本是不会走到这里的.
42 
43 $ cat myfile.txt
44 
45 Line 1.
46 Line 2.
47 Line 3.
48 Line 4.
49 Line 5.
50 Line 6.
51 Line 7.
52 Line 8.
################################End Script######################################### 
注意事项:
[1]  一个文件描述符说白了就是文件系统为了跟踪这个打开的文件而分配给它的一个数字.
  也可以的将其理解为文件指针的一个简单版本. 与C中的文件句柄的概念相似.
[2]  使用文件描述符5可能会引起问题. 当Bash使用exec创建一个子进程的时候, 子进程
  会继承fd5(参见Chet Ramey的归档e-mail, SUBJECT: RE: File descriptor 5 is 
  held open). 最好还是不要去招惹这个特定的fd. 
第17章 Here Documents
======================
here document 就是一段特殊目的的代码块. 他使用I/O 重定向的形式来将一个命令序列传递
到一个交互程序或者命令中, 比如ftp, cat, 或者ex文本编辑器. 
   1 COMMAND <<InputComesFromHERE
   2 ...
   3 InputComesFromHERE 
limit string 用来划定命令序列的范围(译者注: 两个相同的limit string之间就是命令序列)
. 特殊符号 << 用来表识limit string. 这个符号具有重定向文件的输出到程序或命令的输入
的作用. 与 interactive-program < command-file 很相象, command-file包含: 
   1 command #1
   2 command #2
   3 ... 
而here document 的形式看上去是如下的样子: 
   1 #!/bin/bash
   2 interactive-program <<LimitString
   3 command #1
   4 command #2
   5 ...
   6 LimitString 
选择一个名字非常诡异的limit string将会避免命令列表和limit string重名的问题. 
注意,某些时候here document 用在非交互工具和命令上的时候也会有好的效果, 比如, wall. 
Example 17-1 广播: 发送消息给每个登录上的用户
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 wall <<zzz23EndOfMessagezzz23
 4 E-mail your noontime orders for pizza to the system administrator.
 5     (Add an extra dollar for anchovy or mushroom topping.)
 6 # 额外的消息文本写在这里.
 7 # 注意: 'wall' 会打印注释行.
 8 zzz23EndOfMessagezzz23
 9 
10 # 可以使用更有效率的做法
11 #         wall <message-file
12 #  然而将消息模版嵌入到脚本中
13 #+ 是一种"小吃店"(快速但是比较脏)的只能使用一次的解决办法.
14 
15 exit 0
################################End Script######################################### 
即使是某些不大可能的工具, 如vi也可以使用here document. 
Example 17-2 仿造文件: 创建一个两行的仿造文件
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # 用非交互的方式来使用'vi'编辑一个文件.
 4 # 模仿'sed'.
 5 
 6 E_BADARGS=65
 7 
 8 if [ -z "$1" ]
 9 then
10   echo "Usage: `basename $0` filename"
11   exit $E_BADARGS
12 fi
13 
14 TARGETFILE=$1
15 
16 # 在文件中插入两行, 然后保存.
17 #--------Begin here document-----------#
18 vi $TARGETFILE <<x23LimitStringx23
19 i
20 This is line 1 of the example file.
21 This is line 2 of the example file.
22 ^[
23 ZZ
24 x23LimitStringx23
25 #----------End here document-----------#
26 
27 #  注意上边^[是一个转义符,键入Ctrl+v <Esc>就行,
28 #+ 事实上它是<Esc>键.
29 
30 #  Bram Moolenaar指出这种方法不能正常地用在'vim'上, (译者注: Bram Moolenaar是vim作者)
31 #+ 因为可能会有终端的相互影响问题.
32 
33 exit 0
################################End Script######################################### 
上边的脚本也可以不用vi而用ex来实现. Here document 包含ex命令列表的做法足够形成自己
的类别了, 叫ex scripts. 
   1 #!/bin/bash
   2 #  把所有后缀为".txt"文件
   3 #+ 中的"Smith"都替换成"Jones".
   4 
   5 ORIGINAL=Smith
   6 REPLACEMENT=Jones
   7 
   8 for word in $(fgrep -l $ORIGINAL *.txt)
   9 do
  10   # -------------------------------------
  11   ex $word <<EOF
  12   :%s/$ORIGINAL/$REPLACEMENT/g
  13   :wq
  14 EOF
  15   # :%s 是"ex"的替换命令.
  16   # :wq 是保存并退出的意思.
  17   # -------------------------------------
  18 done 
与"ex scripts"相似的是cat scripts. 
Example 17-3 使用cat的多行消息
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 #  'echo' 对于打印单行消息是非常好的,
 4 #+  但是在打印消息块时可能就有点问题了.
 5 #   'cat' here document可以解决这个限制.
 6 
 7 cat <<End-of-message
 8 -------------------------------------
 9 This is line 1 of the message.
10 This is line 2 of the message.
11 This is line 3 of the message.
12 This is line 4 of the message.
13 This is the last line of the message.
14 -------------------------------------
15 End-of-message
16 
17 #  用下边这行代替上边的第7行
18 #+   cat > $Newfile <<End-of-message
19 #+       ^^^^^^^^^^
20 #+ 那么就会把输出写到文件$Newfile中, 而不是stdout.
21 
22 exit 0
23 
24 
25 #--------------------------------------------
26 # 下边的代码不会运行, 因为上边的"exit 0".
27 
28 # S.C. 指出下边代码也可以运行.
29 echo "-------------------------------------
30 This is line 1 of the message.
31 This is line 2 of the message.
32 This is line 3 of the message.
33 This is line 4 of the message.
34 This is the last line of the message.
35 -------------------------------------"
36 # 然而, 文本可能不包含双引号, 除非它们被转义.
################################End Script######################################### 
- 选项用来标记here document的limit string (<<-LimitString), 可以抑制输出时前边的tab
(不是空格). 这可以增加一个脚本的可读性. 
Example 17-4 带有抑制tab功能的多行消息
################################Start Script#######################################
 1 #!/bin/bash
 2 # 与之前的例子相同, 但是...
 3 
 4 #  - 选项对于here docutment来说,<<-
 5 #+ 可以抑制文档体前边的tab,
 6 #+ 而*不*是空格 *not* spaces.
 7 
 8 cat <<-ENDOFMESSAGE
 9  This is line 1 of the message.
10  This is line 2 of the message.
11  This is line 3 of the message.
12  This is line 4 of the message.
13  This is the last line of the message.
14 ENDOFMESSAGE
15 # 脚本在输出的时候左边将被刷掉.
16 # 就是说每行前边的tab将不会显示.
17 
18 # 上边5行"消息"的前边都是tab, 不是空格.
19 # 空格是不受<<-影响的.
20 
21 # 注意, 这个选项对于*嵌在*中间的tab没作用.
22 
23 exit 0
################################End Script######################################### 
here document 支持参数和命令替换. 所以也可以给here document的消息体传递不同的参数, 
这样相应的也会修改输出. 
Example 17-5 使用参数替换的here document
################################Start Script#######################################
 1 #!/bin/bash
 2 # 一个使用'cat'命令的here document, 使用了参数替换
 3 
 4 # 不传命令行参数给它,   ./scriptname
 5 # 传一个命令行参数给它,   ./scriptname Mortimer
 6 # 传一个2个单词(用引号括起来)的命令行参数给它,
 7 #                           ./scriptname "Mortimer Jones"
 8 
 9 CMDLINEPARAM=1     #  所期望的最少的命令行参数的个数.
10 
11 if [ $# -ge $CMDLINEPARAM ]
12 then
13   NAME=$1          #  如果命令行参数超过1个,
14                    #+ 那么就只取第一个参数.
15 else
16   NAME="John Doe"  #  默认情况下, 如果没有命令行参数的话.
17 fi  
18 
19 RESPONDENT="the author of this fine script"  
20   
21 
22 cat <<Endofmessage
23 
24 Hello, there, $NAME.
25 Greetings to you, $NAME, from $RESPONDENT.
26 
27 # This comment shows up in the output (why?).
28 
29 Endofmessage
30 
31 # 注意上边的空行也打印到输出,
32 # 而上边那行"注释"当然也会打印到输出.
33 # (译者注: 这就是为什么不翻译那行注释的原因, 尽量保持原代码的原样)
34 exit 0
################################End Script######################################### 
这是一个包含参数替换的here document的有用的脚本. 
Example 17-6 上传一个文件对到"Sunsite"的incoming目录
################################Start Script#######################################
 1 #!/bin/bash
 2 # upload.sh
 3 
 4 #  上传文件对(Filename.lsm, Filename.tar.gz)
 5 #+ 到Sunsite/UNC (ibiblio.org)的incoming目录.
 6 #  Filename.tar.gz是自身的tar包.
 7 #  Filename.lsm是描述文件.
 8 #  Sunsite需要"lsm"文件, 否则就拒绝贡献.
 9 
10 
11 E_ARGERROR=65
12 
13 if [ -z "$1" ]
14 then
15   echo "Usage: `basename $0` Filename-to-upload"
16   exit $E_ARGERROR
17 fi  
18 
19 
20 Filename=`basename $1`           # 从文件名中去掉目录字符串.
21 
22 Server="ibiblio.org"
23 Directory="/incoming/Linux"
24 #  在这里也不一定非得将上边的参数写死在这个脚本中,
25 #+ 可以使用命令行参数的方法来替换.
26 
27 Password="your.e-mail.address"   # 可以修改成相匹配的密码.
28 
29 ftp -n $Server <<End-Of-Session
30 # -n 选项禁用自动登录.
31 
32 user anonymous "$Password"
33 binary
34 bell                             # 在每个文件传输后, 响铃.
35 cd $Directory
36 put "$Filename.lsm"
37 put "$Filename.tar.gz"
38 bye
39 End-Of-Session
40 
41 exit 0
################################End Script######################################### 
在here document的开头引用或转义"limit string"会使得here document的消息体中的参数替
换被禁用. 
Example 17-7 关闭参数替换
################################Start Script#######################################
 1 #!/bin/bash
 2 #  一个使用'cat'的here document, 但是禁用了参数替换.
 3 
 4 NAME="John Doe"
 5 RESPONDENT="the author of this fine script"  
 6 
 7 cat <<'Endofmessage'
 8 
 9 Hello, there, $NAME.
10 Greetings to you, $NAME, from $RESPONDENT.
11 
12 Endofmessage
13 
14 #  当"limit string"被引用或转义那么就禁用了参数替换.
15 #  下边的两种方式具有相同的效果.
16 #  cat <<"Endofmessage"
17 #  cat <<\Endofmessage
18 
19 exit 0
################################End Script######################################### 
禁用了参数替换后, 将允许输出文本本身(译者注: 就是未转义的原文). 产生脚本甚至是程序
代码就是这种用法的用途之一. 
Example 17-8 一个产生另外一个脚本的脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 # generate-script.sh
 3 # 基于Albert Reiner的一个主意.
 4 
 5 OUTFILE=generated.sh         # 所产生文件的名字.
 6 
 7 
 8 # -----------------------------------------------------------
 9 # 'Here document包含了需要产生的脚本的代码.
10 (
11 cat <<'EOF'
12 #!/bin/bash
13 
14 echo "This is a generated shell script."
15 #  Note that since we are inside a subshell,
16 #+ we can't access variables in the "outside" script.
17 
18 echo "Generated file will be named: $OUTFILE"
19 #  Above line will not work as normally expected
20 #+ because parameter expansion has been disabled.
21 #  Instead, the result is literal output.
22 
23 a=7
24 b=3
25 
26 let "c = $a * $b"
27 echo "c = $c"
28 
29 exit 0
30 EOF
31 ) > $OUTFILE
32 # -----------------------------------------------------------
33 
34 #  将'limit string'引用起来将会阻止上边
35 #+ here document的消息体中的变量扩展.
36 #  这会使得输出文件中的内容保持here document消息体中的原文.
37 
38 if [ -f "$OUTFILE" ]
39 then
40   chmod 755 $OUTFILE
41   # 让所产生的文件具有可执行权限.
42 else
43   echo "Problem in creating file: \"$OUTFILE\""
44 fi
45 
46 #  这个方法也用来产生
47 #+ C程序代码, Perl程序代码, Python程序代码, makefile,
48 #+ 和其他的一些类似的代码.
49 #  (译者注: 中间一段没译的注释将会被here document打印出来)
50 exit 0
################################End Script######################################### 
也可以将here document的输出保存到变量中. 
   1 variable=$(cat <<SETVAR
   2 This variable
   3 runs over multiple lines.
   4 SETVAR)
   5 
   6 echo "$variable" 
同一脚本中的函数也可以接受here document的输出作为自身的参数. 
Example 17-9 Here documents与函数
################################Start Script#######################################
 1 #!/bin/bash
 2 # here-function.sh
 3 
 4 GetPersonalData ()
 5 {
 6   read firstname
 7   read lastname
 8   read address
 9   read city 
10   read state 
11   read zipcode
12 } # 这个函数无疑的看起来就一个交互函数, 但是...
13 
14 
15 # 给上边的函数提供输入.
16 GetPersonalData <<RECORD001
17 Bozo
18 Bozeman
19 2726 Nondescript Dr.
20 Baltimore
21 MD
22 21226
23 RECORD001
24 
25 
26 echo
27 echo "$firstname $lastname"
28 echo "$address"
29 echo "$city, $state $zipcode"
30 echo
31 
32 exit 0
################################End Script######################################### 
也可以这么使用: 做一个假命令来从一个here document中接收输出. 这么做事实上就是创建了
一个"匿名"的here document. 
Example 17-10 "匿名" here Document
################################Start Script#######################################
1 #!/bin/bash
2 
3 : <<TESTVARIABLES
4 ${HOSTNAME?}${USER?}${MAIL?}  # 如果其中一个变量没被设置, 那么就打印错误信息.
5 TESTVARIABLES
6 
7 exit 0
################################End Script######################################### 
注意: 上边所示技术的一种变化可以用来"注释"掉代码块. 
Example 17-11 注释掉一段代码块
################################Start Script#######################################
 1 #!/bin/bash
 2 # commentblock.sh
 3 
 4 : <<COMMENTBLOCK
 5 echo "This line will not echo."
 6 This is a comment line missing the "#" prefix.
 7 This is another comment line missing the "#" prefix.
 8 
 9 &*@!!++=
10 The above line will cause no error message,
11 because the Bash interpreter will ignore it.
12 COMMENTBLOCK
13 
14 echo "Exit value of above \"COMMENTBLOCK\" is $?."   # 0
15 # 这里将不会显示任何错误.
16 
17 
18 #  上边的这种技术当然也可以用来注释掉
19 #+ 一段正在使用的代码, 如果你有某些特定调试要求的话.
20 #  这将比对每行都敲入"#"来得方便的多,
21 #+ 而且如果你想恢复的话, 还得将添加上的"#"删除掉.
22 
23 : <<DEBUGXXX
24 for file in *
25 do
26  cat "$file"
27 done
28 DEBUGXXX
29 
30 exit 0
################################End Script######################################### 
注意: 关于这种小技巧的另一个应用就是能够产生自文档化(self-documenting)的脚本. 
Example 17-12 一个自文档化(self-documenting)的脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 # self-document.sh: 自文档化(self-documenting)的脚本
 3 # Modification of "colm.sh".
 4 
 5 DOC_REQUEST=70
 6 
 7 if [ "$1" = "-h"  -o "$1" = "--help" ]     # 请求帮助.
 8 then
 9   echo; echo "Usage: $0 [directory-name]"; echo
10   sed --silent -e '/DOCUMENTATIONXX$/,/^DOCUMENTATIONXX$/p' "$0" |
11   sed -e '/DOCUMENTATIONXX$/d'; exit $DOC_REQUEST; fi
12 
13 
14 : <<DOCUMENTATIONXX
15 List the statistics of a specified directory in tabular format.
16 ---------------------------------------------------------------
17 The command line parameter gives the directory to be listed.
18 If no directory specified or directory specified cannot be read,
19 then list the current working directory.
20 
21 DOCUMENTATIONXX
22 
23 if [ -z "$1" -o ! -r "$1" ]
24 then
25   directory=.
26 else
27   directory="$1"
28 fi  
29 
30 echo "Listing of "$directory":"; echo
31 (printf "PERMISSIONS LINKS OWNER GROUP SIZE MONTH DAY HH:MM PROG-NAME\n" \
32 ; ls -l "$directory" | sed 1d) | column -t
33 
34 exit 0
################################End Script######################################### 
使用cat 脚本 也能够完成相同的目的. 
   1 DOC_REQUEST=70
   2 
   3 if [ "$1" = "-h"  -o "$1" = "--help" ]     # 请求帮助.
   4 then                                       # 使用"cat 脚本" . . .
   5   cat <<DOCUMENTATIONXX
   6 List the statistics of a specified directory in tabular format.
   7 ---------------------------------------------------------------
   8 The command line parameter gives the directory to be listed.
   9 If no directory specified or directory specified cannot be read,
  10 then list the current working directory.
  11 
  12 DOCUMENTATIONXX
  13 exit $DOC_REQUEST
  14 fi 
参见 Example A-27 可以了解更多关于自文档化脚本的好例子. 
注意: Here document创建临时文件, 但是这些文件将在打开后被删除, 并且不能够被任何其
 他进程所存取. 
  bash$ bash -c 'lsof -a -p $$ -d0' << EOF
  > EOF
  lsof    1213 bozo    0r   REG    3,5    0 30386 /tmp/t1213-0-sh (deleted) 
注意: 某些工具是不能工作在here document中的.
警告: 结束的limit string, 就是here document最后一行的limit string, 必须开始于第一
 个字符位置. 它的前面不能够有任何前置的空白. 而在这个limit string后边的空白也会
 引起异常问题. 空白将会阻止limit string的识别.(译者注: 下边这个脚本由于结束
 limit string的问题, 造成脚本无法结束, 所有内容全部被打印出来, 所以注释就不译了,
  保持例子脚本的原样.) 
   1 #!/bin/bash
   2 
   3 echo "----------------------------------------------------------------------"
   4 
   5 cat <<LimitString
   6 echo "This is line 1 of the message inside the here document."
   7 echo "This is line 2 of the message inside the here document."
   8 echo "This is the final line of the message inside the here document."
   9      LimitString
  10 #^^^^Indented limit string. Error! This script will not behave as expected.
  11 
  12 echo "----------------------------------------------------------------------"
  13 
  14 #  These comments are outside the 'here document',
  15 #+ and should not echo.
  16 
  17 echo "Outside the here document."
  18 
  19 exit 0
  20 
  21 echo "This line had better not echo."  # Follows an 'exit' command. 
对于那些使用"here document"得非常复杂的任务, 最好考虑使用expect脚本语言, 这种语言
就是为了达到向交互程序添加输入的目的而量身定做的. 
17.1. Here Strings
------------------
here string 可以被认为是here document的一种定制形式. 除了COMMAND <<<$WORD 就什么都
没有了, $WORD将被扩展并且被送入COMMAND的stdin中. 
Example 17-13 在一个文件的开头添加文本
################################Start Script#######################################
 1 #!/bin/bash
 2 # prepend.sh: 在文件的开头添加文本.
 3 #
 4 #  Kenny Stauffer所捐助的脚本例子,
 5 #+ 被本文作者作了少量的修改.
 6 
 7 
 8 E_NOSUCHFILE=65
 9 
10 read -p "File: " file   # 'read'命令的 -p 参数显示提示符.
11 if [ ! -e "$file" ]
12 then   # 如果没有这个文件那就进来.
13   echo "File $file not found."
14   exit $E_NOSUCHFILE
15 fi
16 
17 read -p "Title: " title
18 cat - $file <<<$title > $file.new
19 
20 echo "Modified file is $file.new"
21 
22 exit 0
23 
24 # 下边是'man bash'中的一段:
25 # Here Strings
26 #  here document的一种变形,形式如下:
27 # 
28 #   <<<word
29 # 
30 #   word被扩展并且提供到command的标准输入中.
################################End Script######################################### 
练习: 找出here string的其他用法. 
第18章 休息时间 
================
这个神奇的暂停可以给读者一个休息的机会, 可能读者到了这里也会会心一笑吧. 
Linux同志们, 向你们致敬! 你正在阅读的这些东西, 将会给你们带来好运. 把这份文档发给你
的10个朋友. 在拷贝这份文档之前, 在信的结尾写上一个100行的Bash脚本发送给列表上的第一
个人. 然后在信的底部删除它们的名字并添加你自己的名字. 
不要打断这个链条! 并且在48小时之内完成它. 
Brooklyn的Wilfred?P.没有成功的发送他的10个拷贝, 当他第2天早上醒来发现他的工作变成了
"COBOL 程序员". Newport?News的Howard?L.在一个月内才发出了他的10个拷贝, 这个时间足够
建立一个100个节点的Beowulf cluster来玩Tuxracer了. Chicago的Amelia?V.对这封信付之一
笑并且打断了这个链条, 不久之后, 她的终端爆炸了, 她现在花了好多天时间为MS Windows写
文档. 
千万不要打断这个链条! 今天就把10个拷贝发出去! 
[]     
    
高级Bash脚本编程指南(五)（上）
文章整理: 文章来源: 网络 
高级Bash脚本编程指南(五) 
  
  
  
第四部分 高级
++++++++++++++++
到了这儿,我们将要准备深入脚本编程中一些难的,不寻常的话题.随着话题的展开,我们会
以多种方法和检测边界条件的方式来“打开信封”,看个明白.(当我们涉足未知领域时会发
生什么?). 
目录
19. Regular Expressions正则表达式
20. 子shell(Subshells)
21. 受限shell(Restricted Shells)
22. 进程替换
23. 函数
24. 别名(Aliases)
25. 列表结构
26. 数组
27. /dev和/proc
28. 关于Zeros和Nulls
29. 调试
30. 选项
31. 检查遗漏(Gotchas)
32. 脚本编程风格
33. 杂项
34. Bash,版本2和3 
第19章 正则表达式
==================
为了充分发挥shell编程的威力, 你需要精通正则表达式. 一些命令和软件包普遍在脚本编程中
使用正则表达式,例如grep, expr, sed和awk. 
19.1 一个简要的正则表达式介绍
--------------------------------
一个正式表达式是一个字符串.字符串里的字符被称为元字符,它们可能表示了比它们字面上看
起来的意思更丰富的含义.例如,一个引用符号可能表示引用一个人演讲中的话,或者表示下
面将要讲到的引申表示的意思.正则表达式是一个字符或/和元字符组合成的字符集,它们匹配
(或指定)一个模式. 
一个正则表达式包含下面一个或多个项: 
 1. 一个字符集.
  这里的字符集里的字符表示的就是它们字面上的意思.正则表达式最简单的情况就是仅
  仅由字符集组成,而没有其他的元字符. 
 2. 锚. 
  一个锚指明了正则表达式在一行文本中要匹配的位置,例如^和$就是锚. 
 3. 修饰符
  它们用于展开或缩小(即是修改了)正则表达式匹配文本行的范围.修饰符包括了星号.
  括号和反斜杠符号. 
正则表达是的主要作用是用来文本搜索和字串操作.一个正则表达式匹配一个字符或是一串字
符--完整的一串字符或是另外一个字符串的子串. 
星号  -- * -- 匹配前一个字符的任意多次(包括零次).
   "1133*"匹配11 + 一个或更多的3 + 可能的其他字符: 113, 1133, 111312, 等等. 
点   -- . -- 匹配除了新行符之外的任意一个字符. [1]
   "13." 匹配13 + 至少一个任意字符(包括空格): 1133, 11333, 但不匹配 13 
   (因为少了附加的至少一个任意字符). 
脱字符  -- ^ -- 匹配一行的开头,但依赖于上下文环境,可能在正则表达式中表示否定
   一个字符集的意思. 
美元符  -- $ -- 在正则表达式中匹配行尾.
   "^$" 匹配空行. 
方括号  -- [...] -- 在正则表达式中表示匹配括号中的一个字符.
   "[xyz]" 匹配字符x, y, 或z. 
   "[c-n]" 匹配从字符c到n之间的任意一个字符. 
   "[B-Pk-y]" 匹配从B到P 或从k到y的任意一个字符. 
   "[a-z0-9]" 匹配任意小写字母或数字. 
   "[^b-d]" 匹配除了从b到d范围内所有的字符. 这是正则表达式中反转意思或取否
   的一 个例子.(就好像在别的情形中!字符所扮演的角色). 
   多个方括号字符集组合使用可以匹配一般的单词和数字模式."[Yy][Ee][Ss]" 匹
   配yes, Yes, YES, yEs, 等等. 
   "[0-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]"匹配社会安全码
   (Social Security number). 
反斜杠字符 -- \ -- 转义(escapes) 一个特殊的字符,使这个字符表示原来字面上的意思.
   "\$"表示了原来的字面意思"$",而不是在正则表达式中表达的匹配行尾的意思.
   同样,"\\"也被解释成了字面上的意思"\". 
转义(escape)"尖角号" -- \<...\> -- 用于表示单词的边界.
      尖角号必须被转义,因为不这样做的话它们就表示单纯的字面意思
      而已. 
      "\<the\>" 匹配单词"the",但不匹配"them", "there", "other", 
      等等. 
   bash$ cat textfile
   This is line 1, of which there is only one instance.
   This is the only instance of line 2.
   This is line 3, another line.
   This is line 4.
   
   
   bash$ grep 'the' textfile
   This is line 1, of which there is only one instance.
   This is the only instance of line 2.
   This is line 3, another line.
   
   
   bash$ grep '\<the\>' textfile
   This is the only instance of line 2. 
 确定正则表达式能否工作的唯一办法是测试它. 
    1 TEST FILE: tstfile                          # 不匹配.
    2                                             # 不匹配.
    3 Run   grep "1133*"  on this file.           # 匹配.
    4                                             # 不匹配.
    5                                             # 不匹配.
    6 This line contains the number 113.          # 匹配.
    7 This line contains the number 13.           # 不匹配.
    8 This line contains the number 133.          # 不匹配.
    9 This line contains the number 1133.         # 匹配.
   10 This line contains the number 113312.       # 匹配.
   11 This line contains the number 1112.         # 不匹配.
   12 This line contains the number 113312312.    # 匹配.
   13 This line contains no numbers at all.       # 不匹配. 
  bash$ grep "1133*" tstfile
  Run   grep "1133*"  on this file.           # 匹配.
  This line contains the number 113.          # 匹配.
  This line contains the number 1133.         # 匹配.
  This line contains the number 113312.       # 匹配.
  This line contains the number 113312312.    # 匹配. 
扩展的正则表达式. 增加了一些元字符到上面提到的基本的元字符集合里. 它们在egrep, 
     awk,和Perl中使用. 
问号  -- ? -- 匹配零或一个前面的字符. 它一般用于匹配单个字符. 
加号  -- + -- 匹配一个或多个前面的字符.它的作用和*很相似,但唯一的区别是它不
   匹配零个字符的情况. 
     1 # GNU 版本的 sed 和 awk 可以使用"+",
     2 # 但它应该转义一下.
     3 
     4 echo a111b | sed -ne '/a1\+b/p'
     5 echo a111b | grep 'a1\+b'
     6 echo a111b | gawk '/a1+b/'
     7 # 上面三句都是等价的效果.
     8 
     9 # 多谢, S.C. 
转义"大括号" -- \{ \} -- 指示前面正则表达式匹配的次数.
    要转义是因为不转义的话大括号只是表示他们字面上的意思.这个用法只是
    技巧上的而不是基本正则表达式的内容. 
    "[0-9]\{5\}" 精确匹配5个数字 (从 0 到 9的数字). 
    注意: 大括号不能在“经典”(不是POSIX兼容)的正则表达式版本的awk中
      使用. 然而, gawk 有一个选项--re-interval来允许使用大括号
      (不必转义). 
       bash$ echo 2222 | gawk --re-interval '/2{3}/'
       2222 
      Perl和一些egrep版本不要求转义大括号. 
圆括号  -- ( ) -- 括起一组正则表达式. 它和下面要讲的"|"操作符或在用expr进行子字
   符串提取(substring extraction)一起使用很有用. 
竖线  -- | -- "或"正则操作符用于匹配一组可选的字符. 
    bash$ egrep 're(a|e)d' misc.txt
    People who read seem to be better informed than those who do not.
    The clarinet produces sound by the vibration of its reed. 
   注意: 一些sed, ed, 和ex的版本像GNU的软件版本一样支持上面描述的扩展正
     则表达式的版本. 
POSIX字符类. [:class:]
    这是另外一个可选的用于指定匹配字符范围的方法. 
[:alnum:] 匹配字母和数字.等同于A-Za-z0-9. 
[:alpha:] 匹配字母. 等同于A-Za-z. 
[:blank:] 匹配一个空格或是一个制表符(tab). 
[:cntrl:] 匹配控制字符. 
[:digit:] 匹配(十进制)数字. 等同于0-9. 
[:graph:] (可打印的图形字符). 匹配 ASCII 码值的33 - 126之间的字符. 这和下面提到的
   [:print:]一样,但是不包括空格字符. 
[:lower:] 匹配小写字母. 等同于a-z. 
[:print:] (可打印字符). 匹配 ASCII码值 32 - 126之间的字符. 这和上面提到的一样
   [:graph:],但是增多一个空格字符. 
[:space:] 匹配空白字符 (空格符和水平制表符). 
[:upper:] 匹配大写字母. 等同于A-Z. 
[:xdigit:] 匹配十六进制数字. 等同于0-9A-Fa-f. 
注意: POSIX字符类一般都要求用引号或是双方括号double brackets ([[ ]])引起来.
   bash$ grep [[:digit:]] test.file
   abc=723 
  这些字符类在一个受限的范围内甚至可能用在能用在通配(globbing)中.
   bash$ ls -l ?[[:digit:]][[:digit:]]?
   -rw-rw-r--    1 bozo  bozo         0 Aug 21 14:47 a33b 
  为了理解POSIX字符类在脚本中的使用,请参考例子 12-18 和 例子 12-19. 
Sed, awk, 和Perl在脚本中被用作过滤器, "过滤"或转换文件/IO流的时候以正则表达式作为参
数.参考例子 A-12和例子 A-17 来理解这种用法. 
在正则表达式这个复杂主题的标准参考是Friedl的Mastering Regular Expressions.由
Dougherty和Robbins写的 Sed & Awk也给出了一个清晰的正则表达式论述. 查看参考书目找
到这个主题更多的信息. 
注意事项:
[1]  因为sed, awk, 和 grep 通常处理单行,而不能匹配一个新行符. 在要处理多行的一
  个输入时,可以使用点操作符,它可以匹配新行符.
     1 #!/bin/bash
     2 
     3 sed -e 'N;s/.*/[&]/' << EOF   # Here Document
     4 line1
     5 line2
     6 EOF
     7 # 输出:
     8 # [line1
     9 # line2]
    10 
    11 
    12 
    13 echo
    14 
    15 awk '{ $0=$1 "\n" $2; if (/line.1/) {print}}' << EOF
    16 line 1
    17 line 2
    18 EOF
    19 # 输出:
    20 # line
    21 # 1
    22 
    23 
    24 # 多谢, S.C.
    25 
    26 exit 0 
19.1 通配
------------
Bash本身没有正则表达式的功能.在脚本里,使用正则表达式的是命令和软件包 -- 例如sed和
awk -- 它们可以解释正则表达式. 
Bash所做的是展开文件名扩展 [1] -- 这就是所谓的通配(globbing) -- 但它不是使用标准的
正则表达式. 而是使用通配符. 通配解释标准的通配符：*和?, 方括号括起来的字符,还有其他
的一些特殊的字符(比如说^用来表示取反匹配).然而通配机制的通配符有很大的局限性. 包含
有*号的字符串将不会匹配以点开头的文件,例如.bashrc. [2] 另外,通配机制的? 字符和正则
表达式中表示的意思不一样. 
 bash$ ls -l
 total 2
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt
 
 bash$ ls -l t?.sh
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 
 bash$ ls -l [ab]*
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 
 bash$ ls -l [a-c]*
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 a.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 
 bash$ ls -l [^ab]*
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       466 Aug  6 17:48 t2.sh
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt
 
 bash$ ls -l {b*,c*,*est*}
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 b.1
 -rw-rw-r--    1 bozo  bozo         0 Aug  6 18:42 c.1
 -rw-rw-r--    1 bozo  bozo       758 Jul 30 09:02 test1.txt 
Bash会对命令行中没有引号引起来的字符尝试文件名扩展. echo 命令可以印证这一点. 
 bash$ echo *
 a.1 b.1 c.1 t2.sh test1.txt
 
 bash$ echo t*
 t2.sh test1.txt 
注意: 可以改变Bash对通配字符进行解释的行为. set -f 命令可以禁止通配机制, 并且
  shopt的选项nocaseglob和nullglob 能改变通配的行为. 
参考例子 10-4. 
注意事项:
[1]  文件名扩展意思是扩展包含有特殊字符的文件名模式和模板. 例如,example.???可能
  扩展成example.001和/或example.txt.
[2]  文件名扩展能匹配点开头的文件,但仅在模式字串明确地包含字面意思的点(.)时才
  扩展.
     1 ~/[.]bashrc    #  不会扩展成 ~/.bashrc
     2 ~/?bashrc      #  也不会扩展.
     3                #  通配机制中的通配符和元字符不会扩展点文件
     4                #
     5 
     6 ~/.[b]ashrc    #  会扩展成 ~/.bashrc
     7 ~/.ba?hrc      #  也会.
     8 ~/.bashr*      #  也会.
     9 
    10 # 可以使用"dotglob"选项把这个特性禁用.
    11 
    12 # 多谢, S.C. 
第20章 子shell(Subshells)
==========================
运行一个shell脚本时会启动另一个命令解释器. 就好像你的命令是在命令行提示下被解释的一
样, 类似于批处理文件里的一系列命令.每个shell脚本有效地运行在父shell(parent shell)的
一个子进程里.这个父shell是指在一个控制终端或在一个xterm窗口中给你命令指示符的进程. 
shell脚本也能启动他自已的子进程. 这些子shell(即子进程)使脚本因为效率而同时进行多个
子任务执行时能做串行处理. 
一般来说,脚本里的一个外部命令(external command)能生成(forks)出一个子进程,然而
Bash内建(builtin)的命令却不这样做,因此,内建命令比起外部的等价命令执行起来更快. 
圆括号里的命令列表 
( 命令1; 命令2; 命令3; ... )
    嵌在圆括号里的一列命令在一个子shell里运行. 
注意: 在子shell里的变量不能被这段子shell代码块之外外面的脚本访问.这些变量是不能被
  产生这个子shell的父进程(parent process)存取的,实际上它们是局部变量
  (local variables). 
Example 20-1 子shell中的变量作用域
################################Start Script#######################################
 1 #!/bin/bash
 2 # subshell.sh
 3 
 4 echo
 5 
 6 echo "Subshell level OUTSIDE subshell = $BASH_SUBSHELL"
 7 # Bash, 版本 3, 增加了新的              $BASH_SUBSHELL 变量.
 8 echo
 9 
10 outer_variable=Outer
11 
12 (
13 echo "Subshell level INSIDE subshell = $BASH_SUBSHELL"
14 inner_variable=Inner
15 
16 echo "From subshell, \"inner_variable\" = $inner_variable"
17 echo "From subshell, \"outer\" = $outer_variable"
18 )
19 
20 echo
21 echo "Subshell level OUTSIDE subshell = $BASH_SUBSHELL"
22 echo
23 
24 if [ -z "$inner_variable" ]
25 then
26   echo "inner_variable undefined in main body of shell"
27 else
28   echo "inner_variable defined in main body of shell"
29 fi
30 
31 echo "From main body of shell, \"inner_variable\" = $inner_variable"
32 #  $inner_variable 会以没有初始化的变量来打印
33 #+ 因为变量是在子shell里定义的"局部变量".
34 #  这个有办法补救的吗?
35 
36 echo
37 
38 exit 0
################################End Script#########################################
参考例子 31-2.
+
在子shell中的目录更改不会影响到父shell. 
Example 20-2 列出用户的配置文件
################################Start Script#######################################
 1 #!/bin/bash
 2 # allprofs.sh: 打印所有用户的配置文件
 3 
 4 # 由 Heiner Steven编写, 并由本书作者修改.
 5 
 6 FILE=.bashrc  #  在一般的脚本里,包含用户配置的文件是".profile".
 7               #
 8 
 9 for home in `awk -F: '{print $6}' /etc/passwd`
10 do
11   [ -d "$home" ] || continue    # 如果没有家目录,跳过此次循环.
12   [ -r "$home" ] || continue    # 如果目录没有读权限,跳过此次循环.
13   (cd $home; [ -e $FILE ] && less $FILE)
14 done
15 
16 #  当脚本终止时,不必用'cd'命令返回原来的目录,
17 #+ 因为'cd $home'是在子shell中发生的,不影响父shell.
18 
19 exit 0
################################End Script######################################### 
子shell可用于为一组命令设定临时的环境变量. 
   1 COMMAND1
   2 COMMAND2
   3 COMMAND3
   4 (
   5   IFS=:
   6   PATH=/bin
   7   unset TERMINFO
   8   set -C
   9   shift 5
  10   COMMAND4
  11   COMMAND5
  12   exit 3 # 只是从子shell退出.
  13 )
  14 # 父shell不受影响,变量值没有更改.
  15 COMMAND6
  16 COMMAND7 
它的一个应用是测试是否一个变量被定义了. 
   1 if (set -u; : $variable) 2> /dev/null
   2 then
   3   echo "Variable is set."
   4 fi     #  变量已经在当前脚本中被设置,
   5        #+ 或是Bash的一个内部变量,
   6        #+ 或是可见环境变量(指已经被导出的环境变量).
   7 
   8 # 也可以写成            [[ ${variable-x} != x || ${variable-y} != y ]]
   9 # 或                    [[ ${variable-x} != x$variable ]]
  10 # 或                    [[ ${variable+x} = x ]]
  11 # 或                    [[ ${variable-x} != x ]] 
另一个应用是检查一个加锁的文件: 
   1 if (set -C; : > lock_file) 2> /dev/null
   2 then
   3   :   # lock_file 不存在,还没有用户运行这个脚本
   4 else
   5   echo "Another user is already running that script."
   6 exit 65
   7 fi
   8 
   9 #  由Stphane Chazelas编程
  10 #+ 由Paulo Marcel Coelho Aragao修改. 
进程在不同的子shell中可以串行地执行.这样就允许把一个复杂的任务分成几个小的子问题来
同时地处理. 
Example 20-3 在子shell里进行串行处理
################################Start Script#######################################
 1  (cat list1 list2 list3 | sort | uniq > list123) &
 2  (cat list4 list5 list6 | sort | uniq > list456) &
 3  #列表的合并和排序同时进.
 4  #放到后台运行可以确保能够串行执行.
 5  #
 6  #和下面的有相同的作用：
 7  #   cat list1 list2 list3 | sort | uniq > list123 &
 8  #   cat list4 list5 list6 | sort | uniq > list456 &
 9  
10  wait   #在所有的子shell执行完成前不再执行后面的命令.
11  
12  diff list123 list456
################################End Script######################################### 
用"|"管道操作把I/O流重定向到子shell,例如ls -al | (command). 
注意:  在一个花括号内的代码块不会运行一个子shell.
  { command1; command2; command3; ... } 
第21章 受限shell(Restricted Shells)
====================================
在受限shell中禁用的命令 
    在受限shell中运行的脚本或脚本的个代码断会禁用一些正常shell中可以执行的命令.这是
 限制脚本用户的权限和最小化运行脚本导致的破坏的安全措施. 
    使用cd 命令更改工作目录. 
    更改环境变量$PATH, $SHELL, $BASH_ENV,或$ENV 的值. 
    读或更改shell环境选项变量$SHELLOPTS的值. 
    输出重定向. 
    调用的命令路径中包括有一个或更多个/字符. 
    调用exec来把当前的受限shell替换成另外一个不同的进程. 
    脚本中许多其他无意中能破坏或捣乱的命令. 
    在脚本中企图脱离受限shell模式的操作. 
Example 21-1 在受限的情况下运行脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 #  脚本开头以"#!/bin/bash -r"来调用
 4 #+ 会使整个脚本在受限模式下运行.
 5 
 6 echo
 7 
 8 echo "Changing directory."
 9 cd /usr/local
10 echo "Now in `pwd`"
11 echo "Coming back home."
12 cd
13 echo "Now in `pwd`"
14 echo
15 
16 # 不受限的模式下,所有操作都能正常成功.
17 
18 set -r
19 # set --restricted    也能起相同的作用.
20 echo "==> Now in restricted mode. <=="
21 
22 echo
23 echo
24 
25 echo "Attempting directory change in restricted mode."
26 cd ..
27 echo "Still in `pwd`"
28 
29 echo
30 echo
31 
32 echo "\$SHELL = $SHELL"
33 echo "Attempting to change shell in restricted mode."
34 SHELL="/bin/ash"
35 echo
36 echo "\$SHELL= $SHELL"
37 
38 echo
39 echo
40 
41 echo "Attempting to redirect output in restricted mode."
42 ls -l /usr/bin > bin.files
43 ls -l bin.files    # Try to list attempted file creation effort.
44 
45 echo
46 
47 exit 0
################################End Script######################################### 
第22章 进程替换
================
进程替换与命令替换(command substitution)很相似. 命令替换把一个命令的结果赋给一个
变量,例如 dir_contents=`ls -al`或xref=$( grep word datafile). 进程替换则是把一个进
程的输出回馈给另一个进程 (换句话说,它把一个命令的结果发送给另一个命令). 
命令替换的一般形式 
由圆括号括起的命令 
 >(command) 
 <(command) 
 启动进程替换. 它是用/dev/fd/<n>文件把在圆括号内的进程的处理结果发送给另外一个进
 程. [1] (译者注：实际上现代的UNIX类操作系统提供的/dev/fd/n文件是与文件描述相关
 的,整数n指的就是在进程运行时对应数字的文件描述符) 
 注意: 在"<" 或or ">" 与圆括号之间是没有空格的. 如果加了空格将会引起错误信息. 
 bash$ echo >(true)
 /dev/fd/63
 
 bash$ echo <(true)
 /dev/fd/63 
 Bash在两个文件描述符(file descriptors)之间创建了一个管道, --fIn 和 fOut--. true
命令的标准输入被连接到fOut(dup2(fOut, 0)), 然后Bash把/dev/fd/fIn作为参数传给echo.
如果系统的/dev/fd/<n>文件不够时,Bash会使用临时文件. (Thanks, S.C.) 
进程替换能比较两个不同命令之间的输出,或者甚至相同命令不同选项的输出. 
 bash$ comm <(ls -l) <(ls -al)
 total 12
-rw-rw-r--    1 bozo bozo       78 Mar 10 12:58 File0
-rw-rw-r--    1 bozo bozo       42 Mar 10 12:58 File2
-rw-rw-r--    1 bozo bozo      103 Mar 10 12:58 t2.sh
        total 20
        drwxrwxrwx    2 bozo bozo     4096 Mar 10 18:10 .
        drwx------   72 bozo bozo     4096 Mar 10 17:58 ..
        -rw-rw-r--    1 bozo bozo       78 Mar 10 12:58 File0
        -rw-rw-r--    1 bozo bozo       42 Mar 10 12:58 File2
        -rw-rw-r--    1 bozo bozo      103 Mar 10 12:58 t2.sh 
用进程替换来比较两个不同目录的内容 (考察哪些文件名是相同的,哪些是不同的):
   1 diff <(ls $first_directory) <(ls $second_directory) 
其他一些进程替换的用法和技巧: 
   1 cat <(ls -l)
   2 # 等同于     ls -l | cat
   3 
   4 sort -k 9 <(ls -l /bin) <(ls -l /usr/bin) <(ls -l /usr/X11R6/bin)
   5 # 列出系统中3个主要的'bin'目录的所有文件,并且按文件名排序.
   6 # 注意是三个明显不同的命令输出回馈给'sort'.
   7 
   8  
   9 diff <(command1) <(command2)    # 给出两个命令输出的不同之处.
  10 
  11 tar cf >(bzip2 -c > file.tar.bz2) $directory_name
  12 # 调用"tar cf /dev/fd/?? $directory_name",和"bzip2 -c > file.tar.bz2".
  13 #
  14 # 因为/dev/fd/<n>的系统属性,
  15 # 所以两个命令之间的管道不必是命名的.
  16 #
  17 # 这种效果可以模仿出来.
  18 #
  19 bzip2 -c < pipe > file.tar.bz2&
  20 tar cf pipe $directory_name
  21 rm pipe
  22 #        或者
  23 exec 3>&1
  24 tar cf /dev/fd/4 $directory_name 4>&1 >&3 3>&- | bzip2 -c > file.tar.bz2 3>&-
  25 exec 3>&-
  26 
  27 
  28 # Thanks, St`phane Chazelas 
有个读者给我发来下面关于进程替换的有趣例子A. 
   1 # 摘自SuSE发行版中的代码片断:
   2 
   3 while read  des what mask iface; do
   4 # 这里省略了一些命令 ...
   5 done < <(route -n)  
   6 
   7 
   8 # 为了测试它,我们来做些动作.
   9 while read  des what mask iface; do
  10   echo $des $what $mask $iface
  11 done < <(route -n)  
  12 
  13 # 输出:
  14 # Kernel IP routing table
  15 # Destination Gateway Genmask Flags Metric Ref Use Iface
  16 # 127.0.0.0 0.0.0.0 255.0.0.0 U 0 0 0 lo
  17 
  18 
  19 
  20 # 由 Stphane Chazelas给出的,一个更容易理解的等价代码是:
  21 route -n |
  22   while read des what mask iface; do   # 管道的输出被赋给了变量.
  23     echo $des $what $mask $iface
  24   done  #  这样就取回了和上面一样的输出.
  25         #  但是, Ulrich Gayer指出 . . .
  26         #+ 这个简单版本的等价代码在while循环中使用了一个子shell,
  27         #+ 因此当管道结束后变量会被毁掉.
  28  
  29 
  30  
  31 #  更进一步, Filip Moritz解释了上面两个例子之间有一个细微的不同之处
  32 #+ 如下所示.
  33 
  34 (
  35 route -n | while read x; do ((y++)); done
  36 echo $y # $y 仍然没有被声明或设置
  37 
  38 while read x; do ((y++)); done < <(route -n)
  39 echo $y # $y的值为 route -n 输出的行数
  40 )
  41 
  42 # 一般来说
  43 (
  44 : | x=x
  45 # 看上去是启动了一个子shell
  46 : | ( x=x )
  47 # 但
  48 x=x < <(:)
  49 # 实际上不是
  50 )
  51 
  52 # 当解析csv或类似的东西时非常有用.
  53 # 事实上,这就是SuSE原本的代码片断所要实现的功能. 
注意事项:
[1]  这与命名管道(named pipe)(临时文件)有相同的作用, 事实上命名管道同样在进程
  替换中被使用. 
第23章 函数
============
和"真正的"编程语言一样, Bash也有函数,虽然在某些实现方面稍有些限制. 一个函数是一个
子程序,用于实现一串操作的代码块(code block),它是完成特定任务的"黑盒子". 当有重复
代码, 当一个任务只需要很少的修改就被重复几次执行时, 这时你应考虑使用函数. 
function function_name {
command...
} 
或 
function_name () {
command...
} 
第二种格式的写法更深得C程序员的喜欢(并且也是更可移植的). 
因为在C中,函数的左花括号也可以写在下一行中. 
function_name ()
{
command...
} 
函数被调用或被触发, 只需要简单地用函数名调用. 
Example 23-1 简单函数
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 JUST_A_SECOND=1
 4 
 5 funky ()
 6 { # 这是一个最简单的函数.
 7   echo "This is a funky function."
 8   echo "Now exiting funky function."
 9 } # 函数必须在调用前声明.
10 
11 
12 fun ()
13 { # 一个稍复杂的函数.
14   i=0
15   REPEATS=30
16 
17   echo
18   echo "And now the fun really begins."
19   echo
20 
21   sleep $JUST_A_SECOND    # 嘿, 暂停一秒!
22   while [ $i -lt $REPEATS ]
23   do
24     echo "----------FUNCTIONS---------->"
25     echo "<------------ARE-------------"
26     echo "<------------FUN------------>"
27     echo
28     let "i+=1"
29   done
30 }
31 
32   # 现在,调用两个函数.
33 
34 funky
35 fun
36 
37 exit 0
################################End Script######################################### 
函数定义必须在第一次调用函数前完成.没有像C中的函数“声明”方法. 
   1 f1
   2 # 因为函数"f1"还没有定义,这会引起错误信息.
   3 
   4 declare -f f1      # 这样也没用.
   5 f1                 # 仍然会引起错误.
   6 
   7 # 然而...
   8 
   9    
  10 f1 ()
  11 {
  12   echo "Calling function \"f2\" from within function \"f1\"."
  13   f2
  14 }
  15 
  16 f2 ()
  17 {
  18   echo "Function \"f2\"."
  19 }
  20 
  21 f1  #  虽然在它定义前被引用过,
  22     #+ 函数"f2"实际到这儿才被调用.
  23     #  这样是允许的.
  24     
  25     # Thanks, S.C. 
在一个函数内嵌套另一个函数也是可以的,但是不常用. 
   1 f1 ()
   2 {
   3 
   4   f2 () # nested
   5   {
   6     echo "Function \"f2\", inside \"f1\"."
   7   }
   8 
   9 }  
  10 
  11 f2  #  引起错误.
  12     #  就是你先"declare -f f2"了也没用.
  13 
  14 echo    
  15 
  16 f1  #  什么也不做,因为调用"f1"不会自动调用"f2".
  17 f2  #  现在,可以正确的调用"f2"了,
  18     #+ 因为之前调用"f1"使"f2"在脚本中变得可见了.
  19 
  20     # Thanks, S.C. 
函数声明可以出现在看上去不可能出现的地方,那些不可能的地方本该由一个命令出现的地方. 
   1 ls -l | foo() { echo "foo"; }  # 允许,但没什么用.
   2 
   3 
   4 
   5 if [ "$USER" = bozo ]
   6 then
   7   bozo_greet ()   # 在if/then结构中定义了函数.
   8   {
   9     echo "Hello, Bozo."
  10   }
  11 fi  
  12 
  13 bozo_greet        # 只能由Bozo运行, 其他用户会引起错误.
  14 
  15 
  16 
  17 # 在某些上下文,像这样可能会有用.
  18 NO_EXIT=1   # 将会打开下面的函数定义.
  19 
  20 [[ $NO_EXIT -eq 1 ]] && exit() { true; }     # 在"and-list"(and列表)中定义函数.
  21 # 如果 $NO_EXIT 是 1,声明函数"exit ()".
  22 # 把"exit"取别名为"true"将会禁用内建的"exit".
  23 
  24 exit  # 调用"exit ()"函数, 而不是内建的"exit".
  25 
  26 # Thanks, S.C. 
23.1. 复杂函数和函数复杂性
--------------------------
函数可以处理传递给它的参数并且能返回它的退出状态码(exit status)给脚本后续使用. 
   1 function_name $arg1 $arg2 
函数以位置来引用传递过来的参数(就好像他们是位置参数(positional parameters)), 例如
$1, $2,以此类推. 
Example 23-2 带着参数的函数
################################Start Script#######################################
 1 #!/bin/bash
 2 # 函数和参数
 3 
 4 DEFAULT=default                             # 默认的参数值.
 5 
 6 func2 () {
 7    if [ -z "$1" ]                           # 第一个参数是否长度为零?
 8    then
 9      echo "-Parameter #1 is zero length.-"  # 则没有参数传递进来.
10    else
11      echo "-Param #1 is \"$1\".-"
12    fi
13 
14    variable=${1-$DEFAULT}                   #  
15    echo "variable = $variable"              #  参数替换会表现出什么?
16                                             #  ---------------------------
17                                             #  它用于分辨没有参数和一个只有NULL值的参数.
18                                             #
19 
20    if [ "$2" ]
21    then
22      echo "-Parameter #2 is \"$2\".-"
23    fi
24 
25    return 0
26 }
27 
28 echo
29    
30 echo "Nothing passed."   
31 func2                          # 没有参数来调用
32 echo
33 
34 
35 echo "Zero-length parameter passed."
36 func2 ""                       # 以一个长度为零的参数调用
37 echo
38 
39 echo "Null parameter passed."
40 func2 "$uninitialized_param"   # 以未初始化的参数来调用
41 echo
42 
43 echo "One parameter passed."   
44 func2 first           # 用一个参数来调用
45 echo
46 
47 echo "Two parameters passed."   
48 func2 first second    # 以二个参数来调用
49 echo
50 
51 echo "\"\" \"second\" passed."
52 func2 "" second       # 以第一个参数为零长度,而第二个参数是一个ASCII码组成的字符串来调用.
53 echo                  # 
54 
55 exit 0
################################End Script#########################################
注意:  shift命令可以工作在传递给函数的参数 (参考例子 33-15). 
但是,传给脚本的命令行参数怎么办?在函数内部可以看到它们吗?好,让我们来弄清楚. 
Example 23-3 函数和被传给脚本的命令行参数
################################Start Script#######################################
 1 #!/bin/bash
 2 # func-cmdlinearg.sh
 3 #  以一个命令行参数来调用这个脚本,
 4 #+ 类似 $0 arg1来调用.
 5 
 6 
 7 func ()
 8 
 9 {
10 echo "$1"
11 }
12 
13 echo "First call to function: no arg passed."
14 echo "See if command-line arg is seen."
15 func
16 # 不!命令行参数看不到.
17 
18 echo "============================================================"
19 echo
20 echo "Second call to function: command-line arg passed explicitly."
21 func $1
22 # 现在可以看到了!
23 
24 exit 0
################################End Script#########################################
与别的编程语言相比,shell脚本一般只传递值给函数,变量名(实现上是指针)如果作为参数传递给函数会被看成是字面上字符串的意思.函数解释参数是以字面上的意思来解释的. 
间接变量引用(Indirect variable references) (参考例子 34-2)提供了传递变量指针给函数的一个笨拙的机制. 
Example 23-4 传递间接引用给函数
################################Start Script#######################################
 1 #!/bin/bash
 2 # ind-func.sh: 传递间接引用给函数.
 3 
 4 echo_var ()
 5 {
 6 echo "$1"
 7 }
 8 
 9 message=Hello
10 Hello=Goodbye
11 
12 echo_var "$message"        # Hello
13 # 现在,让我们传递一个间接引用给函数.
14 echo_var "${!message}"     # Goodbye
15 
16 echo "-------------"
17 
18 # 如果我们改变"hello"变量的值会发生什么?
19 Hello="Hello, again!"
20 echo_var "$message"        # Hello
21 echo_var "${!message}"     # Hello, again!
22 
23 exit 0
################################End Script#########################################
下一个逻辑问题是：在传递参数给函数之后是否能解除参数的引用. 
Example 23-5 解除传递给函数的参数引用
################################Start Script#######################################
 1 #!/bin/bash
 2 # dereference.sh
 3 # 给函数传递不同的参数.
 4 # Bruce W. Clare编写.
 5 
 6 dereference ()
 7 {
 8      y=\$"$1"   # 变量名.
 9      echo $y    # $Junk
10 
11      x=`eval "expr \"$y\" "`
12      echo $1=$x
13      eval "$1=\"Some Different Text \""  # 赋新值.
14 }
15 
16 Junk="Some Text"
17 echo $Junk "before"    # Some Text before
18 
19 dereference Junk
20 echo $Junk "after"     # Some Different Text after
21 
22 exit 0
################################End Script######################################### 
Example 23-6 再次尝试解除传递给函数的参数引用
################################Start Script#######################################
 1 #!/bin/bash
 2 # ref-params.sh: 解除传递给函数的参数引用.
 3 #                (复杂例子)
 4 
 5 ITERATIONS=3  # 取得输入的次数.
 6 icount=1
 7 
 8 my_read () {
 9   #  用my_read varname来调用,
10   #+ 输出用括号括起的先前的值作为默认值,
11   #+ 然后要求输入一个新值.
12 
13   local local_var
14 
15   echo -n "Enter a value "
16   eval 'echo -n "[$'$1'] "'  #  先前的值.
17 # eval echo -n "[\$$1] "     #  更好理解,
18                              #+ 但会丢失用户输入在尾部的空格.
19   read local_var
20   [ -n "$local_var" ] && eval $1=\$local_var
21 
22   # "and列表(And-list)": 如果变量"local_var"测试成功则把变量"$1"的值赋给它.
23 }
24 
25 echo
26 
27 while [ "$icount" -le "$ITERATIONS" ]
28 do
29   my_read var
30   echo "Entry #$icount = $var"
31   let "icount += 1"
32   echo
33 done  
34 
35 
36 # 多谢Stephane Chazelas提供的示范例子.
37 
38 exit 0
################################End Script######################################### 
退出和返回 
退出状态(exit status) 
    函数返回一个被称为退出状态的值. 退出状态可以由return来指定statement, 否则函数的
 退出状态是函数最后一个执行命令的退出状态(0表示成功,非0表示出错代码). 退出状态
 (exit status)可以在脚本中由$? 引用. 这个机制使脚本函数也可以像C函数一样有一个"
 返回值". 
return 
    终止一个函数.return 命令[1]可选地带一个整数参数,这个整数作为函数的"返回值"返回
 给调用此函数的脚本,并且这个值也被赋给变量$?. 
Example 23-7 两个数中的最大者
################################Start Script#######################################
 1 #!/bin/bash
 2 # max.sh: 两个整数中的最大者.
 3 
 4 E_PARAM_ERR=-198    # 如果传给函数的参数少于2个时的返回值.
 5 EQUAL=-199          # 如果两个整数值相等的返回值.
 6 #  任一个传给函数的参数值溢出
 7 #
 8 
 9 max2 ()             # 返回两个整数的较大值.
10 {                   # 注意: 参与比较的数必须小于257.
11 if [ -z "$2" ]
12 then
13   return $E_PARAM_ERR
14 fi
15 
16 if [ "$1" -eq "$2" ]
17 then
18   return $EQUAL
19 else
20   if [ "$1" -gt "$2" ]
21   then
22     return $1
23   else
24     return $2
25   fi
26 fi
27 }
28 
29 max2 33 34
30 return_val=$?
31 
32 if [ "$return_val" -eq $E_PARAM_ERR ]
33 then
34   echo "Need to pass two parameters to the function."
35 elif [ "$return_val" -eq $EQUAL ]
36   then
37     echo "The two numbers are equal."
38 else
39     echo "The larger of the two numbers is $return_val."
40 fi  
41 
42   
43 exit 0
44 
45 #  练习 (容易):
46 #  ---------------
47 #  把这个脚本转化成交互式的脚本,
48 #+ 也就是说,让脚本可以要求调用者输入两个整数.
################################End Script######################################### 
 注意: 为了函数可以返回字符串或是数组,用一个可在函数外可见的变量. 
    1 count_lines_in_etc_passwd()
    2 {
    3   [[ -r /etc/passwd ]] && REPLY=$(echo $(wc -l < /etc/passwd))
    4   #  如果/etc/passwd可读,则把REPLY设置成文件的行数.
    5   #  返回一个参数值和状态信息.
    6   #  'echo'好像没有必要,但 . . .
    7   #+ 它的作用是删除输出中的多余空白字符.
    8 }
    9 
   10 if count_lines_in_etc_passwd
   11 then
   12   echo "There are $REPLY lines in /etc/passwd."
   13 else
   14   echo "Cannot count lines in /etc/passwd."
   15 fi  
   16 
   17 # Thanks, S.C. 
Example 23-8 把数字转化成罗马数字
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # 阿拉伯数字转化为罗马数字
 4 # 转化范围: 0 - 200
 5 # 这是比较粗糙的,但可以工作.
 6 
 7 # 扩展可接受的范围来作为脚本功能的扩充,这个作为练习完成.
 8 
 9 # 用法: roman number-to-convert
10 
11 LIMIT=200
12 E_ARG_ERR=65
13 E_OUT_OF_RANGE=66
14 
15 if [ -z "$1" ]
16 then
17   echo "Usage: `basename $0` number-to-convert"
18   exit $E_ARG_ERR
19 fi  
20 
21 num=$1
22 if [ "$num" -gt $LIMIT ]
23 then
24   echo "Out of range!"
25   exit $E_OUT_OF_RANGE
26 fi  
27 
28 to_roman ()   # 在第一次调用函数前必须先定义.
29 {
30 number=$1
31 factor=$2
32 rchar=$3
33 let "remainder = number - factor"
34 while [ "$remainder" -ge 0 ]
35 do
36   echo -n $rchar
37   let "number -= factor"
38   let "remainder = number - factor"
39 done  
40 
41 return $number
42        # 练习:
43        # --------
44        # 解释这个函数是怎么工作的.
45        # 提示: 靠不断地除来分割数字.
46 }
47    
48 
49 to_roman $num 100 C
50 num=$?
51 to_roman $num 90 LXXXX
52 num=$?
53 to_roman $num 50 L
54 num=$?
55 to_roman $num 40 XL
56 num=$?
57 to_roman $num 10 X
58 num=$?
59 to_roman $num 9 IX
60 num=$?
61 to_roman $num 5 V
62 num=$?
63 to_roman $num 4 IV
64 num=$?
65 to_roman $num 1 I
66 
67 echo
68 
69 exit 0
################################End Script#########################################
 请参考例子 10-28. 
 注意: 函数最大可返回的正整数为255. return 命令与退出状态(exit status)的概念联
   系很紧密,而退出状态的值受此限制.幸运地是有多种(工作区workarounds)来对
   付这种要求函数返回大整数的情况. 
Example 23-9 测试函数最大的返回值
################################Start Script#######################################
 1 #!/bin/bash
 2 # return-test.sh
 3 
 4 # 一个函数最大可能返回的值是255.
 5 
 6 return_test ()         # 无论传给函数什么都返回它.
 7 {
 8   return $1
 9 }
10 
11 return_test 27         # o.k.
12 echo $?                # 返回 27.
13   
14 return_test 255        # 仍然 o.k.
15 echo $?                # 返回 255.
16 
17 return_test 257        # 错误!
18 echo $?                # 返回 1 (返回代码指示错误).
19 
20 # ======================================================
21 return_test -151896    # 能够返回这个非常大的负数么?
22 echo $?                # 会返回-151896?
23                        # 不! 它将返回168.
24 #  2.05b版本之前的Bash是允许
25 #+ 超大负整数作为返回值的.
26 #  但是比它更新一点的版本修正了这个漏洞.
27 #  这将破坏比较老的脚本.
28 #  慎用!
29 # ======================================================
30 
31 exit 0
################################End Script#########################################
 如果你非常想使用超大整数作为"返回值"的话, 那么只能通过将你想返回的返回值直接的
 传递到一个全局变量中的手段来达到目的. 
    1 Return_Val=   # 全局变量, 用来保存函数中需要返回的超大整数.
    2 
    3 alt_return_test ()
    4 {
    5   fvar=$1
    6   Return_Val=$fvar
    7   return   # Returns 0 (success).
    8 }
    9 
   10 alt_return_test 1
   11 echo $?                              # 0
   12 echo "return value = $Return_Val"    # 1
   13 
   14 alt_return_test 256
   15 echo "return value = $Return_Val"    # 256
   16 
   17 alt_return_test 257
   18 echo "return value = $Return_Val"    # 257
   19 
   20 alt_return_test 25701
   21 echo "return value = $Return_Val"    #25701 
 一种更优雅的方法是让函数echo出它的返回值, 输出到stdout上, 然后再通过"命令替换"
 的手段来捕获它. 参考Section 33.7关于这个问题的讨论. 
Example 23-10 比较两个大整数
################################Start Script#######################################
 1 #!/bin/bash
 2 # max2.sh: 取两个超大整数中最大的.
 3 
 4 #  这个脚本与前面的"max.sh"例子作用相同,
 5 #+ 经过修改可以适用于比较超大整数.
 6 
 7 EQUAL=0             # 如果两个参数相同的返回值.
 8 E_PARAM_ERR=-99999  # 没有足够的参数传递到函数中.
 9 #           ^^^^^^    也可能是传递到函数中的某个参数超出范围了.
10 
11 max2 ()             # 从这两个数中"返回"更大一些的.
12 {
13 if [ -z "$2" ]
14 then
15   echo $E_PARAM_ERR
16   return
17 fi
18 
19 if [ "$1" -eq "$2" ]
20 then
21   echo $EQUAL
22   return
23 else
24   if [ "$1" -gt "$2" ]
25   then
26     retval=$1
27   else
28     retval=$2
29   fi
30 fi
31 
32 echo $retval        # echo(到stdout), 而不是使用返回值.
33                     # 为什么?
34 }
35 
36 
37 return_val=$(max2 33001 33997)
38 #            ^^^^             函数名
39 #                 ^^^^^ ^^^^^ 这是传递进来的参数
40 #  这事实上是一个命令替换的形式:
41 #+ 会把这个函数当作一个命令来处理,
42 #+ 并且分配这个函数的stdout到变量"return_val"中.
43 
44 
45 # ========================= OUTPUT ========================
46 if [ "$return_val" -eq "$E_PARAM_ERR" ]
47   then
48   echo "Error in parameters passed to comparison function!"
49 elif [ "$return_val" -eq "$EQUAL" ]
50   then
51     echo "The two numbers are equal."
52 else
53     echo "The larger of the two numbers is $return_val."
54 fi
55 # =========================================================
56   
57 exit 0
58 
59 #  练习:
60 #  -----
61 #  1) 找出一种更优雅的方法来测试
62 #+    传递到函数中的参数.
63 #  2) 在"OUTPUT"的时候简化if/then结构.
64 #  3) 重写这个脚本使其能够从命令行参数中来获取输入.
################################End Script######################################### 
 下边是获得一个函数的"返回值"的另一个例子. 想要了解这个例子需要一些awk的知识. 
    1 month_length ()  # 以月份数作为参数.
    2 {                # 返回这个月有几天.
    3 monthD="31 28 31 30 31 30 31 31 30 31 30 31"  # 作为局部变量来声明?
    4 echo "$monthD" | awk '{ print $'"${1}"' }'    # 有技巧的.
    5 #                             ^^^^^^^^^
    6 # 先将参数传递到函数中  ($1 -- 月份号), 然后就到awk了.
    7 # Awk将会根据传递进来的月份号来决定打印"print $1 . . . print $12"中的哪个 (依赖于月份号)
    8 # 传递参数到内嵌awk脚本的模版:
    9 #                                 $'"${script_parameter}"'
   10 
   11 #  需要错误检查来修正参数的范围(1-12)
   12 #+ 并且要处理闰年的特殊的2月.
   13 }
   14 
   15 # ----------------------------------------------
   16 # 用例:
   17 month=4        # 拿4月来举个例子.
   18 days_in=$(month_length $month)
   19 echo $days_in  # 30
   20 # ---------------------------------------------- 
 也参考例子 A-7. 
 练习: 用我们已经学到的扩展先前罗马数字那个例子脚本能接受任意大的输入. 
重定向 
重定向函数的标准输入
 函数本质上是一个代码块(code block), 这样意思着它的标准输入可以被重定向
 (就像在例子 3-1中显示的). 
Example 23-11 用户名的真实名
################################Start Script#######################################
 1 #!/bin/bash
 2 # realname.sh
 3 #
 4 # 由用户名而从/etc/passwd取得"真实名".
 5 
 6 
 7 ARGCOUNT=1       # 需要一个参数.
 8 E_WRONGARGS=65
 9 
10 file=/etc/passwd
11 pattern=$1
12 
13 if [ $# -ne "$ARGCOUNT" ]
14 then
15   echo "Usage: `basename $0` USERNAME"
16   exit $E_WRONGARGS
17 fi  
18 
19 file_excerpt ()  # 以要求的模式来扫描文件,然后打印文件相关的部分.
20 {
21 while read line  # "while" does not necessarily need "[ condition ]"
22 do
23   echo "$line" | grep $1 | awk -F":" '{ print $5 }'  # awk指定使用":"为界定符.
24 done
25 } <$file  # 重定向函数的标准输入.
26 
27 file_excerpt $pattern
28 
29 # Yes, this entire script could be reduced to
30 #       grep PATTERN /etc/passwd | awk -F":" '{ print $5 }'
31 # or
32 #       awk -F: '/PATTERN/ {print $5}'
33 # or
34 #       awk -F: '($1 == "username") { print $5 }' # real name from username
35 # 但是,这些可能起不到示例的作用.
36 
37 exit 0
################################End Script#########################################
 还有一个办法,可能是更好理解的重定向函数标准输入方法.它为函数内的一个括号内的
 代码块调用标准输入重定向. 
   1 # 用下面的代替:
   2 Function ()
   3 {
   4  ...
   5  } < file
   6 
   7 # 也试一下这个:
   8 Function ()
   9 {
  10   {
  11     ...
  12    } < file
  13 }
  14 
  15 # 同样,
  16 
  17 Function ()  # 可以工作.
  18 {
  19   {
  20    echo $*
  21   } | tr a b
  22 }
  23 
  24 Function ()  # 这个不会工作
  25 {
  26   echo $*
  27 } | tr a b   # 这儿的内嵌代码块是强制的.
  28 
  29 
  30 # Thanks, S.C. 
注意事项:
[1]  return命令是Bash内建(builtin)的. 
23.2. 局部变量
--------------
怎么样使一个变量变成局部的? 
局部变量
 如果变量用local来声明,那么它只能在该变量声明的代码块(block of code)中可见. 
 这个代码块就是局部"范围". 在一个函数内,局部变量意味着只能在函数代码块内它才
 有意义. 
Example 23-12 局部变量的可见范围
################################Start Script#######################################
 1 #!/bin/bash
 2 # 在函数内部的全局和局部变量.
 3 
 4 func ()
 5 {
 6   local loc_var=23       # 声明为局部变量.
 7   echo                   # 使用内建的'local'关键字.
 8   echo "\"loc_var\" in function = $loc_var"
 9   global_var=999         # 没有声明为局部变量.
10                          # 默认为全局变量. 
11   echo "\"global_var\" in function = $global_var"
12 }  
13 
14 func
15 
16 # 现在,来看看是否局部变量"loc_var"能否在函数外面可见.
17 
18 echo
19 echo "\"loc_var\" outside function = $loc_var"
20                                       # $loc_var outside function = 
21                                       # 不, $loc_var不是全局可访问的.
22 echo "\"global_var\" outside function = $global_var"
23                                       # $global_var outside function = 999
24                                       # $global_var 是全局可访问的.
25 echo          
26 
27 exit 0
28 #  与In contrast to C相比, 在函数内声明的Bash变量只有在
29 #+ 它被明确声明成局部的变量时才是局部的.
################################End Script######################################### 
 注意: 在函数调用之前,所有在函数内声明且没有明确声明为local的变量都可在函数体
   外可见. 
    1 #!/bin/bash
    2 
    3 func ()
    4 {
    5 global_var=37    #  在函数还没有被调用前
    6                  #+ 变量只在函数内可见. 
    7 }                #  函数结束
    8 
    9 echo "global_var = $global_var"  # global_var =
   10                                  #  函数"func"还没有被调用,
   11                                  #+ 所以变量$global_var还不能被访问.
   12 
   13 func
   14 echo "global_var = $global_var"  # global_var = 37
   15                                  # 已经在函数调用时设置了值. 
23.2.1. 局部变量使递归变得可能.
-------------------------------
局部变量可以递归, [1] 但这个办法会产生大量的计算,因此它在shell脚本中是被明确表明
不推荐的. [2] 
Example 23-13 用局部变量来递归
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 #               阶乘
 4 #               ---------
 5 
 6 
 7 # bash允许递归吗?
 8 # 嗯, 允许, 但是...
 9 # 它太慢以致你难以忍受.
10 
11 
12 MAX_ARG=5
13 E_WRONG_ARGS=65
14 E_RANGE_ERR=66
15 
16 
17 if [ -z "$1" ]
18 then
19   echo "Usage: `basename $0` number"
20   exit $E_WRONG_ARGS
21 fi
22 
23 if [ "$1" -gt $MAX_ARG ]
24 then
25   echo "Out of range (5 is maximum)."
26   #  现在让我们来了解实际情况.
27   #  如果你想求比这个更大的范围的阶乘,
28   #+ 应该重新用一个真正的编程语言来写.
29   exit $E_RANGE_ERR
30 fi  
31 
32 fact ()
33 {
34   local number=$1
35   #  变量"number"必须声明为局部,
36   #+ 否则它不会工作.
37   if [ "$number" -eq 0 ]
38   then
39     factorial=1    # 0的阶乘为1.
40   else
41     let "decrnum = number - 1"
42     fact $decrnum  # 递归调用(函数内部调用自己本身).
43     let "factorial = $number * $?"
44   fi
45 
46   return $factorial
47 }
48 
49 fact $1
50 echo "Factorial of $1 is $?."
51 
52 exit 0
################################End Script#########################################
也请参考例子 A-16的脚本递归的例子. 必须意识到递归也意味着巨大的资源消耗和缓慢的运
行,因此它不适合在脚本中使用. 
注意事项:
[1]  Herbert Mayer 给递归下的定义是". . . expressing an algorithm by using a 
  simpler version of that same algorithm(用一个相同算法的版本来表示一个算法) 
  . . ." 递归函数是调用它自己本身的函数.
[2]  太多层的递归可能会引起脚本段错误而崩溃.
     1 #!/bin/bash
     2 
     3 #  警告: 运行这个脚本可能使你的系统失去响应!
     4 #  如果你运气不错,在它使用完所有可用内存之前会段错误而退出.
     5 
     6 recursive_function ()     
     7 {
     8 echo "$1"     # 使函数做些事情以加速产生段错误.
     9 (( $1 < $2 )) && recursive_function $(( $1 + 1 )) $2;
    10 #  当第一个参数比第二个参数少时,
    11 #+ 把第1个参数增1再次递归.
    12 }
    13 
    14 recursive_function 1 50000  # 递归 50,000 次!
    15 #  非常可能段错误 (依赖于栈的大小,它由ulimit -m设置).
    16 
    17 #  这种深度的递归甚至可能由于耗尽栈的内存大小而引起C程序的段错误.
    18 #
    19 
    20 
    21 echo "This will probably not print."
    22 exit 0  # 这个脚本将不会从这儿正常退出.
    23 
    24 #  多谢, St`phane Chazelas. 
23.3. 不使用局部变量的递归
--------------------------
函数甚至可以不使用局部变量来调用自己. 
Example 23-14 汉诺塔
################################Start Script#######################################
  1 #! /bin/bash
  2 #
  3 # 汉诺塔(The Towers Of Hanoi)
  4 # Bash script
  5 # Copyright (C) 2000 Amit Singh. All Rights Reserved.
  6 # http://hanoi.kernelthread.com
  7 #
  8 # 在bash version 2.05b.0(13)-release下测试通过
  9 #
 10 #  经过作者同意后在"Advanced Bash Scripting Guide"书中使用
 11 #
 12 #  由ABS的作者做了少许修改.
 13 
 14 #=================================================================#
 15 #  汉诺塔是由Edouard Lucas提出的数学谜题 ,
 16 #+ 他是19世纪的法国数学家.
 17 #
 18 #  有三个直立的柱子竖在地面上.
 19 #  第一个柱子有一组的盘子套在上面.
 20 #  这些盘子是平整的,中间带着孔,
 21 #+ 因此它们才能套在柱子上面.
 22 #  这组盘子有不同的直径,它们是依照直径从小到大来从高到低放置.
 23 #
 24 #  最小的盘在最高,最大的盘在最底部.
 25 #
 26 #  现在的任务是要把这一组的盘子从一个柱子全部地搬到另一个柱子上.
 27 #
 28 #  你只能一次从一个柱子上移动一个盘子到另一个柱子.
 29 #  允许把盘子重新移回到它原来的最初位置.
 30 #  你可以把一个小的盘子放在大的盘子上面,
 31 #+ 但不能把大的盘子放在小的盘子上面.
 32 #  请注意这一点.
 33 #
 34 #  对于这一组盘子,数量少时,只需要移动很少的次数就能达到要求.
 35 #+ 但随着这组盘子的数量的增加,
 36 #+ 移动的次数几乎成倍增长的,
 37 #+ 而移动的策略变得愈加复杂.
 38 #
 39 #  想了解更多的信息, 请访问 http://hanoi.kernelthread.com.
 40 #
 41 #
 42 #         ...                   ...                    ...
 43 #         | |                   | |                    | |
 44 #        _|_|_                  | |                    | |
 45 #       |_____|                 | |                    | |
 46 #      |_______|                | |                    | |
 47 #     |_________|               | |                    | |
 48 #    |___________|              | |                    | |
 49 #   |             |             | |                    | |
 50 # .--------------------------------------------------------------.
 51 # |**************************************************************|
 52 #          #1                   #2                      #3
 53 #
 54 #=================================================================#
 55 
 56 
 57 E_NOPARAM=66  # 没有参数传给脚本.
 58 E_BADPARAM=67 # 传给脚本的盘子数不合法.
 59 Moves=        # 保存移动次数的全局变量.
 60               # 这儿修改了原脚本.
 61 
 62 dohanoi() {   # 递归函数.
 63     case $1 in
 64     0)
 65         ;;
 66     *)
 67         dohanoi "$(($1-1))" $2 $4 $3
 68         echo move $2 "-->" $3
 69  let "Moves += 1"  # 这儿修改了原脚本.
 70         dohanoi "$(($1-1))" $4 $3 $2
 71         ;;
 72     esac
 73 }
 74 
 75 case $# in
 76 1)
 77     case $(($1>0)) in     # 至少要有一个盘子.
 78     1)
 79         dohanoi $1 1 3 2
 80         echo "Total moves = $Moves"
 81         exit 0;
 82         ;;
 83     *)
 84         echo "$0: illegal value for number of disks";
 85         exit $E_BADPARAM;
 86         ;;
 87     esac
 88     ;;
 89 *)
 90     echo "usage: $0 N"
 91     echo "       Where \"N\" is the number of disks."
 92     exit $E_NOPARAM;
 93     ;;
 94 esac
 95 
 96 # 练习:
 97 # ---------
 98 # 1) 从现在这个位置以下的命令会不会总是被执行?
 99 #    为什么? (容易)
100 # 2) 解释这个可运行的"dohanoi"函数的原理.
101 #    (难)
################################End Script######################################### 
第24章 别名(Aliases)
=====================
Bash别名本质上是一个简称, 缩写, 这可避免键入过长的命令序列. 例如,如果我们添加 
alias lm="ls -l | more" 这一行到文件~/.bashrc file里, 然后每次在命令行键入lm 将会
自动被替换成ls -l | more. 这使用户在命令行不必键冗长的命令序列也避免了记忆复杂的命
令及众多选项. 设置alias rm="rm -i" (交互式删除)可以使你犯下错误时不必过度悲伤,它
能避免你不小心删除重要文件. 
在脚本里,别名机制不是非常的有用. 如果把别名机制想像成C预处理器的某些功能将会非常
好,比如宏扩展,但是,不幸的是Bash不能在别名中扩展参数. [1] 而且,别名不能在“混合
型的结构”中使用,比如if/then语句, 循环, 和函数. 还有一个限制是别名不能递归地扩展. 
大多数情况Almost invariably, 我们想让别名完成的工作都能被函数更高效地完成. 
Example 24-1 脚本中的别名
################################Start Script#######################################
 1 #!/bin/bash
 2 # alias.sh
 3 
 4 shopt -s expand_aliases
 5 # 必须设置这个选项,否则脚本不会扩展别名功能.
 6 
 7 
 8 # 首先, 来点有趣的.
 9 alias Jesse_James='echo "\"Alias Jesse James\" was a 1959 comedy starring Bob Hope."'
10 Jesse_James
11 
12 echo; echo; echo;
13 
14 alias ll="ls -l"
15 # 可以使用单引号(')或双引号(")来定义一个别名.
16 
17 echo "Trying aliased \"ll\":"
18 ll /usr/X11R6/bin/mk*   #* 别名工作了.
19 
20 echo
21 
22 directory=/usr/X11R6/bin/
23 prefix=mk*  # 看通配符会不会引起麻烦.
24 echo "Variables \"directory\" + \"prefix\" = $directory$prefix"
25 echo
26 
27 alias lll="ls -l $directory$prefix"
28 
29 echo "Trying aliased \"lll\":"
30 lll         # 详细列出在/usr/X11R6/bin目录下所有以mk开头的文件.
31 # 别名能处理连接变量 -- 包括通配符 -- o.k.
32 
33 
34 
35 
36 TRUE=1
37 
38 echo
39 
40 if [ TRUE ]
41 then
42   alias rr="ls -l"
43   echo "Trying aliased \"rr\" within if/then statement:"
44   rr /usr/X11R6/bin/mk*   #* 引起错误信息!
45   # 别名不能在混合结构中使用.
46   echo "However, previously expanded alias still recognized:"
47   ll /usr/X11R6/bin/mk*
48 fi  
49 
50 echo
51 
52 count=0
53 while [ $count -lt 3 ]
54 do
55   alias rrr="ls -l"
56   echo "Trying aliased \"rrr\" within \"while\" loop:"
57   rrr /usr/X11R6/bin/mk*   #* 在这儿,别名也不会扩展.
58                            #  alias.sh: line 57: rrr: command not found
59   let count+=1
60 done 
61 
62 echo; echo
63 
64 alias xyz='cat $0'   # 脚本打印自身内容.
65                      # 注意是单引号(强引用).
66 xyz
67 #  虽然Bash的文档它是不会工作的,但好像它是可以工作的.
68 #
69 #
70 #  然而,就像 Steve Jacobson指出,
71 #+ 参数"$0"立即扩展成了这个别名的声明.
72 
73 exit 0
################################End Script######################################### 
unalias 命令删除先前设置的别名. 
Example 24-2 unalias: 设置和删除别名
################################Start Script#######################################
 1 #!/bin/bash
 2 # unalias.sh
 3 
 4 shopt -s expand_aliases  # 打开别名功能扩展.
 5 
 6 alias llm='ls -al | more'
 7 llm
 8 
 9 echo
10 
11 unalias llm              # 删除别名.
12 llm
13 # 引起错误信息,因为'llm'已经不再有效了.
14 
15 exit 0
################################End Script######################################### 
 bash$ ./unalias.sh
 total 6
drwxrwxr-x    2 bozo     bozo         3072 Feb  6 14:04 .
drwxr-xr-x   40 bozo     bozo         2048 Feb  6 14:04 ..
-rwxr-xr-x    1 bozo     bozo          199 Feb  6 14:04 unalias.sh 
./unalias.sh: llm: command not found 
注意事项:
[1]  但是, 别名好像能扩展位置参数. 
第25章 列表结构
================
"与列表(and list)"和"或列表(or list)" 结构提供一种处理一串连续命令的方法. 它们能有
效地替代复杂的嵌套if/then语句甚至可以代替case语句. 
连接命令 
与列表(and list) 
    1 command-1 && command-2 && command-3 && ... command-n 
 如果每个命令都返回真值(0)将会依次执行下去. 当某个命令返回假值(非零值), 整个命
 令链就会结束执行(第一个返回假的命令将会是最后一个执行的命令,后面的都不再执行). 
Example 25-1 使用"与列表(and list)"来测试命令行参数
################################Start Script#######################################
 1 #!/bin/bash
 2 # "and list"
 3 
 4 if [ ! -z "$1" ] && echo "Argument #1 = $1" && [ ! -z "$2" ] && echo "Argument #2 = $2"
 5 then
 6   echo "At least 2 arguments passed to script."
 7   # 所有连接起来的命令都返回真.
 8 else
 9   echo "Less than 2 arguments passed to script."
10   # 整个命令列表中至少有一个命令返回假值.
11 fi  
12 # 注意"if [ ! -z $1 ]" 可以工作,但它是有所假定的等价物,
13 #   if [ -n $1 ] 不会工作.
14 #     但是, 加引用可以让它工作.
15 #  if [ -n "$1" ] 就可以了.
16 #     小心!
17 # 最好总是引起要测试的变量.
18 
19 
20 # 这是使用"纯粹"的 if/then 语句完成的同等功能.
21 if [ ! -z "$1" ]
22 then
23   echo "Argument #1 = $1"
24 fi
25 if [ ! -z "$2" ]
26 then
27   echo "Argument #2 = $2"
28   echo "At least 2 arguments passed to script."
29 else
30   echo "Less than 2 arguments passed to script."
31 fi
32 # 这会更长且不如"与列表"精致.
33 
34 
35 exit 0
################################End Script######################################### 
Example 25-2 用"与列表"的另一个命令行参数测试
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 ARGS=1        # 期望的参数个数.
 4 E_BADARGS=65  # 如果用户给出不正确的参数个数的退出码.
 5 
 6 test $# -ne $ARGS && echo "Usage: `basename $0` $ARGS argument(s)" && exit $E_BADARGS
 7 #  如果 条件1 测试为真(表示传给脚本的参数不对),
 8 #+ 则余下的命令会被执行,并且脚本结束运行.
 9 
10 # 下面的代码只有当上面的测试失败时才会执行.
11 echo "Correct number of arguments passed to this script."
12 
13 exit 0
14 
15 # 为了检查退出码,脚本结束后用"echo $?"来查看退出码.
################################End Script######################################### 
 当然,一个与列表也能给变量设置默认值. 
    1 arg1=$@       # 不管怎样,设置变量$arg1为命令行参数.
    2 
    3 [ -z "$arg1" ] && arg1=DEFAULT
    4               # 如果没有在命令行上指定参数则把$arg1设置为DEFAULT. 
或列表(or list) 
    1 command-1 || command-2 || command-3 || ... command-n 
 只要前一个命令返回假命令链就会依次执行下去. 一旦有一个命令返回真, 命令链就会结
 束(第一个返回真的命令将会是最后一个执行的命令). 这显然和"与列表"正好相反. 
Example 25-3 "或列表"和"与列表"的结合使用
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 #  delete.sh, 不是很聪明的文件删除功能.
 4 #  用法: delete filename
 5 
 6 E_BADARGS=65
 7 
 8 if [ -z "$1" ]
 9 then
10   echo "Usage: `basename $0` filename"
11   exit $E_BADARGS  # 没有参数? 跳出脚本.
12 else  
13   file=$1          # 设置文件名.
14 fi  
15 
16 
17 [ ! -f "$file" ] && echo "File \"$file\" not found. \
18 Cowardly refusing to delete a nonexistent file."
19 # 与列表, 用于文件不存在时给出一个错误信息.
20 # 注意 echo 命令的参数用了一个转义符继续使第二行也是这个命令的参数.
21 
22 [ ! -f "$file" ] || (rm -f $file; echo "File \"$file\" deleted.")
23 # 或列表, 用于存在文件时删除此文件.
24 
25 # 注意上面两个相反的逻辑.
26 # 与列表为真时才执行, 或列表为假时执行.
27 
28 exit 0
################################End Script#########################################
 注意: 如果在与列表的第一个命令返回真时,它会执行. 
   1 # ==> 下面的片断摘自Miquel van Smoorenburg写的 /etc/rc.d/init.d/single 脚本 
   2 #+==> 示例与和或列表的使用.
   3 # ==> "箭头"的注释由本书作者添加.
   4 
   5 [ -x /usr/bin/clear ] && /usr/bin/clear
   6   # ==> 如果 /usr/bin/clear 存在, 则调用它.
   7   # ==> 在调用一个命令前检查它是否存在,
   8   #+==> 以避免产生错误信息和其他难读懂的结果.
   9 
  10   # ==> . . .
  11 
  12 # 如果他们想在单用户模式下运行某些程序, 可能也会运行这个...
  13 for i in /etc/rc1.d/S[0-9][0-9]* ; do
  14         # 检查脚本是否可执行.
  15         [ -x "$i" ] || continue
  16   # ==> 如果在目录$PWD中相应的文件没有发现,
  17   #+==> 则会跳过此次循环.
  18 
  19         # 不接受备份文件和由rpm产生的文件.
  20         case "$1" in
  21                 *.rpmsave|*.rpmorig|*.rpmnew|*~|*.orig)
  22                         continue;;
  23         esac
  24         [ "$i" = "/etc/rc1.d/S00single" ] && continue
  25   # ==> 设置脚本名,但还不执行它.
  26         $i start
  27 done
  28 
  29   # ==> . . . 
注意: 与列表或是或列表的退出状态是最后一个执行命令的退出状态. 
灵活地组合"与"和"或"列表是允许的,但这样逻辑会很容易变得费解并且需要较多的测试. 
   1 false && true || echo false         # false
   2 
   3 # 结果等同
   4 ( false && true ) || echo false     # false
   5 # 但不同与
   6 false && ( true || echo false )     # (没有输出)
   7 
   8 #  注意是从左到右来分组并求值的,
   9 #+ 因为逻辑操作符"&&"和"||"有相同的优先处理权.
  10 
  11 #  最好避免这种复杂,除非你确实知道你在做什么.
  12 
  13 #  Thanks, S.C. 
参考例子 A-7和例子 7-4 演示的使用与/或列表测试变量的例子. 
第26章 数组
============
较新的Bash版本支持一维数组. 数组元素可以用符号variable[xx]来初始化. 另外,脚本可以
用declare -a variable语句来清楚地指定一个数组. 要访问一个数组元素,可以使用花括号
来访问,即${variable[xx]}. 
Example 26-1 简单的数组用法
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 
 4 area[11]=23
 5 area[13]=37
 6 area[51]=UFOs
 7 
 8 #  数组成员不必一定要连贯或连续的.
 9 
10 #  数组的一部分成员允许不被初始化.
11 #  数组中空缺元素是允许的.
12 #  实际上,保存着稀疏数据的数组(“稀疏数组”)在电子表格处理软件中非常有用.
13 #
14 
15 
16 echo -n "area[11] = "
17 echo ${area[11]}    #  {大括号}是需要的.
18 
19 echo -n "area[13] = "
20 echo ${area[13]}
21 
22 echo "Contents of area[51] are ${area[51]}."
23 
24 # 没有初始化内容的数组元素打印空值(NULL值).
25 echo -n "area[43] = "
26 echo ${area[43]}
27 echo "(area[43] unassigned)"
28 
29 echo
30 
31 # 两个数组元素的和被赋值给另一个数组元素
32 area[5]=`expr ${area[11]} + ${area[13]}`
33 echo "area[5] = area[11] + area[13]"
34 echo -n "area[5] = "
35 echo ${area[5]}
36 
37 area[6]=`expr ${area[11]} + ${area[51]}`
38 echo "area[6] = area[11] + area[51]"
39 echo -n "area[6] = "
40 echo ${area[6]}
41 # 这里会失败是因为整数和字符串相加是不允许的.
42 
43 echo; echo; echo
44 
45 # -----------------------------------------------------------------
46 # 另一个数组, "area2".
47 # 另一种指定数组元素的值的办法...
48 # array_name=( XXX YYY ZZZ ... )
49 
50 area2=( zero one two three four )
51 
52 echo -n "area2[0] = "
53 echo ${area2[0]}
54 # 啊哈, 从0开始计数(即数组的第一个元素是[0], 而不是 [1]).
55 
56 echo -n "area2[1] = "
57 echo ${area2[1]}    # [1] 是数组的第二个元素.
58 # -----------------------------------------------------------------
59 
60 echo; echo; echo
61 
62 # -----------------------------------------------
63 # 第三种数组, "area3".
64 # 第三种指定数组元素值的办法...
65 # array_name=([xx]=XXX [yy]=YYY ...)
66 
67 area3=([17]=seventeen [24]=twenty-four)
68 
69 echo -n "area3[17] = "
70 echo ${area3[17]}
71 
72 echo -n "area3[24] = "
73 echo ${area3[24]}
74 # -----------------------------------------------
75 
76 exit 0
################################End Script#########################################
注意: Bash 允许把变量当成数组来操作,即使这个变量没有明确地被声明为数组. 
     1 string=abcABC123ABCabc
     2 echo ${string[@]}               # abcABC123ABCabc
     3 echo ${string[*]}               # abcABC123ABCabc 
     4 echo ${string[0]}               # abcABC123ABCabc
     5 echo ${string[1]}               # 没有输出!
     6                                 # 为什么?
     7 echo ${#string[@]}              # 1
     8                                 # 数组中只有一个元素.
     9                                 # 且是这个字符串本身.
    10 
    11 # Thank you, Michael Zick, for pointing this out. 
  类似的示范请参考Bash variables are untyped. 
Example 26-2 格式化一首诗
################################Start Script#######################################
 1 #!/bin/bash
 2 # poem.sh: 排印出作者喜欢的一首诗.
 3 
 4 # 诗的行数 (一小节诗).
 5 Line[1]="I do not know which to prefer,"
 6 Line[2]="The beauty of inflections"
 7 Line[3]="Or the beauty of innuendoes,"
 8 Line[4]="The blackbird whistling"
 9 Line[5]="Or just after."
10 
11 # 出处.
12 Attrib[1]=" Wallace Stevens"
13 Attrib[2]="\"Thirteen Ways of Looking at a Blackbird\""
14 # 此诗是公众的 (版权期已经到期了).
15 
16 echo
17 
18 for index in 1 2 3 4 5    # 5行.
19 do
20   printf "     %s\n" "${Line[index]}"
21 done
22 
23 for index in 1 2          # 打印两行出处行.
24 do
25   printf "          %s\n" "${Attrib[index]}"
26 done
27 
28 echo
29 
30 exit 0
31 
32 # 练习:
33 # --------
34 # 修改这个脚本使其从一个文本文件中提取内容打印一首行.
################################End Script#########################################
数组元素有它们独有的语法, 并且甚至Bash命令和操作符有特殊的选项可以支持数组使用. 
Example 26-3 多种数组操作
################################Start Script#######################################
 1 #!/bin/bash
 2 # array-ops.sh: 数组更多有趣的用法.
 3 
 4 
 5 array=( zero one two three four five )
 6 # 元素    0   1   2    3     4    5
 7 
 8 echo ${array[0]}       #  zero
 9 echo ${array:0}        #  zero
10                        #  第一个元素的参数扩展,
11                        #+ 从位置0开始 (即第一个字符).
12 echo ${array:1}        #  ero
13                        #  第一个元素的参数扩展,
14                        #+ 从位置1开始 (即第二个字符).
15 
16 echo "--------------"
17 
18 echo ${#array[0]}      #  4
19                        #  数组第一个元素的长度.
20 echo ${#array}         #  4
21                        #  数组第一个元素的长度.
22                        #  (另一种写法)
23 
24 echo ${#array[1]}      #  3
25                        #  数组第二个元素的长度.
26                        #  Bash的数组是0开始索引的.
27 
28 echo ${#array[*]}      #  6
29                        #  数组中元素的个数.
30 echo ${#array[@]}      #  6
31                        #  数组中元素的个数.
32 
33 echo "--------------"
34 
35 array2=( [0]="first element" [1]="second element" [3]="fourth element" )
36 
37 echo ${array2[0]}      # 第一个元素
38 echo ${array2[1]}      # 第二个元素
39 echo ${array2[2]}      #
40                        # 因为初始化时没有指定,因此值为空(null).
41 echo ${array2[3]}      # 第四个元素
42 
43 
44 exit 0
################################End Script######################################### 
大部分标准的字符串操作符 可以用于数组操作. 
Example 26-4 用于数组的字符串操作符
################################Start Script#######################################
  1 #!/bin/bash
  2 # array-strops.sh: 用于数组的字符串操作符.
  3 # 由Michael Zick编码.
  4 # 已征得作者的同意.
  5 
  6 #  一般来说,任何类似 ${name ... } 写法的字符串操作符
  7 #+ 都能在一个数组的所有字符串元素中使用
  8 #+ 像${name[@] ... } 或 ${name[*] ...} 的写法.
  9 
 10 
 11 arrayZ=( one two three four five five )
 12 
 13 echo
 14 
 15 # 提取尾部的子串
 16 echo ${arrayZ[@]:0}     # one two three four five five
 17                         # 所有的元素.
 18 
 19 echo ${arrayZ[@]:1}     # two three four five five
 20                         # 在第一个元素 element[0]后面的所有元素.
 21 
 22 echo ${arrayZ[@]:1:2}   # two three
 23                         # 只提取在元素 element[0]后面的两个元素.
 24 
 25 echo "-----------------------"
 26 
 27 #  子串删除
 28 #  从字符串的前部删除最短的匹配,
 29 #+ 匹配字串是一个正则表达式.
 30 
 31 echo ${arrayZ[@]#f*r}   # one two three five five
 32                         # 匹配表达式作用于数组所有元素.
 33                         # 匹配了"four"并把它删除.
 34 
 35 # 字符串前部最长的匹配
 36 echo ${arrayZ[@]##t*e}  # one two four five five
 37                         # 匹配表达式作用于数组所有元素.
 38                         # 匹配"three"并把它删除.
 39 
 40 # 字符串尾部的最短匹配
 41 echo ${arrayZ[@]%h*e}   # one two t four five five
 42                         # 匹配表达式作用于数组所有元素.
 43                         # 匹配"hree"并把它删除.
 44 
 45 # 字符串尾部的最长匹配
 46 echo ${arrayZ[@]%%t*e}  # one two four five five
 47                         # 匹配表达式作用于数组所有元素.
 48                         # 匹配"three"并把它删除.
 49 
 50 echo "-----------------------"
 51 
 52 # 子串替换
 53 
 54 # 第一个匹配的子串会被替换
 55 echo ${arrayZ[@]/fiv/XYZ}   # one two three four XYZe XYZe
 56                             # 匹配表达式作用于数组所有元素.
 57 
 58 # 所有匹配的子串会被替换
 59 echo ${arrayZ[@]//iv/YY}    # one two three four fYYe fYYe
 60                             # 匹配表达式作用于数组所有元素.
 61 
 62 # 删除所有的匹配子串
 63 # 没有指定代替字串意味着删除
 64 echo ${arrayZ[@]//fi/}      # one two three four ve ve
 65                             # 匹配表达式作用于数组所有元素.
 66 
 67 # 替换最前部出现的字串
 68 echo ${arrayZ[@]/#fi/XY}    # one two three four XYve XYve
 69                             # 匹配表达式作用于数组所有元素.
 70 
 71 # 替换最后部出现的字串
 72 echo ${arrayZ[@]/%ve/ZZ}    # one two three four fiZZ fiZZ
 73                             # 匹配表达式作用于数组所有元素.
 74 
 75 echo ${arrayZ[@]/%o/XX}     # one twXX three four five five
 76                             # 为什么?
 77 
 78 echo "-----------------------"
 79 
 80 
 81 # 在从awk(或其他的工具)取得数据之前 --
 82 # 记得:
 83 #   $( ... ) 是命令替换.
 84 #   函数以子进程运行.
 85 #   函数将输出打印到标准输出.
 86 #   用read来读取函数的标准输出.
 87 #   name[@]的写法指定了一个"for-each"的操作.
 88 
 89 newstr() {
 90     echo -n "!!!"
 91 }
 92 
 93 echo ${arrayZ[@]/%e/$(newstr)}
 94 # on!!! two thre!!! four fiv!!! fiv!!!
 95 # Q.E.D: 替换部分的动作实际上是一个'赋值'.
 96 
 97 #  使用"For-Each"型的
 98 echo ${arrayZ[@]//*/$(newstr optional_arguments)}
 99 #  现在Now, 如果if Bash只传递匹配$0的字符串给要调用的函数. . . 
100 #
101 
102 echo
103 
104 exit 0
################################End Script######################################### 
命令替换能创建数组的新的单个元素. 
Example 26-5 将脚本的内容传给数组
################################Start Script#######################################
 1 #!/bin/bash
 2 # script-array.sh: 把此脚本的内容传进数组.
 3 # 从Chris Martin的e-mail中得到灵感 (多谢!).
 4 
 5 script_contents=( $(cat "$0") )  #  把这个脚本($0)的内容存进数组.
 6                                  #
 7 
 8 for element in $(seq 0 $((${#script_contents[@]} - 1)))
 9   do                #  ${#script_contents[@]}
10                     #+ 表示数组中元素的个数.
11                     #
12                     #  问题:
13                     #  为什么需要  seq 0  ?
14                     #  试试更改成 seq 1.
15   echo -n "${script_contents[$element]}"
16                     # 将脚本的每行列成一个域.
17   echo -n " -- "    # 使用" -- "作为域分隔符.
18 done
19 
20 echo
21 
22 exit 0
23 
24 # 练习:
25 # --------
26 #  修改这个脚本使它能按照它原本的格式输出,
27 #+ 连同空白符,换行,等等.
28 #
################################End Script#########################################
在数组的环境里, 一些 Bash 内建的命令 含义有一些轻微的改变. 例如, unset 会删除数组
元素, 或甚至删除整个数组. 
Example 26-6 一些数组专用的工具
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 declare -a colors
 4 #  所有脚本后面的命令都会把
 5 #+ 变量"colors"作为数组对待.
 6 
 7 echo "Enter your favorite colors (separated from each other by a space)."
 8 
 9 read -a colors    # 键入至少3种颜色以用于下面的示例.
10 #  指定'read'命令的选项,
11 #+ 允许指定数组元素.
12 
13 echo
14 
15 element_count=${#colors[@]}
16 # 专用语法来提取数组元素的个数.
17 #     element_count=${#colors[*]} 也可以.
18 #
19 #  "@"变量允许分割引号内的单词
20 #+ (依靠空白字符来分隔变量).
21 #
22 #  这就像"$@" 和"$*"在位置参数中表现出来的一样.
23 # 
24 
25 index=0
26 
27 while [ "$index" -lt "$element_count" ]
28 do    # List all the elements in the array.
29   echo ${colors[$index]}
30   let "index = $index + 1"
31 done
32 # 每个数组元素被列为单独的一行.
33 # 如果这个没有要求, 可以用  echo -n "${colors[$index]} "
34 #
35 # 可以用一个"for"循环来做:
36 #   for i in "${colors[@]}"
37 #   do
38 #     echo "$i"
39 #   done
40 # (Thanks, S.C.)
41 
42 echo
43 
44 # 再次列出数组中所有的元素, 但使用更优雅的做法.
45   echo ${colors[@]}          # echo ${colors[*]} 也可以.
46 
47 echo
48 
49 # "unset"命令删除一个数组元素或是整个数组.
50 unset colors[1]              # 删除数组的第二个元素.
51                              # 作用等同于   colors[1]=
52 echo  ${colors[@]}           # 再列出数组,第二个元素没有了.
53 
54 unset colors                 # 删除整个数组.
55                              #  unset colors[*] 或
56                              #+ unset colors[@] 都可以.
57 echo; echo -n "Colors gone."      
58 echo ${colors[@]}            # 再列出数组, 则为空了.
59 
60 exit 0
################################End Script######################################### 
正如在前面的例子中看到的, ${array_name[@]}和${array_name[*]} 都与数组的所有元素相
关. 同样地, 为了计算数组的元素个数, 可以用${#array_name[@]} 或${#array_name[*]}. 
${#array_name} 是数组第一个元素${array_name[0]}的长度(字符数) . 
Example 26-7 关于空数组和空数组元素
################################Start Script#######################################
  1 #!/bin/bash
  2 # empty-array.sh
  3 
  4 #  多谢 Stephane Chazelas 制作这个例子最初的版本,
  5 #+ 并由 Michael Zick 扩展了.
  6 
  7 
  8 # 空数组不同与含有空值元素的数组.
  9 
 10 array0=( first second third )
 11 array1=( '' )   # "array1" 由一个空元素组成.
 12 array2=( )      # 没有元素 . . . "array2" 是空的.
 13 
 14 echo
 15 ListArray()
 16 {
 17 echo
 18 echo "Elements in array0:  ${array0[@]}"
 19 echo "Elements in array1:  ${array1[@]}"
 20 echo "Elements in array2:  ${array2[@]}"
 21 echo
 22 echo "Length of first element in array0 = ${#array0}"
 23 echo "Length of first element in array1 = ${#array1}"
 24 echo "Length of first element in array2 = ${#array2}"
 25 echo
 26 echo "Number of elements in array0 = ${#array0[*]}"  # 3
 27 echo "Number of elements in array1 = ${#array1[*]}"  # 1  (惊奇!)
 28 echo "Number of elements in array2 = ${#array2[*]}"  # 0
 29 }
 30 
 31 # ===================================================================
 32 
 33 ListArray
 34 
 35 # 尝试扩展这些数组.
 36 
 37 # 增加一个元素到数组.
 38 array0=( "${array0[@]}" "new1" )
 39 array1=( "${array1[@]}" "new1" )
 40 array2=( "${array2[@]}" "new1" )
 41 
 42 ListArray
 43 
 44 # 或
 45 array0[${#array0[*]}]="new2"
 46 array1[${#array1[*]}]="new2"
 47 array2[${#array2[*]}]="new2"
 48 
 49 ListArray
 50 
 51 # 当像上面的做法增加数组时,数组像 '栈'
 52 # 上面的做法是 'push(压栈)'
 53 # 栈高是:
 54 height=${#array2[@]}
 55 echo
 56 echo "Stack height for array2 = $height"
 57 
 58 # 'pop(出栈)' 是:
 59 unset array2[${#array2[@]}-1]   # 数组是以0开始索引的,
 60 height=${#array2[@]}            #+ 这就意味着第一个元素下标是 0.
 61 echo
 62 echo "POP"
 63 echo "New stack height for array2 = $height"
 64 
 65 ListArray
 66 
 67 # 只列出数组array0的第二和第三个元素.
 68 from=1   #是以0开始的数字
 69 to=2  #
 70 array3=( ${array0[@]:1:2} )
 71 echo
 72 echo "Elements in array3:  ${array3[@]}"
 73 
 74 # 像一个字符串一样处理(字符的数组).
 75 # 试试其他的字符串格式.
 76 
 77 # 替换:
 78 array4=( ${array0[@]/second/2nd} )
 79 echo
 80 echo "Elements in array4:  ${array4[@]}"
 81 
 82 # 替换所有匹配通配符的字符串.
 83 array5=( ${array0[@]//new?/old} )
 84 echo
 85 echo "Elements in array5:  ${array5[@]}"
 86 
 87 # 当你开始觉得对此有把握的时候 . . .
 88 array6=( ${array0[@]#*new} )
 89 echo # 这个可能会使你感到惊奇.
 90 echo "Elements in array6:  ${array6[@]}"
 91 
 92 array7=( ${array0[@]#new1} )
 93 echo # 数组array6之后就没有惊奇了.
 94 echo "Elements in array7:  ${array7[@]}"
 95 
 96 # 这看起来非常像 . . .
 97 array8=( ${array0[@]/new1/} )
 98 echo
 99 echo "Elements in array8:  ${array8[@]}"
100 
101 #  那么我们怎么总结它呢So what can one say about this?
102 
103 #  字符串操作在数组var[@]的每一个元素中执行.
104 #
105 #  因此Therefore : 如果结果是一个零长度的字符串,
106 #+ Bash支持字符串向量操作,
107 #+ 元素会在结果赋值中消失不见.
108 
109 #  提问, 这些字符串是强还是弱引用?
110 
111 zap='new*'
112 array9=( ${array0[@]/$zap/} )
113 echo
114 echo "Elements in array9:  ${array9[@]}"
115 
116 # 当你还在想你在Kansas州的何处时 . . .
117 array10=( ${array0[@]#$zap} )
118 echo
119 echo "Elements in array10:  ${array10[@]}"
120 
121 # 把 array7 和 array10比较.
122 # 把 array8 和 array9比较.
123 
124 # 答案: 必须用弱引用.
125 
126 exit 0
################################End Script######################################### 
${array_name[@]}和${array_name[*]} 的关系类似于$@ and $*. 这种数组用法非常有用. 
   1 # 复制一个数组.
   2 array2=( "${array1[@]}" )
   3 # 或
   4 array2="${array1[@]}"
   5 
   6 # 给数组增加一个元素.
   7 array=( "${array[@]}" "new element" )
   8 # 或
   9 array[${#array[*]}]="new element"
  10 
  11 # Thanks, S.C. 
注意: array=( element1 element2 ... elementN ) 初始化操作, 依赖于命令替换
  (command substitution)使将一个文本内容加载进数组成为可能. 
   1 #!/bin/bash
   2 
   3 filename=sample_file
   4 
   5 #            cat sample_file
   6 #
   7 #            1 a b c
   8 #            2 d e fg
   9 
  10 
  11 declare -a array1
  12 
  13 array1=( `cat "$filename"`)                #  加载$filename文件的内容进数组array1.
  14 #         打印文件到标准输出               #
  15 #
  16 #  array1=( `cat "$filename" | tr '\n' ' '`)
  17 #                            把文件里的换行变为空格. 
  18 #  这是没必要的,因为Bash做单词分割时会把换行变为空格.
  19 #
  20 
  21 echo ${array1[@]}            # 打印数组.
  22 #                              1 a b c 2 d e fg
  23 #
  24 #  文件中每个由空白符分隔开的“词”都被存在数组的一个元素里
  25 #
  26 
  27 element_count=${#array1[*]}
  28 echo $element_count          # 8 
出色的技巧使数组的操作技术又多了一种. 
Example 26-8 初始化数组
################################Start Script#######################################
 1 #! /bin/bash
 2 # array-assign.bash
 3 
 4 #  数组操作是Bash特有的,
 5 #+ 因此脚本名用".bash"结尾.
 6 
 7 # Copyright (c) Michael S. Zick, 2003, All rights reserved.
 8 # 许可证: 没有任何限制,可以用于任何目的的反复使用.
 9 # Version: $ID$
10 #
11 # 由William Park添加注释.
12 
13 #  基于Stephane Chazelas提供在本书中的一个例子
14 #
15 
16 # 'times' 命令的输出格式:
17 # User CPU <空格> System CPU
18 # User CPU of dead children <空格> System CPU of dead children
19 
20 #  Bash赋一个数组的所有元素给新的数组变量有两种办法. 
21 #
22 #  在Bash版本2.04, 2.05a 和 2.05b,
23 #+ 这两种办法都对NULL的值的元素全部丢弃.
24 #  另一种数组赋值办法是维护[下标]=值之间的关系将会在新版本的Bash支持.
25 #
26 
27 #  可以用外部命令来构造一个大数组,
28 #+ 但几千个元素的数组如下就可以构造了.
29 #
30 
31 declare -a bigOne=( /dev/* )
32 echo
33 echo 'Conditions: Unquoted, default IFS, All-Elements-Of'
34 echo "Number of elements in array is ${#bigOne[@]}"
35 
36 # set -vx
37 
38 
39 
40 echo
41 echo '- - testing: =( ${array[@]} ) - -'
42 times
43 declare -a bigTwo=( ${bigOne[@]} )
44 #                 ^              ^
45 times
46 
47 echo
48 echo '- - testing: =${array[@]} - -'
49 times
50 declare -a bigThree=${bigOne[@]}
51 # 这次没有用括号.
52 times
53 
54 #  正如Stephane Chazelas指出的那样比较输出的数组可以了解第二种格式的赋值比第三和第四的times的更快
55 #
56 #
57 #  William Park 解释explains:
58 #+ bigTwo 数组是被赋值了一个单字符串,
59 #+ bigThree 则赋值时一个一个元素的赋值.
60 #  所以, 实际上的情况是:
61 #                   bigTwo=( [0]="... ... ..." )
62 #                   bigThree=( [0]="..." [1]="..." [2]="..." ... )
63 
64 
65 #  我在本书的例子中仍然会继续用第一种格式,
66 #+ 因为我认为这会对说明清楚更有帮助.
67 
68 #  我的例子中的可复用的部分实际上还是会使用第二种格式,
69 #+ 因为这种格式更快一些.
70 
71 # MSZ: 很抱歉早先的失误(应是指本书的先前版本).
72 
73 
74 #  注:
75 #  ----
76 #  在31和43行的"declare -a"语句不是必须的,
77 #+ 因为会在使用Array=( ... )赋值格式时暗示它是数组.
78 #
79 #  但是, 省略这些声明会导致后面脚本的相关操作更慢一些.
80 #
81 #  试一下, 看有什么变化.
82 
83 exit 0
################################End Script######################################### 
注意: 对变量增加 declare -a  语句声明可以加速后面的数组操作速度. 
Example 26-9 复制和连接数组
################################Start Script#######################################
 1 #! /bin/bash
 2 # CopyArray.sh
 3 #
 4 # 由 Michael Zick编写.
 5 # 在本书中使用已得到许可.
 6 
 7 #  怎么传递变量名和值处理,返回就用使用该变量,
 8 #+ 或说"创建你自己的赋值语句".
 9 
10 
11 CpArray_Mac() {
12 
13 # 创建赋值命令语句
14 
15     echo -n 'eval '
16     echo -n "$2"                    # 目的变量名
17     echo -n '=( ${'
18     echo -n "$1"                    # 源名字
19     echo -n '[@]} )'
20 
21 # 上面的全部会合成单个命令.
22 # 这就是函数所有的功能.
23 }
24 
25 declare -f CopyArray                # 函数"指针"
26 CopyArray=CpArray_Mac               # 建立命令
27 
28 Hype()
29 {
30 
31 # 要复制的数组名为 $1.
32 # (接合数组,并包含尾部的字符串"Really Rocks".)
33 # 返回结果的数组名为 $2.
34 
35     local -a TMP
36     local -a hype=( Really Rocks )
37 
38     $($CopyArray $1 TMP)
39     TMP=( ${TMP[@]} ${hype[@]} )
40     $($CopyArray TMP $2)
41 }
42 
43 declare -a before=( Advanced Bash Scripting )
44 declare -a after
45 
46 echo "Array Before = ${before[@]}"
47 
48 Hype before after
49 
50 echo "Array After = ${after[@]}"
51 
52 # 有多余的字符串?
53 
54 echo "What ${after[@]:3:2}?"
55 
56 declare -a modest=( ${after[@]:2:1} ${after[@]:3:2} )
57 #                    ----     子串提取       ----
58 
59 echo "Array Modest = ${modest[@]}"
60 
61 # 'before'变量变成什么了 ?
62 
63 echo "Array Before = ${before[@]}"
64 
65 exit 0
################################End Script######################################### 
Example 26-10 关于连接数组的更多信息
################################Start Script#######################################
  1 #! /bin/bash
  2 # array-append.bash
  3 
  4 # Copyright (c) Michael S. Zick, 2003, All rights reserved.
  5 # 许可: 可以无限制的以任何目的任何格式重复使用.
  6 # 版本: $ID$
  7 #
  8 # 格式上由M.C做了轻微的修改.
  9 
 10 
 11 # 数组操作是Bash特有的属性.
 12 # 原来的 UNIX /bin/sh 没有类似的功能.
 13 
 14 
 15 #  把此脚本的输出管道输送给 'more'
 16 #+ 以便输出不会滚过终端屏幕.
 17 
 18 
 19 # 下标依次使用.
 20 declare -a array1=( zero1 one1 two1 )
 21 # 下标有未使用的 ([1] 没有被定义).
 22 declare -a array2=( [0]=zero2 [2]=two2 [3]=three2 )
 23 
 24 echo
 25 echo '- Confirm that the array is really subscript sparse. -'
 26 echo "Number of elements: 4"        # 这儿是举例子就用硬编码.
 27 for (( i = 0 ; i < 4 ; i++ ))
 28 do
 29     echo "Element [$i]: ${array2[$i]}"
 30 done
 31 # 也可以参考basics-reviewed.bash更多的常见代码.
 32 
 33 
 34 declare -a dest
 35 
 36 # 组合 (添加) 两个数组到第三个数组.
 37 echo
 38 echo 'Conditions: Unquoted, default IFS, All-Elements-Of operator'
 39 echo '- Undefined elements not present, subscripts not maintained. -'
 40 # # 那些未定义的元素不存在; 组合时会丢弃这些元素.
 41 
 42 dest=( ${array1[@]} ${array2[@]} )
 43 # dest=${array1[@]}${array2[@]}     # 奇怪的结果, 或者叫臭虫.
 44 
 45 # 现在, 打印出结果.
 46 echo
 47 echo '- - Testing Array Append - -'
 48 cnt=${#dest[@]}
 49 
 50 echo "Number of elements: $cnt"
 51 for (( i = 0 ; i < cnt ; i++ ))
 52 do
 53     echo "Element [$i]: ${dest[$i]}"
 54 done
 55 
 56 # 把一个数组赋值给另一个数组的单个元素 (两次).
 57 dest[0]=${array1[@]}
 58 dest[1]=${array2[@]}
 59 
 60 # 列出结果.
 61 echo
 62 echo '- - Testing modified array - -'
 63 cnt=${#dest[@]}
 64 
 65 echo "Number of elements: $cnt"
 66 for (( i = 0 ; i < cnt ; i++ ))
 67 do
 68     echo "Element [$i]: ${dest[$i]}"
 69 done
 70 
 71 # 检测第二个元素的改变.
 72 echo
 73 echo '- - Reassign and list second element - -'
 74 
 75 declare -a subArray=${dest[1]}
 76 cnt=${#subArray[@]}
 77 
 78 echo "Number of elements: $cnt"
 79 for (( i = 0 ; i < cnt ; i++ ))
 80 do
 81     echo "Element [$i]: ${subArray[$i]}"
 82 done
 83 
 84 #  用 '=${ ... }' 把整个数组的值赋给另一个数组的单个元素
 85 #+ 使数组所有元素值被转换成了一个字符串,各元素的值由一个空格分开(其实是IFS的第一个字符).
 86 #
 87 #
 88 
 89 # 如果原先的元素没有包含空白符 . . .
 90 # 如果原先的数组下标都是连续的 . . .
 91 # 我们就能取回最初的数组结构.
 92 
 93 # 恢复第二个元素的修改回元素.
 94 echo
 95 echo '- - Listing restored element - -'
 96 
 97 declare -a subArray=( ${dest[1]} )
 98 cnt=${#subArray[@]}
 99 
100 echo "Number of elements: $cnt"
101 for (( i = 0 ; i < cnt ; i++ ))
102 do
103     echo "Element [$i]: ${subArray[$i]}"
104 done
105 echo '- - Do not depend on this behavior. - -'
106 echo '- - This behavior is subject to change - -'
107 echo '- - in versions of Bash newer than version 2.05b - -'
108 
109 # MSZ: 很抱歉早先时混淆的几个要点(译者注：应该是指本书早先的版本).
110 
111 exit 0
################################End Script#########################################
--
数组允许在脚本中实现一些常见的熟悉算法.这是否是必要的好想法在此不讨论,留给读者自
行判断. 
Example 26-11 一位老朋友: 冒泡排序
################################Start Script#######################################
 1 #!/bin/bash
 2 # bubble.sh: 排序法之冒泡排序.
 3 
 4 # 回忆冒泡排序法. 在这个版本中要实现它...
 5 
 6 #  靠连续地多次比较数组元素来排序,
 7 #+ 比较两个相邻的元素,如果排序顺序不对,则交换两者的顺序.
 8 #  当第一轮比较结束后,最"重"的元素就被排到了最底部.
 9 #  当第二轮比较结束后,第二"重"的元素就被排到了次底部的位置.
10 #  以此类推.
11 #  这意味着每轮的比较不需要比较先前已"沉淀"好的数据.
12 #  因此你会注意到后面数据的打印会比较快一些.
13 
14 
15 exchange()
16 {
17   # 交换数组的两个元素.
18   local temp=${Countries[$1]} #  临时保存要交换的一个元素.
19                               #
20   Countries[$1]=${Countries[$2]}
21   Countries[$2]=$temp
22   
23   return
24 }  
25 
26 declare -a Countries  #  声明数组,
27                       #+ 在此是可选的,因为下面它会被按数组来初始化.
28 
29 #  是否允许用转义符(\)将数组的各变量值放到几行上?
30 #
31 #  是的.
32 
33 Countries=(Netherlands Ukraine Zaire Turkey Russia Yemen Syria \
34 Brazil Argentina Nicaragua Japan Mexico Venezuela Greece England \
35 Israel Peru Canada Oman Denmark Wales France Kenya \
36 Xanadu Qatar Liechtenstein Hungary)
37 
38 # "Xanadu" 是个虚拟的充满美好的神话之地.
39 #
40 
41 
42 clear                      # 开始之前清除屏幕. 
43 
44 echo "0: ${Countries[*]}"  # 从0索引的元素开始列出整个数组.
45 
46 number_of_elements=${#Countries[@]}
47 let "comparisons = $number_of_elements - 1"
48 
49 count=1 # 传递数字.
50 
51 while [ "$comparisons" -gt 0 ]          # 开始外部的循环
52 do
53 
54   index=0  # 每轮开始前重设索引值为0.
55 
56   while [ "$index" -lt "$comparisons" ] # 开始内部循环
57   do
58     if [ ${Countries[$index]} \> ${Countries[`expr $index + 1`]} ]
59     #  如果原来的排序次序不对...
60     #  回想一下 \> 在单方括号里是is ASCII 码的比较操作符.
61     #
62 
63     #  if [[ ${Countries[$index]} > ${Countries[`expr $index + 1`]} ]]
64     #+ 也可以.
65     then
66       exchange $index `expr $index + 1`  # 交换.
67     fi  
68     let "index += 1"
69   done # 内部循环结束
70 
71 # ----------------------------------------------------------------------
72 # Paulo Marcel Coelho Aragao 建议使用更简单的for-loops.
73 #
74 # for (( last = $number_of_elements - 1 ; last > 1 ; last-- ))
75 # do
76 #     for (( i = 0 ; i < last ; i++ ))
77 #     do
78 #         [[ "${Countries[$i]}" > "${Countries[$((i+1))]}" ]] \
79 #             && exchange $i $((i+1))
80 #     done
81 # done
82 # ----------------------------------------------------------------------
83   
84 
85 let "comparisons -= 1" #  因为最"重"的元素冒到了最底部,
86                        #+ 我们可以每轮少做一些比较.
87 
88 echo
89 echo "$count: ${Countries[@]}"  # 每轮结束后,打印一次数组.
90 echo
91 let "count += 1"                # 增加传递计数.
92 
93 done                            # 外部循环结束
94                                 # 完成.
95 
96 exit 0
################################End Script#########################################
--
在数组内嵌一个数组有可能做到吗? 
   1 #!/bin/bash
   2 # "内嵌" 数组.
   3 
   4 #  Michael Zick 提供这个例子,
   5 #+ 由William Park作了些纠正和解释.
   6 
   7 AnArray=( $(ls --inode --ignore-backups --almost-all \
   8  --directory --full-time --color=none --time=status \
   9  --sort=time -l ${PWD} ) )  # 命令及选项.
  10 
  11 # 空格是有意义的 . . . 不要在上面引号引用任何东西.
  12 
  13 SubArray=( ${AnArray[@]:11:1}  ${AnArray[@]:6:5} )
  14 #  这个数组有6个元素:
  15 #+     SubArray=( [0]=${AnArray[11]} [1]=${AnArray[6]} [2]=${AnArray[7]}
  16 #      [3]=${AnArray[8]} [4]=${AnArray[9]} [5]=${AnArray[10]} )
  17 #
  18 #  Bash中的数组像是字符串(char *)型的(循环)链表.
  19 #
  20 #  因此, 这实际上不是内嵌的数组,
  21 #+ 但它的功能是相似的.
  22 
  23 echo "Current directory and date of last status change:"
  24 echo "${SubArray[@]}"
  25 
  26 exit 0 
--
内嵌数组和间接引用(indirect references) 的组合使用产生了一些有趣的用法. 
Example 26-12 内嵌数组和间接引用
################################Start Script#######################################
 1 #!/bin/bash
 2 # embedded-arrays.sh
 3 # 内嵌数组和间接引用.
 4 
 5 # 由Dennis Leeuw编写.
 6 # 已获使用许可.
 7 # 由本文作者修改.
 8 
 9 
10 ARRAY1=(
11         VAR1_1=value11
12         VAR1_2=value12
13         VAR1_3=value13
14 )
15 
16 ARRAY2=(
17         VARIABLE="test"
18         STRING="VAR1=value1 VAR2=value2 VAR3=value3"
19         ARRAY21=${ARRAY1[*]}
20 )       # 把ARRAY1数组嵌到这个数组里.
21 
22 function print () {
23         OLD_IFS="$IFS"
24         IFS=$'\n'       #  这是为了在每个行打印一个数组元素.
25                         #
26         TEST1="ARRAY2[*]"
27         local ${!TEST1} # 试下删除这行会发生什么.
28         #  间接引用.
29  #  这使 $TEST1只在函数内存取.
30  #
31 
32 
33         #  我们看看还能干点什么.
34         echo
35         echo "\$TEST1 = $TEST1"       #  变量的名称.
36         echo; echo
37         echo "{\$TEST1} = ${!TEST1}"  #  变量的内容.
38                                       #  这就是间接引用的作用.
39                                       #
40         echo
41         echo "-------------------------------------------"; echo
42         echo
43 
44 
45         # 打印变量
46         echo "Variable VARIABLE: $VARIABLE"
47  
48         # 打印一个字符串元素
49         IFS="$OLD_IFS"
50         TEST2="STRING[*]"
51         local ${!TEST2}      # 间接引用 (像上面一样).
52         echo "String element VAR2: $VAR2 from STRING"
53 
54         # 打印一个字符串元素
55         TEST2="ARRAY21[*]"
56         local ${!TEST2}      # 间接引用 (像上面一样).
57         echo "Array element VAR1_1: $VAR1_1 from ARRAY21"
58 }
59 
60 print
61 echo
62 
63 exit 0
64 
65 #   脚本作者注,
66 #+ "你可以很容易地将其扩展成Bash的一个能创建hash的脚本."
67 #   (难) 留给读者的练习: 实现它.
################################End Script######################################### 
--
数组使埃拉托色尼素数筛子有了shell脚本的实现. 当然, 如果是追求效率的应用自然应该用
一种编译型的语言,例如用C. 这种脚本运行实在是太慢. 
Example 26-13 复杂数组应用: 埃拉托色尼素数筛子
################################Start Script#######################################
  1 #!/bin/bash
  2 # sieve.sh (ex68.sh)
  3 
  4 # 埃拉托色尼素数筛子
  5 # 找素数的经典算法.
  6 
  7 #  在同等数量的数值内这个脚本比用C写的版本慢很多.
  8 #
  9 
 10 LOWER_LIMIT=1       # 从1开始.
 11 UPPER_LIMIT=1000    # 到 1000.
 12 # (如果你很有时间的话,你可以把它设得更高 . . . )
 13 
 14 PRIME=1
 15 NON_PRIME=0
 16 
 17 let SPLIT=UPPER_LIMIT/2
 18 # 优化:
 19 # 只需要测试中间到最大之间的值 (为什么?).
 20 
 21 
 22 declare -a Primes
 23 # Primes[] 是一个数组.
 24 
 25 
 26 initialize ()
 27 {
 28 # 初始化数组.
 29 
 30 i=$LOWER_LIMIT
 31 until [ "$i" -gt "$UPPER_LIMIT" ]
 32 do
 33   Primes[i]=$PRIME
 34   let "i += 1"
 35 done
 36 #  假定所有的数组成员都是需要检查的 (素数)
 37 #+ 一直到检查完成前.
 38 }
 39 
 40 print_primes ()
 41 {
 42 # 打印出所有Primes[]数组中被标记为素数的元素.
 43 
 44 i=$LOWER_LIMIT
 45 
 46 until [ "$i" -gt "$UPPER_LIMIT" ]
 47 do
 48 
 49   if [ "${Primes[i]}" -eq "$PRIME" ]
 50   then
 51     printf "%8d" $i
 52     # 每个数字打印前先打印8个空格, 数字是在偶数列打印的.
 53   fi
 54   
 55   let "i += 1"
 56   
 57 done
 58 
 59 }
 60 
 61 sift () # 查出非素数.
 62 {
 63 
 64 let i=$LOWER_LIMIT+1
 65 # 我们都知道1是素数, 所以我们从2开始.
 66 
 67 until [ "$i" -gt "$UPPER_LIMIT" ]
 68 do
 69 
 70 if [ "${Primes[i]}" -eq "$PRIME" ]
 71 # 不要处理已经过滤过的数字 (被标识为非素数).
 72 then
 73 
 74   t=$i
 75 
 76   while [ "$t" -le "$UPPER_LIMIT" ]
 77   do
 78     let "t += $i "
 79     Primes[t]=$NON_PRIME
 80     # 标识为非素数.
 81   done
 82 
 83 fi  
 84 
 85   let "i += 1"
 86 done  
 87 
 88 
 89 }
 90 
 91 
 92 # ==============================================
 93 # main ()
 94 # 继续调用函数.
 95 initialize
 96 sift
 97 print_primes
 98 # 这就是被称为结构化编程的东西了.
 99 # ==============================================
100 
101 echo
102 
103 exit 0
104 
105 
106 
107 # -------------------------------------------------------- #
108 # 因为前面的一个'exit',所以下面的代码不会被执行. 
109 
110 #  下面是Stephane Chazelas写的一个埃拉托色尼素数筛子的改进版本,
111 #+ 运行会稍微快一点.
112 
113 # 必须在命令行上指定参数(寻找素数的限制范围).
114 
115 UPPER_LIMIT=$1                  # 值来自命令行.
116 let SPLIT=UPPER_LIMIT/2         # 从中间值到最大值.
117 
118 Primes=( '' $(seq $UPPER_LIMIT) )
119 
120 i=1
121 until (( ( i += 1 ) > SPLIT ))  # 仅需要从中间值检查.
122 do
123   if [[ -n $Primes[i] ]]
124   then
125     t=$i
126     until (( ( t += i ) > UPPER_LIMIT ))
127     do
128       Primes[t]=
129     done
130   fi  
131 done  
132 echo ${Primes[*]}
133 
134 exit 0
################################End Script#########################################
比较这个用数组的素数产生器和另一种不用数组的例子 A-16. 
-- 
数组可以做一定程度的扩展,以模拟支持Bash原本不支持的数据结构. 
Example 26-14 模拟下推的堆栈
################################Start Script#######################################
  1 #!/bin/bash
  2 # stack.sh: 下推的堆栈模拟
  3 
  4 #  类似于CPU栈, 下推的堆栈依次保存数据项, 
  5 #+ 但取出时则反序进行, 后进先出.
  6 
  7 BP=100            #  栈数组的基点指针.
  8                   #  从元素100开始.
  9 
 10 SP=$BP            #  栈指针.
 11                   #  初始化栈底.
 12 
 13 Data=             #  当前栈的内容.  
 14                   #  必须定义成全局变量,
 15                   #+ 因为函数的返回整数有范围限制.
 16 
 17 declare -a stack
 18 
 19 
 20 push()            # 把一个数据项压入栈.
 21 {
 22 if [ -z "$1" ]    # 没有可压入的?
 23 then
 24   return
 25 fi
 26 
 27 let "SP -= 1"     # 更新堆栈指针.
 28 stack[$SP]=$1
 29 
 30 return
 31 }
 32 
 33 pop()                    # 从栈中弹出一个数据项.
 34 {
 35 Data=                    # 清空保存数据项中间变量.
 36 
 37 if [ "$SP" -eq "$BP" ]   # 已经没有数据可弹出?
 38 then
 39   return
 40 fi                       #  这使SP不会超过100,
 41                          #+ 例如, 这可保护一个失控的堆栈.
 42 
 43 Data=${stack[$SP]}
 44 let "SP += 1"            # 更新堆栈指针.
 45 return
 46 }
 47 
 48 status_report()          # 打印堆栈的当前状态.
 49 {
 50 echo "-------------------------------------"
 51 echo "REPORT"
 52 echo "Stack Pointer = $SP"
 53 echo "Just popped \""$Data"\" off the stack."
 54 echo "-------------------------------------"
 55 echo
 56 }
 57 
 58 
 59 # =======================================================
 60 # 现在,来点乐子.
 61 
 62 echo
 63 
 64 # 看你是否能从空栈里弹出数据项来.
 65 pop
 66 status_report
 67 
 68 echo
 69 
 70 push garbage
 71 pop
 72 status_report     # 压入garbage, 弹出garbage.      
 73 
 74 value1=23; push $value1
 75 value2=skidoo; push $value2
 76 value3=FINAL; push $value3
 77 
 78 pop              # FINAL
 79 status_report
 80 pop              # skidoo
 81 status_report
 82 pop              # 23
 83 status_report    # 后进, 先出!
 84 
 85 #  注意堆栈指针每次压栈时减,
 86 #+ 每次弹出时加一.
 87 
 88 echo
 89 
 90 exit 0
 91 
 92 # =======================================================
 93 
 94 
 95 # 练习:
 96 # ---------
 97 
 98 # 1)  修改"push()"函数,使其调用一次就能够压入多个数据项.
 99 #
100 
101 # 2)  修改"pop()"函数,使其调用一次就能弹出多个数据项.
102 #
103 
104 # 3)  给那些有临界操作的函数增加出错检查.
105 #     即是指是否一次完成操作或没有完成操作返回相应的代码,
106 #   + 没有完成要启动合适的处理动作.
107 #
108 
109 # 4)  这个脚本为基础,
110 #   + 写一个栈实现的四则运算计算器.
################################End Script######################################### 
-- 
要想操作数组的下标需要中间变量. 如果确实要这么做, 可以考虑使用一种更强功能的编程语
言, 例如 Perl 或 C. 
Example 26-15 复杂的数组应用: 列出一种怪异的数学序列
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # Douglas Hofstadter的有名的"Q-series":
 4 
 5 # Q(1) = Q(2) = 1
 6 # Q(n) = Q(n - Q(n-1)) + Q(n - Q(n-2)), 当 n>2 时
 7 
 8 # 这是令人感到陌生的也是没有规律的"乱序"整数序列.
 9 # 序列的头20个如下所示:
10 # 1 1 2 3 3 4 5 5 6 6 6 8 8 8 10 9 10 11 11 12 
11 
12 #  参考Hofstadter的书, "Goedel, Escher, Bach: An Eternal Golden Braid",
13 #+ 页码 137.
14 
15 
16 LIMIT=100     # 计算数的个数.
17 LINEWIDTH=20  # 很行要打印的数的个数.
18 
19 Q[1]=1        # 序列的头2个是 1.
20 Q[2]=1
21 
22 echo
23 echo "Q-series [$LIMIT terms]:"
24 echo -n "${Q[1]} "             # 打印头2个数.
25 echo -n "${Q[2]} "
26 
27 for ((n=3; n <= $LIMIT; n++))  # C风格的循环条件.
28 do   # Q[n] = Q[n - Q[n-1]] + Q[n - Q[n-2]]  当 n>2 时
29 #  需要将表达式分步计算,
30 #+ 因为Bash不擅长处理此类复杂计算.
31 
32   let "n1 = $n - 1"        # n-1
33   let "n2 = $n - 2"        # n-2
34   
35   t0=`expr $n - ${Q[n1]}`  # n - Q[n-1]
36   t1=`expr $n - ${Q[n2]}`  # n - Q[n-2]
37   
38   T0=${Q[t0]}              # Q[n - Q[n-1]]
39   T1=${Q[t1]}              # Q[n - Q[n-2]]
40 
41 Q[n]=`expr $T0 + $T1`      # Q[n - Q[n-1]] + Q[n - Q[n-2]]
42 echo -n "${Q[n]} "
43 
44 if [ `expr $n % $LINEWIDTH` -eq 0 ]    # 格式化输出.
45 then   #      ^ 取模操作
46   echo # 把行分成内部的块.
47 fi
48 
49 done
50 
51 echo
52 
53 exit 0
54 
55 # 这是Q-series问题的迭代实现.
56 # 更直接明了的递归实现留给读者完成.
57 # 警告: 递归地计算这个序列会花很长的时间.
################################End Script######################################### 
-- 
Bash 只支持一维数组,但有一些技巧可用来模拟多维数组. 
Example 26-16 模拟二维数组,并使它倾斜
################################Start Script#######################################
  1 #!/bin/bash
  2 # twodim.sh: 模拟二维数组.
  3 
  4 # 一维数组由单行组成.
  5 # 二维数组由连续的行组成.
  6 
  7 Rows=5
  8 Columns=5
  9 # 5 X 5 的数组Array.
 10 
 11 declare -a alpha     # char alpha [Rows] [Columns];
 12                      # 不必要的声明. 为什么?
 13 
 14 load_alpha ()
 15 {
 16 local rc=0
 17 local index
 18 
 19 for i in A B C D E F G H I J K L M N O P Q R S T U V W X Y
 20 do     # 如果你高兴,可以使用不同的符号.
 21   local row=`expr $rc / $Columns`
 22   local column=`expr $rc % $Rows`
 23   let "index = $row * $Rows + $column"
 24   alpha[$index]=$i
 25 # alpha[$row][$column]
 26   let "rc += 1"
 27 done  
 28 
 29 #  更简单的办法
 30 #+   declare -a alpha=( A B C D E F G H I J K L M N O P Q R S T U V W X Y )
 31 #+ 但这就缺少了二维数组的感觉了.
 32 }
 33 
 34 print_alpha ()
 35 {
 36 local row=0
 37 local index
 38 
 39 echo
 40 
 41 while [ "$row" -lt "$Rows" ]   #  以行顺序为索引打印行的各元素:
 42 do                             #+ 即数组列值变化快,
 43                                #+ 行值变化慢.
 44   local column=0
 45 
 46   echo -n "       "            #  依行倾斜打印正方形的数组.
 47   
 48   while [ "$column" -lt "$Columns" ]
 49   do
 50     let "index = $row * $Rows + $column"
 51     echo -n "${alpha[index]} "  # alpha[$row][$column]
 52     let "column += 1"
 53   done
 54 
 55   let "row += 1"
 56   echo
 57 
 58 done  
 59 
 60 # 等同于
 61 #     echo ${alpha[*]} | xargs -n $Columns
 62 
 63 echo
 64 }
 65 
 66 filter ()     # 过滤出负数的数组索引.
 67 {
 68 
 69 echo -n "  "  # 产生倾斜角度.
 70               # 解释怎么办到的.
 71 
 72 if [[ "$1" -ge 0 &&  "$1" -lt "$Rows" && "$2" -ge 0 && "$2" -lt "$Columns" ]]
 73 then
 74     let "index = $1 * $Rows + $2"
 75     # Now, print it rotated现在,打印旋转角度.
 76     echo -n " ${alpha[index]}"
 77     #           alpha[$row][$column]
 78 fi    
 79 
 80 }
 81   
 82 
 83 
 84 
 85 rotate ()  #  旋转数组 45 度 --
 86 {          #+ 在左下角"平衡"图形.
 87 local row
 88 local column
 89 
 90 for (( row = Rows; row > -Rows; row-- ))
 91   do       # 从后面步进数组. 为什么?
 92 
 93   for (( column = 0; column < Columns; column++ ))
 94   do
 95 
 96     if [ "$row" -ge 0 ]
 97     then
 98       let "t1 = $column - $row"
 99       let "t2 = $column"
100     else
101       let "t1 = $column"
102       let "t2 = $column + $row"
103     fi  
104 
105     filter $t1 $t2   # 过滤出负数数组索引.
106                      # 如果你不这样做会怎么样?
107   done
108 
109   echo; echo
110 
111 done 
112 
113 #  数组旋转灵感源于Herbert Mayer写的
114 #+ "Advanced C Programming on the IBM PC," 的例子 (页码. 143-146)
115 #+ (看参考书目附录).
116 #  这也能看出C能做的事情有多少能用shell脚本做到.
117 #
118 
119 }
120 
121 
122 #---------------   现在, 可以开始了.     ------------#
123 load_alpha     # 加载数组.
124 print_alpha    # 打印数组.  
125 rotate         # 反时钟旋转数组45度.
126 #-----------------------------------------------------#
127 
128 exit 0
129 
130 # 这是有点做作,不太优雅.
131 
132 # 练习:
133 # ---------
134 # 1)  重写数组加载和打印函数,
135 #     使其更直观和容易了解.
136 #
137 # 2)  指出数组旋转函数是什么原理.
138 #     Hint索引: 思考数组从尾向前索引的实现.
139 #
140 # 3)  重写脚本使其可以处理非方形数组Rewrite this script to handle a non-square array,
141 #     例如 6 X 4 的数组.
142 #     尝试旋转数组时做到最小"失真".
################################End Script#########################################
二维数组本质上等同于一维数组, 而只增加了使用行和列的位置来引用和操作元素的寻址模式. 
关于二维数组更好的例子, 请参考例子 A-10. 
-- 
另一个有趣的使用数组的脚本: 
    * 例子 14-3
[]     
    
高级Bash脚本编程指南(五)（下）
文章整理: 文章来源: 网络 
第27章 /dev 和 /proc
=====================
Linux 或 UNIX 机器都带有/dev和/proc目录用于特殊目的. 
27.1. /dev
----------
在 /dev 目录内包含以或不以硬件形式出现的物理设备条目. [1] 包含被挂载的文件系统的硬
设备分区在/dev目录下都有对应的条目, 就像df命令所展示的. 
 bash$ df
 Filesystem           1k-blocks      Used Available Use%
 Mounted on
 /dev/hda6               495876    222748    247527  48% /
 /dev/hda1                50755      3887     44248   9% /boot
 /dev/hda8               367013     13262    334803   4% /home
 /dev/hda5              1714416   1123624    503704  70% /usr 
在其他方面, /dev 目录也包含环回设备(loopback devices) , 例如/dev/loop0. 环回设备是
一个使普通文件能被像对待块设备一样来进行存取的机制. [2] 这使我们可以将一个大文件内
的整个文件系统挂载到系统目录下. 参考例子 13-8和例子 13-7. 
/dev还有少量的伪设备用于特殊的用途, 例如/dev/null, /dev/zero, /dev/urandom, 
/dev/sda1, /dev/udp, 和/dev/tcp. 
例如:
为了挂载(mount) 一个USB闪盘设备, 将下面一行添加到/etc/fstab. [3] 
   1 /dev/sda1    /mnt/flashdrive    auto    noauto,user,noatime    0 0 
(也请参考例子 A-23.) 
当对/dev/tcp/$host/$port 伪设备文件执行一个命令时, Bash会打开一个相关的TCP的socket.
[4] 
从nist.gov得到时间: 
 bash$ cat </dev/tcp/time.nist.gov/13
 53082 04-03-18 04:26:54 68 0 0 502.3 UTC(NIST) *
        
[Mark贡献了上面的例子.] 
下载一个 URL: 
 bash$ exec 5<>/dev/tcp/www.net.cn/80
 bash$ echo -e "GET / HTTP/1.0\n" >&5
 bash$ cat <&5
        
[Thanks, Mark 和 Mihai Maties.] 
Example 27-1 利用/dev/tcp 来检修故障
################################Start Script#######################################
 1 #!/bin/bash
 2 # dev-tcp.sh: 用/dev/tcp 重定向来检查Internet连接.
 3 
 4 # Troy Engel编写.
 5 # 已得到作者允许.
 6  
 7 TCP_HOST=www.dns-diy.com   # 一个已知的 ISP.
 8 TCP_PORT=80                # http的端口是80 .
 9   
10 # 尝试连接. (有些像 'ping' . . .) 
11 echo "HEAD / HTTP/1.0" >/dev/tcp/${TCP_HOST}/${TCP_PORT}
12 MYEXIT=$?
13 
14 : <<EXPLANATION
15 If bash was compiled with --enable-net-redirections, it has the capability of
16 using a special character device for both TCP and UDP redirections. These
17 redirections are used identically as STDIN/STDOUT/STDERR. The device entries
18 are 30,36 for /dev/tcp:
19 
20   mknod /dev/tcp c 30 36
21 
22 >From the bash reference:
23 /dev/tcp/host/port
24     If host is a valid hostname or Internet address, and port is an integer
25 port number or service name, Bash attempts to open a TCP connection to the
26 corresponding socket.
27 EXPLANATION
28 
29    
30 if [ "X$MYEXIT" = "X0" ]; then
31   echo "Connection successful. Exit code: $MYEXIT"
32 else
33   echo "Connection unsuccessful. Exit code: $MYEXIT"
34 fi
35 
36 exit $MYEXIT
################################End Script######################################### 
译者补充上面这个例子输出的解释(EXPLANATION)译文： 
如果bash以--enable-net- redirections选项来编译,它就拥有了使用一个特殊字符设备来完
成TCP和UDP重定向功能的能力.这种重定向能力就像 STDIN/STDOUT/STDERR一样被标识.该字
符设备/dev/tcp的主次设备号是30,36: 
mknod /dev/tcp c 30 36 
>摘自bash参考手册： 
/dev/tcp/host/port 
如果host是一个有效的主机名或因特网有效地址,并且port是一个整数的端口号或是服务名称
,Bash会尝试打开一个相对应的TCP连接socket. 
注意事项:
[1]  /dev目录中的条目是为各种物理设备和虚拟设备提供的挂载点. 这些条目使用非常少
  的设备空间.
  一些像/dev/null, /dev/zero, 和 /dev/urandom的设备是虚拟的. 它们不是真正的
  物理设备,而只是存在于软件的虚拟设备.
[2]  块设备读或写(或两者兼之)数据都是以块为单位的进行的, 与之相对应的字符设备
  则使用字符为单位来进行存取.块设备典型的有硬盘和CD-ROM设备,字符设备典型的
  例子如键盘.
[3]  当然,挂载点/mnt/flashdrive必须存在,如果不存在,以root用户来执行
  mkdir /mnt/flashdrive.  
  为了最终能挂载设备,用下面的命令: mount /mnt/flashdrive
  较新的Linux发行版自动把闪盘设备挂载到/media目录.
[4]  socket是一种特殊的用于通信的I/O端口. 它允许同一台主机内不同硬件设备间的数
  据传输,允许在相同网络中的主机间的数据传输,也允许穿越不同网络的主机间的数
  据传输,当然,也允许在Internet上不同位置主机间的数据传输. 
27.2. /proc
-----------
/proc目录实际上是一个伪文件系统 . 在 /proc 目录里的文件是当前运行系统和内核进程及
它们的相关信息和统计. 
 bash$ cat /proc/devices
 Character devices:
   1 mem
   2 pty
   3 ttyp
   4 ttyS
   5 cua
   7 vcs
  10 misc
  14 sound
  29 fb
  36 netlink
 128 ptm
 136 pts
 162 raw
 254 pcmcia 
 Block devices:
   1 ramdisk
   2 fd
   3 ide0
   9 md
 
 
 bash$ cat /proc/interrupts
            CPU0       
   0:      84505          XT-PIC  timer
   1:       3375          XT-PIC  keyboard
   2:          0          XT-PIC  cascade
   5:          1          XT-PIC  soundblaster
   8:          1          XT-PIC  rtc
  12:       4231          XT-PIC  PS/2 Mouse
  14:     109373          XT-PIC  ide0
 NMI:          0 
 ERR:          0
 
 
 bash$ cat /proc/partitions
 major minor  #blocks  name     rio rmerge rsect ruse wio wmerge wsect wuse running use aveq 
    3     0    3007872 hda 4472 22260 114520 94240 3551 18703 50384 549710 0 111550 644030
    3     1      52416 hda1 27 395 844 960 4 2 14 180 0 800 1140
    3     2          1 hda2 0 0 0 0 0 0 0 0 0 0 0
    3     4     165280 hda4 10 0 20 210 0 0 0 0 0 210 210
    ...
 
 
 bash$ cat /proc/loadavg
 0.13 0.42 0.27 2/44 1119
 
 
 bash$ cat /proc/apm
 1.16 1.2 0x03 0x01 0xff 0x80 -1% -1 ? 
Shell 脚本可以从/proc目录中的一些文件里提取数据. [1] 
   1 FS=iso                       # ISO 文件系统是否被内核支持?
   2 
   3 grep $FS /proc/filesystems   # iso9660 
   1 kernel_version=$( awk '{ print $3 }' /proc/version ) 
   1 CPU=$( awk '/model name/ {print $4}' < /proc/cpuinfo )
   2 
   3 if [ $CPU = Pentium ]
   4 then
   5   run_some_commands
   6   ...
   7 else
   8   run_different_commands
   9   ...
  10 fi 
   1 devfile="/proc/bus/usb/devices"
   2 USB1="Spd=12"
   3 USB2="Spd=480"
   4 
   5 
   6 bus_speed=$(grep Spd $devfile | awk '{print $9}')
   7 
   8 if [ "$bus_speed" = "$USB1" ]
   9 then
  10   echo "USB 1.1 port found."
  11   # 这儿开始操作USB 1.1相关的动作.
  12 fi 
/proc目录下有许多不相同的数字命名的子目录. 这些子目录的数字名字都映射对应的当前正
在运行的进程的进程号(process ID) . 这些子目录里面有许多文件用于保存对应进程的信息.
文件 stat 和 status 保存着进程运行时的各项统计, the cmdline文件保存该进程的被调用
时的命令行参数, 而and the exe 文件是该运行进程完整路径名的符号链接. 还有其他一些文
件,但从脚本的观点来看它们都非常的有意思. 
Example 27-2 搜索与一个PID相关的进程
################################Start Script#######################################
 1 #!/bin/bash
 2 # pid-identifier.sh: 给出指定PID的进程的程序全路径.
 3 
 4 ARGNO=1  # 此脚本期望的参数个数.
 5 E_WRONGARGS=65
 6 E_BADPID=66
 7 E_NOSUCHPROCESS=67
 8 E_NOPERMISSION=68
 9 PROCFILE=exe
10 
11 if [ $# -ne $ARGNO ]
12 then
13   echo "Usage: `basename $0` PID-number" >&2  # 帮助信息重定向到标准出错.
14   exit $E_WRONGARGS
15 fi  
16 
17 pidno=$( ps ax | grep $1 | awk '{ print $1 }' | grep $1 )
18 # 搜索命令"ps"输出的第一列.
19 # 然后再次确认是真正我们要寻找的进程,而不是这个脚本调用而产生的进程.
20 # 后一个"grep $1"会滤掉这个可能产生的进程.
21 #
22 #    pidno=$( ps ax | awk '{ print $1 }' | grep $1 )
23 #    也可以, 由 Teemu Huovila指出.
24 
25 if [ -z "$pidno" ]  # 如果过滤完后结果是一个空字符串,
26 then                # 没有对应的PID进程在运行.
27   echo "No such process running."
28   exit $E_NOSUCHPROCESS
29 fi  
30 
31 # 也可以用:
32 #   if ! ps $1 > /dev/null 2>&1
33 #   then                # 没有对应的PID进程在运行.
34 #     echo "No such process running."
35 #     exit $E_NOSUCHPROCESS
36 #    fi
37 
38 # 为了简化整个进程,使用"pidof".
39 
40 
41 if [ ! -r "/proc/$1/$PROCFILE" ]  # 检查读权限.
42 then
43   echo "Process $1 running, but..."
44   echo "Can't get read permission on /proc/$1/$PROCFILE."
45   exit $E_NOPERMISSION  # 普通用户不能存取/proc目录的某些文件.
46 fi  
47 
48 # 最后两个测试可以用下面的代替:
49 #    if ! kill -0 $1 > /dev/null 2>&1 # '0'不是一个信号,
50                                       # 但这样可以测试是否可以
51                                       # 向该进程发送信号.
52 #    then echo "PID doesn't exist or you're not its owner" >&2
53 #    exit $E_BADPID
54 #    fi
55 
56 
57 
58 exe_file=$( ls -l /proc/$1 | grep "exe" | awk '{ print $11 }' )
59 # 或       exe_file=$( ls -l /proc/$1/exe | awk '{print $11}' )
60 #
61 # /proc/pid-number/exe 是进程程序全路径的符号链接.
62 #
63 
64 if [ -e "$exe_file" ]  # 如果 /proc/pid-number/exe 存在 ...
65 then                 # 则相应的进程存在.
66   echo "Process #$1 invoked by $exe_file."
67 else
68   echo "No such process running."
69 fi  
70 
71 
72 # 这个被详细讲解的脚本几乎可以用下面的命令代替：
73 # ps ax | grep $1 | awk '{ print $5 }'
74 # 然而, 这样并不会工作...
75 # 因为'ps'输出的第5列是进程的argv[0](即命令行第一个参数,调用时程序用的程序路径本身),
76 # 但不是可执行文件.
77 #
78 # 然而, 下面的两个都可以工作.
79 #       find /proc/$1/exe -printf '%l\n'
80 #       lsof -aFn -p $1 -d txt | sed -ne 's/^n//p'
81 
82 # 由Stephane Chazelas附加注释.
83 
84 exit 0
################################End Script######################################### 
Example 27-3 网络连接状态
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 PROCNAME=pppd        # ppp 守护进程
 4 PROCFILENAME=status  # 在这儿寻找信息.
 5 NOTCONNECTED=65
 6 INTERVAL=2           # 两秒刷新一次.
 7 
 8 pidno=$( ps ax | grep -v "ps ax" | grep -v grep | grep $PROCNAME | awk '{ print $1 }' )
 9 # 搜索ppp守护进程'pppd'的进程号.
10 # 一定要过滤掉由搜索进程产生的该行进程.
11 #
12 #  正如Oleg Philon指出的那样,
13 #+ 使用"pidof"命令会相当的简单.
14 #  pidno=$( pidof $PROCNAME )
15 #
16 #  颇有良心的建议:
17 #+ 当命令序列变得复杂的时候,去寻找更简洁的办法. .
18 
19 
20 if [ -z "$pidno" ]   # 如果没有找到此进程号,则进程没有运行.
21 then
22   echo "Not connected."
23   exit $NOTCONNECTED
24 else
25   echo "Connected."; echo
26 fi
27 
28 while [ true ]       # 死循环,这儿可以有所改进.
29 do
30 
31   if [ ! -e "/proc/$pidno/$PROCFILENAME" ]
32   # 进程运行时,对应的"status"文件会存在.
33   then
34     echo "Disconnected."
35     exit $NOTCONNECTED
36   fi
37 
38 netstat -s | grep "packets received"  # 取得一些连接统计.
39 netstat -s | grep "packets delivered"
40 
41 
42   sleep $INTERVAL
43   echo; echo
44 
45 done
46 
47 exit 0
48 
49 # 当要停止它时,可以用Control-C终止.
50 
51 #    练习:
52 #    ---------
53 #    改进这个脚本,使它能按"q"键退出.
54 #    给脚本更友好的界面.
################################End Script######################################### 
注意: 一般来说, 写/proc目录里的文件是危险 ,因为这样会破坏这个文件系统或摧毁机器. 
注意事项:
[1]  一些系统命令, 例如 procinfo, free, vmstat, lsdev, 和uptime也能做类似的事情. 
第28章 关于Zeros和Nulls
========================
/dev/zero和/dev/null 
使用/dev/null 
    把/dev/null看作"黑洞". 它非常等价于一个只写文件. 所有写入它的内容都会永远丢失. 
而尝试从它那儿读取内容则什么也读不到. 然而, /dev/null对命令行和脚本都非常的有用. 
    禁止标准输出. 
   1 cat $filename >/dev/null
   2 # 文件内容丢失,而不会输出到标准输出. 
    禁止标准错误 (来自例子 12-3). 
   1 rm $badname 2>/dev/null
   2 #           这样错误信息[标准错误]就被丢到太平洋去了. 
    禁止标准输出和标准错误的输出. 
   1 cat $filename 2>/dev/null >/dev/null
   2 # 如果"$filename"不存在,将不会有任何错误信息提示.
   3 # 如果"$filename"存在, 文件的内容不会打印到标准输出.
   4 # 因此Therefore, 上面的代码根本不会输出任何信息.
   5 #
   6 #  当只想测试命令的退出码而不想有任何输出时非常有用.
   7 #
   8 #
   9 # cat $filename &>/dev/null
  10 #     也可以, 由 Baris Cicek 指出. 
 删除一个文件的内容, 但是保留文件本身, 和所有的文件权限(来自于Example 2-1和
 Example 2-3): 
   1 cat /dev/null > /var/log/messages
   2 #  : > /var/log/messages   有同样的效果, 但不会产生新的进程.(因为:是内建的)
   3 
   4 cat /dev/null > /var/log/wtmp 
    自动清空日志文件的内容 (特别适合处理这些由商业Web站点发送的讨厌的"cookies"): 
Example 28-1 隐藏cookie而不再使用
################################Start Script#######################################
1 if [ -f ~/.netscape/cookies ]  # 如果存在则删除.
2 then
3   rm -f ~/.netscape/cookies
4 fi
5 
6 ln -s /dev/null ~/.netscape/cookies
7 # 现在所有的cookies都会丢入黑洞而不会保存在磁盘上了.
################################End Script#########################################
使用/dev/zero
 像/dev/null一样, /dev/zero也是一个伪文件, 但它实际上产生连续不断的null的流
 (二进制的零流,而不是ASCII型的). 写入它的输出会丢失不见, 而从/dev/zero读出一
 连串的null也比较困难, 虽然这也能通过od或一个十六进制编辑器来做到. /dev/zero主
 要的用处是用来创建一个指定长度用于初始化的空文件,就像临时交换文件. 
Example 28-2 用/dev/zero创建一个交换临时文件
################################Start Script#######################################
 1 #!/bin/bash
 2 # 创建一个交换文件.
 3 
 4 ROOT_UID=0         # Root 用户的 $UID 是 0.
 5 E_WRONG_USER=65    # 不是 root?
 6 
 7 FILE=/swap
 8 BLOCKSIZE=1024
 9 MINBLOCKS=40
10 SUCCESS=0
11 
12 
13 # 这个脚本必须用root来运行.
14 if [ "$UID" -ne "$ROOT_UID" ]
15 then
16   echo; echo "You must be root to run this script."; echo
17   exit $E_WRONG_USER
18 fi  
19   
20 
21 blocks=${1:-$MINBLOCKS}          #  如果命令行没有指定,
22                                  #+ 则设置为默认的40块.
23 # 上面这句等同如：
24 # --------------------------------------------------
25 # if [ -n "$1" ]
26 # then
27 #   blocks=$1
28 # else
29 #   blocks=$MINBLOCKS
30 # fi
31 # --------------------------------------------------
32 
33 
34 if [ "$blocks" -lt $MINBLOCKS ]
35 then
36   blocks=$MINBLOCKS              # 最少要有 40 个块长.
37 fi  
38 
39 
40 echo "Creating swap file of size $blocks blocks (KB)."
41 dd if=/dev/zero of=$FILE bs=$BLOCKSIZE count=$blocks  # 把零写入文件.
42 
43 mkswap $FILE $blocks             # 将此文件建为交换文件(或称交换分区).
44 swapon $FILE                     # 激活交换文件.
45 
46 echo "Swap file created and activated."
47 
48 exit $SUCCESS
################################End Script#########################################
关于 /dev/zero 的另一个应用是为特定的目的而用零去填充一个指定大小的文件, 如挂载一个
文件系统到环回设备 (loopback device) (参考例子 13-8) 或"安全地" 删除一个文件
(参考例子 12-55). 
Example 28-3 创建ramdisk
################################Start Script#######################################
 1 #!/bin/bash
 2 # ramdisk.sh
 3 
 4 #  "ramdisk"是系统RAM内存的一段,
 5 #+ 它可以被当成是一个文件系统来操作.
 6 #  它的优点是存取速度非常快 (包括读和写).
 7 #  缺点: 易失性, 当计算机重启或关机时会丢失数据.
 8 #+       会减少系统可用的RAM.
 9 #
10 #  那么ramdisk有什么作用呢?
11 #  保存一个较大的数据集在ramdisk, 比如一张表或字典,
12 #+ 这样可以加速数据查询, 因为在内存里查找比在磁盘里查找快得多.
13 
14 
15 E_NON_ROOT_USER=70             # 必须用root来运行.
16 ROOTUSER_NAME=root
17 
18 MOUNTPT=/mnt/ramdisk
19 SIZE=2000                      # 2K 个块 (可以合适的做修改)
20 BLOCKSIZE=1024                 # 每块有1K (1024 byte) 的大小
21 DEVICE=/dev/ram0               # 第一个 ram 设备
22 
23 username=`id -nu`
24 if [ "$username" != "$ROOTUSER_NAME" ]
25 then
26   echo "Must be root to run \"`basename $0`\"."
27   exit $E_NON_ROOT_USER
28 fi
29 
30 if [ ! -d "$MOUNTPT" ]         #  测试挂载点是否已经存在了,
31 then                           #+ 如果这个脚本已经运行了好几次了就不会再建这个目录了
32   mkdir $MOUNTPT               #+ 因为前面已经建立了.
33 fi
34 
35 dd if=/dev/zero of=$DEVICE count=$SIZE bs=$BLOCKSIZE  # 把RAM设备的内容用零填充.
36                                                       # 为何需要这么做?
37 mke2fs $DEVICE                 # 在RAM设备上创建一个ext2文件系统.
38 mount $DEVICE $MOUNTPT         # 挂载设备.
39 chmod 777 $MOUNTPT             # 使普通用户也可以存取这个ramdisk.
40                                # 但是, 只能由root来载它.
41 
42 echo "\"$MOUNTPT\" now available for use."
43 # 现在 ramdisk 即使普通用户也可以用来存取文件了.
44 
45 #  注意, ramdisk是易失的, 所以当计算机系统重启或关机时ramdisk里的内容会消失.
46 #
47 #  拷贝所有你想保存文件到一个常规的磁盘目录下.
48 
49 # 重启之后, 运行这个脚本再次建立起一个 ramdisk.
50 # 仅重新加载 /mnt/ramdisk 而没有其他的步骤将不会正确工作.
51 
52 #  如果加以改进, 这个脚本可以放在 /etc/rc.d/rc.local,
53 #+ 以使系统启动时能自动设立一个ramdisk.
54 #  这样很合适速度要求高的数据库服务器.
55 
56 exit 0
################################End Script#########################################
 最后值得一提的是, ELF二进制文件利用了/dev/zero. 
第29章 调试
============
Debugging is twice as hard as writing the code in the first place. Therefore, 
if you write the code as cleverly as possible, you are, by definition, not smart 
enough to debug it.
             Brian Kernighan 
Bash shell 没有自带调试器, 甚至没有任何调试类型的命令或结构. [1]  脚本里的语法错误
或拼写错误会产生含糊的错误信息,通常这些在调试非功能性的脚本时没什么帮助. 
Example 29-1 一个错误的脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 # ex74.sh
 3 
 4 # 这是一个错误的脚本.
 5 # 哪里有错?
 6 
 7 a=37
 8 
 9 if [$a -gt 27 ]
10 then
11   echo $a
12 fi  
13 
14 exit 0
################################End Script#########################################
脚本的输出:
 ./ex74.sh: [37: command not found
上面的脚本有什么错误(线索: 注意if的后面)? 
Example 29-2 丢失关键字(keyword)
################################Start Script#######################################
1 #!/bin/bash
2 # missing-keyword.sh: 会产生什么样的错误信息?
3 
4 for a in 1 2 3
5 do
6   echo "$a"
7 # done     # 第7行的必需的关键字 'done' 被注释掉了.
8 
9 exit 0  
################################End Script#########################################
脚本的输出:
 missing-keyword.sh: line 10: syntax error: unexpected end of file 
注意错误信息中说明的错误行不必一定要参考, 但那行是Bash解释器最终认识到是个错误的
地方. 
出错信息可能在报告语法错误的行号时会忽略脚本的注释行. 
如果脚本可以执行,但不是你所期望的那样工作怎么办? 这大多是由于常见的逻辑错误产生的. 
Example 29-3 另一个错误脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 #  这个脚本目的是为了删除当前目录下的所有文件,包括文件名含有空格的文件.
 4 #
 5 #  但不能工作.
 6 #  为什么?
 7 
 8 
 9 badname=`ls | grep ' '`
10 
11 # 试试这个:
12 # echo "$badname"
13 
14 rm "$badname"
15 
16 exit 0
################################End Script#########################################
为了找出 例子 29-3  的错误可以把echo "$badname" 行的注释去掉. echo 出来的信息对你
判断是否脚本以你希望的方式运行时很有帮助. 
在这个实际的例子里, rm "$badname" 不会达到想要的结果,因为$badname 没有引用起来. 
加上引号以保证rm 命令只有一个参数(这就只能匹配一个文件名). 一个不完善的解决办法是
删除A partial fix is to remove to quotes from $badname and to reset $IFS to contain only a newline, IFS=$'\n'. 不过, 存在更简单的办法.<rojy bug> 
   1 # 修正删除包含空格文件名时出错的办法.
   2 rm *\ *
   3 rm *" "*
   4 rm *' '*
   5 # Thank you. S.C. 
总结该脚本的症状, 
   1. 终止于一个"syntax error"(语法错误)的信息, 或
   2. 它能运行, 但不是按期望的那样运行(逻辑错误).
   3. 它能运行,运行的和期望的一样, 但有讨厌的副作用 (逻辑炸弹). 
用来调试不能工作的脚本的工具包括 
   1.  echo 语句可用在脚本中的有疑问的点上以跟踪了解变量的值, 并且也可以了解后续脚
  本的动作. 
    注意: 最好只在调试时才使用echo语句. 
     1 ### debecho (debug-echo), by Stefano Falsetto ###
     2 ### 只有变量 DEBUG 设置了值时才会打印传递进来的变量值. ###
     3 debecho () {
     4   if [ ! -z "$DEBUG" ]; then
     5      echo "$1" >&2
     6      #         ^^^ 打印到标准出错
     7   fi
     8 }
     9 
    10 DEBUG=on
    11 Whatever=whatnot
    12 debecho $Whatever   # whatnot
    13 
    14 DEBUG=
    15 Whatever=notwhat
    16 debecho $Whatever   # (这儿就不会打印了.) 
   2.  使用 tee 过滤器来检查临界点的进程或数据流. 
   3.  设置选项 -n -v -x 
      sh -n scriptname 不会实际运行脚本,而只是检查脚本的语法错误. 这等同于把 
  set -n 或 set -o noexec 插入脚本中. 注意还是有一些语法错误不能被这种检查找
  出来. 
      sh -v scriptname 在实际执行一个命令前打印出这个命令. 这也等同于在脚本里设置
   set -v 或 set -o verbose. 
      选项 -n 和 -v 可以一块使用. sh -nv scriptname 会打印详细的语法检查. 
      sh -x scriptname 打印每个命令的执行结果, 但只用在某些小的方面. 它等同于脚本
  中插入 set -x 或 set -o xtrace. 
      把 set -u 或 set -o nounset 插入到脚本里并运行它, 就会在每个试图使用没有申明
  过的变量的地方打印出一个错误信息. 
   4.  使用一个"assert"(断言) 函数在脚本的临界点上测试变量或条件. 
  (这是从C语言中借用来的.) 
Example 29-4 用"assert"测试条件
################################Start Script#######################################
 1 #!/bin/bash
 2 # assert.sh
 3 
 4 assert ()                 #  如果条件测试失败,
 5 {                         #+ 则打印错误信息并退出脚本.
 6   E_PARAM_ERR=98
 7   E_ASSERT_FAILED=99
 8 
 9 
10   if [ -z "$2" ]          # 没有传递足够的参数.
11   then
12     return $E_PARAM_ERR   # 什么也不做就返回.
13   fi
14 
15   lineno=$2
16 
17   if [ ! $1 ] 
18   then
19     echo "Assertion failed:  \"$1\""
20     echo "File \"$0\", line $lineno"
21     exit $E_ASSERT_FAILED
22   # else
23   #   return
24   #   返回并继续执行脚本后面的代码.
25   fi  
26 }    
27 
28 
29 a=5
30 b=4
31 condition="$a -lt $b"     #  会错误信息并从脚本退出.
32                           #  把这个“条件”放在某个地方,
33                           #+ 然后看看有什么现象.
34 
35 assert "$condition" $LINENO
36 # 脚本以下的代码只有当"assert"成功时才会继续执行.
37 
38 
39 # 其他的命令.
40 # ...
41 echo "This statement echoes only if the \"assert\" does not fail."
42 # ...
43 # 余下的其他命令.
44 
45 exit 0
################################End Script######################################### 
 5.  用变量$LINENO和内建的caller. 
 6.  捕捉exit.
  脚本中的The exit 命令会触发信号0,终结进程,即脚本本身. [2] 这常用来捕捉
  exit命令做某事, 如强制打印变量值. trap 命令必须是脚本中第一个命令. 
捕捉信号 
trap
 当收到一个信号时指定一个处理动作; 这在调试时也很有用.
 注意: 信号是发往一个进程的非常简单的信息, 要么是由内核发出要么是由另一个进程, 
   以告诉接收进程采取一些指定的动作 (一般是中止). 例如, 按Control-C, 发送
   一个用户中断( 即 INT 信号)到运行中的进程.
    1 trap '' 2
    2 # 忽略信号 2 (Control-C), 没有指定处理动作. 
    3 
    4 trap 'echo "Control-C disabled."' 2
    5 # 当按 Control-C 时显示一行信息. 
Example 29-5 捕捉 exit
################################Start Script#######################################
 1 #!/bin/bash
 2 # 用trap捕捉变量值.
 3 
 4 trap 'echo Variable Listing --- a = $a  b = $b' EXIT
 5 #  EXIT 是脚本中exit命令产生的信号的信号名.
 6 #
 7 #  由"trap"指定的命令不会被马上执行,只有当发送了一个适应的信号时才会执行.
 8 #
 9 
10 echo "This prints before the \"trap\" --"
11 echo "even though the script sees the \"trap\" first."
12 echo
13 
14 a=39
15 
16 b=36
17 
18 exit 0
19 #  注意到注释掉上面一行的'exit'命令也没有什么不同,
20 #+ 这是因为执行完所有的命令脚本都会退出.
################################End Script######################################### 
Example 29-6 在Control-C后清除垃圾
################################Start Script#######################################
 1 #!/bin/bash
 2 # logon.sh: 简陋的检查你是否还处于连线的脚本.
 3 
 4 umask 177  # 确定临时文件不是全部用户都可读的.
 5 
 6 
 7 TRUE=1
 8 LOGFILE=/var/log/messages
 9 #  注意 $LOGFILE 必须是可读的
10 #+ (用 root来做：chmod 644 /var/log/messages).
11 TEMPFILE=temp.$$
12 #  创建一个"唯一的"临时文件名, 使用脚本的进程ID.
13 #     用 'mktemp' 是另一个可行的办法.
14 #     举例:
15 #     TEMPFILE=`mktemp temp.XXXXXX`
16 KEYWORD=address
17 #  上网时, 把"remote IP address xxx.xxx.xxx.xxx"这行
18 #                      加到 /var/log/messages.
19 ONLINE=22
20 USER_INTERRUPT=13
21 CHECK_LINES=100
22 #  日志文件中有多少行要检查.
23 
24 trap 'rm -f $TEMPFILE; exit $USER_INTERRUPT' TERM INT
25 #  如果脚本被control-c中断了,则清除临时文件.
26 
27 echo
28 
29 while [ $TRUE ]  #死循环.
30 do
31   tail -$CHECK_LINES $LOGFILE> $TEMPFILE
32   #  保存系统日志文件的最后100行到临时文件.
33   #  这是需要的, 因为新版本的内核在登录网络时产生许多日志文件信息.
34   search=`grep $KEYWORD $TEMPFILE`
35   #  检查"IP address" 短语是不是存在,
36   #+ 它指示了一次成功的网络登录.
37 
38   if [ ! -z "$search" ] #  引号是必须的,因为变量可能会有一些空白符.
39   then
40      echo "On-line"
41      rm -f $TEMPFILE    #  清除临时文件.
42      exit $ONLINE
43   else
44      echo -n "."        #  -n 选项使echo不会产生新行符,
45                         #+ 这样你可以从该行的继续打印.
46   fi
47 
48   sleep 1  
49 done  
50 
51 
52 #  注: 如果你更改KEYWORD变量的值为"Exit",
53 #+ 这个脚本就能用来在网络登录后检查掉线
54 #
55 
56 # 练习: 修改脚本,像上面所说的那样,并修正得更好
57 #
58 
59 exit 0
60 
61 
62 # Nick Drage 建议用另一种方法:
63 
64 while true
65   do ifconfig ppp0 | grep UP 1> /dev/null && echo "connected" && exit 0
66   echo -n "."   # 在连接上之前打印点 (.....).
67   sleep 2
68 done
69 
70 # 问题: 用 Control-C来终止这个进程可能是不够的.
71 #+         (点可能会继续被打印.)
72 # 练习: 修复这个问题.
73 
74 
75 
76 # Stephane Chazelas 也提出了另一个办法:
77 
78 CHECK_INTERVAL=1
79 
80 while ! tail -1 "$LOGFILE" | grep -q "$KEYWORD"
81 do echo -n .
82    sleep $CHECK_INTERVAL
83 done
84 echo "On-line"
85 
86 # 练习: 讨论这几个方法的优缺点.
87 #
################################End Script#########################################
注意: trap 的DEBUG参数在每个命令执行完后都会引起一个指定的执行动作,例如,这可用来
 跟踪变量. 
Example 29-7 跟踪变量
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 trap 'echo "VARIABLE-TRACE> \$variable = \"$variable\""' DEBUG
 4 # 在每个命令行显示变量$variable 的值.
 5 
 6 variable=29
 7 
 8 echo "Just initialized \"\$variable\" to $variable."
 9 
10 let "variable *= 3"
11 echo "Just multiplied \"\$variable\" by 3."
12 
13 exit $?
14 
15 #  "trap 'command1 . . . command2 . . .' DEBUG" 的结构适合复杂脚本的环境
16 #+ 在这种情况下多次"echo $variable"比较没有技巧并且也耗时.
17 #
18 #
19 
20 # Thanks, Stephane Chazelas 指出这一点.
21 
22 
23 脚本的输出:
24 
25 VARIABLE-TRACE> $variable = ""
26 VARIABLE-TRACE> $variable = "29"
27 Just initialized "$variable" to 29.
28 VARIABLE-TRACE> $variable = "29"
29 VARIABLE-TRACE> $variable = "87"
30 Just multiplied "$variable" by 3.
31 VARIABLE-TRACE> $variable = "87"
################################End Script######################################### 
当然, trap 命令除了调试还有其他的用处. 
Example 29-8 运行多进程 (在多处理器的机器里)
################################Start Script#######################################
  1 #!/bin/bash
  2 # parent.sh
  3 # 在多处理器的机器里运行多进程.
  4 # 作者: Tedman Eng
  5 
  6 #  这是要介绍的两个脚本的第一个,
  7 #+ 这两个脚本都在要在相同的工作目录下.
  8 
  9 
 10 
 11 
 12 LIMIT=$1         # 要启动的进程总数
 13 NUMPROC=4        # 当前进程数 (forks?)
 14 PROCID=1         # 启动的进程ID
 15 echo "My PID is $$"
 16 
 17 function start_thread() {
 18         if [ $PROCID -le $LIMIT ] ; then
 19                 ./child.sh $PROCID&
 20                 let "PROCID++"
 21         else
 22            echo "Limit reached."
 23            wait
 24            exit
 25         fi
 26 }
 27 
 28 while [ "$NUMPROC" -gt 0 ]; do
 29         start_thread;
 30         let "NUMPROC--"
 31 done
 32 
 33 
 34 while true
 35 do
 36 
 37 trap "start_thread" SIGRTMIN
 38 
 39 done
 40 
 41 exit 0
 42 
 43 
 44 
 45 # ======== 下面是第二个脚本 ========
 46 
 47 
 48 #!/bin/bash
 49 # child.sh
 50 # 在多处理器的机器里运行多进程.
 51 # 这个脚本由parent.sh脚本调用(即上面的脚本).
 52 # 作者: Tedman Eng
 53 
 54 temp=$RANDOM
 55 index=$1
 56 shift
 57 let "temp %= 5"
 58 let "temp += 4"
 59 echo "Starting $index  Time:$temp" "$@"
 60 sleep ${temp}
 61 echo "Ending $index"
 62 kill -s SIGRTMIN $PPID
 63 
 64 exit 0
 65 
 66 
 67 # ======================= 脚本作者注 ======================= #
 68 #  这不是完全没有bug的脚本.
 69 #  我运行LIMIT = 500 ,在过了开头的一二百个循环后,
 70 #+ 这些进程有一个消失了!
 71 #  不能确定是不是因为捕捉信号产生碰撞还是其他的原因.
 72 #  一但信号捕捉到,在下一个信号设置之前,
 73 #+ 会有一个短暂的时间来执行信号处理程序,
 74 #+ 这段时间内很可能会丢失一个信号捕捉,因此失去生成一个子进程的机会.
 75 
 76 #  毫无疑问会有人能找出这个bug的原因,并且修复它 
 77 #+ . . . 在将来的某个时候.
 78 
 79 
 80 
 81 # ===================================================================== #
 82 
 83 
 84 
 85 # ----------------------------------------------------------------------#
 86 
 87 
 88 
 89 #################################################################
 90 # 下面的脚本由Vernia Damiano原创.
 91 # 不幸地是, 它不能正确工作.
 92 #################################################################
 93 
 94 #!/bin/bash
 95 
 96 #  必须以最少一个整数参数来调用这个脚本
 97 #+ (这个整数是协作进程的数目).
 98 #  所有的其他参数被传给要启动的进程.
 99 
100 
101 INDICE=8        # 要启动的进程数目
102 TEMPO=5         # 每个进程最大的睡眼时间
103 E_BADARGS=65    # 没有参数传给脚本的错误值.
104 
105 if [ $# -eq 0 ] # 检查是否至少传了一个参数给脚本.
106 then
107   echo "Usage: `basename $0` number_of_processes [passed params]"
108   exit $E_BADARGS
109 fi
110 
111 NUMPROC=$1              # 协作进程的数目
112 shift
113 PARAMETRI=( "$@" )      # 每个进程的参数
114 
115 function avvia() {
116          local temp
117          local index
118          temp=$RANDOM
119          index=$1
120          shift
121          let "temp %= $TEMPO"
122          let "temp += 1"
123          echo "Starting $index Time:$temp" "$@"
124          sleep ${temp}
125          echo "Ending $index"
126          kill -s SIGRTMIN $$
127 }
128 
129 function parti() {
130          if [ $INDICE -gt 0 ] ; then
131               avvia $INDICE "${PARAMETRI[@]}" &
132                 let "INDICE--"
133          else
134                 trap : SIGRTMIN
135          fi
136 }
137 
138 trap parti SIGRTMIN
139 
140 while [ "$NUMPROC" -gt 0 ]; do
141          parti;
142          let "NUMPROC--"
143 done
144 
145 wait
146 trap - SIGRTMIN
147 
148 exit $?
149 
150 : <<SCRIPT_AUTHOR_COMMENTS
151 我需要运行能指定选项的一个程序,
152 能接受许多不同的文件,并在一个多处理器的机器上运行
153 所以我想(我也将会)使指定数目的进程运行,并且每个进程终止后都能启动一个新的
154
155 
156 "wait"命令没什么帮助, 因为它是等候一个指定的或所有的后台进程.
157  所以我写了这个使用了trap指令的bash脚本来做这个任务.
158 
159   --Vernia Damiano
160 SCRIPT_AUTHOR_COMMENTS
################################End Script#########################################
注意: trap '' SIGNAL (两个引号引空) 在脚本中禁用了 SIGNAL 信号的动作(即忽略了). 
  trap SIGNAL 则恢复了 SIGNAL 信号前次的处理动作. 这在保护脚本的某些临界点的
  位置不受意外的中断影响时很有用. 
   1  trap '' 2  # 信号 2是  Control-C, 现在被忽略了.
   2  command
   3  command
   4  command
   5  trap 2     # 再启用Control-C
   6   
 Bash的版本 3 增加了下面的特殊变量用于调试. 
   1.  $BASH_ARGC
   2.  $BASH_ARGV
   3.  $BASH_COMMAND
   4.  $BASH_EXECUTION_STRING
   5.  $BASH_LINENO
   6.  $BASH_SOURCE
   7.  $BASH_SUBSHELL 
注意事项:
[1]  Rocky Bernstein的 Bash debugger 实际上填补了这个空白.
[2]  依据惯例,信号0 被指定为退出(exit). 
第30章 选项
============
选项用来更改shell或/和脚本行为的机制. 
set 命令用来在脚本里激活各种选项. 在脚本中任何你想让选项生效的地方,插入 
set -o option-name 或, 用更简短的格式, set -option-abbrev. 这两种格式都是等价的. 
   1       #!/bin/bash
   2 
   3       set -o verbose
   4       # 执行前打印命令. 
   1       #!/bin/bash
   2 
   3       set -v
   4       # 和上面的有完全相同的效果. 
注意: 为了在脚本里停用一个选项, 插入 set +o option-name 或 set +option-abbrev. 
   1       #!/bin/bash
   2 
   3       set -o verbose
   4       # 激活命令回显.
   5       command
   6       ...
   7       command
   8 
   9       set +o verbose
  10       # 停用命令回显.
  11       command
  12       # 没有回显命令了.
  13 
  14 
  15       set -v
  16       # 激活命令回显.
  17       command
  18       ...
  19       command
  20 
  21       set +v
  22       # 停用命令回显.
  23       command
  24 
  25       exit 0
  26       
另一个在脚本里启用选项的方法是在脚本头部的#!后面指定选项. 
   1       #!/bin/bash -x
   2       #
   3       # 下面是脚本的主要内容.
   4       
从命令行来激活脚本的选项也是可以办到的. 一些不能和set一起用的选项可以用在命令行指
定. -i是其中之一, 可以使脚本以交互方式运行. 
bash -v script-name 
bash -o verbose script-name 
下面的表格列举了一些有用的选项. 它们都可以用简短格式来指定(以一个短横线开头)也可
以用完整的名字来指定(用双短横线开头或用-o来指定). 
table 30-1 Bash 选项
==================================================================================
| 缩写      | 名称   | 作用
==================================================================================
| -C     | noclobber   | 防止重定向时覆盖文件 (此作用会被>|覆盖)
==================================================================================
| -D     | (none)   | 列出双引号引起的含有$前缀的字符串,但不执行脚本
|      |    | 中的命令
==================================================================================
| -a     | allexport  | 导出所有定义的变量到环境变量中
==================================================================================
| -b     | notify   | 当后台任务终止时给出通知 (在脚本中用的不多)
==================================================================================
| -c...     | (none)   | 从...读命令
==================================================================================
| -e     | errexit  | 脚本发生第一个错误时就中止脚本运行,即当一个命令
|      |    | 返回非零值时退出脚本 (除了until 或 while loops, 
|      |    | if-tests, list constructs)
==================================================================================
| -f     | noglob   | 文件名替换停用(指像*这样的符号不能替换为文件名了)
==================================================================================
| -i     | interactive | 使脚本以交互式方式运行
==================================================================================
| -n     | noexec   | 从脚本里读命令但不执行它们(语法检查)
==================================================================================
| -o Option-Name  | (none)   | 调用Option-Name 选项
==================================================================================
| -o posix    | POSIX   | 更改Bash或脚本的行为,使之符合POSIX标准.
==================================================================================
| -p     | privileged  | 脚本作为"suid"程序来运行 (小心!)
==================================================================================
| -r     | restricted  | 脚本在受限模式中运行 (参考第21章).
==================================================================================
| -s     | stdin   | 从标准输入读命令
==================================================================================
| -t     | (none)   | 第一个命令后就退出
==================================================================================
| -u     | nounset  | 当使用一个未定义的变量时产生一个错误信息,并强制
|      |    | 退出脚本.
==================================================================================
| -v     | verbose  | 执行命令之前打印命令到标准输出
==================================================================================
| -x     | xtrace   | 与-v相似, 但打印完整的命令
==================================================================================
| -      | (none)   | 选项列表结束的标志. 后面的参数是位置参数.
==================================================================================
| --     | (none)   | 释放位置参数. 如果参数列表被指定了(-- arg1 arg2),
|      |    | 则位置参数被依次设置为参数列表中的值.
================================================================================== 
第31章 Gotchas
===============
Turandot: Gli enigmi sono tre, la morte una!
Caleph: No, no! Gli enigmi sono tre, una la vita! 
            Puccini 
将保留字和字符声明为变量名. 
   1 case=value0       # 引发错误.
   2 23skidoo=value1   # 也会有错误.
   3 # 以数字开头的变量名是由shell保留使用的.
   4 # 试试 _23skidoo=value1. 用下划线开头的变量名是允许的.
   5 
   6 # 但是 . . .   仅使用下划线来用做变量名也是不行的.
   7 _=25
   8 echo $_           # $_ 是一个特殊的变量,被设置为最后命令的最后一个参数.
   9 
  10 xyz((!*=value2    # 引起严重的错误.
  11 # 在第三版的Bash, 标点不能在变量名中出现. 
用连字符或其他保留字符当做变量名(或函数名). 
   1 var-1=23
   2 # 用 'var_1' 代替.
   3 
   4 function-whatever ()   # 错误
   5 # 用 'function_whatever ()' 代替.
   6 
   7  
   8 # 在第三版的 Bash, 标点不能在函数名中使用.
   9 function.whatever ()   # 错误
  10 # 用 'functionWhatever ()' 代替. 
给变量和函数使用相同的名字. 这会使脚本不能分辨两者. 
   1 do_something ()
   2 {
   3   echo "This function does something with \"$1\"."
   4 }
   5 
   6 do_something=do_something
   7 
   8 do_something do_something
   9 
  10 # 这些都是合法的,但让人混淆. 
不适当地使用宽白符(whitespace). 和其它的编程语言相比,Bash非常讲究空白字符的使用. 
   1 var1 = 23   # 'var1=23' 正确.
   2 # 上面一行,Bash试图执行命令"var1"
   3 # 并且它的参数是"="和"23".
   4  
   5 let c = $a - $b   # 'let c=$a-$b' 或 'let "c = $a - $b"'是正确的.
   6 
   7 if [ $a -le 5]    # if [ $a -le 5 ]   是正确的.
   8 # if [ "$a" -le 5 ]   会更好.
   9 # [[ $a -le 5 ]] 也可以. 
未初始化的变量(指赋值前的变量)被认为是NULL值的,而不是有零值. 
   1 #!/bin/bash
   2 
   3 echo "uninitialized_var = $uninitialized_var"
   4 # uninitialized_var = 
混淆测试里的= 和 -eq 操作符. 请记住, = 是比较字符变量而 -eq 比较整数. 
   1 if [ "$a" = 273 ]      # $a 是一个整数还是一个字符串?
   2 if [ "$a" -eq 273 ]    # 如果$a 是一个整数,用这个表达式.
   3 
   4 # 有时你能混用 -eq 和 = 而没有不利的结果.
   5 # 然而 . . .
   6 
   7 
   8 a=273.0   # 不是一个整数.
   9     
  10 if [ "$a" = 273 ]
  11 then
  12   echo "Comparison works."
  13 else  
  14   echo "Comparison does not work."
  15 fi    # Comparison does not work.
  16 
  17 # 与   a=" 273"  和 a="0273" 一样.
  18 
  19 
  20 # 同样, 问题仍然是试图对非整数值使用 "-eq" 测试.
  21     
  22 if [ "$a" -eq 273.0 ]
  23 then
  24   echo "a = $a"
  25 fi  # 因错误信息而中断.  
  26 # test.sh: [: 273.0: integer expression expected 
误用字符串比较操作符. 
Example 31-1 数字和字符串比较是不相等同的
################################Start Script#######################################
 1 #!/bin/bash
 2 # bad-op.sh: 在整数比较中使用字符串比较.
 3 
 4 echo
 5 number=1
 6 
 7 # 下面的 "while" 循环有两个错误:
 8 #+ 一个很明显,另一个比较隐蔽.
 9 
10 while [ "$number" < 5 ]    # 错误! 应该是:  while [ "$number" -lt 5 ]
11 do
12   echo -n "$number "
13   let "number += 1"
14 done  
15 #  尝试运行时会收到错误信息而退出:
16 #+ bad-op.sh: line 10: 5: No such file or directory
17 #  在单括号里, "<" 需要转义,
18 #+ 而即使是如此, 对此整数比较它仍然是错的.
19 
20 
21 echo "---------------------"
22 
23 
24 while [ "$number" \< 5 ]    #  1 2 3 4
25 do                          #
26   echo -n "$number "        #  看起来好像是能工作的, 但 . . .
27   let "number += 1"         #+ 它其实是在对 ASCII 码的比较,
28 done                        #+ 而非是对数值的比较.
29 
30 echo; echo "---------------------"
31 
32 # 下面这样便会引起问题了. 例如:
33 
34 lesser=5
35 greater=105
36 
37 if [ "$greater" \< "$lesser" ]
38 then
39   echo "$greater is less than $lesser"
40 fi                          # 105 is less than 5
41 #  事实上, "105" 小于 "5"
42 #+ 是因为使用了字符串比较 (以ASCII码的排序顺序比较).
43 
44 echo
45 
46 exit 0
################################End Script#########################################
有时在测试时的方括号([ ])里的变量需要引用起来(双引号). 如果没有这么做可能会引起不
可预料的结果. 参考例子 7-6, 例子 16-5, 和 例子 9-6. 
在脚本里的命令可能会因为脚本没有运行权限而导致运行失败. 如果用户不能在命令行里调用
一个命令,即使把这个命令加到一个脚本中也一样会失败. 这时可以尝试更改访命令的属性,
甚至可能给它设置suid位(当然是以root来设置). 
试图用 - 来做重定向操作(事实上它不是操作符)会导致令人讨厌的意外. 
   1 command1 2> - | command2  # 试图把command1的错误重定向到一个管道里...
   2 #    ...不会工作. 
   3 
   4 command1 2>& - | command2  # 也没有效果.
   5 
   6 Thanks, S.C. 
用 Bash 版本 2+ 的功能可以当有错误信息时引发修复动作. 老一些的 Linux机器可能默认的
安装是 1.XX 版本的Bash. 
   1 #!/bin/bash
   2 
   3 minimum_version=2
   4 # 因为 Chet Ramey 经常给Bash增加新的特性,
   5 # 你把 $minimum_version 设为 2.XX比较合适,或者是其他合适的值.
   6 E_BAD_VERSION=80
   7 
   8 if [ "$BASH_VERSION" \< "$minimum_version" ]
   9 then
  10   echo "This script works only with Bash, version $minimum or greater."
  11   echo "Upgrade strongly recommended."
  12   exit $E_BAD_VERSION
  13 fi
  14 
  15 ... 
在非Linux的机器上使用Bourne shell脚本(#!/bin/sh)的Bash专有功能可能会引起不可预料的
行为. Linux系统通常都把sh 取别名为 bash, 但在其他的常见的UNIX系统却不一定是这样. 
使用Bash中没有文档化的属性是危险的尝试. 在这本书的前几版中有几个脚本依赖于exit或
return的值没有限制不能用负整数(虽然限制了exit或return 的最大值是255). 不幸地是, 
在版本 2.05b 以上这种情况就消失了. 参考See 例子 23-9. 
一个带有DOS风格新行符 (\r\n) 的脚本会执行失败, 因为#!/bin/bash\r\n 不是合法的,不同
于合法的#!/bin/bash\n. 解决办法就是把脚本转换成UNIX风格的新行符. 
   1 #!/bin/bash
   2 
   3 echo "Here"
   4 
   5 unix2dos $0    # 脚本先把自己改成DOS格式.
   6 chmod 755 $0   # 更改回执行权限.
   7                # 'unix2dos'命令会删除执行权限.
   8 
   9 ./$0           # 脚本尝试再次运行自己本身.
  10                # 但它是一个DOS文件而不会正常工作了.
  11 
  12 echo "There"
  13 
  14 exit 0 
shell脚本以 #!/bin/sh 行开头将不会在Bash兼容的模式下运行. 一些Bash专有的功能可能会
被禁用掉. 那些需要完全使用Bash专有扩展特性的脚本应该用#!/bin/bash开头. 
脚本里在 here document 的终结输入的字符串前加入空白字符会引起不可预料的结果. 
脚本不能export(导出)变量到它的父进程(parent process),或父进程的环境里. 就像我
们学的生物一样,一个子进程可以从父进程里继承但不能去影响父进程. 
   1 WHATEVER=/home/bozo
   2 export WHATEVER
   3 exit 0 
 bash$ echo $WHATEVER
 
 bash$ 
可以确定, 回到命令提示符, $WHATEVER 变量仍然没有设置. 
在子SHELL(subshell)设置和操作变量 , 然后尝试在子SHELL的作用范围外使用相同名的变
量将会导致非期望的结果. 
Example 31-2 子SHELL缺陷
################################Start Script#######################################
 1 #!/bin/bash
 2 # 在子SHELL中的变量缺陷.
 3 
 4 outer_variable=outer
 5 echo
 6 echo "outer_variable = $outer_variable"
 7 echo
 8 
 9 (
10 # 子SHELL开始
11 
12 echo "outer_variable inside subshell = $outer_variable"
13 inner_variable=inner  # Set
14 echo "inner_variable inside subshell = $inner_variable"
15 outer_variable=inner  # Will value change globally?
16 echo "outer_variable inside subshell = $outer_variable"
17 
18 # 导出变量会有什么不同吗?
19 #    export inner_variable
20 #    export outer_variable
21 # 试试看.
22 
23 # 子SHELL结束
24 )
25 
26 echo
27 echo "inner_variable outside subshell = $inner_variable"  # Unset.
28 echo "outer_variable outside subshell = $outer_variable"  # Unchanged.
29 echo
30 
31 exit 0
32 
33 # 如果你没有注释第 19 和 20行会怎么样?
34 # 会有什么不同吗?
################################End Script######################################### 
把 echo 的输出用管道(Piping)输送给read命令可能会产生不可预料的结果. 在这个情况下,
 read  表现地好像它是在一个子SHELL里一样. 可用set 命令代替 (就像在例子 11-16里的一
样). 
Example 31-3 把echo的输出用管道输送给read命令
################################Start Script#######################################
 1 #!/bin/bash
 2 #  badread.sh:
 3 #  尝试用 'echo 和 'read'
 4 #+ 来达到不用交互地给变量赋值的目的.
 5 
 6 a=aaa
 7 b=bbb
 8 c=ccc
 9 
10 echo "one two three" | read a b c
11 # 试图重新给 a, b, 和 c赋值.
12 
13 echo
14 echo "a = $a"  # a = aaa
15 echo "b = $b"  # b = bbb
16 echo "c = $c"  # c = ccc
17 # 重新赋值失败.
18 
19 # ------------------------------
20 
21 # 用下面的另一种方法.
22 
23 var=`echo "one two three"`
24 set -- $var
25 a=$1; b=$2; c=$3
26 
27 echo "-------"
28 echo "a = $a"  # a = one
29 echo "b = $b"  # b = two
30 echo "c = $c"  # c = three 
31 # 重新赋值成功.
32 
33 # ------------------------------
34 
35 #  也请注意echo值到'read'命令里是在一个子SHELL里起作用的.
36 #  所以,变量的值只在子SHELL里被改变了.
37 
38 a=aaa          # 从头开始.
39 b=bbb
40 c=ccc
41 
42 echo; echo
43 echo "one two three" | ( read a b c;
44 echo "Inside subshell: "; echo "a = $a"; echo "b = $b"; echo "c = $c" )
45 # a = one
46 # b = two
47 # c = three
48 echo "-----------------"
49 echo "Outside subshell: "
50 echo "a = $a"  # a = aaa
51 echo "b = $b"  # b = bbb
52 echo "c = $c"  # c = ccc
53 echo
54 
55 exit 0
################################End Script#########################################
事实上, 也正如 Anthony Richardson 指出的那样, 管道任何的数据到循环里都会引起相似的
问题. 
   1 # 循环管道问题.
   2 #  Anthony Richardson编写此例,
   3 #+ Wilbert Berendsen补遗此例.
   4 
   5 
   6 foundone=false
   7 find $HOME -type f -atime +30 -size 100k |
   8 while true
   9 do
  10    read f
  11    echo "$f is over 100KB and has not been accessed in over 30 days"
  12    echo "Consider moving the file to archives."
  13    foundone=true
  14    # ------------------------------------
  15    echo "Subshell level = $BASH_SUBSHELL"
  16    # Subshell level = 1
  17    # 没错, 现在是在子shell里头运行.
  18    # ------------------------------------
  19 done
  20    
  21 #  foundone 变量在此总是有false值
  22 #+ 因此它是在子SHELL里被设为true值的
  23 if [ $foundone = false ]
  24 then
  25    echo "No files need archiving."
  26 fi
  27 
  28 # =====================现在, 使用正确的方法:=================
  29 
  30 foundone=false
  31 for f in $(find $HOME -type f -atime +30 -size 100k)  # 没有使用管道.
  32 do
  33    echo "$f is over 100KB and has not been accessed in over 30 days"
  34    echo "Consider moving the file to archives."
  35    foundone=true
  36 done
  37    
  38 if [ $foundone = false ]
  39 then
  40    echo "No files need archiving."
  41 fi
  42 
  43 # ==================另一种方法==================
  44 
  45 #  脚本中读变量值的相应部分替换在代码块里头读变量,
  46 #+ 这使变量能在相同的子SHELL里共享了.
  47 #  Thank you, W.B.
  48 
  49 find $HOME -type f -atime +30 -size 100k | {
  50      foundone=false
  51      while read f
  52      do
  53        echo "$f is over 100KB and has not been accessed in over 30 days"
  54        echo "Consider moving the file to archives."
  55        foundone=true
  56      done
  57 
  58      if ! $foundone
  59      then
  60        echo "No files need archiving."
  61      fi
  62 } 
相关的问题是：当尝试写 tail -f 的输出给管道并传递给grep时会发生问题. 
   1 tail -f /var/log/messages | grep "$ERROR_MSG" >> error.log
   2 # "error.log"文件里将不会写入任何东西. 
-- 
在脚本中使用"suid" 的命令是危险的, 因为这会危及系统安全. [1] 
用shell编写CGI程序是值得商榷的. Shell脚本的变量不是"类型安全的", 这样它用于CGI连接
使用时会引发不希望的结果. 其次, 它很难防范骇客的攻击. 
Bash 不能正确处理双斜线 (//) 字符串. 
在Linux 或 BSD上写的Bash脚本可能需要修正以使它们也能在商业的UNIX (或 Apple OSX)上运
行. 这些脚本常使用比一般的UNIX系统上的同类工具更强大功能的GNU 命令和过滤工具. 这方
面一个明显的例子是文本处理工具tr. 
         Danger is near thee -- 
         Beware, beware, beware, beware. 
         Many brave hearts are asleep in the deep. 
         So beware -- 
         Beware.
             A.J. Lamb and H.W. Petrie 
注意事项:
[1]  给脚本设置suid 权限是没有用的. 
第32章 脚本编程风格
====================
写脚本时养成结构化和系统方法的习惯. 即使你在信封背后随便做一下草稿也是有益的,要养
成在写代码前花几分钟来规划和组织你的想法. 
这儿是一些风格的指南. 注意这节文档不是想成为一个官方Shell编程风格. 
32.1. 非官方的Shell脚本风格
---------------------------
* 注释你的代码.这会使你的代码更容易让别人理解和赏识,同时也便于你维护. 
    1 PASS="$PASS${MATRIX:$(($RANDOM%${#MATRIX})):1}"
    2 # 当你去年写下这句代码时非常的了解它在干什么事,但现在它完全是一个谜.
    3 # (摘自 Antek Sawicki的"pw.sh" 脚本.) 
 给脚本和函数加上描述性的头部信息. 
    1 #!/bin/bash
    2 
    3 #************************************************#
    4 #                   xyz.sh                       #
    5 #           written by Bozo Bozeman              #
    6 #                July 05, 2001                   #
    7 #                                                #
    8 #                   清除项目文件.                #
    9 #************************************************#
   10 
   11 E_BADDIR=65                       # 没有那样的目录.
   12 projectdir=/home/bozo/projects    # 要清除的目录.
   13 
   14 # --------------------------------------------------------- #
   15 # cleanup_pfiles ()                                         #
   16 # 删除指定目录里的所有文件.                                 #
   17 # 参数: $target_directory                                   #
   18 # 返回: 成功返回0 , 失败返回$E_BADDIR值.                    #
   19 # --------------------------------------------------------- #
   20 cleanup_pfiles ()
   21 {
   22   if [ ! -d "$1" ]  # 测试目标目录是否存在.
   23   then
   24     echo "$1 is not a directory."
   25     return $E_BADDIR
   26   fi
   27 
   28   rm -f "$1"/*
   29   return 0   # 成功.
   30 }  
   31 
   32 cleanup_pfiles $projectdir
   33 
   34 exit 0 
 确认 #!/bin/bash 在脚本的第一行,在任何头部注释行之前. 
* 避免使用 "魔数,"  [1]  它是硬编码的字符常量. 用有意义的变量名来代替. 这使脚本
  更容易理解并允许在不破坏应用的情况下做改变和更新. 
    1 if [ -f /var/log/messages ]
    2 then
    3   ...
    4 fi
    5 # 一年以后,你决定让脚本改为检查 /var/log/syslog.
    6 # 那么现在就需要你手动修改脚本里每一处的要改动的代码,
    7 # 希望不要有你疏漏的地方.
    8 
    9 # 更好的办法是:
   10 LOGFILE=/var/log/messages  # 只需要改动一行.
   11 if [ -f "$LOGFILE" ]
   12 then
   13   ...
   14 fi 
* 为变量和函数选择描述性的名字. 
    1 fl=`ls -al $dirname`                 # 含义含糊.
    2 file_listing=`ls -al $dirname`       # 更好的名字.
    3 
    4 
    5 MAXVAL=10   # 同一个脚本所有程序代码使用脚本常量.
    6 while [ "$index" -le "$MAXVAL" ]
    7 ...
    8 
    9 
   10 E_NOTFOUND=75                        #  把错误代码的代表的变量名大写U,
   11                                      # +并以"E_"开头.
   12 if [ ! -e "$filename" ]
   13 then
   14   echo "File $filename not found."
   15   exit $E_NOTFOUND
   16 fi  
   17 
   18 
   19 MAIL_DIRECTORY=/var/spool/mail/bozo  # 环境变量名用大写.
   20 export MAIL_DIRECTORY
   21 
   22 
   23 GetAnswer ()                         # 函数名用适当的大小写混合组成.
   24 {
   25   prompt=$1
   26   echo -n $prompt
   27   read answer
   28   return $answer
   29 }  
   30 
   31 GetAnswer "What is your favorite number? "
   32 favorite_number=$?
   33 echo $favorite_number
   34 
   35 
   36 _uservariable=23                     # 语法允许, 但不推荐.
   37 # 用户定义的变量最好不要用下划线开头.
   38 # 把这个留给系统变量使用更好. 
* 用有含义和系统的方法来使用退出代码(exit codes).
    1 E_WRONG_ARGS=65
    2 ...
    3 ...
    4 exit $E_WRONG_ARGS 
 也参考附录 D. 
 最后 建议在脚本中使用/usr/include/sysexits.h的退出码, 虽然它们主要由 C 和 C++ 
 语言编程时使用. 
* 使用标准的参数选项. 最后 建议使用下面一组参数标志. 
    1 -a      All: Return all information (including hidden file info).
    2 -b      Brief: Short version, usually for other scripts.
    3 -c      Copy, concatenate, etc.
    4 -d      Daily: Use information from the whole day, and not merely
    5         information for a specific instance/user.
    6 -e      Extended/Elaborate: (often does not include hidden file info).
    7 -h      Help: Verbose usage w/descs, aux info, discussion, help.
    8         See also -V.
    9 -l      Log output of script.
   10 -m      Manual: Launch man-page for base command.
   11 -n      Numbers: Numerical data only.
   12 -r      Recursive: All files in a directory (and/or all sub-dirs).
   13 -s      Setup & File Maintenance: Config files for this script.
   14 -u      Usage: List of invocation flags for the script.
   15 -v      Verbose: Human readable output, more or less formatted.
   16 -V      Version / License / Copy(right|left) / Contribs (email too). 
 也参考附录 F. 
* 把复杂的脚本分割成简单一些的模块. 用合适的函数来实现各个功能. 参考例子 34-4. 
* 如果有简单的结构可以使用,不要使用复杂的结构. 
    1 COMMAND
    2 if [ $? -eq 0 ]
    3 ...
    4 # 多余的并且也不直接明了.
    5 
    6 if COMMAND
    7 ...
    8 # 更简练 (或者可能会损失一些可读性). 
     ... reading the UNIX source code to the Bourne shell 
     (/bin/sh). I was shocked at how much simple algorithms could 
     be made cryptic, and therefore useless, by a poor choice of 
     code style. I asked myself, "Could someone be proud of this 
     code?"
                 Landon Noll
注意事项:
[1]  在上下文, "魔数" 和用来指明文件类型的 魔数(magic numbers)有完全不同的意思. 
第33章 杂项
============
    Nobody really knows what the Bourne shell's grammar is. Even 
    examination of the source code is little help.
               Tom Duff 
33.1. 交互式和非交互式的shells和脚本
------------------------------------
交互式的shell在 tty终端从用户的输入中读取命令. 另一方面, shell能在启动时读取启动文
件,显示一个提示符并默认激活作业控制. 用户能交互地使用shell. 
运行脚本的shell一般都是非交互的shell. 但脚本仍然可以存取它拥有的终端. 脚本里甚至可
以仿效成可交互的shell. 
   1 #!/bin/bash
   2 MY_PROMPT='$ '
   3 while :
   4 do
   5   echo -n "$MY_PROMPT"
   6   read line
   7   eval "$line"
   8   done
   9 
  10 exit 0
  11 
  12 # 这个例子脚本, 和上面的解释由
  13 # Stéphane Chazelas 提供(再次感谢). 
让我们考虑一个要求用户交互式输入的脚本,通常用read语句 (参考例子 11-3). 真正的情况
可能有些混乱.以现在假设的情况来说,交互式脚本被限制在一个tty设备上,它本身已经是从
一个控制终端或一个中被用户调用的. 
初始化和启动脚本不必是非交互式的,因为它们必须不需要人为地干预地运行.许多管理和系
统维护脚本也同样是非交互式的.不多变的重复性的任务可以自动地由非交互式脚本完成. 
非交互式的脚本可以在后台运行,但交互脚本在后台运行则会被挂起,等待永远不会到达的输
入.解决这个难点的办法可以写预料这种情况的脚本或是内嵌here document 的脚本来获取脚
本期望的输入,这样就可作为后台任务运行了.在最简单的情况,重定向一个文件给一个read
语句提供输入(read variable <file). 这就可能适应交互和非交互的工作环境下都能达成脚
本运行的目的. 
如果脚本需要测试当前是否运行在交互shell中,一个简单的办法是找一下是否有提示符变量,
即$PS1是否设置了. (如果脚本需要用户输入数据,则脚本会显示一个提示符.) 
   1 if [ -z $PS1 ] # 没有提示符?
   2 then
   3   # 非交互式
   4   ...
   5 else
   6   # 交互式
   7   ...
   8 fi 
另一个办法是脚本可以测试是否在变量$-中出现了选项"i". 
   1 case $- in
   2 *i*)    # 交互式 shell
   3 ;;
   4 *)      # 非交互式 shell
   5 ;;
   6 # (Courtesy of "UNIX F.A.Q.," 1993) 
注意: 脚本可以使用-i选项强制在交互式模式下运行或脚本头用#!/bin/bash -i. 注意这样
  可能会引起脚本古怪的行为或当没有错误出现时也会显示错误信息. 
33.2. Shell 包装
----------------
包装脚本是指嵌有一个系统命令和程序的脚本,也保存了一组传给该命令的参数. [1]  包装
脚本使原本很复杂的命令行简单化. 这对 sed 和 awk 特别有用. 
sed 和 awk 命令一般从命令行上以 sed -e 'commands' 和 awk 'commands' 来调用. 把sed
和awk的命令嵌入到Bash脚本里使调用变得更简单, 并且也可多次使用. 也可以综合地利用 
sed 和 awk 的功能, 例如管道(piping)连接sed 命令的输出到awk命令中. 保存为可执行的
文件, 你可以用脚本编写的或修改的调用格式多次的调用它, 而不必在命令行上重复键入复杂
的命令行. 
Example 33-1 shell 包装
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # 这是一个把文件中的空行删除的简单脚本.
 4 # 没有参数检查.
 5 #
 6 # 你可能想增加类似下面的代码:
 7 #
 8 # E_NOARGS=65
 9 # if [ -z "$1" ]
10 # then
11 #  echo "Usage: `basename $0` target-file"
12 #  exit $E_NOARGS
13 # fi
14 
15 
16 # 就像从命令行调用下面的命令：
17 #    sed -e '/^$/d' filename
18 #
19 
20 sed -e /^$/d "$1"
21 #  The '-e' 意味着后面跟的是编辑命令 (这是可选的).
22 #  '^' 匹配行的开头, '$' 则是行的结尾.
23 #  这个表达式匹配行首和行尾之间什么也没有的行,
24 #+ 即空白行.
25 #  'd'是删除命令.
26 
27 #  引号引起命令行参数就允许在文件名中使用空白字符和特殊字符
28 #
29 
30 #  注意这个脚本不能真正的修改目标文件.
31 #  如果你需要保存修改,就要重定向到某个输出文件里.
32 
33 exit 0
################################End Script######################################### 
Example 33-2 稍微复杂一些的shell包装
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 #  "subst", 把一个文件中的一个模式替换成一个模式的脚本
 4 #
 5 #  例如, "subst Smith Jones letter.txt".
 6 
 7 ARGS=3         # 脚本要求三个参数.
 8 E_BADARGS=65   # 传递了错误的参数个数给脚本.
 9 
10 if [ $# -ne "$ARGS" ]
11 # 测试脚本参数的个数 (这是好办法).
12 then
13   echo "Usage: `basename $0` old-pattern new-pattern filename"
14   exit $E_BADARGS
15 fi
16 
17 old_pattern=$1
18 new_pattern=$2
19 
20 if [ -f "$3" ]
21 then
22     file_name=$3
23 else
24     echo "File \"$3\" does not exist."
25     exit $E_BADARGS
26 fi
27 
28 
29 #  这儿是实现功能的代码.
30 
31 # -----------------------------------------------
32 sed -e "s/$old_pattern/$new_pattern/g" $file_name
33 # -----------------------------------------------
34 
35 #  's' 在sed命令里表示替换,
36 #+ /pattern/表示匹配地址.
37 #  The "g"也叫全局标志使sed会在每一行有$old_pattern模式出现的所有地方替换,
38 #+ 而不只是匹配第一个出现的地方.
39 #  参考'sed'的有关书籍了解更深入的解释.
40 
41 exit 0    # 脚本成功调用会返回 0.
################################End Script######################################### 
Example 33-3 写到日志文件的shell包装
################################Start Script#######################################
 1 #!/bin/bash
 2 #  普通的shell包装,执行一个操作并记录在日志里
 3 #
 4 
 5 # 需要设置下面的两个变量.
 6 OPERATION=
 7 #         可以是一个复杂的命令链,
 8 #+        例如awk脚本或是管道 . . .
 9 LOGFILE=
10 #         不管怎么样,命令行参数还是要提供给操作的.
11 
12 
13 OPTIONS="$@"
14 
15 
16 # 记录操作.
17 echo "`date` + `whoami` + $OPERATION "$@"" >> $LOGFILE
18 # 现在, 执行操作.
19 exec $OPERATION "$@"
20 
21 # 在操作之前记录日志是必须的.
22 # 为什么?
################################End Script######################################### 
Example 33-4 包装awk的脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 # pr-ascii.sh: 打印 ASCII 码的字符表.
 3 
 4 START=33   # 可打印的 ASCII 字符的范围 (十进制).
 5 END=125
 6 
 7 echo " Decimal   Hex     Character"   # 表头.
 8 echo " -------   ---     ---------"
 9 
10 for ((i=START; i<=END; i++))
11 do
12   echo $i | awk '{printf("  %3d       %2x         %c\n", $1, $1, $1)}'
13 # 在这个上下文,不会运行Bash的内建printf命令:
14 #     printf "%c" "$i"
15 done
16 
17 exit 0
18 
19 
20 #  Decimal   Hex     Character
21 #  -------   ---     ---------
22 #    33       21         !
23 #    34       22         "
24 #    35       23         #
25 #    36       24         $
26 #
27 #    . . .
28 #
29 #   122       7a         z
30 #   123       7b         {
31 #   124       7c         |
32 #   125       7d         }
33 
34 
35 #  把脚本的输出重定向到一个文件或是管道给more命令来查看:
36 #+   sh pr-asc.sh | more
################################End Script######################################### 
Example 33-5 另一个包装awk的脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # 给目标文件增加一列由数字指定的列.
 4 
 5 ARGS=2
 6 E_WRONGARGS=65
 7 
 8 if [ $# -ne "$ARGS" ] # 检查命令行参数个数是否正确.
 9 then
10    echo "Usage: `basename $0` filename column-number"
11    exit $E_WRONGARGS
12 fi
13 
14 filename=$1
15 column_number=$2
16 
17 #  传递shell变量给脚本的awk部分需要一点技巧.
18 #  方法之一是在awk脚本中使用强引用来引起bash脚本的变量
19 #
20 #     $'$BASH_SCRIPT_VAR'
21 #      ^                ^
22 #  这个方法在下面的内嵌的awk脚本中出现.
23 #  参考awk文档了解更多的细节.
24 
25 # 多行的awk脚本调用格式为:  awk ' ..... '
26 
27 
28 # 开始 awk 脚本.
29 # -----------------------------
30 awk '
31 
32 { total += $'"${column_number}"'
33 }
34 END {
35      print total
36 }     
37 
38 ' "$filename"
39 # -----------------------------
40 # awk脚本结束.
41 
42 
43 #   把shell变量传递给awk变量可能是不安全的,
44 #+  因此Stephane Chazelas提出了下面另外一种方法:
45 #   ---------------------------------------
46 #   awk -v column_number="$column_number" '
47 #   { total += $column_number
48 #   }
49 #   END {
50 #       print total
51 #   }' "$filename"
52 #   ---------------------------------------
53 
54 
55 exit 0
################################End Script#########################################
对于要实现这些功能而只用一种多合一的瑞士军刀应该用Perl. Perl兼有sed和awk的能力, 并
且具有C的一个很大的子集. 它是标准的并支持面向对象编程的方方面面,甚至是很琐碎的东
西. 短的Perl脚本也可以嵌入到shell脚本中去,以至于有些人宣称Perl能够完全地代替shell
编程(本文作者对此持怀疑态度). 
Example 33-6 把Perl嵌入Bash脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # Shell命令可以包含 Perl 脚本.
 4 echo "This precedes the embedded Perl script within \"$0\"."
 5 echo "==============================================================="
 6 
 7 perl -e 'print "This is an embedded Perl script.\n";'
 8 # 像sed脚本, Perl 也使用"-e"选项.
 9 
10 echo "==============================================================="
11 echo "However, the script may also contain shell and system commands."
12 
13 exit 0
################################End Script#########################################
把Bash脚本和Perl脚本放在同一个文件是可能的. 依赖于脚本如何被调用, 要么是Bash部分被
执行,要么是Perl部分被执行. 
Example 33-7 Bash 和 Perl 脚本联合使用
################################Start Script#######################################
 1 #!/bin/bash
 2 # bashandperl.sh
 3 
 4 echo "Greetings from the Bash part of the script."
 5 # 下面可以有更多的Bash命令.
 6 
 7 exit 0
 8 # 脚本的Bash部分结束.
 9 
10 # =======================================================
11 
12 #!/usr/bin/perl
13 # 脚本的这个部分必须用-x选项来调用.
14 
15 print "Greetings from the Perl part of the script.\n";
16 # 下面可以有更多的Perl命令.
17 
18 # 脚本的Perl部分结束.
################################End Script######################################### 
 bash$ bash bashandperl.sh
 Greetings from the Bash part of the script.
 
 bash$ perl -x bashandperl.sh
 Greetings from the Perl part of the script. 
注意事项:
[1]  事实上,相当数量的Linux软件工具包是shell包装脚本. 例如/usr/bin/pdf2ps, 
  /usr/bin/batch, 和 /usr/X11R6/bin/xmkmf. 
33.3. 测试和比较: 另一种方法
----------------------------
对于测试,[[ ]]结构可能比[ ]更合适.同样地,算术比较可能用(( ))结构更有用. 
   1 a=8
   2 
   3 # 下面所有的比较是等价的.
   4 test "$a" -lt 16 && echo "yes, $a < 16"         # "与列表"
   5 /bin/test "$a" -lt 16 && echo "yes, $a < 16" 
   6 [ "$a" -lt 16 ] && echo "yes, $a < 16" 
   7 [[ $a -lt 16 ]] && echo "yes, $a < 16"          # 在[[ ]]和(( ))中不必用引号引起变量
   8 (( a < 16 )) && echo "yes, $a < 16"             #
   9 
  10 city="New York"
  11 # 同样,下面的所有比较都是等价的.
  12 test "$city" \< Paris && echo "Yes, Paris is greater than $city"  # 产生 ASCII 顺序.
  13 /bin/test "$city" \< Paris && echo "Yes, Paris is greater than $city" 
  14 [ "$city" \< Paris ] && echo "Yes, Paris is greater than $city" 
  15 [[ $city < Paris ]] && echo "Yes, Paris is greater than $city"    # 不需要用引号引起$city.
  16 
  17 # 多谢, S.C. 
33.4. 递归
----------
脚本是否能 递归地  调用自己本身? 当然可以. 
Example 33-8 递归调用自己本身的(无用)脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 # recurse.sh
 3 
 4 #  脚本能否递归地调用自己?
 5 #  是的, 但这有什么实际的用处吗?
 6 #  (看下面的.)
 7 
 8 RANGE=10
 9 MAXVAL=9
10 
11 i=$RANDOM
12 let "i %= $RANGE"  # 产生一个从 0 到 $RANGE - 1 之间的随机数.
13 
14 if [ "$i" -lt "$MAXVAL" ]
15 then
16   echo "i = $i"
17   ./$0             #  脚本递归地调用再生成一个和自己一样的实例.
18 fi                 #  每个子脚本做的事都一样,
19                    #+ 直到产生的变量 $i 和变量 $MAXVAL 相等.
20 
21 #  用"while"循环代替"if/then"测试会引起错误.
22 #  解释为什么会这样.
23 
24 exit 0
25 
26 # 注:
27 # ----
28 # 脚本要正确地工作必须有执行权限.
29 # 这是指用"sh"命令来调用这个脚本而没有设置正确权限导致的问题.
30 # 请解释原因.
################################End Script######################################### 
Example 33-9 递归调用自己本身的(有用)脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 # pb.sh: 电话本(phone book)
 3 
 4 # 由Rick Boivie编写,已得到使用许可.
 5 # 由ABS文档作者修改.
 6 
 7 MINARGS=1     #  脚本需要至少一个参数.
 8 DATAFILE=./phonebook
 9               #  在当前目录下名为"phonebook"的数据文件必须存在
10               #
11 PROGNAME=$0
12 E_NOARGS=70   #  没有参数的错误值.
13 
14 if [ $# -lt $MINARGS ]; then
15       echo "Usage: "$PROGNAME" data"
16       exit $E_NOARGS
17 fi      
18 
19 
20 if [ $# -eq $MINARGS ]; then
21       grep $1 "$DATAFILE"
22       #  如果$DATAFILE文件不存在,'grep' 会打印一个错误信息.
23 else
24       ( shift; "$PROGNAME" $* ) | grep $1
25       # 脚本递归调用本身.
26 fi
27 
28 exit 0        #  脚本在这儿退出.
29               #  因此Therefore, 从这行开始可以写没有#开头的的注释行
30        #
31 
32 # ------------------------------------------------------------------------
33 "phonebook"文件的例子:
34 
35 John Doe        1555 Main St., Baltimore, MD 21228          (410) 222-3333
36 Mary Moe        9899 Jones Blvd., Warren, NH 03787          (603) 898-3232
37 Richard Roe     856 E. 7th St., New York, NY 10009          (212) 333-4567
38 Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678
39 Zoe Zenobia     4481 N. Baker St., San Francisco, SF 94338  (415) 501-1631
40 # ------------------------------------------------------------------------
41 
42 $bash pb.sh Roe
43 Richard Roe     856 E. 7th St., New York, NY 10009          (212) 333-4567
44 Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678
45 
46 $bash pb.sh Roe Sam
47 Sam Roe         956 E. 8th St., New York, NY 10009          (212) 444-5678
48 
49 #  当超过一个参数传给这个脚本时,
50 #+ 它只打印包含所有参数的行.
################################End Script######################################### 
Example 33-10 另一个递归调用自己本身的(有用)脚本
################################Start Script#######################################
 1 #!/bin/bash
 2 # usrmnt.sh, 由Anthony Richardson编写
 3 # 得到允许在此使用.
 4 
 5 # usage:       usrmnt.sh
 6 # 描述: 挂载设备, 调用者必须列在/etc/sudoers文件的MNTUSERS组里
 7 #
 8 
 9 # ----------------------------------------------------------
10 #  这是一个用户挂载设备的脚本,它用sudo来调用自己.
11 #  只有拥有合适权限的用户才能用
12 
13 #   usermount /dev/fd0 /mnt/floppy
14 
15 # 来代替
16 
17 #   sudo usermount /dev/fd0 /mnt/floppy
18 
19 #  我使用相同的技术来处理我所有的sudo脚本, 
20 #+ 因为我觉得它很方便.
21 # ----------------------------------------------------------
22 
23 #  如果 SUDO_COMMAND 变量没有设置,我们不能通过sudo来运行脚本本身.
24 #+ 传递用户的真实ID和组ID . . .
25 
26 if [ -z "$SUDO_COMMAND" ]
27 then
28    mntusr=$(id -u) grpusr=$(id -g) sudo $0 $*
29    exit 0
30 fi
31 
32 # 如果我们以sudo来调用运行,就会运行这儿.
33 /bin/mount $* -o uid=$mntusr,gid=$grpusr
34 
35 exit 0
36 
37 # 附注 (由脚本作者加注): 
38 # -------------------------------------------------
39 
40 # 1) Linux允许在/etc/fstab文件中使用"users"选项 
41 #    以使任何用户能挂载可移动的介质.
42 #    但是, 在一个服务器上, 
43 #    我只想有限的几个用户可以存取可移动介质.
44 #    我发现使用sudo可以有更多的控制.
45 
46 # 2) 我也发现sudo能通过组更方便地达成目的.
47 # 
48 
49 # 3) 这个方法使给予任何想给合适权限的人使用mount命令
50 #    所以要小心使用.
51 #    你也可以开发类似的脚本mntfloppy, mntcdrom,和 mntsamba来使mount命令得到更好的控制
52 # 
53 # 
54 # 
################################End Script#########################################
注意: 过多层次的递归调用会耗尽脚本的堆栈空间,会引起段错误. 
33.5. 彩色脚本
--------------
ANSI [1]  定义了屏幕属性的转义序列集合,例如粗体文本,背景和前景颜色. DOS批处理文
件(batch files) 一般使用ANSI的转义代码来控制色彩输出,Bash脚本也是这么做的. 
Example 33-11 一个 "彩色的" 地址资料库
################################Start Script#######################################
 1 #!/bin/bash
 2 # ex30a.sh: ex30.sh的"彩色" 版本.
 3 #            没有加工处理的地址资料库
 4 
 5 
 6 clear                                   # 清除屏幕.
 7 
 8 echo -n "          "
 9 echo -e '\E[37;44m'"\033[1mContact List\033[0m"
10                                         # 白色为前景色,蓝色为背景色
11 echo; echo
12 echo -e "\033[1mChoose one of the following persons:\033[0m"
13                                         # 粗体
14 tput sgr0
15 echo "(Enter only the first letter of name.)"
16 echo
17 echo -en '\E[47;34m'"\033[1mE\033[0m"   # 蓝色
18 tput sgr0                               # 把色彩设置为"常规"
19 echo "vans, Roland"                     # "[E]vans, Roland"
20 echo -en '\E[47;35m'"\033[1mJ\033[0m"   # 红紫色
21 tput sgr0
22 echo "ones, Mildred"
23 echo -en '\E[47;32m'"\033[1mS\033[0m"   # 绿色
24 tput sgr0
25 echo "mith, Julie"
26 echo -en '\E[47;31m'"\033[1mZ\033[0m"   # 红色
27 tput sgr0
28 echo "ane, Morris"
29 echo
30 
31 read person
32 
33 case "$person" in
34 # 注意变量被引起来了.
35 
36   "E" | "e" )
37   # 接受大小写的输入.
38   echo
39   echo "Roland Evans"
40   echo "4321 Floppy Dr."
41   echo "Hardscrabble, CO 80753"
42   echo "(303) 734-9874"
43   echo "(303) 734-9892 fax"
44   echo "revans@zzy.net"
45   echo "Business partner & old friend"
46   ;;
47 
48   "J" | "j" )
49   echo
50   echo "Mildred Jones"
51   echo "249 E. 7th St., Apt. 19"
52   echo "New York, NY 10009"
53   echo "(212) 533-2814"
54   echo "(212) 533-9972 fax"
55   echo "milliej@loisaida.com"
56   echo "Girlfriend"
57   echo "Birthday: Feb. 11"
58   ;;
59 
60 # 稍后为 Smith 和 Zane 增加信息.
61 
62           * )
63    # 默认选项Default option.   
64    # 空的输入(直接按了回车) 也会匹配这儿.
65    echo
66    echo "Not yet in database."
67   ;;
68 
69 esac
70 
71 tput sgr0                               # 把色彩重设为"常规".
72 
73 echo
74 
75 exit 0
################################End Script######################################### 
Example 33-12 画盒子
################################Start Script#######################################
  1 #!/bin/bash
  2 # Draw-box.sh: 用ASCII字符画一个盒子.
  3 
  4 # Stefano Palmeri编写,文档作者作了少量编辑.
  5 # 征得作者同意在本书使用.
  6 
  7 
  8 ######################################################################
  9 ###  draw_box 函数的注释  ###
 10 
 11 #  "draw_box" 函数使用户可以在终端上画一个盒子.
 12 #
 13 #
 14 #  用法: draw_box ROW COLUMN HEIGHT WIDTH [COLOR] 
 15 #  ROW 和 COLUMN 定位要画的盒子的左上角.       
 16 #
 17 #  ROW 和 COLUMN 必须要大于0且小于目前终端的尺寸.
 18 #
 19 #  HEIGHT 是盒子的行数,必须 > 0. 
 20 #  HEIGHT + ROW 必须 <= 终端的高度. 
 21 #  WIDTH 是盒子的列数,必须 > 0.
 22 #  WIDTH + COLUMN 必须 <= 终端的宽度.
 23 #
 24 #  例如: 如果你当前终端的尺寸是 20x80,
 25 #  draw_box 2 3 10 45 是合法的
 26 #  draw_box 2 3 19 45 的 HEIGHT 值是错的 (19+2 > 20)
 27 #  draw_box 2 3 18 78 的 WIDTH 值是错的 (78+3 > 80)
 28 #
 29 #  COLOR 是盒子边框的颜色.
 30 #  它是第5个参数,并且它是可选的.
 31 #  0=黑色 1=红色 2=绿色 3=棕褐色 4=蓝色 5=紫色 6=青色 7=白色.
 32 #  如果你传给这个函数错的参数,
 33 #+ 它就会以代码65退出,
 34 #+ 没有其他的信息打印到标准出错上.
 35 #
 36 #  在画盒子之前要清屏.
 37 #  函数内不包含有清屏命令.
 38 #  这使用户可以画多个盒子,甚至叠接多个盒子.
 39 
 40 ###  draw_box 函数注释结束  ### 
 41 ######################################################################
 42 
 43 draw_box(){
 44 
 45 #=============#
 46 HORZ="-"
 47 VERT="|"
 48 CORNER_CHAR="+"
 49 
 50 MINARGS=4
 51 E_BADARGS=65
 52 #=============#
 53 
 54 
 55 if [ $# -lt "$MINARGS" ]; then                 # 如果参数小于4,退出.
 56     exit $E_BADARGS
 57 fi
 58 
 59 # 搜寻参数中的非数字的字符.
 60 # 能用其他更好的办法吗 (留给读者的练习?).
 61 if echo $@ | tr -d [:blank:] | tr -d [:digit:] | grep . &> /dev/null; then
 62    exit $E_BADARGS
 63 fi
 64 
 65 BOX_HEIGHT=`expr $3 - 1`   #  -1 是需要的,因为因为边角的"+"是高和宽共有的部分. 
 66 BOX_WIDTH=`expr $4 - 1`    #
 67 T_ROWS=`tput lines`        #  定义当前终端长和宽的尺寸, 
 68 T_COLS=`tput cols`         #
 69          
 70 if [ $1 -lt 1 ] || [ $1 -gt $T_ROWS ]; then    #  如果参数是数字就开始检查有效性.
 71    exit $E_BADARGS                             #
 72 fi
 73 if [ $2 -lt 1 ] || [ $2 -gt $T_COLS ]; then
 74    exit $E_BADARGS
 75 fi
 76 if [ `expr $1 + $BOX_HEIGHT + 1` -gt $T_ROWS ]; then
 77    exit $E_BADARGS
 78 fi
 79 if [ `expr $2 + $BOX_WIDTH + 1` -gt $T_COLS ]; then
 80    exit $E_BADARGS
 81 fi
 82 if [ $3 -lt 1 ] || [ $4 -lt 1 ]; then
 83    exit $E_BADARGS
 84 fi                                 # 参数检查完毕.
 85 
 86 plot_char(){                       # 函数内的函数.
 87    echo -e "\E[${1};${2}H"$3
 88 }
 89 
 90 echo -ne "\E[3${5}m"               # 如果传递了盒子边框颜色参数,则设置它.
 91 
 92 # start drawing the box
 93 
 94 count=1                                         #  用plot_char函数画垂直线
 95 for (( r=$1; count<=$BOX_HEIGHT; r++)); do      #
 96   plot_char $r $2 $VERT
 97   let count=count+1
 98 done 
 99 
100 count=1
101 c=`expr $2 + $BOX_WIDTH`
102 for (( r=$1; count<=$BOX_HEIGHT; r++)); do
103   plot_char $r $c $VERT
104   let count=count+1
105 done 
106 
107 count=1                                        #  用plot_char函数画水平线
108 for (( c=$2; count<=$BOX_WIDTH; c++)); do      #
109   plot_char $1 $c $HORZ
110   let count=count+1
111 done 
112 
113 count=1
114 r=`expr $1 + $BOX_HEIGHT`
115 for (( c=$2; count<=$BOX_WIDTH; c++)); do
116   plot_char $r $c $HORZ
117   let count=count+1
118 done 
119 
120 plot_char $1 $2 $CORNER_CHAR                   # 画盒子的角.
121 plot_char $1 `expr $2 + $BOX_WIDTH` +
122 plot_char `expr $1 + $BOX_HEIGHT` $2 +
123 plot_char `expr $1 + $BOX_HEIGHT` `expr $2 + $BOX_WIDTH` +
124 
125 echo -ne "\E[0m"             #  恢复最初的颜色.
126 
127 P_ROWS=`expr $T_ROWS - 1`    #  在终端的底部打印提示符.
128 
129 echo -e "\E[${P_ROWS};1H"
130 }      
131 
132 
133 # 现在, 让我们来画一个盒子.
134 clear                       # 清屏.
135 R=2      # 行
136 C=3      # 列
137 H=10     # 高
138 W=45     # 宽
139 col=1    # 颜色(红)
140 draw_box $R $C $H $W $col   # 画盒子.
141 
142 exit 0
143 
144 # 练习:
145 # --------
146 # 增加可以在盒子里打印文本的选项
################################End Script#########################################
最简单也可能是最有用的ANSI转义序列是加粗文本, \033[1m ... \033[0m. \033 触发转义序
列, 而 "[1" 启用加粗属性, 而"[0" 表示切换回禁用加粗状态. "m"则表示终止一个转义序列. 
 bash$ echo -e "\033[1mThis is bold text.\033[0m" 
一种相似的转义序列可切换下划线效果 (在 rxvt 和 aterm 上). 
 bash$ echo -e "\033[4mThis is underlined text.\033[0m"
        
注意: echo使用-e选项可以启用转义序列. 
其他的转义序列可用于更改文本或/和背景色彩. 
 bash$ echo -e '\E[34;47mThis prints in blue.'; tput sgr0
 
 bash$ echo -e '\E[33;44m'"yellow text on blue background"; tput sgr0
 
 bash$ echo -e '\E[1;33;44m'"BOLD yellow text on blue background"; tput sgr0
        
注意: 通常为淡色的前景色文本设置粗体效果是较好的. 
tput sgr0 把终端设置恢复为原样. 如果省略这一句会使后续在该终端的输出仍为蓝色. 
注意: 因为tput sgr0 在某些环境下不能恢复终端设置, echo -ne \E[0m 会是更好的选择. 
可以在有色的背景上用下面的模板写有色彩的文本. 
echo -e '\E[COLOR1;COLOR2mSome text goes here.' 
"\E[" 开始转义序列. 分号分隔的数值"COLOR1" 和 "COLOR2" 指定前景色和背景色, 数值和
色彩的对应参见下面的表格. (数值的顺序不是有关系的,因为前景色和背景色数值都落在不
重叠的范围里.) "m"终止该转义序列, 然后文本以结束的转义指定的属性显示. 
也要注意到用单引号引用了echo -e后面的余下命令序列. 
下表的数值是在 rxvt 终端运行的结果. 具体效果可能在其他的各种终端上不一样. 
table 33-1. 转义序列中数值和彩色的对应 
==========================
| 色彩  | 前景色 | 背景色|
|  黑  |  30  |  40   |
|  红  |  31  |  41   |
|  绿  |  32  |  42   |
|  黄  |  33  |  43   |
|  蓝  |  34  |  44   |
|  洋红 |  35  |  45   |
|  青  |  36  |  46   |
|  白  |  37  |  47   |
========================== 
Example 33-13 显示彩色文本
################################Start Script#######################################
 1 #!/bin/bash
 2 # color-echo.sh: 用彩色来显示文本.
 3 
 4 # 依照需要修改这个脚本.
 5 # 这比手写彩色的代码更容易一些.
 6 
 7 black='\E[30;47m'
 8 red='\E[31;47m'
 9 green='\E[32;47m'
10 yellow='\E[33;47m'
11 blue='\E[34;47m'
12 magenta='\E[35;47m'
13 cyan='\E[36;47m'
14 white='\E[37;47m'
15 
16 
17 alias Reset="tput sgr0"      #  把文本属性重设回原来没有清屏前的
18                              #
19 
20 
21 cecho ()                     # Color-echo.
22                              # 参数 $1 = 要显示的信息
23                              # 参数 $2 = 颜色
24 {
25 local default_msg="No message passed."
26                              # 不是非要一个本地变量.
27 
28 message=${1:-$default_msg}   # 默认的信息.
29 color=${2:-$black}           # 如果没有指定,默认使用黑色.
30 
31   echo -e "$color"
32   echo "$message"
33   Reset                      # 重设文本属性.
34 
35   return
36 }  
37 
38 
39 # 现在,让我们试试.
40 # ----------------------------------------------------
41 cecho "Feeling blue..." $blue
42 cecho "Magenta looks more like purple." $magenta
43 cecho "Green with envy." $green
44 cecho "Seeing red?" $red
45 cecho "Cyan, more familiarly known as aqua." $cyan
46 cecho "No color passed (defaults to black)."
47        # 缺失 $color (色彩)参数.
48 cecho "\"Empty\" color passed (defaults to black)." ""
49        # 空的 $color (色彩)参数.
50 cecho
51        # $message(信息) 和 $color (色彩)参数都缺失.
52 cecho "" ""
53        # 空的 $message (信息)和 $color (色彩)参数.
54 # ----------------------------------------------------
55 
56 echo
57 
58 exit 0
59 
60 # 练习:
61 # ---------
62 # 1) 为'cecho ()'函数增加粗体的效果.
63 # 2) 增加可选的彩色背景.
################################End Script######################################### 
Example 33-14 "赛马" 游戏
################################Start Script#######################################
  1 #!/bin/bash
  2 # horserace.sh: 非常简单的赛马模拟.
  3 # 作者: Stefano Palmeri
  4 # 已取得使用许可.
  5 
  6 ################################################################
  7 #  脚本目的:
  8 #  使用转义字符和终端颜色.
  9 #
 10 #  练习:
 11 #  编辑脚本使其更具有随机性,
 12 #+ 设置一个假的赌场 . . .     
 13 #  嗯 . . . 嗯 . . . 这个开始使我想起了一部电影 . . .
 14 #
 15 #  脚本给每匹马一个随机的障碍.
 16 #  不均等会以障碍来计算
 17 #+ 并且用一种欧洲风格表达出来.
 18 #  例如: 机率(odds)=3.75 意味着如果你押1美元赢,
 19 #+ 你可以赢得3.75美元.
 20 # 
 21 #  脚本已经在GNU/Linux操作系统上测试过 OS,
 22 #+ 测试终端有xterm 和 rxvt, 及 konsole.
 23 #  测试机器有AMD 900 MHz 的处理器,
 24 #+ 平均比赛时间是75秒.    
 25 #  在更快的计算机上比赛时间应该会更低.
 26 #  所以, 如果你想有更多的悬念,重设USLEEP_ARG 变量的值.
 27 #
 28 #  由Stefano Palmeri编写.
 29 ################################################################
 30 
 31 E_RUNERR=65
 32 
 33 # 检查 md5sum 和 bc 是不是安装了. 
 34 if ! which bc &> /dev/null; then
 35    echo bc is not installed.  
 36    echo "Can\'t run . . . "
 37    exit $E_RUNERR
 38 fi
 39 if ! which md5sum &> /dev/null; then
 40    echo md5sum is not installed.  
 41    echo "Can\'t run . . . "
 42    exit $E_RUNERR
 43 fi
 44 
 45 #  更改下面的变量值可以使脚本执行的更慢.
 46 #  它会作为usleep的参数 (man usleep)  
 47 #+ 并且它的单位是微秒 (500000微秒 = 半秒).
 48 USLEEP_ARG=0  
 49 
 50 #  如果脚本接收到ctrl-c中断,清除临时目录, 恢复终端光标和颜色 
 51 #
 52 trap 'echo -en "\E[?25h"; echo -en "\E[0m"; stty echo;\
 53 tput cup 20 0; rm -fr  $HORSE_RACE_TMP_DIR'  TERM EXIT
 54 #  参考调试的章节了解'trap'的更多解释
 55 
 56 # 给脚本设置一个唯一(实际不是绝对唯一的)的临时目录名.
 57 HORSE_RACE_TMP_DIR=$HOME/.horserace-`date +%s`-`head -c10 /dev/urandom | md5sum | head -c30`
 58 
 59 # 创建临时目录,并切换到该目录下.
 60 mkdir $HORSE_RACE_TMP_DIR
 61 cd $HORSE_RACE_TMP_DIR
 62 
 63 
 64 #  这个函数把光标移动到行为 $1 列为 $2 然后打印 $3.
 65 #  例如: "move_and_echo 5 10 linux" 等同于
 66 #+ "tput cup 4 9; echo linux", 但是用一个命令代替了两个.
 67 #  注: "tput cup" 表示在终端左上角的 0 0 位置,
 68 #+ echo 是在终端的左上角的 1 1 位置.
 69 move_and_echo() {
 70           echo -ne "\E[${1};${2}H""$3" 
 71 }
 72 
 73 # 产生1-9之间伪随机数的函数. 
 74 random_1_9 () {
 75                 head -c10 /dev/urandom | md5sum | tr -d [a-z] | tr -d 0 | cut -c1 
 76 }
 77 
 78 #  画马时模拟运动的两个函数. 
 79 draw_horse_one() {
 80                echo -n " "//$MOVE_HORSE//
 81 }
 82 draw_horse_two(){
 83               echo -n " "\\\\$MOVE_HORSE\\\\ 
 84 }   
 85 
 86 
 87 # 取得当前的终端尺寸.
 88 N_COLS=`tput cols`
 89 N_LINES=`tput lines`
 90 
 91 # 至少需要 20-行 X 80-列 的终端尺寸. 检查一下.
 92 if [ $N_COLS -lt 80 ] || [ $N_LINES -lt 20 ]; then
 93    echo "`basename $0` needs a 80-cols X 20-lines terminal."
 94    echo "Your terminal is ${N_COLS}-cols X ${N_LINES}-lines."
 95    exit $E_RUNERR
 96 fi
 97 
 98 
 99 # 开始画赛场.
100 
101 # 需要一个80个字符的字符串,看下面的.
102 BLANK80=`seq -s "" 100 | head -c80`
103 
104 clear
105 
106 # 把前景和背景颜色设置成白色的.
107 echo -ne '\E[37;47m'
108 
109 # 把光标移到终端的左上角.
110 tput cup 0 0 
111 
112 # 画六条白线.
113 for n in `seq 5`; do
114       echo $BLANK80        # 线是用80个字符组成的字符串.  
115 done
116 
117 # 把前景色设置成黑色. 
118 echo -ne '\E[30m'
119 
120 move_and_echo 3 1 "START  1"            
121 move_and_echo 3 75 FINISH
122 move_and_echo 1 5 "|"
123 move_and_echo 1 80 "|"
124 move_and_echo 2 5 "|"
125 move_and_echo 2 80 "|"
126 move_and_echo 4 5 "|  2"
127 move_and_echo 4 80 "|"
128 move_and_echo 5 5 "V  3"
129 move_and_echo 5 80 "V"
130 
131 # 把前景色设置成红色. 
132 echo -ne '\E[31m'
133 
134 # 一些ASCII艺术.
135 move_and_echo 1 8 "..@@@..@@@@@...@@@@@.@...@..@@@@..."
136 move_and_echo 2 8 ".@...@...@.......@...@...@.@......."
137 move_and_echo 3 8 ".@@@@@...@.......@...@@@@@.@@@@...."
138 move_and_echo 4 8 ".@...@...@.......@...@...@.@......."
139 move_and_echo 5 8 ".@...@...@.......@...@...@..@@@@..."
140 move_and_echo 1 43 "@@@@...@@@...@@@@..@@@@..@@@@."
141 move_and_echo 2 43 "@...@.@...@.@.....@.....@....."
142 move_and_echo 3 43 "@@@@..@@@@@.@.....@@@@...@@@.."
143 move_and_echo 4 43 "@..@..@...@.@.....@.........@."
144 move_and_echo 5 43 "@...@.@...@..@@@@..@@@@.@@@@.."
145 
146 
147 # 把前景和背景颜色设为绿色.
148 echo -ne '\E[32;42m'
149 
150 # 画11行绿线.
151 tput cup 5 0
152 for n in `seq 11`; do
153       echo $BLANK80
154 done
155 
156 # 把前景色设为黑色. 
157 echo -ne '\E[30m'
158 tput cup 5 0
159 
160 # 画栅栏. 
161 echo "++++++++++++++++++++++++++++++++++++++\
162 ++++++++++++++++++++++++++++++++++++++++++"
163 
164 tput cup 15 0
165 echo "++++++++++++++++++++++++++++++++++++++\
166 ++++++++++++++++++++++++++++++++++++++++++"
167 
168 # 把前景和背景色设回白色.
169 echo -ne '\E[37;47m'
170 
171 # 画3条白线.
172 for n in `seq 3`; do
173       echo $BLANK80
174 done
175 
176 # 把前景色设为黑色.
177 echo -ne '\E[30m'
178 
179 # 创建9个文件来保存障碍物.
180 for n in `seq 10 7 68`; do
181       touch $n
182 done  
183 
184 # 设置脚本要画的马的类型为第一种类型.
185 HORSE_TYPE=2
186 
187 #  为每匹马创建位置文件和机率文件.
188 #+ 在这些文件里保存了该匹马当前的位置,
189 #+ 类型和机率.
190 for HN in `seq 9`; do
191       touch horse_${HN}_position
192       touch odds_${HN}
193       echo \-1 > horse_${HN}_position
194       echo $HORSE_TYPE >>  horse_${HN}_position
195       # 给马定义随机的障碍物.
196        HANDICAP=`random_1_9`
197       # 检查random_1_9函数是否返回了有效值.
198       while ! echo $HANDICAP | grep [1-9] &> /dev/null; do
199                 HANDICAP=`random_1_9`
200       done
201       # 给马定义最后的障碍的位置. 
202       LHP=`expr $HANDICAP \* 7 + 3`
203       for FILE in `seq 10 7 $LHP`; do
204             echo $HN >> $FILE
205       done   
206      
207       # 计算机率.
208       case $HANDICAP in 
209               1) ODDS=`echo $HANDICAP \* 0.25 + 1.25 | bc`
210                                  echo $ODDS > odds_${HN}
211               ;;
212               2 | 3) ODDS=`echo $HANDICAP \* 0.40 + 1.25 | bc`
213                                        echo $ODDS > odds_${HN}
214               ;;
215               4 | 5 | 6) ODDS=`echo $HANDICAP \* 0.55 + 1.25 | bc`
216                                              echo $ODDS > odds_${HN}
217               ;; 
218               7 | 8) ODDS=`echo $HANDICAP \* 0.75 + 1.25 | bc`
219                                        echo $ODDS > odds_${HN}
220               ;; 
221               9) ODDS=`echo $HANDICAP \* 0.90 + 1.25 | bc`
222                                   echo $ODDS > odds_${HN}
223       esac
224 
225 
226 done
227 
228 
229 # 打印机率.
230 print_odds() {
231 tput cup 6 0
232 echo -ne '\E[30;42m'
233 for HN in `seq 9`; do
234       echo "#$HN odds->" `cat odds_${HN}`
235 done
236 }
237 
238 # 在起跑线上画马.
239 draw_horses() {
240 tput cup 6 0
241 echo -ne '\E[30;42m'
242 for HN in `seq 9`; do
243       echo /\\$HN/\\"                               "
244 done
245 }
246 
247 print_odds
248 
249 echo -ne '\E[47m'
250 # 等待回车按键开始赛马.
251 # 转义序列'\E[?25l'禁显了光标.
252 tput cup 17 0
253 echo -e '\E[?25l'Press [enter] key to start the race...
254 read -s
255 
256 #  禁用了终端的常规显示功能.
257 #  这避免了赛跑时不小心按了按键键入显示字符而弄乱了屏幕.
258 #  
259 stty -echo
260 
261 # --------------------------------------------------------
262 # 开始赛跑.
263 
264 draw_horses
265 echo -ne '\E[37;47m'
266 move_and_echo 18 1 $BLANK80
267 echo -ne '\E[30m'
268 move_and_echo 18 1 Starting...
269 sleep 1
270 
271 # 设置终点线的列数.
272 WINNING_POS=74
273 
274 # 记录赛跑开始的时间.
275 START_TIME=`date +%s`
276 
277 # COL 是由下面的"while"结构使用的.
278 COL=0    
279 
280 while [ $COL -lt $WINNING_POS ]; do
281                    
282           MOVE_HORSE=0     
283           
284           # 检查random_1_9函数是否返回了有效值.
285           while ! echo $MOVE_HORSE | grep [1-9] &> /dev/null; do
286                 MOVE_HORSE=`random_1_9`
287           done
288           
289           # 取得随机取得的马的类型和当前位置.
290           HORSE_TYPE=`cat  horse_${MOVE_HORSE}_position | tail -1`
291           COL=$(expr `cat  horse_${MOVE_HORSE}_position | head -1`) 
292           
293           ADD_POS=1
294           # 检查当前的位置是否是障碍物的位置. 
295           if seq 10 7 68 | grep -w $COL &> /dev/null; then
296                 if grep -w $MOVE_HORSE $COL &> /dev/null; then
297                       ADD_POS=0
298                       grep -v -w  $MOVE_HORSE $COL > ${COL}_new
299                       rm -f $COL
300                       mv -f ${COL}_new $COL
301                       else ADD_POS=1
302                 fi 
303           else ADD_POS=1
304           fi
305           COL=`expr $COL + $ADD_POS`
306           echo $COL >  horse_${MOVE_HORSE}_position  # 保存新位置.
307                             
308          # 选择要画的马的类型.         
309           case $HORSE_TYPE in 
310                 1) HORSE_TYPE=2; DRAW_HORSE=draw_horse_two
311                 ;;
312                 2) HORSE_TYPE=1; DRAW_HORSE=draw_horse_one 
313           esac       
314           echo $HORSE_TYPE >>  horse_${MOVE_HORSE}_position # 保存当前类型.
315          
316           # 把前景色设为黑,背景色设为绿.
317           echo -ne '\E[30;42m'
318           
319           # 把光标位置移到新的马的位置.
320           tput cup `expr $MOVE_HORSE + 5`  `cat  horse_${MOVE_HORSE}_position | head -1` 
321           
322           # 画马.
323           $DRAW_HORSE
324            usleep $USLEEP_ARG
325           
326            # 当所有的马都越过15行的之后,再次打印机率.          
327            touch fieldline15
328            if [ $COL = 15 ]; then
329              echo $MOVE_HORSE >> fieldline15  
330            fi
331            if [ `wc -l fieldline15 | cut -f1 -d " "` = 9 ]; then
332                print_odds
333                : > fieldline15
334            fi           
335           
336           # 取得领头的马.
337           HIGHEST_POS=`cat *position | sort -n | tail -1`          
338           
339           # 把背景色重设为白色.
340           echo -ne '\E[47m'
341           tput cup 17 0
342           echo -n Current leader: `grep -w $HIGHEST_POS *position | cut -c7`"                              "           
343 
344 done  
345 
346 # 取得赛马结束的时间.
347 FINISH_TIME=`date +%s`
348 
349 # 背景色设为绿色并且启用闪动的功能.
350 echo -ne '\E[30;42m'
351 echo -en '\E[5m'
352 
353 # 使获胜的马闪动.
354 tput cup `expr $MOVE_HORSE + 5` `cat  horse_${MOVE_HORSE}_position | head -1`
355 $DRAW_HORSE
356 
357 # 禁用闪动文本.
358 echo -en '\E[25m'
359 
360 # 把前景和背景色设为白色.
361 echo -ne '\E[37;47m'
362 move_and_echo 18 1 $BLANK80
363 
364 # 前景色设为黑色.
365 echo -ne '\E[30m'
366 
367 # 闪动获胜的马.
368 tput cup 17 0
369 echo -e "\E[5mWINNER: $MOVE_HORSE\E[25m""  Odds: `cat odds_${MOVE_HORSE}`"\
370 "  Race time: `expr $FINISH_TIME - $START_TIME` secs"
371 
372 # 恢复光标和最初的颜色.
373 echo -en "\E[?25h"
374 echo -en "\E[0m"
375 
376 # 恢复回显功能.
377 stty echo
378 
379 # 删除赛跑的临时文件.
380 rm -rf $HORSE_RACE_TMP_DIR
381 
382 tput cup 19 0
383 
384 exit 0
################################End Script#########################################
参考 例子 A-22. 
注意: 然而,有一个主要的问题,那就是ANSI 转义序列是不可移植的. 在一些终端运行的
  很好的代码可能在另外一些终端上可能运行地很糟糕. 在彩色脚本作者终端上运行的
  很好的脚本可能在另外一些终端上就产生不可阅读的输出了. 这给彩色脚本的用处大
  大打了个折扣,而很可能使这些技术变成一个暗机关或只是一个玩具而已. 
Moshe Jacobson的颜色工具(http://runslinux.net/projects.html#color)能相当容易地使用
ANSI转义序列. 它用清晰和较有逻辑的语法来代替刚才讨论的难用的结构. 
Henry/teikedvl 也同样开发了一个软件包来简化彩色脚本的一些操作 
(http://scriptechocolor.sourceforge.net/). 
注意事项:
[1]  当然,ANSI是American National Standards Institute(美国国家标准组织)的缩
  写. 这个令人敬畏的组织建立和维护着许多技术和工业的标准. 
33.6. 优化
----------
大多数shell脚本处理不复杂的问题时会有很快的解决办法. 正因为这样,优化脚本速度不是
一个问题. 考虑这样的情况, 一个脚本处理很重要的任务, 虽然它确实运行的很好很正确,但
是处理速度太慢. 用一种可编译的语言重写它可能不是非常好的选择. 最简单的办法是重写使
这个脚本效率低下的部分. 这个代码优化的原理是否同样适用于效率低下的shell脚本? 
检查脚本中的循环. 反复执行操作的时间消耗增长非常的快. 如果可能, 可以从循环中删除时
间消耗的操作. 
优先使用内建(builtin)命令而不是系统命令. 内建命令执行起来更快并且一般调用时不会
产生新的子shell. 
避免不需要的命令, 特别是管道(pipe). 
   1 cat "$file" | grep "$word"
   2 
   3 grep "$word" "$file"
   4 
   5 #  上面的命令行有同样的效果,
   6 #+ 但第二个运行的更有效率,因为它不产生新的子进程. 
cat 命令似乎特别常在脚本中被滥用. 
用time和times工具去了解计算花费的时间. 考虑用C甚至是汇编重写关键的消耗时间的部分. 
尝试最小化文件I/O. Bash在文件处理上不是特别地有效率, 所以要考虑在脚本中使用更合适
地工具来处理, 比如说awk 或 Perl. 
采用结构化的思想来写脚本, 使各个模块能够依据需要组织和合并起来.一些适用于高级语言
的优化技术也可以用在脚本上 , 但有些技术, 比如说循环优化, 几乎是不相关的. 上面的讨
论, 依据经验来判断. 
怎样优化减少执行时间的优秀脚本示例, 请参考例子 12-42. 
33.7. 各种小技巧
----------------
* 为了记录在一个实际的会话期或多个会话期内运行的用户脚本,可以加下面的代码到每
 个你想追踪记录的脚本里. 这会记录下连续的脚本名记录和调用的次数. 
    1 # 添加(>>)下面几行到你想追踪记录的脚本末尾处.
    2 
    3 whoami>> $SAVE_FILE    # 记录调用脚本的用户.
    4 echo $0>> $SAVE_FILE   # 记录脚本名.
    5 date>> $SAVE_FILE      # 记录日期和时间.
    6 echo>> $SAVE_FILE      # 空行作为分隔行.
    7 
    8 #  当然, SAVE_FILE 变量应在~/.bashrc中定义并导出(export) 
    9 #+ (变量值类似如 ~/.scripts-run) 
* >> 操作符可以在文件尾添加内容. 如果你想在文件头添加内容,那应该怎么办? 
    1 file=data.txt
    2 title="***This is the title line of data text file***"
    3 
    4 echo $title | cat - $file >$file.new
    5 # "cat -" 连接标准输出的内容和$file的内容.
    6 #  最后的结果就是生成了一个新文件,
    7 #+ 文件的头添加了 $title 的值,后跟$file的内容. 
 这是早先例子 17-13中的简化变体. 当然, , sed 也可以办到. 
* 脚本也可以像内嵌到另一个shell脚本的普通命令一样调用, 如 Tcl 或 wish 脚本, 甚至
 可以是Makefile. 它们可以作为外部shell命令用C语言的 system() 函数调用, 例如., 
 system("script_name");. 
* 把内嵌的 sed 或 awk 脚本的内容赋值给一个变量可以增加包装脚本(shell wrapper)
 的可读性. 参考 例子 A-1 和 例子 11-18. 
* 把你最喜欢和最有用的定义和函数放在一些文件中. 当需要的使用的时候, 在脚本中使用
 dot (.) 或 source 命令来"包含(include)"这些"库文件"的一个或多个. 
    1 # 脚本库
    2 # ------ -------
    3 
    4 # 注:
    5 # 本文件没有"#!"开头.
    6 # 也没有真正做执行动作的代码.
    7 
    8 
    9 # 有用的变量定义
   10 
   11 ROOT_UID=0             # Root用户的 $UID 值是0.
   12 E_NOTROOT=101          # 非root用户出错代码. 
   13 MAXRETVAL=255          # 函数最大的的返回值(正值).
   14 SUCCESS=0
   15 FAILURE=-1
   16 
   17 
   18 
   19 # 函数
   20 
   21 Usage ()               # "Usage:" 信息(即帮助信息).
   22 {
   23   if [ -z "$1" ]       # 没有传递参数.
   24   then
   25     msg=filename
   26   else
   27     msg=$@
   28   fi
   29 
   30   echo "Usage: `basename $0` "$msg""
   31 }  
   32 
   33 
   34 Check_if_root ()       # 检查是不是root在运行脚本.
   35 {                      # 取自例子"ex39.sh".
   36   if [ "$UID" -ne "$ROOT_UID" ]
   37   then
   38     echo "Must be root to run this script."
   39     exit $E_NOTROOT
   40   fi
   41 }  
   42 
   43 
   44 CreateTempfileName ()  # 创建一个"唯一"的临时文件.
   45 {                      # 取自例子"ex51.sh".
   46   prefix=temp
   47   suffix=`eval date +%s`
   48   Tempfilename=$prefix.$suffix
   49 }
   50 
   51 
   52 isalpha2 ()            # 测试字符串是不是都是字母组成的.
   53 {                      # 取自例子"isalpha.sh".
   54   [ $# -eq 1 ] || return $FAILURE
   55 
   56   case $1 in
   57   *[!a-zA-Z]*|"") return $FAILURE;;
   58   *) return $SUCCESS;;
   59   esac                 # Thanks, S.C.
   60 }
   61 
   62 
   63 abs ()                           # 绝对值.
   64 {                                # 注意: 最大的返回值 = 255.
   65   E_ARGERR=-999999
   66 
   67   if [ -z "$1" ]                 # 要传递参数.
   68   then
   69     return $E_ARGERR             # 返回错误.
   70   fi
   71 
   72   if [ "$1" -ge 0 ]              # 如果非负的值,
   73   then                           #
   74     absval=$1                    # 绝对值是本身.
   75   else                           # 否则,
   76     let "absval = (( 0 - $1 ))"  # 改变它的符号.
   77   fi  
   78 
   79   return $absval
   80 }
   81 
   82 
   83 tolower ()             #  把传递的字符串转为小写
   84 {                      #
   85 
   86   if [ -z "$1" ]       #  如果没有传递参数,
   87   then                 #+ 打印错误信息
   88     echo "(null)"      #+ (C风格的void指针的错误信息)
   89     return             #+ 然后从函数中返回.
   90   fi  
   91 
   92   echo "$@" | tr A-Z a-z
   93   # 转换传递过来的所有参数($@).
   94 
   95   return
   96 
   97 # 用命令替换功能把函数的输出赋给变量.
   98 # 例如:
   99 #    oldvar="A seT of miXed-caSe LEtTerS"
  100 #    newvar=`tolower "$oldvar"`
  101 #    echo "$newvar"    # 一串混合大小写的字符转换成了全部小写字符
  102 #
  103 # 练习: 重写这个函数把传递的参数变为大写
  104 #       ... toupper()  [容易].
  105 }
* 在脚本中添加特殊种类的注释开头标识有助于条理清晰和可读性.
    1 ## 表示注意.
    2 rm -rf *.zzy   ##  "rm"命令的"-rf"组合选项非常的危险,
    3                ##+ 尤其是对通配符而言.
    4 
    5 #+ 表示继续上一行.
    6 #  这是第一行
    7 #+ 这是多行的注释,
    8 #+ 这里是最后一行.
    9 
   10 #* 表示标注.
   11 
   12 #o 表示列表项.
   13 
   14 #> 表示另一个观点.
   15 while [ "$var1" != "end" ]    #> while test "$var1" != "end" 
* if-test 结构的一种聪明用法是用来注释一块代码块.
    1 #!/bin/bash
    2 
    3 COMMENT_BLOCK=
    4 #  给上面的变量设置某个值就会产生讨厌的结果
    5 #
    6 
    7 if [ $COMMENT_BLOCK ]; then
    8 
    9 Comment block --
   10 =================================
   11 This is a comment line.
   12 This is another comment line.
   13 This is yet another comment line.
   14 =================================
   15 
   16 echo "This will not echo."
   17 
   18 Comment blocks are error-free! Whee!
   19 
   20 fi
   21 
   22 echo "No more comments, please."
   23 
   24 exit 0
 把这种方法和使用here documents来注释代码块作一个比较.
* 测试$? 退出状态变量, 因为一个脚本可能想要测试一个参数是否只包含数字,以便后面
 可以把它当作一个整数.
    1 #!/bin/bash
    2 
    3 SUCCESS=0
    4 E_BADINPUT=65
    5 
    6 test "$1" -ne 0 -o "$1" -eq 0 2>/dev/null
    7 # 整数要么等于零要么不等于零.
    8 # 2>/dev/null 可以抑制错误信息.
    9 
   10 if [ $? -ne "$SUCCESS" ]
   11 then
   12   echo "Usage: `basename $0` integer-input"
   13   exit $E_BADINPUT
   14 fi
   15 
   16 let "sum = $1 + 25"             # 如果$1不是整数就会产生错误.
   17 echo "Sum = $sum"
   18 
   19 # 任何变量,而不仅仅命令行参数可用这种方法来测试.
   20 
   21 exit 0 
* 0 - 255 范围的函数返回值是个严格的限制. 用全局变量和其他方法常常出问题. 函数内
 返回值给脚本主体的另一个办法是让函数写值到标准输出(通常是用echo) 作为"返回值", 
 并且将其赋给一个变量. 这实际是命令替换(command substitution)的变体. 
Example 33-15 返回值技巧
################################Start Script#######################################
 1 #!/bin/bash
 2 # multiplication.sh
 3 
 4 multiply ()                     # 传递乘数.
 5 {                               # 能接受多个参数.
 6 
 7   local product=1
 8 
 9   until [ -z "$1" ]             # 直到所有参数都处理完毕...
10   do
11     let "product *= $1"
12     shift
13   done
14 
15   echo $product                 #  不会打印到标准输出,
16 }                               #+ 因为要把它赋给一个变量.
17 
18 mult1=15383; mult2=25211
19 val1=`multiply $mult1 $mult2`
20 echo "$mult1 X $mult2 = $val1"
21                                 # 387820813
22 
23 mult1=25; mult2=5; mult3=20
24 val2=`multiply $mult1 $mult2 $mult3`
25 echo "$mult1 X $mult2 X $mult3 = $val2"
26                                 # 2500
27 
28 mult1=188; mult2=37; mult3=25; mult4=47
29 val3=`multiply $mult1 $mult2 $mult3 $mult4`
30 echo "$mult1 X $mult2 X $mult3 X $mult4 = $val3"
31                                 # 8173300
32 
33 exit 0
################################End Script#########################################
 相同的技术也可用在字符串中. 这意味着函数可以"返回"一个非数字的值. 
    1 capitalize_ichar ()          #  把传递来的参数字符串的第一个字母大写
    2 {                            #
    3 
    4   string0="$@"               # 能接受多个参数.
    5 
    6   firstchar=${string0:0:1}   # 第一个字符.
    7   string1=${string0:1}       # 余下的字符.
    8 
    9   FirstChar=`echo "$firstchar" | tr a-z A-Z`
   10                              # 第一个字符转换成大写字符.
   11 
   12   echo "$FirstChar$string1"  # 打印到标准输出.
   13 
   14 }  
   15 
   16 newstring=`capitalize_ichar "every sentence should start with a capital letter."`
   17 echo "$newstring"          # Every sentence should start with a capital letter. 
 用这种办法甚至可能"返回" 多个值. 
Example 33-16 整型还是string?
################################Start Script#######################################
 1 #!/bin/bash
 2 # sum-product.sh
 3 # 函数可以"返回"多个值.
 4 
 5 sum_and_product ()   # 计算所传参数的总和与乘积.
 6 {
 7   echo $(( $1 + $2 )) $(( $1 * $2 ))
 8 # 打印每个计算的值到标准输出,各值用空格分隔开.
 9 }
10 
11 echo
12 echo "Enter first number "
13 read first
14 
15 echo
16 echo "Enter second number "
17 read second
18 echo
19 
20 retval=`sum_and_product $first $second`      # 把函数的输出赋值给变量.
21 sum=`echo "$retval" | awk '{print $1}'`      # 把第一个域的值赋给sum变量.
22 product=`echo "$retval" | awk '{print $2}'`  # 把第二个域的值赋给product变量.
23 
24 echo "$first + $second = $sum"
25 echo "$first * $second = $product"
26 echo
27 
28 exit 0
################################End Script######################################### 
* 下一个技巧是传递数组给函数的技术, 然后 "返回" 一个数组给脚本. 
 用 变量替换(command substitution)把数组的所有元素用空格分隔开来并赋给一个变量
 就可以实现给函数传递数组. 用先前介绍的方法函数内echo一个数组并"返回此值",然后
 调用命令替换用 ( ... ) 操作符赋值给一个数组. 
Example 33-17 传递和返回数组
################################Start Script#######################################
 1 #!/bin/bash
 2 # array-function.sh: 传递一个数组给函数并且...
 3 #                   从函数"返回"一个数组
 4 
 5 
 6 Pass_Array ()
 7 {
 8   local passed_array   # 局部变量.
 9   passed_array=( `echo "$1"` )
10   echo "${passed_array[@]}"
11   #  列出新数组中的所有元素
12   #+ 新数组是在函数内声明和赋值的.
13 }
14 
15 
16 original_array=( element1 element2 element3 element4 element5 )
17 
18 echo
19 echo "original_array = ${original_array[@]}"
20 #                      列出最初的数组元素.
21 
22 
23 # 下面是传递数组给函数的技巧.
24 # **********************************
25 argument=`echo ${original_array[@]}`
26 # **********************************
27 #  把原数组的所有元素用空格分隔开合成一个字符串并赋给一个变量
28 #
29 #
30 # 注意：只是把数组本身传给函数是不会工作的.
31 
32 
33 # 下面是允许数组作为"返回值"的技巧.
34 # *****************************************
35 returned_array=( `Pass_Array "$argument"` )
36 # *****************************************
37 # 把函数的输出赋给数组变量.
38 
39 echo "returned_array = ${returned_array[@]}"
40 
41 echo "============================================================="
42 
43 #  现在,再试一次Now, try it again,
44 #+ 尝试在函数外存取(列出)数组.
45 Pass_Array "$argument"
46 
47 # 函数本身可以列出数组,但...
48 #+ 函数外存取数组被禁止.
49 echo "Passed array (within function) = ${passed_array[@]}"
50 # 因为变量是函数内的局部变量,所以只有NULL值.
51 
52 echo
53 
54 exit 0
################################End Script#########################################
 在例子 A-10中有一个更精心制作的给函数传递数组的例子. 
* 利用双括号结构,使在for 和 while 循环中可以使用C风格的语法来设置和增加变量. 参
 考例子 10-12 和 例子 10-17. 
* 在脚本开头设置 path 和 umask 增加脚本的"可移植性" -- 在某些把 $PATH 和 umask 
 弄乱的系统里也可以运行. 
    1 #!/bin/bash
    2 PATH=/bin:/usr/bin:/usr/local/bin ; export PATH
    3 umask 022   # 脚本的创建的文件有 755 的权限设置.
    4 
    5 # 多谢Ian D. Allen提出这个技巧. 
* 一个有用的脚本技术是：重复地把一个过滤器的输出回馈(用管道)给另一个相同过滤器,
 但过滤器有不同的参数和/或选项. 尤其对 tr 和 grep 更合适. 
    1 # 取自例子"wstrings.sh".
    2 
    3 wlist=`strings "$1" | tr A-Z a-z | tr '[:space:]' Z | \
    4 tr -cs '[:alpha:]' Z | tr -s '\173-\377' Z | tr Z ' '` 
Example 33-18 anagrams游戏
################################Start Script#######################################
 1 #!/bin/bash
 2 # agram.sh: 用anagrams玩游戏.
 3 
 4 # 寻找 anagrams ...
 5 LETTERSET=etaoinshrdlu
 6 FILTER='.......'       # 最小有多少个字母?
 7 #       1234567
 8 
 9 anagram "$LETTERSET" | # 找出这串字符中所有的 anagrams ...
10 grep "$FILTER" |       # 至少7个字符,
11 grep '^is' |           # 以'is'开头
12 grep -v 's$' |         # 不是复数的(指英文单词复数)
13 grep -v 'ed$'          # 不是过去式的(当然也是英文单词)
14 # 可以加许多组合条件和过滤器.
15 
16 #  使用 "anagram" 软件
17 #+ 它是作者 "yawl" 单词列表软件包的一部分.
18 #  http://ibiblio.org/pub/Linux/libs/yawl-0.3.2.tar.gz
19 #  http://personal.riverusers.com/~thegrendel/yawl-0.3.2.tar.gz
20 
21 exit 0                 # 代码结束.
22 
23 
24 bash$ sh agram.sh
25 islander
26 isolate
27 isolead
28 isotheral
29 
30 
31 
32 #  练习:
33 #  ---------
34 #  修改这个脚本使 LETTERSET 能作为命令行参数来接受.
35 #  能够传递参数给第 11 - 13 行的过滤器(就像 $FILTER),
36 #+ 以便能靠传递参数来指定一种功能.
37 
38 #  参考agram2.sh了解些微不同的anagram的一种方法
39 #
################################End Script#########################################
 See also Example 27-3, Example 12-22, and Example A-9. 
* 使用"匿名的 here documents" 来注释代码块,这样避免了对代码块的每一块单独用#来
 注释了. 参考例子 17-11. 
* 当依赖某个命令脚本在一台没有安装该命令的机器上运行时会出错. 使用 whatis 命令可
 以避免此问题. 
    1 CMD=command1                 # 第一选择First choice.
    2 PlanB=command2               # 第二选择Fallback option.
    3 
    4 command_test=$(whatis "$CMD" | grep 'nothing appropriate')
    5 #  如果'command1'没有在系统里发现 , 'whatis'会返回:
    6 #+ "command1: nothing appropriate."
    7 #
    8 #  另一种更安全的办法是:
    9 #     command_test=$(whereis "$CMD" | grep \/)
   10 #  但后面的测试判断应该翻转过来,
   11 #+ 因为$command_test只有当系统存在$CMD命令时才有内容.
   12 #
   13 #     (Thanks, bojster.)
   14 
   15 
   16 if [[ -z "$command_test" ]]  # 检查命令是否存在.
   17 then
   18   $CMD option1 option2       #  调用command1.
   19 else                         #  否则,
   20   $PlanB                     #+ 调用command2. 
   21 fi 
* 在发生错误的情况下 if-grep test 可能不会返回期望的结果,因为文本是打印在标准出
 错而不是标准输出上. 
    1 if ls -l nonexistent_filename | grep -q 'No such file or directory'
    2   then echo "File \"nonexistent_filename\" does not exist."
    3 fi 
 把标准出错重定向到标准输出上可以修改这个. 
    1 if ls -l nonexistent_filename 2>&1 | grep -q 'No such file or directory'
    2 #                             ^^^^
    3   then echo "File \"nonexistent_filename\" does not exist."
    4 fi
    5 
    6 # 多谢Chris Martin指出. 
* The run-parts 命令很容易依次运行一组命令脚本,特别是和 cron 或 at 组合起来. 
* 在shell脚本里能调用 X-Windows 的窗口小部件将多么美好. 已经存在有几种工具包实现
 这个了, 它们称为Xscript, Xmenu, 和 widtools. 头两个已经不再维护. 幸运地是仍然
 可以从这儿下载widtools. 
 注意: widtools (widget tools) 工具包要求安装了 XForms 库. 另外, 它的 Makefile
   在典型的Linux系统上安装前需要做一些合适的编辑. 最后, 提供的6个部件有3个
   不能工作 (事实上会发生段错误). 
 dialog 工具集提供了shell脚本使用一种称为"对话框"的窗口部件. 原始的 dialog 软件
 包工作在文本模式的控制台下, 但它的后续软件 gdialog, Xdialog, 和 kdialog 使用基
 于X-Windows的窗口小部件集. 
Example 33-19 在shell脚本中调用的窗口部件
################################Start Script#######################################
 1 #!/bin/bash
 2 # dialog.sh: 使用 'gdialog' 窗口部件.
 3 # 必须在你的系统里安装'gdialog'才能运行此脚本.
 4 # 版本 1.1 (04/05/05 修正)
 5 
 6 # 这个脚本的灵感源自下面的文章.
 7 #     "Scripting for X Productivity," by Marco Fioretti,
 8 #      LINUX JOURNAL, Issue 113, September 2003, pp. 86-9.
 9 # Thank you, all you good people at LJ.
10 
11 
12 # 在窗口中的输入错误.
13 E_INPUT=65
14 # 输入窗口显示的尺寸.
15 HEIGHT=50
16 WIDTH=60
17 
18 # 输出文件名 (由脚本名构建而来).
19 OUTFILE=$0.output
20 
21 # 把这个脚本的内容显示在窗口中.
22 gdialog --title "Displaying: $0" --textbox $0 $HEIGHT $WIDTH
23 
24 
25 
26 # 现在,保存输入到输出文件中.
27 echo -n "VARIABLE=" > $OUTFILE
28 gdialog --title "User Input" --inputbox "Enter variable, please:" \
29 $HEIGHT $WIDTH 2>> $OUTFILE
30 
31 
32 if [ "$?" -eq 0 ]
33 # 检查退出状态是一个好习惯.
34 then
35   echo "Executed \"dialog box\" without errors."
36 else
37   echo "Error(s) in \"dialog box\" execution."
38         # 或者, 点击"Cancel", 而不是"OK" 按钮.
39   rm $OUTFILE
40   exit $E_INPUT
41 fi
42 
43 
44 
45 # 现在,我们重新取得并显示保存的变量.
46 . $OUTFILE   # 'Source' 保存的文件(即执行).
47 echo "The variable input in the \"input box\" was: "$VARIABLE""
48 
49 
50 rm $OUTFILE  # 清除临时文件.
51              # 有些应用可能需要保留这些文件.
52 
53 exit $?
################################End Script#########################################
 其他的在脚本中使用窗口的工具还有 Tk 或 wish (Tcl 派生物), PerlTk (Perl 的 Tk 
 扩展), tksh (ksh 的 Tk 扩展), XForms4Perl (Perl 的 XForms 扩展), Gtk-Perl 
 (Perl 的 Gtk 扩展), 或 PyQt (Python 的 Qt 扩展). 
* 为了对复杂的脚本做多次的版本修订管理, 可以使用 rcs 软件包. 
 使用这个软件包的好处之一是会自动地升级ID头标识.在 rcs 的co命令处理一些预定义的
 关键字参数替换,例如,代替脚本里头#$Id$的,如类似下面的行: 
    1 #$Id: hello-world.sh,v 1.1 2004/10/16 02:43:05 bozo Exp $ 
33.8. 安全话题
-------------- 
33.8.1. 被感染的脚本
--------------------
有一个简短的关于脚本安全的介绍是适当的. 脚本程序可能会包含蠕虫病毒,特洛伊木马, 或
是其他的病毒. 由于这些原因, 决不要以root身份运行脚本 (或允许它被插入到系统的
/etc/rc.d里的启动脚本中) 除非你确定这是值得信赖的源码或你已经很小心地分析过了脚本
并确信它不会有什么危害. 
Bell实验室及其他地方的病毒研究人员, 包括 M. Douglas McIlroy, Tom Duff, 和 
Fred Cohen 已经调查过了shell脚本病毒的实现. 他们认为写脚本病毒甚至对于新手来说也是
很容易的,就像“脚本小子(script kiddie)”也能容易地写出. [1] 
这也是学习脚本编程的原因之一：学习读懂脚本和理解脚本可以保护你的系统免受骇客攻击或
破坏. 
33.8.2. 隐藏Shell脚本源码
-------------------------
为了安全, 使脚本不可读是有必要的. 如果有软件可以把脚本转化成相应的二进制执行文件就
好了. Francisco Rosales的 shc - 通用的Shell脚本编译器(generic shell script 
compiler) 可以出色地完成目标. 
不幸地, 依照发表在2005年十月的Linux Journal杂志上的一篇文章, 二进制文件可以,至少
在某些情况下能被恢复回脚本的原始代码. 但不管怎么说,这对大多数技术不高超的骇客来说
仍然是一个保持脚本安全的有效的方法. 
注意事项:
[1]  参考 Marius van Oers 的文章(Unix Shell Scripting Malware),和列在参考书目
  (bibliography)的参考资料. 
33.9. 移植话题
--------------
这本书是关于在GNU/Linux系统下的Bash编程. 但同样,sh  和 ksh 用户也能在这儿得到许多
有用的价值. 
以现在的情况来看,许多种shell和脚本语言都尽力使自己符合 POSIX 1003.2 标准. 用 
--posix 选项调用Bash或在脚本开头插入 set -o posix 就能使Bash能以很接近这个标准的方
式运行. 在脚本开头用 
   1 #!/bin/sh 
比用 
   1 #!/bin/bash 
会更好.注意在Linux和一些UNIX风格的系统里/bin/sh是/bin/bash的一个链接(link), 并且
如果脚本以/bin/sh调用时会禁用Bash的扩展功能. 
大多数的Bash脚本能不作修改就能运行在 ksh下, 反之亦然, 因为 Chet Ramey 辛勤地把 ksh 
的属性移植到了最新的Bash版本. 
在商业的 UNIX 机器上, 使用了GNU扩展属性的标准命令的脚本可能不会工作. 这个问题在最
近几年已经有所改观了, 因为GNU软件包完美地代替了在这些"大块头的"UNIX运行的相应工具. 
源码分发 给传统UNIX上加快了这种趋势. 
Bash 有传统的 Bourne shell 缺乏的一些属性. 下面是其中一些: 
* 一些扩展的 调用选项(invocation options)
* 使用 $( ) 结构来完成命令替换(Command substitution)
* 一些 字符串处理(string manipulation)  操作符
* 进程替换(Process substitution)
* Bash的 内建(builtins) 命令 
参考 Bash F.A.Q. 查看完整的列表. 
33.10. 在Windows下进行Shell编程
-------------------------------
使用其他操作系统用户希望能运行UNIX类型的脚本能在他们的系统上运行, 因此也希望能在这
本书里能学到这方面的知识. 来自Cygnus的 Cygwin 软件结合来自Mortice Kern的MKS软件包
(MKS utilities)可以给Windows添加shell脚本的兼容. 
已经有正式宣布Windows的将来版本会包含Bash风格的命令行和脚本能力,但目前为止还没有
结果. 
第34章 Bash, 版本 2 和 3
========================= 
34.1. Bash, 版本2
-----------------
当前运行在你的机器里的Bash版本号是版本 2.xx.y 或 3.xx.y. 
 bash$ echo $BASH_VERSION
 2.05.b.0(1)-release 
经典的Bash版本2编程语言升级版增加了数组变量, [1] 字符串和参数扩展, 和间接变量引用
的更好的方法,及其他的属性. 
Example 34-1 字符串扩展
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # 字符串扩展.
 4 # Bash版本2引入的特性.
 5 
 6 #  具有$'xxx'格式的字符串
 7 #+ 将会解释里面的标准的转义字符. 
 8 
 9 echo $'Ringing bell 3 times \a \a \a'
10      # 可能在一些终端只能响铃一次.
11 echo $'Three form feeds \f \f \f'
12 echo $'10 newlines \n\n\n\n\n\n\n\n\n\n'
13 echo $'\102\141\163\150'   # Bash
14                            # 八进制相等的字符.
15 
16 exit 0
################################End Script######################################### 
Example 34-2 间接变量引用 - 新方法
################################Start Script#######################################
 1 #!/bin/bash
 2 
 3 # 间接变量引用.
 4 # 这有点像C++的引用属性.
 5 
 6 
 7 a=letter_of_alphabet
 8 letter_of_alphabet=z
 9 
10 echo "a = $a"           # 直接引用.
11 
12 echo "Now a = ${!a}"    # 间接引用.
13 # ${!variable} 形式比老的"eval var1=\$$var2"更高级
14 
15 echo
16 
17 t=table_cell_3
18 table_cell_3=24
19 echo "t = ${!t}"                      # t = 24
20 table_cell_3=387
21 echo "Value of t changed to ${!t}"    # 387
22 
23 #  这在用来引用数组或表格的成员时非常有用,
24 #+ 或用来模拟多维数组.
25 #  如果有可索引的选项 (类似于指针运算)
26 #+ 会更好. 唉.
27 
28 exit 0
################################End Script######################################### 
Example 34-3 使用间接变量引用的简单数据库应用
################################Start Script#######################################
 1 #!/bin/bash
 2 # resistor-inventory.sh
 3 # 使用间接变量引用的简单数据库应用.
 4 
 5 # ============================================================== #
 6 # 数据
 7 
 8 B1723_value=470                                   # 值
 9 B1723_powerdissip=.25                             # 是什么
10 B1723_colorcode="yellow-violet-brown"             # 色彩带宽
11 B1723_loc=173                                     # 它们存在哪儿
12 B1723_inventory=78                                # 有多少
13 
14 B1724_value=1000
15 B1724_powerdissip=.25
16 B1724_colorcode="brown-black-red"
17 B1724_loc=24N
18 B1724_inventory=243
19 
20 B1725_value=10000
21 B1725_powerdissip=.25
22 B1725_colorcode="brown-black-orange"
23 B1725_loc=24N
24 B1725_inventory=89
25 
26 # ============================================================== #
27 
28 
29 echo
30 
31 PS3='Enter catalog number: '
32 
33 echo
34 
35 select catalog_number in "B1723" "B1724" "B1725"
36 do
37   Inv=${catalog_number}_inventory
38   Val=${catalog_number}_value
39   Pdissip=${catalog_number}_powerdissip
40   Loc=${catalog_number}_loc
41   Ccode=${catalog_number}_colorcode
42 
43   echo
44   echo "Catalog number $catalog_number:"
45   echo "There are ${!Inv} of [${!Val} ohm / ${!Pdissip} watt] resistors in stock."
46   echo "These are located in bin # ${!Loc}."
47   echo "Their color code is \"${!Ccode}\"."
48 
49   break
50 done
51 
52 echo; echo
53 
54 # 练习:
55 # ---------
56 # 1) 重写脚本,使其从外部文件里读数据.
57 # 2) 重写脚本,用数组代替间接变量引用
58 #
59 #    用数组会更简单明了
60 
61 
62 # 注:
63 # -----
64 #  Shell脚本除了最简单的数据应用,其实并不合适数据库应用,
65 #+ 它过多地依赖实际工作的环境和命令.
66 #  写数据库应用更好的还是用一门自然支持数据结构的语言,
67 #+ 如 C++ 或 Java (或甚至是 Perl).
68 
69 exit 0
################################End Script######################################### 
Example 34-4 用数组和其他的小技巧来处理四人随机打牌
################################Start Script#######################################
  1 #!/bin/bash
  2 
  3 # Cards:
  4 # 处理四人打牌.
  5 
  6 UNPICKED=0
  7 PICKED=1
  8 
  9 DUPE_CARD=99
 10 
 11 LOWER_LIMIT=0
 12 UPPER_LIMIT=51
 13 CARDS_IN_SUIT=13
 14 CARDS=52
 15 
 16 declare -a Deck
 17 declare -a Suits
 18 declare -a Cards
 19 #  用一个三维数据来描述数据会更容易实现也更明了一些.
 20 #
 21 #  可能Bash将来的版本会支持多维数组.
 22 
 23 
 24 initialize_Deck ()
 25 {
 26 i=$LOWER_LIMIT
 27 until [ "$i" -gt $UPPER_LIMIT ]
 28 do
 29   Deck[i]=$UNPICKED   # 把整副牌的每张牌都设为没人持牌.
 30   let "i += 1"
 31 done
 32 echo
 33 }
 34 
 35 initialize_Suits ()
 36 {
 37 Suits[0]=C #梅花
 38 Suits[1]=D #方块
 39 Suits[2]=H #红心
 40 Suits[3]=S #黑桃
 41 }
 42 
 43 initialize_Cards ()
 44 {
 45 Cards=(2 3 4 5 6 7 8 9 10 J Q K A)
 46 # 另一种初始化数组的方法.
 47 }
 48 
 49 pick_a_card ()
 50 {
 51 card_number=$RANDOM
 52 let "card_number %= $CARDS"
 53 if [ "${Deck[card_number]}" -eq $UNPICKED ]
 54 then
 55   Deck[card_number]=$PICKED
 56   return $card_number
 57 else  
 58   return $DUPE_CARD
 59 fi
 60 }
 61 
 62 parse_card ()
 63 {
 64 number=$1
 65 let "suit_number = number / CARDS_IN_SUIT"
 66 suit=${Suits[suit_number]}
 67 echo -n "$suit-"
 68 let "card_no = number % CARDS_IN_SUIT"
 69 Card=${Cards[card_no]}
 70 printf %-4s $Card
 71 # 优雅地打印各张牌.
 72 }
 73 
 74 seed_random ()  # 随机产生牌上数值的种子.
 75 {               # 如果你没有这么做会有什么发生?
 76 seed=`eval date +%s`
 77 let "seed %= 32766"
 78 RANDOM=$seed
 79 #  其他的产生随机用的种子的方法还有什么W?
 80 #
 81 }
 82 
 83 deal_cards ()
 84 {
 85 echo
 86 
 87 cards_picked=0
 88 while [ "$cards_picked" -le $UPPER_LIMIT ]
 89 do
 90   pick_a_card
 91   t=$?
 92 
 93   if [ "$t" -ne $DUPE_CARD ]
 94   then
 95     parse_card $t
 96 
 97     u=$cards_picked+1
 98     # 改回1步进的索引(临时的). 为什么?
 99     let "u %= $CARDS_IN_SUIT"
100     if [ "$u" -eq 0 ]   # 内嵌的 if/then 条件测试.
101     then
102      echo
103      echo
104     fi
105     # Separate hands.
106 
107     let "cards_picked += 1"
108   fi  
109 done  
110 
111 echo
112 
113 return 0
114 }
115 
116 
117 # 结构化编程:
118 # 整个程序逻辑模块化.
119 
120 #================
121 seed_random
122 initialize_Deck
123 initialize_Suits
124 initialize_Cards
125 deal_cards
126 #================
127 
128 exit 0
129 
130 
131 
132 # 练习 1:
133 # 把这个脚本完整地做注释.
134 
135 # 练习 2:
136 # 增加一个处理例程 (函数) 来以花色排序打印出每个人手中的牌.
137 # 如果你高兴,可增加你喜欢的各种酷的代码.
138 
139 # 练习 3:
140 # 简化和理顺脚本的逻辑.
################################End Script######################################### 
注意事项:
[1]  Chet Ramey 承诺会在Bash的未来版本中实现关联数组(associative arrays) 
  (一个Perl特性). 到了版本3,这个特性还没有实现. 
34.2. Bash版本3
---------------
在2004年7月27日, Chet Ramey 发布了Bash的第三版本. 它修复了许多bug并加入了一些新的
属性. 
增加的一些属性有: 
* 新的,更特别的不可移植的 {a..z} 花括号扩展(brace expansion) 操作符. 
    1 #!/bin/bash
    2 
    3 for i in {1..10}
    4 #  比下面的更简单并且更易于理解
    5 #+ for i in $(seq 10)
    6 do
    7   echo -n "$i "
    8 done
    9 
   10 echo
   11 
   12 # 1 2 3 4 5 6 7 8 9 10 
* ${!array[@]} 操作符, 它扩展给定的数组(array)的所有元素下标. 
    1 #!/bin/bash
    2 
    3 Array=(element-zero element-one element-two element-three)
    4 
    5 echo ${Array[0]}   # 元素0
    6                    # 数组的第一个元素.
    7 
    8 echo ${!Array[@]}  # 0 1 2 3
    9                    # 数组所有的下标.
   10 
   11 for i in ${!Array[@]}
   12 do
   13   echo ${Array[i]} # element-zero
   14                    # element-one
   15                    # element-two
   16                    # element-three
   17                    #
   18                    # 在数组里的所有元素.
   19 done 
* =~ 正则表达式(Regular Expression) 匹配操作符在双方括号(double brackets)
 测试表达式中使用. (Perl也有一个相似的操作符.) 
    1 #!/bin/bash
    2 
    3 variable="This is a fine mess."
    4 
    5 echo "$variable"
    6 
    7 if [[ "$variable" =~ "T*fin*es*" ]]
    8 # 在双方括号([[]])里用=~操作符进行正则匹配.
    9 then
   10   echo "match found"
   11       # match found
   12 fi 
 或, 更有用的用法: 
    1 #!/bin/bash
    2 
    3 input=$1
    4 
    5 
    6 if [[ "$input" =~ "[1-9][0-9][0-9]-[0-9][0-9]-[0-9][0-9][0-9][0-9]" ]]
    7 # NNN-NN-NNNN
    8 # 每个N是一个数字.
    9 # 但, 开头的第一个数字不能是 0.
   10 then
   11   echo "Social Security number."
   12   # 处理 SSN.
   13 else
   14   echo "Not a Social Security number!"
   15   # 或者, 要求正确的输入.
   16 fi 
 还有一个使用 =~ 操作符的例子, 参考例子 A-28. 
注意: 升级到Bash版本3使原来在早先版本可以工作的少部分脚本不能工作了. 要重新测试
  原来的脚本看是否它们仍然可以工作! 
  确实发生不能工作的情况, 在 Advanced Bash Scripting Guide 里的部分脚本代码
  不得不修复 (例如,例子 A-20 和 例子 9-4). 
第35章 后记
============ 
35.1. 作者后记
-------------- 
          doce ut discas 
          (Teach, that you yourself may learn.) 
我怎么会写这本脚本编程的书?这有一个很奇怪的故事.时间回到前几年,那时我准备学习
shell脚本编程－－这最好的办法莫过于读一本这方面的好书了.我一直在找一本能覆盖这个
主题方方面面的指南参考书.我也在找一本能把难点说得清楚容易并能用实际的代码和代码注
释解释这些难以理解的细节. [1]  事实上,我在找一本非常满意的书, 或者是类似的东西.
不幸的是,这是不存在的.如果我想要一本,那我不得不自己写一本.于是,它就写出来了. 
这使我想起一个关于疯子教授的故事.下面的事像笨蛋那样荒谬.当这本书上架之前,对于所
有的在图书馆的书使他有了想写一本书的主意.他就这样做了,开始了这项好处多多的工作.
他争分夺秒地开始完成和现在这本书标题很像的书,他每天都很快地奔跑回家来做这件事.当
几年之后他死掉了,他有了写几千本书保存下来,可能会被和其他的破书一块放在书架上.可
能他写的书不是那么的好,但这有什么关系呢?这是一个活在幻想里的一个朋友.即使他没有
被幻想给迷惑驱使...但我忍不住地钦佩这个老笨蛋. 
注意事项:
[1]  这是声名狼藉使人郁闷到死的技术. 
35.2. 关于作者
--------------
这家伙到底是谁? 
作者没有外交特权,不是被强迫写作的. [1] 这本书有点违背他的其他的主要工作, 
HOW-2 Meet Women: The Shy Man's Guide to Relationships. 他另外也写了 
Software-Building HOWTO. 近来, 他尝试写一些虚构的短篇小说. 
自1995年成为一个Linux用户以来(Slackware 2.2, kernel 1.2.1), 作者已经发表了一些软件
包,包括 cruft 一次性加密软件包(one-time pad encryption utility), 软件 mcalc 可
用做计算器, 软件judge是Scrabble拼字游戏的自动求解包, 和软件包yawl 一起组成猜词表. 
他从一台CDC 3800上使用FORTRAN IV开始他的编程之旅, 但那种日子一点也不值得怀念. 
作者和他的妻子还有他们的狗隐居在一个偏远的地方,他幻想着人性是善良的. 
注意事项:
[1]   这些谁可以做,谁不可以做...拿到一个MCSE证书. 
35.3. 哪里可以取得帮助?
-----------------------
作者不是太忙(并且心情不错)的话,会回答一般性的脚本编程问题.但是,如果你的特定应
用的脚本不工作,建议你最好把问题发到 comp.os.unix.shell 新闻组去. 
35.4. 制作这本书的工具
---------------------- 
35.4.1 硬件
-----------
一个运行着Red Hat 7.1/7.3的IBM Thinkpad, model 760XL(P166, 104 meg RAM)的笔记本.
是的,它非常的缓慢并且还有一个更人胆战心惊的键盘,但它总比一根铅笔加一个巨大的写字
板好多了. 
升级： 升级到了运行着FC3的 770Z Thinkpad (P2-366, 192 meg RAM)笔记本.谁想捐赠一个
更新的一点笔记本给这个快饿死的作者 <g>? 
35.4.2 软件和排版软件
---------------------
   1.  Bram Moolenaar的功能强大的SGML软件 vim文本编辑器.
   2.  OpenJade, 一个把SGML文档转换为其他格式的DSSSL翻译引擎.
   3.  Norman Walsh的DSSSL排版框架.
   4.  由Norman Walsh和Leonard Muellner (O'Reilly, ISBN 1-56592-580-7)写的最权威的
  指南：DocBook. 它仍然是任何一个想写Docbook SGML格式的书的标准参考书. 
  
todo
====
12.22 第2部分翻译结束.阶段性总结.
12.02 本打算自己看,做做笔记就算了,如果要大家看,就不行了.补全前3章所有未译的地方.
01.06 所有的没翻译或翻译不对的地方标记<rojy bug>.
01.08 一些朋友提出想要,可惜没译完,最近效率比较低,手里还有些其它的活:(.
  丑媳妇总要见公婆,还是放了吧.
01.13 11章结束
01.14 12章开始, 翻译html版本.
01.19 开始12.4节.
02.16 开始12.6节.
03.23 12章终于结束了...
04.15 前3部分终于结束了, 历时4个多月:(, 后边的部分就交给
05.15 终于完成了, 没有黄毅兄的帮助, 真是不敢想象, 恐怕就要流产了
  接下来就要搞sgml版本的了, 唉... 到底走弯路了... 
[]     
    
awk基础入门(1)
文章整理: 文章来源: 网络 
Awk是一种非常好的语言，同时有一个非常奇怪的名称。在本系列文章中，DanielRobbins 将使您迅速掌握 awk编程技巧。随着本系列的进展，将讨论更高级的主题，最后将演示一个真正的高级awk 演示程序。 
捍卫 awk
   在本系列文章中，我将使您成为精通 awk 的编码人员。我承认，awk 并没有一个非常好听且又非常“时髦”的名字。awk 的 GNU 版本（叫作 gawk）听起来非常怪异。那些不熟悉这种语言的人可能听说过 "awk"，并可能认为它是一组落伍且过时的混乱代码。它甚至会使最博学的 UNIX 权威陷于错乱的边缘（使他不断地发出 "kill -9!" 命令，就象使用咖啡机一样）。
    的确，awk 没有一个动听的名字。但它是一种很棒的语言。awk 适合于文本处理和报表生成，它还有许多精心设计的特性，允许进行需要特殊技巧程序设计。与某些语言不同，awk 的语法较为常见。它借鉴了某些语言的一些精华部分，如 C 语言、python 和 bash（虽然在技术上，awk 比 python 和 bash 早创建）。awk 是那种一旦学会了就会成为您战略编码库的主要部分的语言。
第一个 awk
让我们继续，开始使用 awk，以了解其工作原理。在命令行中输入以下命令： 
$ awk '{ print }' /etc/passwd
[]     
    
awk基础入门(2)
文章整理: 文章来源: 网络 
如您所见，awk 打印出 /etc/passwd 文件的第一和第三个字段，它们正好分别是用户名和用户标识字段。现在，当脚本运行时，它并不理想 -- 在两个输出字段之间没有空格！如果习惯于使用 bash 或 python 进行编程，那么您会指望 print $1 $3 命令在两个字段之间插入空格。然而，当两个字符串在 awk 程序中彼此相邻时，awk 会连接它们但不在它们之间添加空格。以下命令会在这两个字段中插入空格： 
$ awk -F":" '{ print $1 " " $3 }' /etc/passwd
[]     
    
awk基础入门(3)
文章整理: 文章来源: 网络 
条件语句
awk 还提供了非常好的类似于 C 语言的 if 语句。如果您愿意，可以使用 if 语句重写前一个脚本： 
{     if ( $5 ~ /root/ ) {         print $3     }}
[]     
    
awk基础入门(4)
文章整理: 文章来源: 网络 
字符串化变量
    awk 的优点之一就是“简单和字符串化”。我认为 awk 变量“字符串化”是因为所有 awk 变量在内部都是按字符串形式存储的。同时，awk 变量是“简单的”，因为可以对它执行数学操作，且只要变量包含有效数字字符串，awk 会自动处理字符串到数字的转换步骤。要理解我的观点，请研究以下这个示例： 
x="1.01"# We just set x to contain the *string* "1.01"x=x+1# We just added one to a *string* print x# Incidentally, these are comments :)
[]     
    
awk基础入门(5)
文章整理: 文章来源: 网络 
记录号
    记录号 (NR) 是另一个方便的变量。它始终包含当前记录的编号（awk 将第一个记录算作记录号 1）。迄今为止，我们已经处理了每一行包含一个记录的输入文件。对于这些情况，NR 还会告诉您当前行号。然而，当我们在本系列以后部分中开始处理多行记录时，就不会再有这种情况，所以要注意！可以象使用 NF 变量一样使用 NR 来只打印某些输入行： 
(NR < 10 ) || (NR > 100) { print "We are on record number 1-9 or 101+" }
[]     
    
Unix系列shell程序编写(上)
文章整理: 文章来源: 网络 
作者：htldm  出处：Unix爱好者家园unix-cd.com   
*Shell是什么? 
　　任何发明都具有供用户使用的界面。UNIX供用户使用的界面就是Shell(DOS的command熟悉吧，但UNIX的要强大的多)。 Shell为用户提供了输入命令和参数并可得到命令执行结果的环境。 
　　为了不同的需要，UNIX提供了不同的Shell。现在的UNIX大部分都支持BourneShell，以下教程就以BourneShell(Bsh)为例，一步步的领略UNIX Shell的强大功能，占先其强大魅力，达到更方便灵活的管理、应用UNIX的目的。 
　　1.UNIX内核和Shell的交互方法 
　　启动UNIX时，程序UNIX(内核)将被调入计算机内存，并一直保留在内存中直到机器关闭。在引导过程中，程序 init将进入后台运行一直到机器关闭。该程序查询文件/etc/inittab，该文件列出了连接终端的各个端口及其特征。当发现一个活动的终端时，init程序调用getty程序在终端上显示login等登陆信息。(username和passwd)，在输入密码后， getty调用login进程，该进程根据文件/etc/passwd的内容来验证用户的身份。若用户通过身份验证，login进程 把用户的home目录设置成当前目录并把控制交给一系列setup程序。setup程序可以是指定的应用程序，通常setup程序 为一个Shell程序，如:/bin/sh 即Bourne Shell（command出来了，呵呵）。 
　　得到控制后，Shell程序读取并执行文件/etc/.profile以及.profile。这两个文件分别建立了系统范围内的和 该用户自己的工作环境。最后Shell显示命令提示符，如$。(这是以bsh为例，若是csh,为.cshrc,ksh为.kshrc,bash为.bashrc等等) 　　　 
　　注:(不妨把/etc/.profile和.profile看成DOS的autoexec.bat 或 config.sys文件) 
　　当shell退出时，内核把控制交给init程序,该程序重新启动自动登陆过程。有两种方法使shell退出，一是用户执行exit命令，二是 内核(例如root用kill命令)发出一个kill命令结束shell进程。shell退出后，内核回收用户及程序使用的资源。 
　　用户登陆后，用户命令同计算机交互的关系为:命令进程--->Shell程序--->UNIX内核--->计算机硬件。当用户输入一个命令，如$ls, Shell将定位其可执行文件/bin/ls并把其传递给内核执行。内核产生一个新的子进程调用并执行/bin/ls。当程序执行完毕后，内核取消 该子进程并把控制交给其父进程，即Shell程序。例如执行: 
　　　　$ps 
　　　　该命令将会列出用户正在执行的进程，即Shell程序(下来详细说说，别急现在)和ps程序。若执行: 
　　　　$sleep 10 & 
　　　　$ps 
　　其中第一条命令将产生一个在后台执行的sleep子进程。ps命令执行时会显示出该子进程。 
　　每当用户执行一条命令时，就会产生一个子进程。该子进程的执行与其父进程或Shell完全无关，这样可以使Shell去做其他工作。(Shell只是把用户的意图告诉内核，然后该干嘛干嘛:)) 现在windows有个计划任务(在固定的时间，日期自动执行某任务),其实UNIX很早就有这个功能了，也就是所谓的Shell的自动执行。一些UNIX 资源，如cron可以自动执行Shell程序而无需用户的参与，(这个功能好象在/var/spool/crotab目录里)。 
Crontab 程序对于系统管理员来说是非常有用的。Cron 服务用于计划程序在特定时间（月、日、周、时、分）运行。我们以root的crontab 为例。根用户的 crontab 文件放在 /var/spool/crontab/root 中，其格式如下： 
　　(1) 　(2) 　(3) 　(4) 　(5)　 (6) 
　　 0　　 0 　　*　　 * 　　3　　 /usr/bin/updatedb 
　　　　　　1. 分钟 (0-60) 
　　　　　　2. 小时 (0-23) 
　　　　　　3. 日 (1-31) 
　　　　　　4. 月 (1-12) 
　　　　　　5. 星期 (1-7) 
　　　　　　6. 所要运行的程序 
　　2.Shell的功能和特点 
　　1>命令行解释 
　　2>使用保留字 
　　3>使用Shell元字符(通配符) 
　　4>可处理程序命令 
　　5>使用输入输出重定向和管道 
　　6>维护一些变量 
　　7>运行环境控制 
　　8>支持Shell编程 
　　对于"命令行解释"就不多说了，就是在shell提示符(例如:"$","%","#"等)后输入一行unix命令，Shell将接收用户的输入。 
　　"使用保留字":Shell有一些具有特殊意义的字，例如在Shell脚本中，do,done,for等字用来控制循环操作，if,then等控制条件操作。 保留字随Shell环境的不同而不同。 
　　"通配符"：* 匹配任何位置 
　　　　　　　? 匹配单个字符 
　　　　　　　[] 匹配的字符范围或列表 例如: 
　　　　　　　 
　　　　　　　　　 $ls [a-c]* 
　　　　　　　　　 
　　　　　　　　　 将列出以a-c范围内字符开头的所有文件 
　　　　　　　　　 $ls [a,m,t]* 
　　　　　　　　　将列出以e,m或t开头的所有文件 
　　"程序命令" ：当用户输入命令后，Shell读取环境变量$path(一般在用户自己的.profile中设置)，该变量包含了命令可执行文件可能存在的目录列表。 shell从这些目录中寻找命令所对应的可执行文件，然后将该文件送给内核执行。 
　　"输入输出重定向及管道" ：重定向的功能同DOS的重定向功能： 
　　　　 ">" 重定向输出 
　　　　 "<" 重定向输入 
　　而管道符号，是unix功能强大的一个地方,符号是一条竖线:"|"，用法: command 1 | command 2 他的功能是把第一个命令command 1执行的结果作为command 2的输入传给command 2，例如: 
　　　　$ls -s|sort -nr|pg 
　　该命令列出当前目录中的所有文件，并把输出送给sort命令作为输入，sort命令按数字递减的顺序把ls的输出排序。然后把排序后的 内容传送给pg命令，pg命令在显示器上显示sort命令排序后的内容。 
　　"维护变量" ：Shell可以维护一些变量。变量中存放一些数据供以后使用。用户可以用"="给变量赋值，如: 
　　　　　　　　　$lookup=/usr/mydir 
该命令建立一个名为lookup的变量并给其赋值/usr/mydir,以后用户可以在命令行中使用lookup来代替/usr/mydir，例如: 　　　　　　　　　 
　　　　　　　　　$echo $lookup 
　　　　　　　　　结果显示:/usr/mydir 
　　　　　　　　　为了使变量能被子进程使用,可用exprot命令，例如: 
　　　　　　　　　$lookup=/usr/mydir 
　　　　　　　　　$export lookup 
　　"运行环境控制" ：当用户登陆启动shell后，shell要为用户创建一个工作的环境，如下: 
　　1>当login程序激活用户shell后，将为用户建立环境变量。从/etc/profile和.profile文件中读出，在这些文件中一般都用$TERM 变量设置终端类型，用$PATH变量设置Shell寻找可执行文件的路径。 
　　2>从/etc/passwd文件或命令行启动shell时，用户可以给shell程序指定一些参数，例如"-x"，可以在命令执行前显示该命令及其参数。后面详细介绍这些参数。 
　　"shell编程" ：本文主要介绍的内容。 
　　shell本身也是一种语言(*可以先理解为unix命令的组合，加上类C的条件，循环等程序控制语句,类似dos批处理，但要强大的多),用户可以 通过shell编程(脚本,文本文件)，完成特定的工作。 
SHELL变量 
　　下面我们详细的介绍Bourne Shell的编程: 
　　自从贝尔实验室设计了Bourne Shell。从那时起许多厂商根据不同的硬件平台设计了许多版本得unix。但在众多版本的unix中，Bourne Shell 一直保持一致。 
　　1>Bsh的启动：用户在登陆后，系统根据文件/etc/passwd中有关该用户的信息项启动Shell。例如某用户在passwd中 的信息项为: 
　　　　ice_walk:!:411:103:Imsnow ,ice_walk:/home/ice_walk:/bin/bsh 
　　则表明，用户名是ice_walk等信息，在最后一项"/bin/bsh"表明用户的sh环境类型是bsh,于是系统启动之。在启动或执行(包括下面我们要讲 的shell程序--脚本）过程中可以使用以下一些参数，我们一一说明: 
　　-a 将所有变量输出 
　　-c "string"从string中读取命令 
　　-e 使用非交互式模式 
　　-f 禁止shell文件名产生 
　　-h 定义 
　　-i 交互式模式 
　　-k 为命令的执行设置选项 
　　-n 读取命令但不执行 
　　-r 受限模式 
　　-s 命令从标准输入读取 
　　-t 执行一命令，然后退出shell 
　　-u 在替换时，使用未设置的变量将会出错 
　　-v 显示shell的输入行 
　　-x 跟踪模式，显示执行的命令 
许多模式可以组合起来用,您可以试试了，但-ei好象不行，你说why呢？ 
　　使用set可以设置或取消shell的选项来改变shell环境。打开选项用"-",关闭选项用"+",多数unix允许打开或关闭a、f、e、h、k、n、 u、v和x选项。若显示Shell中已经设置的选项，执行: 
　　　　$echo $- 
　　Bsh中每个用户的home目录下都有一个.profile文件，可以修改该文件来修改shell环境。为了增加一个可执行文件的路径(例如/ice_walk/bin)， 可以把下面代码加入.profile中 
　　　　PATH=$PATH:/ice_walk/bin;exprot PATH 
　　 .profile中shell的环境变量意思如下: 
　　　　CDPATH 执行cd命令时使用的搜索路径 
　　　　HOME 用户的home目录 
　　　　IFS 内部的域分割符，一般为空格符、制表符、或换行符 
　　　　MAIL 指定特定文件(信箱)的路径，有UNIX邮件系统使用 
　　　　PATH 寻找命令的搜索路径(同dos的config.sys的 path) 
　　　　PS1 主命令提示符，默认是"$" 
　　　　PS2 从命令提示符，默认是">" 
　　　　TERM 使用终端类型 
　　2>Bsh里特殊字符及其含义 
　　在Bsh中有一组非字母字符。这些字符的用途分为四类:作为特殊变量名、产生文件名、数据或程序控制以及引用和逃逸字符控制。他们 可以让用户在Shell中使用最少的代码完成复杂的任务。 
　　　　　*> Shell变量名使用的特殊字符 
　　　　　　　　$# 传送给命令Shell的参数序号 
　　　　　　　　$- 在Shell启动或使用set命令时提供选项 
　　　　　　　　$? 上一条命令执行后返回的值 
　　　　　　　　$$ 当前shell的进程号 
　　　　　　　　$! 上一个子进程的进程号 
　　　　　　　　$@ 所有的参数，每个都用双括号括起 
　　　　　　　　$* 所有参数，用双括号括起 
　　　　　　　　$n 位置参数值，n表示位置 
　　　　　　　　$0 当前shell名 
　　　　　*>产生文件名的特殊字符 
　　　　　　　　包括"*","?","[]"，上面讲过，不再多说。 
　　　　　*>数据或程序控制使用的特殊字符 
　　　　　　　　>(file) 输出重定向到文件中(没有文件则创建，有则覆盖) 
　　　　　　　　>>(file) 输出重定向到文件中(没有则创建，有则追加到文件尾部) 
　　　　　　　　<(file) 输入重定向到文件 
　　　　　　　　; 命令分割符 
　　　　　　　　| 管道符 
　　　　　　　　& 后台运行(例如:sleep 10 &) 
　　　　　　　　` ` 命令替换，重定向一条命令的输出作为另一命令的参数 
　　　　　*>对于引用或逃逸的特殊字符 
Bsh用单引号' '和双引号" "将特殊字符或由空白分隔的字引用起来组成一个简单的数据串.使用单引号和双引号的区别是双引号中的内容可进行参数和变量替换.逃逸字符也一样. 
　　　　　　　　$echo "$HOME $PATH" 
　　　　 　　　 结果显示$/u/ice_walk/bin:/etc:/usr/bin 
　　　　　　　　而$echo '$HOME $PATH' 结果显示$HOME $PATH 
　　shell的逃逸符是一个"\",表示其后的字符不具有特殊的含义或不是shell的函数 
　　　　　　　　$echo \$HOME $PATH 
　　　　　　　　结果显$$HOME /bin:/etc:/usr/bin: 
3>Bsh的变量 
　　前面我们在多个地方引用了变量,当Shell遇到一个"$"符时(没有被引用或逃逸)，它将认为其后为一变量。不论该变量是环境变量还是用户自定义的变量，在命令行中变量名要被变量值替换。例如命令:ls $HOME将列出变量HOME对应目录下的文件。 用户可以在命令行中的任何地方进行变量替换。包括命令名本身，例如： 
　　　　$dir=ls 
　　　　$$dir f* 
　　将列出以f开头的文件。 
　　现在详细的介绍下Bsh的变量。Bsh中有四类变量:用户定义的变量、位置变量(shell参数)、预定义变量及环境变量。 
　　用户定义的变量： 
　　用户定义的变量由字母和下划线组成，并且变量名的第一个字符不能为数字(0~9)。与其他UNIX名字一样，变量名是大小写敏感的。用户可以在命令行上用"="给变量赋值，例如: 
　　　　$NAME=ice_walk 
　　给变量NAME赋值为ice_walk,在应用变量NAME的时候，在NAME前加"$"即可，前面已说，不再废话(别说我废话多，关键是没当过老师:()。可以用变量和其他字符组成新的字，例如: 
　　　　$SUN=sun 
　　　　$echo ${SUN}day 
　　在应用shell变量时候，可以在变量名字两边$后面加上{}，以更加清楚的显示给shell,哪个是真正的变量，以实现字符串的合并等功能。 
　 
　　结果显示:sunday(注意不能echo $SUNday,因为SUNday变量没定义，读者试下执行结果) 用户也可以在命令行上同时对多个变量赋值，赋值语句之间用空格分开: 
　　　　$X=x Y=y 
　　　　注意变量赋值是从右到左进行的 
　　　　$X=$Y Y=y 
　　　　X的值是y 
　　　　$X=z Y=$Z 
　　　　Y的值是空(变量未赋值时，shell不报错，而是赋值为空) 
　　用户可以使用"unset <变量>"命令清除给变量赋的值 
用户使用变量时要在其前面加一"$"符，使变量名被变量值所替换。Bsh可以进行变量的条件替换，即只有某种条件发生时才进行替换。替换条件放在一对大括号{}中，如: 
　　　　${variable: -value} variable是一变量值，value是变量替换使用的默认值 
　　　　$echo Hello $UNAME 
　　　　结果显示:Hello 
　　　　$echo Hello ${UNAME: -there} 
　　　　结果显示:Hello there 
　　　　$echo $UNAME 
　　　　结果显示: (空) 
　　　　$UNAME=John 
　　　　$echo Hello ${UNAME: -there} 
　　　　结果显示:Hello John 
　　可以看出，变量替换时将使用命令行中定义的默认值，但变量的值并没有因此而改变。另外一种替换的方法是不但使用默认值进行替换，而且将默认值赋给该变量。其形式如下: 
　　　　${variable:=value} 
　　该形式在变量替换后同时把值value符给变量variable。 
　　　　$echo Hello $UNAME 
　　　　结果显示:Hello 
　　　　$echo Hello ${UNAME:=there} 
　　　　结果显示:Hello there 
　　　　$echo $UNAME 
　　　　结果显示:there 
　　　　$UNAME=John 
　　　　$echo Hello ${UNAME:-there} 
　　　　结果显示:Hello John 
　　变量替换的值也可以是` `括起来的命令: 
　　　　$USERDIR={$Mydir: -`pwd`} 
　　第三种变量的替换方法是只有当变量已赋值时才用指定值替换形式: 
　　　　${variable: +value} 
　　　　只有变量variable已赋值时，其值才用value替换，否则不进行任何替换，例如: 
　　　　$ERROPT=A 
　　　　$echo ${ERROPT: +"Error tracking is acitive"} 
　　　　结果显示:Error tracking is acitive 
　　　　$ERROPT= 
　　　　$echo ${ERROPT: +"Error tracking is acitive"} 
　　　　结果显示: (空) 
　　我们还可以使用错误检查的条件进行变量替换: 
　　　　${variable:?message} 
当变量variable已设置时，正常替换。否则消息message将送到标准错误输出(若此替换出现在shell程序中,那么该程序将终止)。　例如： 
　　　　$UNAME= 
　　　　$echo $ {UNAME:?"UNAME HAS NOT BEEN SET"} 
　　　　结果显示:UNAME HAS NOT BEEN SET 
　　　　$UNAME=Stephanie 
　　　　$echo $ {UNAME:?"UNAME HAS NOT BEEN SET"} 
　　　　结果显示:Stephanie 
　　　　当没有指定message时，shell将显示一条默认的消息，例如: 
　　　　$UNAME= 
　　　　$echo $ {UNAME:?} 
　　　　结果显示:sh:UNAME:parameter null or not set 
4>位置变量或Shell参数 
　　在shell解释用户的命令时，将把命令行的第一个字作为命令，而其他的字作为参数。当命令对应的可执行文件为Shell程序时，这些参数将作为位置变量传送给该程序。第一个参数记为$1,第二个为$2....第九个为$9。其中1到9是真正的参数名，"$"符只是用来标识变量的替换。 
　　位置变量$0指命令对应的可执行文件名。在后面将详细介绍位置变量。 
　　1.只读变量 
　　用户将变量赋值后，为了防止以后对该变量的修改，可以用以下命令将该变量设置为只读变量： 
　　　　readonly variable 
　　2.export命令 
　　shell执行一个程序时，首先为该程序建立一个新的执行环境，称为子shell。在Bourne Shell中变量都是局部的，即他们只在创建他们的Shell中有意义。用户可以用export命令让变量被其他子Shell识别。但某用户的变量是没法让其他用户使用的。 
　　当用户启动一个新shell时,该shell将使用默认的提示符。因为赋给变量PS1的值只在当前shell中有效。为了让子Shell使用当前Shell中定义的提示符号，可以使用export命令： 
　　　　$PS1="Enter command:" 
　　　　Enter command:export PS1 
　　　　Enter command:sh 
　　　　Enter command: 
　　　　此时变量PS1变成了全局变量。它可以被其子Shell使用。当变量被设置成全局的以后，将一直保持有效直到用户退出该变量所在的Shell。用户可以在文件.profile中给一个变量永久赋值。详见"规范Shell"。 
基本语句 
　　从本节起，我们将详细介绍Shell程序设计的基本知识，通过编写Shell脚本，用户可以根据自己的需要有条件的或者重复的执行命令。通过Shell程序，可以把单个的UNIX命令组合成一个完全实用的工具，完成用户的任务。 
　　1>什么是Shell程序 
　　当用户在UNIX Shell中输入了一条复杂的命令，如: 
　　　　$ls -R /|greo myname |pg 
　　我们可以称用户在对Shell编程，当把这条语句写在一个文件里，并且符给该文件可执行权限，那么该文件就是我们传统上说的Shell程序。 
　　2>简单的Shell程序 
　　假设用户每天使用下述命令备份自己的数据文件: 
　　　　$cd /usr/icewalk;ls * |cpio -o > /dev/fd0 
　　我们可以把它写在一个文件，如:ba.sh中: 
　　　　$cat >ba.sh 
　　　　cd /usr/icewalk 
　　　　ls * |cpio -o > /dev/fd0 
　　　　^D 　(ctrl_d) 
　　程序ba.sh就是Shell脚本，用户可以用vi或其他编辑工具编写更复杂的脚本。 
　　此时用户备份文件只需要执行Shell程序ba.sh,执行时需在当前Shell中创建一个子Shell: 
　　　　$sh ba.sh 
　　程序sh与用户登陆时执行的Bourne Shell相同，但当Sh命令带参数ba.sh后，它将不再是一个交互式的Shell，而是直接从文件ba.sh中读取命令。 
　　执行ba.sh中命令的另一方法是给文件ba.sh执行权限： 
　　　　$chmod +x ba.sh 
　　此时，用户可以输入文件名ba.sh做为一个命令来备份自己的数据，需要注意的是，用这种方法执行命令的时候，文件ba.sh必须存在于环境变量$PATH所指定的路径上。 
[]     
    
Unix系列shell程序编写(中)
文章整理: 文章来源: 网络 
作者：htldm  出处：Unix爱好者家园unix-cd.com   
3>在Shell中使用数据变量 
　　用户可以在Shell中使用数据变量，例如ba.sh程序: 
　　　　cd/usr/icewalk 
　　　　ls|cpio -o > /dev/fd0 
　　该程序中要备份的目录为一常量，即该程序只能用来备份一个目录。若在该程序中使用变量，则会使其更通用: 
　　　　workdir=$1 
　　　　cd $workdir 
　　　　ls * |cpio -o > /dev/fd0 
　　通过这一改变，用户可以使用程序备份变量$workdir指定的目录。例如我们要备份/home/www的内容，只要运行ba.sh /home/www即可实现。(若不明白 $1，下面将详细介绍shell参数的传递，$1代表本sh程序-ba.sh的第一个参数) 
　　4>在Shell程序中加上注释 
　　为了增加程序的可读性，我们提倡加入注释。在Shell程序中注释将以"#"号开始。当Shell解释到"#"时，会认为从"#"号起一直到该行行尾为注释。 
　　5>对Shell变量进行算术运算 
　　高级语言中变量是具有类型的，即变量将被限制为某一数据类型，如整数或字符类型。Shell变量通常按字符进行存储，为了对Shell变量进行算术运算，必须使用expr命令。 
　　expr命令将把一个算术表达式作为参数，通常形式如下: 
　　　　expr [数字] [操作符] [数字] 
　　由于Shell是按字符形式存储变量的，所以用户必须保证参加算术运算的操作数必须为数值。下面是有效的算术操作符: 
　　　　+　　　两个整数相加 
　　　　-　　　第一个数减去第二个数 
　　　　*　　　两整数相乘 
　　　　/　　　第一个整数除以第二个整数 
　　　　%　　　两整数相除，取余数 
　　例如: 
　　　　$expr 2 + 1 
　 　　 结果显示：3 
　　　　$expr 5 - 3 
　 　　 结果显示：2 
若expr的一个参数是变量，那么在表达式计算之前用变量值替换变量名。 
　　　　$int=3 
　　　　$expr $int + 4 
　　　　结果显示:7 
　　用户不能单纯使用"*"做乘法,若输入: 
　　　　$expr 4*5 
　　系统将会报错，因为Shell看到"*"将会首先进行文件名替换。正确形式为: 
　　　　$expr 4 \* 5 
　 　　 结果显示:20 
　　多个算术表达式可以组合在一起，例如: 
　　　　$expr 5 + 7 / 3 
　　　　结果显示:7 
　　运算次序是先乘除后加减，若要改变运算次序，必须使用"`"号,如: 
　　　　$int=`expr 5 + 7` 
　　　　$expr $int/3 
　　 　 结果显示:4 
　　　　或者： 
　　　　$expr `expr 5+7`/3 
　　　　结果显示:4 
　　6>向Shell程序传递参数 
　　一个程序可以使用两种方法获得输入数据。一是执行时使用参数。另一种方法是交互式地获得数据。vi编辑程序可以通过交互式的方法获得数据，而ls和expr则从参数中取得数据。以上两种方法Shell程序都可以使用。在"交互式读入数据"一节中将介绍Shell程序通过交互式的方法获得参数。 
　　通过命令行给Shell程序传递参数可以扩大程序的用途。以前面提到的ba.sh程序为例: 
　　$cat >re.sh 
　　cd $workdir 
　　cpio -i < /dev/fd0 
　　^d 
　　程序re.sh恢复了ba.sh程序备份的所有文件。若只从软盘上恢复一个指定的文件，可以用该文件名作为参数，传递给Shell程序re.sh: 
　　程序改写如下: 
　　$cat >re2.sh 
　　cd $workdir 
　　cpio -i $1 < /dev/fd0 
　　^d 
　　用户可以指定要恢复的文件，例如fname 
　　$re2.sh fname 
此时文件fname作为第一个位置参数传递给re2.sh,re2.sh的缺点是要恢复两个或多个文件要重复运行，我们可以用$*变量传递不确定的参数给程序: 
　　$cat >re3.sh 
　　cd $workdir 
　　cpio -i $* < /dev/fd0 
　　^d 
　　我们就可以恢复多个文件，例如fname1,fname2,fname3 
　　$re3.sh fname1 fname2 fname3 
　　(以上程序re.sh,re2.sh,re3.sh，假设用户已经chmod了可执行权利) 
　　因为没有赋值的变量可以作为NULL看待，所以若是程序re3.sh在执行时候没赋予参数，那么一个空值将被插入到cpio命令中。该命令将恢复所有保存的文件。 
条件判断语句 
　　条件判断语句是程序设计语言中十分重要的语句，该语句的含义是当某一条件满足时，执行指定的一组命令。 
1>if - then语句 
　　格式: if command1 
　　　　　then 
　　　　　　　command2 
　　　　　　　command3 
　　　　　fi　　　　　　---(if 语句结束) 
　　　　　　　command4 
　　每个程序或命令执行结束后都有一个返回的状态，用户可以用Shell变量$?获得这一状态。if语句检查前面命令执行的返回状态，若该命令成功执行，那么在then和fi之间的命令都将被执行。在上面的命令序列中，command1和command4总要执行。若command1成功执行,command2和command3也将执行。 
　　请看下面程序: 
　　　　#unload -program to backup and remove files 
　　　　cd $1 
　　　　ls -a | cpio -o > /dev/mnt0 
　　　　rm * 
　　该程序在备份资料后，删除档案，但当cpio命令不能成功执行时，rm命令还是把资料删除了，我们可不希望这样，为了避免此情况，可以用if - then语句: 
　　　　#--卸载和判断删除程序 
　　　　cd $1 
　　　　if ls -a | cpio > /dev/mnt0 
　　　　then 
　　　　　　rm * 
　　　　fi 
　　上面程序在cpio执行成功后才删除档案 
同时，若执行没有成功，我们希望得到提示，sh中的echo命令可以向用户显示消息，并显示后换行，上面程序可以写成: 
　　 　 #--卸载和判断删除程序 
　　　　cd $1 
　　　　if ls -a | cpio > /dev/mnt0 
　　　　then 
　　　　　　echo "正删除文件资料... ..." 
　　　　　　rm * 
　　　　fi 
　　echo命令可以使用一些特殊的逃逸字符进行格式化输出，下面是这些字符及其含义: 
　　　　\b　　Backspace 
　　　　\c　　显示后不换行 
　　　　\f　　在终端上屏幕的开始处显示 
　　　　\n　　换行 
　　　　\r　　回车 
　　　　\t　　制表符 
　　　　\v　　垂直制表符 
　　　　\　　 反斜框 
　　　　\0nnn 用1,2或3位8进制整数表示一个ASCII码字符 
2>if - then - else语句 
　　不用多说它的作用，别的高级语言中都有，格式为: 
　　if command1 
　　then 
　　　　command2 
　　　　command3 
　　else 
　　　　command4 
　　　　command5 
　　fi 
　　在此结构中，command1中是先执行，当command1成功执行时，将执行command2和command3，否则执行command4和command5 
　　注意看下面程序: 
　　　　#备份程序 
　　　　cd $1 
　　　　if ls -a |cpio -o > /dev/mnt0 
　　　　then 
　　　　　　echo "删除源资料... ..." 
　　　　　　rm * 
　　　　else 
　　　　　　echo "磁带备份失败!" 
　　　　fi 
3>test命令进行条件测试 
　　if语句可以通过测试命令执行的返回状态来控制命令的执行，若要测试其他条件，在bsh中可以使用test命令。该命令检测某一条件，当条件为真时返回0，否则返回非0值。test命令可以使Shell程序中的if语句象其他程序语言中的条件判断语句一样，具有很强的功能。 
　　test命令的使用方法为: 
　　　　test condition 
　　可测试的条件分为4类: 
　　1)测试两个字符串之间的关系。 
　　2)测试两个整数之间关系。 
　　3)测试文件是否存在或是否具有某种状态或属性。 
　　4)测试多个条件的与(and)或(or)组合。 
1、条件语句>>test语句 
1>测试字符串间的关系 
　　bsh把所有的命令行和变量都看作字符串。一些命令如expr和test可以把字符当作数字进行操作。 
　　同样任何数字也可以作为字符串进行操作。 
　　用户可以比较两个字符串相等或不等，也可以测试一个串是否赋了值。有关串的操作符如下: 
　　　　str1 = str2　　　　　　当两个串有相同内容、长度时为真 
　　　　str1 != str2　　　　　 当串str1和str2不等时为真 
　　　　-n str1　　　　　　　  当串的长度大于0时为真(串非空) 
　　　　-z str1　　　　　　　  当串的长度为0时为真(空串) 
　　　　str1　　　　　　　　   当串str1为非空时为真 
　　不但Shell程序可以使用test进行条件判断，test命令也可以独立执行，如: 
　　　　$str1=abcd 
　　　　$test $str1 = abcd 
　　　　$echo $? 
　　　　结果显示:0 
与上例中第一行赋值语句中的等号不同，test命令中的等号两边必须要有空格。本例test命令共有3个参数。注意两个串相等必须是长度和内容都相等。 
　　　　$str1="abcd " 
　　　　$test "$str1" = abcd 
　　　　$echo $? 
　　　　结果显示:1 
　　上面str1包含5个字符，其中最后一个为空格符。而test命令中的另一个串只有4个字符，所以两串不等，test返回1。 
　　不带任何操作符和使用-n操作符测试一个串结果是一样的，例如: 
　　　　$str1=abce 
　　　　$test $str1 
　　　　$echo $? 
　　　　结果显示:0　　　　 
　　　　$test -n $str1 
　　　　$echo $? 
　　　　结果显示:0 
　　但是，上面两条命令也有一点差别，反映出了使用test命令潜在的问题，请看下例: 
　　　　$str1="　　　" 
　　　　$test $str1 
　　　　$echo $? 
　　　　结果显示:1 
　　　　$test -n "$str1" 
　　　　$echo $? 
　　　　结果显示:0 
　　　　$test -n $str1 
　　　　结果显示:test:argument expected 
　　上例中，第一次测试为假因为Shell在执行命令行之前首先要进行变量替换，即把$str1换成空格，然后shell又将命令行上的空格删除，故test命令测试到的为空串。而在第二次测试中，变量替换后空格位于括号内，故不会被删除，test测试到的是一个包含空格的串，在第三次测试中，shell把空格删除，只把-n传个test命令，所以显示参数错。 
2>测试两个整数之间关系 
　　test命令与expr命令一样，也可以把字符转变成整数，然后对其操作。test命令对两个数进行比较，使用的操作符如下: 
　　　　int1 -eq int2　　　　两数相等为真 
　　　　int1 -ne int2　　　　两数不等为真 
　　　　int1 -gt int2　　　　int1大于int2为真 
　　　　int1 -ge int2　　　　int1大于等于int2为真 
　　　　int1 -lt int2　　　　int1小于int2为真 
　　　　int1 -le int2　　　　int1小于等于int2为真 
　　下面的例子反映了字符串比较与数字比较的不同: 
　　　　$str1=1234 
　　　　$str2=01234 
　　　　$test $str1 = $str2 
　　　　$echo $? 
　　　　结果显示:1 
　　　　$test $str1 -eq $str2 
　　　　$echo $? 
　　　　结果显示:0 
3>有关文件的测试 
　　使用test进行的第三类测试是测试文件的状态，用户可以测试文件是否存在，是否可写以及其他文件属性。下面是文件测试时使用的选项。注意只有文件存在时，才有可能为真。 
　　-r file　　　　　用户可读为真 
　　-w file　　　　　用户可写为真 
　　-x file　　　　　用户可执行为真 
　　-f file　　　　　文件为正规文件为真 
　　-d file　　　　　文件为目录为真 
　　-c file　　　　　文件为字符特殊文件为真 
　　-b file　　　　　文件为块特殊文件为真 
　　-s file　　　　　文件大小非0时为真 
　　-t file　　　　　当文件描述符(默认为1)指定的设备为终端时为真 
4>复杂的条件测试(and 、or 、not) 
　　-a 　 　　　　　 与 
　　-o　　　　　　　 或 
　　!　　　　　　　　非 
　　就是组合条件了，任何高级语言中都有的(NOT 、AND 、OR)，例如: 
　　　　$test -r em.null -a -s em.null 
　　　　$echo $? 
　　　　结果显示:1 
　　　　说明了em.null并不是可读并且非空的文件 
5>另一种执行test的方法 
　　bsh中还有另一种执行test命令的方法，就是把测试条件放到一对[ ]中，例如: 
　　　　$int1=4 
　　　　$[ $int1 -gt 2 ] 
　　　　$echo $? 
　　　　结果显示:0 
要注意在[ 的后面和 ]符号的前面要有一个空格。 
　　下面我们用test命令写个简单但比较完善的程序: 
　　　　#-- 备份程序 
　　 
　　　　#-- 检查参数 
　　　　if [ $# -ne 1 ] 
　　　　then 
　　　　　　echo "请在程序名后面指出要备份文件所在目录!" 
　　　　　　exit 1 
　　　　fi 
　　　　#-- 检查目录名是否有效 
　　　　if [ !-d "$1" ] 
　　　　then 
　　　　　　echo "$1 不是一个目录!" 
　　　　　　exit 2 
　　　　fi 
　　　　cd $1 
　　　　ls -a | cpio -o >/dev/mnt0 
　　　　if [ $? -eq 0 ] 
　　　　then 
　　　　　　rm * 
　　　　else 
　　　　　　echo "cpio执行不成功!备份失败..." 
　　　　　　exit 3 
　　　　fi 
6>空命令 
　　在Bsh中用 : 代表空命令，就是充个数，什么都不做 
7>嵌套if语句和elif结构 
　　检查条件1 
　　A:当条件1为真，则执行一部分操作 
　　B:若条件1为假，检查条件2 
　　　　1)若条件2为真，执行另外一部分操作 
　　　　2)若条件2为假，检查条件3 
　　　　3)若条件3为真，执行其他一部分操作 
　　语法如下: 
　　　　if command 
　　　　then 
　　　　　　command 
　　　　else 
　　　　　　if command 
　　　　　　then 
　　　　　　　　command 
　　　　　　else 
　　　　　　　　if command 
　　　　　　　　then 
　　　　　　　　　　command 
　　　　　　　　fi 
　　　　　　fi 
　　　　fi 
8>elif语句 
　　嵌套if语句有时会给用户带来混乱，特别是什么时候fi语句很难判断。因此Bourne Shell又提供了elif语句。elif是else-if的缩写，它表示是if语句的继续。格式为: 
　　　　if command 
　　　　then 
　　　　　　command 
　　　　elif command 
　　　　then 
　　　　　　command 
　　　　elif command 
　　　　then 
　　　　　　command 
　　　　fi 
　　上面介绍的嵌套if语句和elif语句完成相同的功能，用户可以根据自己的喜好选择一种使用。 
9>case语句 
　　前面说的elif语句替代if-then-else语句，但有时在编程时还会遇到对同一变量进行多次的测试，该情况可以用多个elif语句实现,但还有一种更简单的方法就是用case语句。 
　　case语句不但取代了多个elif和then语句，还可以用变量值对多个模式进行匹配，当某个模式与变量值匹配后，其后的一系列命令将被执行，下面是case语句使用的语句。 
　　case value in 
　　　pattem 1) 
　　　　command 
　　　　command;; 
　　　pattem 2) 
　　　　command 
　　　　command;; 
　　　.... 
　　　pattem) 
　　　　command; 
　　esac 
　　case语句只执行其中的一组命令，当变量值与多个模式相匹配时，只有第一个匹配的模式对应的命令被执行。";;"表示该模式对应的命令部分程序。 
　　通过学习下面的read语句，我们们再举例子说明case语句的用法。 
10>read语句 
　　Shell程序不但可以通过命令行参数得到输入数据，还可以使用read命令提示用户输入数据，其语法格式为： 
　　read var1 var2... ...varn 
当Bsh遇到一个read语句时，在标准输入文件中读取数据直到一个换行符。此时Shell在解释输入行时，不进行文件名或变量的替换，只是简单地删除多余的空格。然后Shell将输入行的第一个字的内容给变量1,第二个给变量2,直到所有变量都赋上值或是输入行为空。若输入行中字的个数超过变量个数，Shell将把输入行中剩余的所有字的内容都赋给最后一个变量。当变量个数多于输入行字的个数时候，多于的变量将赋一个空值。输入行的每一个字是由空格分隔的一个字母和数字组成的字符串。 
　　$read var1 var2 var3 
　　 　输入:Hello my friend 
　　 
　　$echo $var1 $var2 $var3 
　　　 结果显示:Hello my friend 
　　$echo $var2 
　　　 结果显示:my 
下面用个read和case的例子结束本部分的学习: 
　　#--交互式备份，恢复程序 
　　echo "输入要备份文件所在目录:\c" 
　　read WORKDIR 
　　if [ !-d $WORKDIR ] 
　　then 
　　　　echo "Sorry,$WORKDIR is not a directory" 
　　　　exit 1 
　　fi 
　　cd $WORKDIR 
　　echo "输入选择:" 
　　echo _ 
　　echo "1.恢复到 $WORKDIR" 
　　echo "2.备份 $WORKDIR" 
　　echo "0.退出" 
　　echo 
　　echo "\c" 
　　read CHOICE 
　　case "$CHOICE" in 
　　　1)echo "恢复中... ..." 
　　　　cpio -i < /dev/mnt0;; 
　　　2)echo "备份中... ..." 
　　　　ls | cpio -o > /dev/mnt0;; 
　　　0)exit 1 
　　　*)exit 1 
　　esac 
　　if [ $? -ne 0 ] 
　　then 
　　　echo "程序运行中出现错误!" 
　　else 
　　　echo "操作成功!" 
fi 　 
　 
　　在上面代码中，"*"定义了其他模式下不匹配时的默认操作。 
循环语句 
　　前面介绍的程序和所学的语句都是从头到尾成一条主线下来，或是成分支结构，在日常管理UNIX的过程中，经常要重复的做一些操作，处理批量的问题，这就涉及到了循环结构，同高级语言相似，UNIX的Shell也提供了强大的循环处理语句。 
　　Bsh语言中有三种循环语句-while循环、until循环、for循环，下面通过具体的例子分别介绍这三种结构。 
While循环 
　　在while循环语句中，当某一条件为真时，执行指定的命令。语句的结构如下： 
while command 
do 
　　command 
　　command 
　　… … 
done 
示例代码如下： 
#测试while循环小程序 
x_t=1 
　　while [  $x_t -lt 5 ] 
　　do 
　　　　　mm=` expr $x_t \* $int `　　#注意"\"的作用 
　　　　　echo "$mm" 
　　　　　x_t=` expr $x_t + 1 `　　　#注意expr的用法 
　　done 
　　echo "THE WHILE IS END!\n" 
程序的执行结果如下: 
1 
4 
9 
16 
THE WHILE IS END 
　　在上述程序中，当变量x_t的值小于5的时候，执行while循环中的语句。在第五次循环时， [ $x_t-lt5]命令返回非零值，于是程序执行done后面的代码。 
现在利用while循环，可以改进我们早些时候用的备份数据的例子，当用户指定的目录备份完毕后，使用while循环使程序执行一次可以备份多个用户指定的目录。代码如下： 
echo "欢迎使用备份小程序" 
　　ANS=Y 
　　while [ $ANS = Y -o $ANS = y ] 
　　do 
　　　　echo _ 
　　　　#读目录名 
　　　　echo "输入要备份的目录名：\c" 
　　　　read DIR 
　　　　if [ ! -d $DIR ] 
　　　　then 
　　　　　　　　echo "$DIR不是一个目录!" 
　　　　　　　　exit 1 
　　　　fi 
　　　　cd $DIR 
　　　　echo "请选择:" 
　　　　echo _ 
　　　　echo "1 恢复数据到 $DIR" 
　　　　echo "2 备份$DIR的数据" 
　　　　echo 
　　　　echo "请选择:\c" 
　　　　read CHOICE 
　　　　case "$CHOICE" in 
　　　　　　　1) echo "恢复中… …" 
　　　　　　　　cpio -i 　　　　　　　2) echo "备份中… …" 
　　　　　　　　cpio -o >/dev/rmt0;; 
　　　　　　　*) echo "选择无效" 
　　　　esac 
　　　　if [ $? -ne 0 ] 
　　　　then 
　　　　　　　echo "cpio执行过程中出现问题" 
　　　　　　　exit 2 
　　　　fi 
　　　　echo "继续别的目录吗？(Y/y)\c" 
　　　　read ANS 
　　done 
　　在程序开始，我们给变量ANS符值为Y,根据whlie的判断条件，程序进入while循环，执行do-done中的语句，每次循环都要求用户输入ANS的值用来判断是否进行下次重复执行do-done中的语句。如果用户输入的条件不满足while语句条件，循环结束，程序执行done后面的语句。 
[]     
    
Unix系列shell程序编写(下)
文章整理: 文章来源: 网络 
作者：htldm  出处：Unix爱好者家园unix-cd.com   
Until语句 
　　While语句中，只要某条件为真，则重复执行循环代码，until语句正好同while相反，该语句使循环代码重复执行，直到遇到某一条件为真才停止。 
Until语句的结构如下： 
until command 
　　do 
　　　　command 
　　　　command 
　　　　… … 
　　done 
　　可以用until语句替换上面备份程序的while语句，完成同样的功能: 
until [ $ANS != Y -a $ANS != y ] 
for 循环 
　　在介绍for循环之前，我们要学个非常有用的unix命令:shift。我们知道，对于位置变量或命令行参数，其个数必须是确定的，或者当Shell程序不知道其个数时，可以把所有参数一起赋值给变量$*。若用户要求Shell在不知道位置变量个数的情况下，还能逐个的把参数一一处理，也就是在$1后为$2,在$2后面为$3等。在 shift命令执行前变量$1的值在shift命令执行后就不可用了。 
示例如下： 
#测试shift命令(x_shift.sh) 
    until [ $# -eq 0 ] 
    do 
         echo "第一个参数为: $1 参数个数为: $#" 
         shift 
    done 
执行以上程序x_shift.sh： 
    $./x_shift.sh 1 2 3 4 
结果显示如下： 
    第一个参数为: 1 参数个数为: 3 
    第一个参数为: 2 参数个数为: 2 
    第一个参数为: 3 参数个数为: 1 
    第一个参数为: 4 参数个数为: 0 
从上可知shift命令每执行一次，变量的个数($#)减一，而变量值提前一位，下面代码用until和shift命令计算所有命令行参数的和。 
#shift上档命令的应用(x_shift2.sh) 
    if [ $# -eq 0 ] 
    then 
        echo "Usage:x_shift2.sh 参数" 
        exit 1 
    fi 
    sum=0 
    until [ $# -eq 0 ] 
    do 
        sum=`expr $sum + $1` 
        shift 
    done 
    echo "sum is: $sum" 
执行上述程序: 
    $x_shift2.sh 10 20 15 
其显示结果为： 
    45 
　　shift命令还有另外一个重要用途,Bsh定义了9个位置变量，从$1到$9,这并不意味着用户在命令行只能使用9个参数，借助shift命令可以访问多于9个的参数。 
　　Shift命令一次移动参数的个数由其所带的参数指定。例如当shell程序处理完前九个命令行参数后，可以使用shift 9命令把$10移到$1。 
　　在熟悉了shift命令后，我们一起看看，Bsh程序中非常有用的for循环语句，这种循环同上面说的while和until循环不同，for语句中的循环是否执行并不由某个条件的真和假来决定，决定for循环是否继续的条件是参数表中是否还有未处理的参数。 
For语句的结构如下： 
for variable in arg1 arg2 … argn 
do 
    command 
    command 
    … … 
done 
下面是for循环的简单例子: 
for LETTER in a b c d 
do 
     echo $LETTER 
done 
程序执行结果如下： 
a 
b 
c 
d 
在上面计算参数和的例子中，我们可以用for循环，实现如下： 
#测试 for 程序(x_for.sh) 
if [ $# -eq 0 ] 
then 
　　　echo "Usage:x_for.sh 参数… …" 
　　　exit 1 
fi 
sum=0 
for I in $* 
do 
　　　sum=`expr $sum + $I` 
done 
echo "sum is: $sum" 
中断循环指令 
　　在程序循环语句中，我们有时候希望遇到某中情况时候结束本次循环执行下次循环或结束这个循环，这就涉及到两条语句:continue和break。continue命令可使程序忽略其后循环体中的其他指令，直接进行下次循环，而break命令则立刻结束循环，执行循环体后面的的语句。 
#测试continue 
I=1 
while [ $I -lt 10 ] 
do 
　　if [ $I -eq 3 ] 
　　then 
　　　　continue 
　　fi 
　　if [ $I -eq 7 ] 
　　then 
　　　　break 
　　fi 
　　echo "$I\c" 
done 
执行上面程序，结果如下： 
12456789 
与或结构 
使用与/或结构有条件的执行命令 
　　Shell程序中可以使用多种不同的方法完成相同的功能，例如until和while语句就可以完成相同的功能，同样，除了if-then-else结构可以使命令有条件的执行外，$$和||操作符也能完成上述功能。在C语言中这两个操作符分别表示逻辑与和逻辑或操作。在Bourne Shell中，用&&连接两条命令的含义只有前面一条命令成功执行了，后面的命令才会执行。 
　　&&操作的形式为: 
　　　　command && command 
　　例如语句: 
　　　　rm $TEMPDIR/* && echo "Files successfully removed" 
　　只有rm命令成功执行以后，才会执行echo命令。若用if-then语句实现上述功能，形式为: 
　　　　if rm $TEMPDIR/* 
　　　　then 
　　　　　　echo "Files successfully removed" 
　　　　fi 
　　相反，用||连接两条命令的含义为只有第一条命令执行失败才执行第二条命令，例如: 
　　　　rm $TEMPDIR/* || echo "File were not removed" 
　　上面语句的等价形式为: 
　　　　if rm $TEMPDIR/* 
　　　　then 
　　　　　　: 
　　　　else 
　　　　　　echo "Files were not removed" 
　　　　fi 
　　这两种操作符可以联合使用，如在下面的命令行中，只有command1和command2执行成功后，command3才会执行: 
　　　　command1 && command2 && command3 
　　下面的命令行表示只有command1成功执行，command2不成功执行时，才会执行command3。 
　　&&和||操作符可以简化命令条件执行的格式，但一般只用于一条命令的条件执行。如果许多命令都使用这两个操作符，那么整个程序的可读性将变的很差，所以在多条命令的条件执行时，最好采用可读性好的if语句。 
函数 
　　现在我们介绍Shell程序中的函数部分，基本上任何高级语言都支持函数这个东西，能让我们胜好多事情的东西，至少省的频繁的敲击相同的东西，好了come on 
Shell程序中的函数 
　　函数又叫做子程序，可以在程序中的任何地方被调用，其格式如下: 
　　函数名字() 
　　{ 
　　　　command 
　　　　... ... 
　　　　command; 
　　} 
　　Shell程序的任何地方都可以用命令 "函数名字"　调用，使用函数的好处有两点，一点是使用函数可以把一个复杂的程序化为多个模块，易于管理,符合结构化程序的设计思想，另一个好处是代码的重用。 
　　Shell函数和Shel程序比较相似，它们的区别在于Shell程序在子Shell中运行，而Shell函数在当前Shell中运行。因此，在当前Shell中可以看到Shell函数对变量的修改。在任何Shell中都可以定义函数，包括交互式Shell。 
　　例如: 
　　　　$dir() {ls -l;} 
　　　　结果是我们在$后面打dir,其显示结果同ls -l的作用是相同的。该dir函数将一直保留到用户从系统退出，或执行了如下所示的unset命令： 
　　　　$unset dir 
　　　　下面的例子说明了函数还可以接受位置参数: 
　　　　$dir(){_ 
　　　　>echo "permission 　　　ln owner　　　group 　　　file sz last access 
　　　　>ls -l $*; 
　　　　>} 
　　　　运行 dir a* 看产生什么结果 
　　　　参数a*传递到dir函数中并且代替了$* 
　　　　通常Shell程序将在子Shell中执行，该程序对变量的改变只在子Shell中有效而在当前Shell中无效。"."命令可以使Shell程序在当前Shell中执行。用户可以在当前Shell中定义函数和对变量赋值。通常用下面命令来重新初使化.profile对Shell环境的设置。 
　　　　$ . .profile 
　　由于看到这部分相对简单，我们还是顺便说说trap好了 
使用trap命令进行例外处理 
　　用户编写程序在程序运行时可能会发生一些例外情况，比如执行该程序的用户按中断键或使用kill命令，或者控制终端突然与系统断开等。unix系统中的上述情况会使系统向进程发一个信号，通常情况下该信号使进程终止运行。有时侯用户希望进程在接到终止信号时进行一些特殊的操作。若进程在运行时产生一些临时文件，又因接受到的信号而终止。那么该进程产生的临时文件将保留下来。在bsh中，用户可以使用trap命令修改进程接收到终止信号时进行的默认操作。 
　　trap命令格式如下: 
　　　　　trap command_string signals 
多数系统中共有15种发给进程的信号，默认情况下大多数信号都会使程序终止。用户最好查阅自己系统的文挡，看看本系统内使用的信号种类。除了信号为9(真正的kill信号)不能使用trap命令外，其他信号所带来的操作都可以用trap命令进行指定。下面是trap命令中经常使用的几种信号: 
　　　　信号　　　功能 
　　　　 
　　　　 1 　 　　挂起 
　　　　 2　　　　操作中断 
　　　　 15　　　 软终止(kill信号) 
　　若命令串中包含不只一条命令，必须使用引号将整个命令括起来，具体是单引号还是双引号，由用户是否需要变量替换决定。" "替换，' '不替换。 
　　使用下面trap命令可以使程序在接收到挂起、中断或kill信号时，首先把临时文件删除，然后退出: 
　　　　trap "rm $TEMPDIR/* $$;exit" 1 2 15 
　　在上面例子中，当Shell读取trap命令时，首先对$TEMPDIR和$$进行变量替换，替换之后的命令串将被保存在trap表中，若上例中trap命令使用单引号时，trap命令执行时候，不进行变量替换，而把命令串　rm $TEMPDIR/* $$;exit　放到trap表中，当检测到信号时，程序解释执行trap表中的命令串，此时进行变量替换。前面变量$TEMPDIR和$$的值为执行trap指令时候的值，后一种情况中变量的值为程序接收到信号时候的值，所以 "、'一定要区分仔细。 
　　下面命令的含义为用户按二次中断键后，程序才终止: 
　　　　trap 'trap 2' 2 
　　一般trap命令中的命令串中几乎都包含exit语句，上面rm的例子若无exit语句，接收到信号rm命令执行完后程序将挂起。但有时用户也需要程序在接到信号后挂起，例如当终端和系统断开后，用户发出挂起信号，并执行空命令,如下: 
　　　　trap : 1 
　　若用户想取消前trap指令设置的命令串，可以再执行trap命令，在命令中不指定命令串表示接收到信号后进行默认的操作，命令如下: 
　　　　trap 1 
规范Shell 
获取UNIX类型的选项: 
　　unix有一个优点就是标准UNIX命令在执行时都具有相同的命令行格式: 
　　command -options parameters 
　　如果在执行Shell程序也采用上述格式，Bourne Shell中提供了一条获取和处理命令行选项的语句，即getopts语句。该语句的格式为: 
　　getopts option_string variable 
　　其中option_string中包含一个有效的单字符选项。若getopts命令在命令行中发现了连字符，那么它将用连字符后面的字符同option_string相比较。若有匹配，则把变量variable的值设为该选项。若无匹配，则variable设为?。当getopts发现连字符后面没有字符，会返回一个非零的状态值。Shell程序中可以利用getopts的返回值建立一个循环。 
　　下面代码说明了date命令中怎么使用getopts命令处理各种选项，该程序除了完成unix的标准命令date的功能外，还增加了许多新的选项。 
　　#新date程序 
　　if [ $# -lt 1 ] 
　　then 
　　　　date 
　　else 
　　　　while getopts mdyDHMSTJjwahr OPTION 
　　　　do 
　　　　　　case $OPTION 
　　　　　　in 
　　　　　　　　m)date '+%m';; 
　　　　　　　　d)date '+%d';; 
　　　　　　　　y)date '+%y';; 
　　　　　　　　D)date '+%D';; 
　　　　　　　　H0date '+%H';; 
　　　　　　　　M)date '+%M';; 
　　　　　　　　S)date '+%S';; 
　　　　　　　　T)date '+%T';; 
　　　　　　　　j)date '+%j';; 
　　　　　　　　J)date '+%y%j';; 
　　　　　　　　w)date '+%w';; 
　　　　　　　　a)date '+%a';; 
　　　　　　　　h)date '+%h';; 
　　　　　　　　r)date '+%r';; 
　　　　　　　　\?)echo "无效的选项!$OPTION";; 
　　　　　　esac 
　　　　done 
　　fi 
有时侯选项中还带一个值，getopts命令同样也支持这一功能。这时需要在option_string中选项字母后加一个冒号。当getopts命令发现冒号后，会从命令行该选项后读取该值。若该值存在，那么将被存在一个特殊的变量OPTARG中。如果该值不存在，getopts命令将在OPTARG中存放一个问号，并且在标准错误输出上显示一条消息。 
　　下面的例子，实现拷贝一个文件，并给文件赋一个新的名字。-c选项指定程序拷贝的次数，-v选项要求显示新创建文件的文件名。 
　　#--拷贝程序 
　　COPIES=1 
　　VERBOSE=N 
　　while getopts vc:OPTION 
　　do 
　　　　case $OPTION 
　　　　in 
　　　　　　c)COPIES=$OPTARG;; 
　　　　　　v)VERBOSE=Y;; 
　　　　　　\?)echo "无效参数!" 
　　　　　　　 exit 1;; 
　　　　esac 
　　done 
　　if [ $OPTIND -gt $# ] 
　　then 
　　　　echo "No file name specified" 
　　 　 exit 2 
　　fi 
　　shift 'expr $OPTIND - 1' 
　　FILE=$1 
　　COPY=0 
　　while [ $COPIES -gt $COPY ] 
　　do 
　　　　COPY='expr $COPY + 1' 
　　　　cp $FILE $ {FILE} $ {COPY} 
　　　　if [ VERBOSE = Y } 
　　　　then 
　　　　　　echo ${FILE} $ {COPY} 
　　　　fi 
　　done 
规范Shell: 
　　我们知道环境变量PS1是提示符,看下面程序chdir: 
　　if [ ! -d "$!" ] 
　　then 
　　　　echo "$1 is not a directory" 
　　　　exit 1 
　　fi 
　　cd $1 
　　PS1="'pwd'>" 
　　export PS1 
　　我们执行: 
　　 　$chdir /usr/ice666 
　　结果提示符号变成/usr/ice666>了吗？没有，为什么? 
　　原因在于:chdir在子Shell中执行，变量PS1的修改在当前Shell中也不会起作用，若要chdir完成意想中的功能，必须在当前Shell中执行该命令。最好的方法就是把其改成一个函数并且在.profile文件中定义。但若要把函数放到单个文件中并在当前Shell中执行，则需要使用 . 命令，并将chdir重写成一个函数，把其中的exit改写成return。下面代码是 .ice_ps的内容: 
　　#--提示符 
　　chdir() 
　　{ 
　　if [ !-d "$1" ] 
　　then 
　　　　echo " $1 is not a directory" 
　　　　return 
　　fi 
　　cd $1 
　　PS1="'pwd'>" 
　　export PS1; 
　　} 
　　然后我们在.profile文件中加入下面语句 
　　.ice_ps 
　　然后在切换目录的时候，我们用chdir命令，结果是什么呢，自己实验好了! 　 
调试Shell程序 
1>调试shell程序 
　　用户刚编写完Shell程序中，不可避免的会有错误，这时我们可以利用Bsh中提供的跟踪选项，该选项会显示刚刚执行的命令及参数。用户可以通过set命令打开-x选项或在启动Shell使用-x选项将Shell设置成跟踪模式。例如有下面代码ice_tx: 
　　if [ $# -eq 0 ] 
　　then 
　　　　echo "usage:sumints integer list" 
　　　　exit 1 
　　fi 
　　sum=0 
　　until [ $# -eq 0 ] 
　　do 
　　　　sum='expr $sum + $1' 
　　　　shift 
　　done 
　　echo $sum 
　　我们用跟踪模式运行: 
　　$sh -x ice_tx 2 3 4 
　　结果显示: 
　　+[ 3 -eq 0 ] 
　　+sum=0 
　　+[ 3 -eq 0 ] 
　　+expr 0+2 
　　+sum=2 
　　+shift 
　　+[ 2 -eq 0 ] 
　　+expr 2+3 
　　+sum=5 
　　+shift 
　　+[ 1 -eq 0 ] 
　　+expr 5+4 
　　+sum=9 
　　+[ 0 -eq 0 ] 
　　+echo 9 
　　9 
　　从上面可以看出，跟踪模式下Shell显示执行的每一条命令以及该命令使用的变量替换后的参数值。一些控制字如if、then、until等没显示。 
2>命令分组 
　　Shell中若干命令可以组成一个单元一起执行。为了标识一组命令，这些命令必须放到"()"或"{}"中。放在"()"中的命令将在子Shell中运行，而放在"{}"中的命令将在当前Shell中运行。子Shell中运行的命令不影响当前Shell的变量。当前Shell中运行的命令影响当前Shell的变量。 
　$NUMBER=2 
　　$(A=2;B=2;NUMBER='expr $A+$B';echo $NUMBER) 
　　结果为:4 
　　$echo $NUMBER 
　　结果为:2 
　　如果把上面的()变成{}，结果会是怎么样的呢？ 
3>使用Shell分层管理器shl 
　　UNIX是一个多道程序设计的操作系统，一些UNIX系统利用这一特性提供了Shell层次管理器shl。使用shl用户一次可以打开多个层次的Shell，其中活跃的Shell可以从终端上获得输入。但所有Shell的输出都可在终端上显示，除非显示被禁止。 
　　多个Shell中有一个为shl,当用户在某个Shell中工作时，可以通过使用特殊字符(一般为Ctrl+z)返回shl。为了同其他Shell区别，shl中提示符为">>>"。当用户工作在Shell层次管理器中时，可以创建、激活和删除Shell，下面是shl中使用的命令。 
　　create name　　　　产生名为name的层次 
　　delete name　　　　删除名为name的层次 
　　block name　　　　 禁止名为name的层次的输出 
　　unblock name　　　 恢复名为name的层次的输出 
　　resume name　　　　激活名为name的层次 
　　toggle　　　　　　 激活近来经常使用的层次 
　　name　　　　　　　 激活名为name的层次 
　　layers [-l] name　 对于表中的每个层次，显示其正在运行的进程的进程号，-l选项要求显示详细信息。 
　　help 　　　　　　　显示shl命令的帮助信息 
　　quit　　　　　　　 退出shl以及所有被激活的层次 
总结 
　　在前面我们主要介绍了sh的变量、基本语法、程序设计等。如果掌握了这些内容，在学习其他UNIX下编程语言的时候，相信有一定的好处，我们说了，在大多数的UNIX中都提供Bourn Shell，而且很少有象sh这样强大的脚本编辑语言了，是系统管理员和程序员的一笔财富，并且不需要额外的软件环境，对文件等处理借助unix命令，实现起来比c实现还要简单。 
[]     
    
shell游戏:俄罗斯方块
文章整理: 文章来源: 网络 
作者：飞灰橙   
运行于GNU bash, version 2.05a.0(1)-release (i686-pc-linux-gnu) 
#!/bin/bash 
# Tetris Game 
# 10.21.2003 xhchen<xhchen@winbond.com.tw> 
#颜色定义 
cRed=1 
cGreen=2 
cYellow=3 
cBlue=4 
cFuchsia=5 
cCyan=6 
cWhite=7 
colorTable=($cRed $cGreen $cYellow $cBlue $cFuchsia $cCyan $cWhite) 
#位置和大小 
iLeft=3 
iTop=2 
((iTrayLeft = iLeft + 2)) 
((iTrayTop = iTop + 1))  
((iTrayWidth = 10)) 
((iTrayHeight = 15)) 
#颜色设置 
cBorder=$cGreen 
cScore=$cFuchsia 
cScorevalue=$cCyan 
#控制信号 
#改游戏使用两个进程，一个用于接收输入，一个用于游戏流程和显示界面; 
#当前者接收到上下左右等按键时，通过向后者发送signal的方式通知后者。 
sigRotate=25 
sigLeft=26 
sigRight=27 
sigDown=28 
sigAllDown=29 
sigExit=30 
#七中不同的方块的定义 
#通过旋转，每种方块的显示的样式可能有几种 
box0=(0 0 0 1 1 0 1 1) 
box1=(0 2 1 2 2 2 3 2 1 0 1 1 1 2 1 3) 
box2=(0 0 0 1 1 1 1 2 0 1 1 0 1 1 2 0) 
box3=(0 1 0 2 1 0 1 1 0 0 1 0 1 1 2 1) 
box4=(0 1 0 2 1 1 2 1 1 0 1 1 1 2 2 2 0 1 1 1 2 0 2 1 0 0 1 0 1 1 1 2) 
box5=(0 1 1 1 2 1 2 2 1 0 1 1 1 2 2 0 0 0 0 1 1 1 2 1 0 2 1 0 1 1 1 2) 
box6=(0 1 1 1 1 2 2 1 1 0 1 1 1 2 2 1 0 1 1 0 1 1 2 1 0 1 1 0 1 1 1 2) 
#所有其中方块的定义都放到box变量中 
box=(${box0[@]} ${box1[@]} ${box2[@]} ${box3[@]} ${box4[@]} ${box5[@]} ${box6[@]}) 
#各种方块旋转后可能的样式数目 
countBox=(1 2 2 2 4 4 4) 
#各种方块再box数组中的偏移 
offsetBox=(0 1 3 5 7 11 15) 
#每提高一个速度级需要积累的分数 
iScoreEachLevel=50 #be greater than 7 
#运行时数据 
sig=0 #接收到的signal 
iScore=0 #总分 
iLevel=0 #速度级 
boxNew=() #新下落的方块的位置定义 
cBoxNew=0 #新下落的方块的颜色 
iBoxNewType=0 #新下落的方块的种类 
iBoxNewRotate=0 #新下落的方块的旋转角度 
boxCur=() #当前方块的位置定义 
cBoxCur=0 #当前方块的颜色 
iBoxCurType=0 #当前方块的种类 
iBoxCurRotate=0 #当前方块的旋转角度 
boxCurX=-1 #当前方块的x坐标位置 
boxCurY=-1 #当前方块的y坐标位置 
iMap=() #背景方块图表 
#初始化所有背景方块为-1, 表示没有方块 
for ((i = 0; i < iTrayHeight * iTrayWidth; i++)); do iMap[$i]=-1; done 
#接收输入的进程的主函数 
function RunAsKeyReceiver() 
{ 
local pidDisplayer key aKey sig cESC sTTY 
pidDisplayer=$1 
aKey=(0 0 0) 
cESC=`echo -ne "\33"` 
cSpace=`echo -ne "\40"` 
#保存终端属性。在read -s读取终端键时，终端的属性会被暂时改变。 
#如果在read -s时程序被不幸杀掉，可能会导致终端混乱， 
#需要在程序退出时恢复终端属性。 
sTTY=`stty -g` 
#捕捉退出信号 
trap "MyExit;" INT TERM 
trap "MyExitNoSub;" $sigExit 
#隐藏光标 
echo -ne "\33[?25l" 
while (( 1 )) 
do 
#读取输入。注-s不回显，-n读到一个字符立即返回 
read -s -n 1 key 
aKey[0]=${aKey[1]} 
aKey[1]=${aKey[2]} 
aKey[2]=$key 
sig=0 
#判断输入了何种键 
if [[ $key == $cESC && ${aKey[1]} == $cESC ]] 
then 
#ESC键 
MyExit 
elif [[ ${aKey[0]} == $cESC && ${aKey[1]} == "[" ]] 
then 
if [[ $key == "A" ]]; then sig=$sigRotate #<向上键> 
elif [[ $key == "B" ]]; then sig=$sigDown #<向下键> 
elif [[ $key == "D" ]]; then sig=$sigLeft #<向左键> 
elif [[ $key == "C" ]]; then sig=$sigRight #<向右键> 
fi 
elif [[ $key == "W" || $key == "w" ]]; then sig=$sigRotate #W, w 
elif [[ $key == "S" || $key == "s" ]]; then sig=$sigDown #S, s 
elif [[ $key == "A" || $key == "a" ]]; then sig=$sigLeft #A, a 
elif [[ $key == "D" || $key == "d" ]]; then sig=$sigRight #D, d 
elif [[ "[$key]" == "[]" ]]; then sig=$sigAllDown #空格键 
elif [[ $key == "Q" || $key == "q" ]] #Q, q 
then 
MyExit 
fi 
if [[ $sig != 0 ]] 
then 
#向另一进程发送消息 
kill -$sig $pidDisplayer 
fi 
done 
} 
#退出前的恢复 
function MyExitNoSub() 
{ 
local y 
#恢复终端属性 
stty $sTTY 
((y = iTop + iTrayHeight + 4)) 
#显示光标 
echo -e "\33[?25h\33[${y};0H" 
exit 
} 
function MyExit() 
{ 
#通知显示进程需要退出 
kill -$sigExit $pidDisplayer 
MyExitNoSub 
} 
#处理显示和游戏流程的主函数 
function RunAsDisplayer() 
{ 
local sigThis 
InitDraw 
#挂载各种信号的处理函数 
trap "sig=$sigRotate;" $sigRotate 
trap "sig=$sigLeft;" $sigLeft 
trap "sig=$sigRight;" $sigRight 
trap "sig=$sigDown;" $sigDown 
trap "sig=$sigAllDown;" $sigAllDown 
trap "ShowExit;" $sigExit 
while (( 1 )) 
do 
#根据当前的速度级iLevel不同，设定相应的循环的次数 
for ((i = 0; i < 21 - iLevel; i++)) 
do 
sleep 0.02 
sigThis=$sig 
sig=0 
#根据sig变量判断是否接受到相应的信号 
if ((sigThis == sigRotate)); then BoxRotate; #旋转 
elif ((sigThis == sigLeft)); then BoxLeft; #左移一列 
elif ((sigThis == sigRight)); then BoxRight; #右移一列 
elif ((sigThis == sigDown)); then BoxDown; #下落一行 
elif ((sigThis == sigAllDown)); then BoxAllDown; #下落到底 
fi 
done 
#kill -$sigDown $$ 
BoxDown #下落一行 
done 
} 
#BoxMove(y, x), 测试是否可以把移动中的方块移到(x, y)的位置, 返回0则可以, 1不可以 
function BoxMove() 
{ 
local j i x y xTest yTest 
yTest=$1 
xTest=$2 
for ((j = 0; j < 8; j += 2)) 
do 
((i = j + 1)) 
((y = ${boxCur[$j]} + yTest)) 
((x = ${boxCur[$i]} + xTest)) 
if (( y < 0 || y >= iTrayHeight || x < 0 || x >= iTrayWidth)) 
then 
#撞到墙壁了 
return 1 
fi 
if ((${iMap[y * iTrayWidth + x]} != -1 )) 
then 
#撞到其他已经存在的方块了 
return 1 
fi 
done 
return 0; 
} 
#将当前移动中的方块放到背景方块中去, 
#并计算新的分数和速度级。(即一次方块落到底部) 
function Box2Map() 
{ 
local j i x y xp yp line 
#将当前移动中的方块放到背景方块中去 
for ((j = 0; j < 8; j += 2)) 
do 
((i = j + 1)) 
((y = ${boxCur[$j]} + boxCurY)) 
((x = ${boxCur[$i]} + boxCurX)) 
((i = y * iTrayWidth + x)) 
iMap[$i]=$cBoxCur 
done 
#消去可被消去的行 
line=0 
for ((j = 0; j < iTrayWidth * iTrayHeight; j += iTrayWidth)) 
do 
for ((i = j + iTrayWidth - 1; i >= j; i--)) 
do 
if ((${iMap[$i]} == -1)); then break; fi 
done 
if ((i >= j)); then continue; fi 
((line++)) 
for ((i = j - 1; i >= 0; i--)) 
do 
((x = i + iTrayWidth)) 
iMap[$x]=${iMap[$i]} 
done 
for ((i = 0; i < iTrayWidth; i++)) 
do 
iMap[$i]=-1 
done 
done 
if ((line == 0)); then return; fi 
#根据消去的行数line计算分数和速度级 
((x = iLeft + iTrayWidth * 2 + 7)) 
((y = iTop + 11)) 
((iScore += line * 2 - 1)) 
#显示新的分数 
echo -ne "\33[1m\33[3${cScorevalue}m\33[${y};${x}H${iScore}         " 
if ((iScore % iScoreEachLevel < line * 2 - 1)) 
then 
if ((iLevel < 20)) 
then 
((iLevel++)) 
((y = iTop + 14)) 
#显示新的速度级 
echo -ne "\33[3${cScorevalue}m\33[${y};${x}H${iLevel}        " 
fi 
fi 
echo -ne "\33[0m" 
#重新显示背景方块 
for ((y = 0; y < iTrayHeight; y++)) 
do 
((yp = y + iTrayTop + 1)) 
((xp = iTrayLeft + 1)) 
((i = y * iTrayWidth)) 
echo -ne "\33[${yp};${xp}H" 
for ((x = 0; x < iTrayWidth; x++)) 
do 
((j = i + x)) 
if ((${iMap[$j]} == -1)) 
then 
echo -ne "  " 
else 
echo -ne "\33[1m\33[7m\33[3${iMap[$j]}m\33[4${iMap[$j]}m[]\33[0m" 
fi 
done 
done 
} 
#下落一行 
function BoxDown() 
{ 
local y s 
((y = boxCurY + 1)) #新的y坐标 
if BoxMove $y $boxCurX #测试是否可以下落一行 
then 
s="`DrawCurBox 0`" #将旧的方块抹去 
((boxCurY = y)) 
s="$s`DrawCurBox 1`" #显示新的下落后方块 
echo -ne $s 
else 
#走到这儿, 如果不能下落了 
Box2Map #将当前移动中的方块贴到背景方块中 
RandomBox #产生新的方块 
fi 
} 
#左移一列 
function BoxLeft() 
{ 
local x s 
((x = boxCurX - 1)) 
if BoxMove $boxCurY $x 
then 
s=`DrawCurBox 0` 
((boxCurX = x)) 
s=$s`DrawCurBox 1` 
echo -ne $s 
fi 
} 
#右移一列 
function BoxRight() 
{ 
local x s 
((x = boxCurX + 1)) 
if BoxMove $boxCurY $x 
then 
s=`DrawCurBox 0` 
((boxCurX = x)) 
s=$s`DrawCurBox 1` 
echo -ne $s 
fi 
} 
#下落到底 
function BoxAllDown() 
{ 
local k j i x y iDown s 
iDown=$iTrayHeight 
#计算一共需要下落多少行 
for ((j = 0; j < 8; j += 2)) 
do 
((i = j + 1)) 
((y = ${boxCur[$j]} + boxCurY)) 
((x = ${boxCur[$i]} + boxCurX)) 
for ((k = y + 1; k < iTrayHeight; k++)) 
do 
((i = k * iTrayWidth + x)) 
if (( ${iMap[$i]} != -1)); then break; fi 
done 
((k -= y + 1)) 
if (( $iDown > $k )); then iDown=$k; fi 
done 
s=`DrawCurBox 0` #将旧的方块抹去 
((boxCurY += iDown)) 
s=$s`DrawCurBox 1` #显示新的下落后的方块 
echo -ne $s 
Box2Map #将当前移动中的方块贴到背景方块中 
RandomBox #产生新的方块 
} 
#旋转方块 
function BoxRotate() 
{ 
local iCount iTestRotate boxTest j i s 
iCount=${countBox[$iBoxCurType]} #当前的方块经旋转可以产生的样式的数目 
#计算旋转后的新的样式 
((iTestRotate = iBoxCurRotate + 1)) 
if ((iTestRotate >= iCount)) 
then 
((iTestRotate = 0)) 
fi 
#更新到新的样式, 保存老的样式(但不显示) 
for ((j = 0, i = (${offsetBox[$iBoxCurType]} + $iTestRotate) * 8; j < 8; j++, i++)) 
do 
boxTest[$j]=${boxCur[$j]} 
boxCur[$j]=${box[$i]} 
done 
if BoxMove $boxCurY $boxCurX #测试旋转后是否有空间放的下 
then 
#抹去旧的方块 
for ((j = 0; j < 8; j++)) 
do 
boxCur[$j]=${boxTest[$j]} 
done 
s=`DrawCurBox 0` 
#画上新的方块 
for ((j = 0, i = (${offsetBox[$iBoxCurType]} + $iTestRotate) * 8; j < 8; j++, i++)) 
do 
boxCur[$j]=${box[$i]} 
done 
s=$s`DrawCurBox 1` 
echo -ne $s 
iBoxCurRotate=$iTestRotate 
else 
#不能旋转，还是继续使用老的样式 
for ((j = 0; j < 8; j++)) 
do 
boxCur[$j]=${boxTest[$j]} 
done 
fi 
} 
#DrawCurBox(bDraw), 绘制当前移动中的方块, bDraw为1, 画上, bDraw为0, 抹去方块。 
function DrawCurBox() 
{ 
local i j t bDraw sBox s 
bDraw=$1 
s="" 
if (( bDraw == 0 )) 
then 
sBox="\40\40" 
else 
sBox="[]" 
s=$s"\33[1m\33[7m\33[3${cBoxCur}m\33[4${cBoxCur}m" 
fi 
for ((j = 0; j < 8; j += 2)) 
do 
((i = iTrayTop + 1 + ${boxCur[$j]} + boxCurY)) 
((t = iTrayLeft + 1 + 2 * (boxCurX + ${boxCur[$j + 1]}))) 
#\33[y;xH, 光标到(x, y)处 
s=$s"\33[${i};${t}H${sBox}" 
done 
s=$s"\33[0m" 
echo -n $s 
} 
#更新新的方块 
function RandomBox() 
{ 
local i j t 
#更新当前移动的方块 
iBoxCurType=${iBoxNewType} 
iBoxCurRotate=${iBoxNewRotate} 
cBoxCur=${cBoxNew} 
for ((j = 0; j < ${#boxNew[@]}; j++)) 
do 
boxCur[$j]=${boxNew[$j]} 
done 
#显示当前移动的方块 
if (( ${#boxCur[@]} == 8 )) 
then 
#计算当前方块该从顶端哪一行"冒"出来 
for ((j = 0, t = 4; j < 8; j += 2)) 
do 
if ((${boxCur[$j]} < t)); then t=${boxCur[$j]}; fi 
done 
((boxCurY = -t)) 
for ((j = 1, i = -4, t = 20; j < 8; j += 2)) 
do 
if ((${boxCur[$j]} > i)); then i=${boxCur[$j]}; fi 
if ((${boxCur[$j]} < t)); then t=${boxCur[$j]}; fi 
done 
((boxCurX = (iTrayWidth - 1 - i - t) / 2)) 
#显示当前移动的方块 
echo -ne `DrawCurBox 1` 
#如果方块一出来就没处放，Game over! 
if ! BoxMove $boxCurY $boxCurX 
then 
kill -$sigExit ${PPID} 
ShowExit 
fi 
fi 
#清除右边预显示的方块 
for ((j = 0; j < 4; j++)) 
do 
((i = iTop + 1 + j)) 
((t = iLeft + 2 * iTrayWidth + 7)) 
echo -ne "\33[${i};${t}H        " 
done 
#随机产生新的方块 
((iBoxNewType = RANDOM % ${#offsetBox[@]})) 
((iBoxNewRotate = RANDOM % ${countBox[$iBoxNewType]})) 
for ((j = 0, i = (${offsetBox[$iBoxNewType]} + $iBoxNewRotate) * 8; j < 8; j++, i++)) 
do 
boxNew[$j]=${box[$i]}; 
done 
((cBoxNew = ${colorTable[RANDOM % ${#colorTable[@]}]})) 
#显示右边预显示的方块 
echo -ne "\33[1m\33[7m\33[3${cBoxNew}m\33[4${cBoxNew}m" 
for ((j = 0; j < 8; j += 2)) 
do 
((i = iTop + 1 + ${boxNew[$j]})) 
((t = iLeft + 2 * iTrayWidth + 7 + 2 * ${boxNew[$j + 1]})) 
echo -ne "\33[${i};${t}H[]" 
done 
echo -ne "\33[0m" 
} 
#初始绘制 
function InitDraw() 
{ 
clear 
RandomBox #随机产生方块，这时右边预显示窗口中有方快了 
RandomBox #再随机产生方块，右边预显示窗口中的方块被更新，原先的方块将开始下落 
local i t1 t2 t3 
#显示边框 
echo -ne "\33[1m" 
echo -ne "\33[3${cBorder}m\33[4${cBorder}m" 
((t2 = iLeft + 1)) 
((t3 = iLeft + iTrayWidth * 2 + 3)) 
for ((i = 0; i < iTrayHeight; i++)) 
do 
((t1 = i + iTop + 2)) 
echo -ne "\33[${t1};${t2}H||" 
echo -ne "\33[${t1};${t3}H||" 
done 
((t2 = iTop + iTrayHeight + 2)) 
for ((i = 0; i < iTrayWidth + 2; i++)) 
do 
((t1 = i * 2 + iLeft + 1)) 
echo -ne "\33[${iTrayTop};${t1}H==" 
echo -ne "\33[${t2};${t1}H==" 
done 
echo -ne "\33[0m" 
#显示"Score"和"Level"字样 
echo -ne "\33[1m" 
((t1 = iLeft + iTrayWidth * 2 + 7)) 
((t2 = iTop + 10)) 
echo -ne "\33[3${cScore}m\33[${t2};${t1}HScore" 
((t2 = iTop + 11)) 
echo -ne "\33[3${cScorevalue}m\33[${t2};${t1}H${iScore}" 
((t2 = iTop + 13)) 
echo -ne "\33[3${cScore}m\33[${t2};${t1}HLevel" 
((t2 = iTop + 14)) 
echo -ne "\33[3${cScorevalue}m\33[${t2};${t1}H${iLevel}" 
echo -ne "\33[0m" 
} 
#退出时显示GameOVer! 
function ShowExit() 
{ 
local y 
((y = iTrayHeight + iTrayTop + 3)) 
echo -e "\33[${y};0HGameOver!\33[0m" 
exit 
} 
#游戏主程序在这儿开始. 
if [[ $1 != "--show" ]] 
then 
bash $0 --show& #以参数--show将本程序再运行一遍 
RunAsKeyReceiver $! #以上一行产生的进程的进程号作为参数 
exit 
else 
#当发现具有参数--show时，运行显示函数 
RunAsDisplayer 
exit 
fi 
[]     
    
shell游戏:五子棋
文章整理: 文章来源: 网络 
作者：c1l2d3   
#!/bin/sh
# Programname: five 
# Author: CLD
# 2004.01
#
L()
{
# 屏幕任意位置
  h=$1;l=$2
  echo -n "[$h;$l;H"
}
## 界面颜色控制变量
white_b="[47;30m"        # 白底黑字
green_b="[42;30m"        # 绿底黑字(移动棋字亮块)
blue_b="[44;37m"         # 兰底白字
gray_b="[40;30;5m"       # 灰底黑字
gray_w="[40;37;5m"       # 灰底白字
black_w="[37;40;0m"      # 黑底白字
# 棋盘换色控制变量
brown_b="[43;30m"        # 桔黄底黑棋
brown_w="[43;37m"        # 桔黄底白棋
mage_b="[45;30m"         # 紫底黑棋
mage_w="[45;37m"         # 紫底白棋
lt_blue_b="[44;30;5m"    # 浅兰底黑棋
lt_blue_w="[44;37;5m"    # 浅兰底白棋
kkk()
{
# 棋盘
  L 1 22;echo "$gray_b                                  $black_w"
  L 2 22;echo "$gray_b  ┏┯┯┯┯┯┯┯┯┯┯┯┯┯┓  $black_w"
  L 3 22;echo "$gray_b  ┠┼┼┼┼┼┼┼┼┼┼┼┼┼┨  $black_w"
  L 4 22;echo "$gray_b  ┠┼┼┼┼┼┼┼┼┼┼┼┼┼┨  $black_w"
  L 5 22;echo "$gray_b  ┠┼┼╋┼┼┼┼┼┼┼╋┼┼┨  $black_w"
  L 6 22;echo "$gray_b  ┠┼┼┼┼┼┼┼┼┼┼┼┼┼┨  $black_w"
  L 7 22;echo "$gray_b  ┠┼┼┼┼┼┼┼┼┼┼┼┼┼┨  $black_w"
  L 8 22;echo "$gray_b  ┠┼┼┼┼┼┼┼┼┼┼┼┼┼┨  $black_w"
  L 9 22;echo "$gray_b  ┠┼┼┼┼┼┼┼┼┼┼┼┼┼┨  $black_w"
  L 10 22;echo "$gray_b  ┠┼┼┼┼┼┼┼┼┼┼┼┼┼┨  $black_w"
  L 11 22;echo "$gray_b  ┠┼┼┼┼┼┼┼┼┼┼┼┼┼┨  $black_w"
  L 12 22;echo "$gray_b  ┠┼┼┼┼┼┼┼┼┼┼┼┼┼┨  $black_w"
  L 13 22;echo "$gray_b  ┠┼┼╋┼┼┼┼┼┼┼╋┼┼┨  $black_w"
  L 14 22;echo "$gray_b  ┠┼┼┼┼┼┼┼┼┼┼┼┼┼┨  $black_w"
  L 15 22;echo "$gray_b  ┠┼┼┼┼┼┼┼┼┼┼┼┼┼┨  $black_w"
  L 16 22;echo "$gray_b  ┗┷┷┷┷┷┷┷┷┷┷┷┷┷┛  $black_w"
  L 17 22;echo "$gray_b                                  $black_w"
}
getchar()
{
  key=`stty -g`
  stty -echo
  stty raw
  dd if=/dev/tty bs=1 count=1 2>/dev/null
  stty -raw
  stty echo
  stty $key
}
        
clear
kkk
  L 5 34;echo " 五 子 棋 "    
  L 10 24;echo "┌────游戏○设定────┐"
  L 11 24;echo "│                          │"
  L 12 24;echo "│  1_白先走  2_黑先走 [ ]  │"
  L 13 24;echo "│                          │"
  L 14 24;echo "└─────────────┘"
  L 12 48;echo -n
goo=`getchar`
case $goo in
  1) go="白";ss=0;sss=0;;
  2) go="黑";ss=1;sss=1;;
  *) clear;exit;;
esac
  by=0;bs=0;bsy=0;hy=0;hs=0;hsy=0  #初始化输赢局数
tput civis
help()
{
L 16 3;echo "┏━━━━━━━┓"
L 16 57;echo "┏━━━━━━━┓"
L 17 3;echo "┃              ┃"
L 17 57;echo "┃              ┃"
L 18 3;echo "┃              ┃                                    ┃              ┃"
L 19 3;echo "┃ 赢盘数:      ┃┏━━━━━"$gray_b" m---和为贵 "$black_w"━━━━━┓┃ 赢盘数:      ┃"
L 20 3;echo "┃ 输盘数:      ┃┃ 友                          比 ┃┃ 输盘数:      ┃"
L 21 3;echo "┃              ┃┃ 谊   "$white_b"Press c change color"$black_w"   赛 ┃┃              ┃"
L 22 3;echo "┃              ┃┃ 第                          第 ┃┃              ┃"
L 23 3;echo "┃ 最后成绩:    ┃┃ 一                          二 ┃┃ 最后成绩:    ┃"
L 24 3;echo "┗━━━━━━━┛┗━━━━━━━━━━━━━━━━┛┗━━━━━━━┛"
}
init_(){   # 继续棋局初始化
kkk >abc
a1=2      
a2=38
b1=52
b2=16
write=$green_b$go$black_w
cat abc
L $a1 $a2;echo $write  # 棋子初始位置
ccc=1  #改变颜色次数
color1=`expr substr $gray_b 3 8`;color2=`expr substr $gray_w 3 8` #默认棋子颜色
L 19 13;echo $by;L 19 68;echo $hy
L 20 13;echo $bs;L 20 68;echo $hs
L 23 15;echo $bsy"  ";L 23 70;echo $hsy"  "
}
init_
help
## 棋子移动函数
left(){    ##左移
if [ $a2 -eq 24 ];then a2=24;else a2=`expr $a2 - 2`;fi
sort -t"[" -n +1 abc
L $a1 $a2;echo $write
}
right(){   ##右移
if [ $a2 -eq $b1 ];then a2=$b1;else a2=`expr $a2 + 2`;fi
sort -t"[" -n +1 abc
L $a1 $a2;echo $write
}
down(){    ##下移
if [ $a1 -eq $b2 ];then a1=$b2;else a1=`expr $a1 + 1`;fi
sort -t"[" -n +1 abc
L $a1 $a2;echo $write
}
up(){     ##上移
if [ $a1 -eq 2 ];then a1=2;else a1=`expr $a1 - 1`;fi
sort -t"[" -n +1 abc
L $a1 $a2;echo $write
}
sy(){    # 继续棋局输方先走,统计输赢结果
if [ $qs -eq 7 ];then 
  go="黑"      #如果白棋赢则下一盘黑先走
  run="白"
  bs=`expr $bs + 0`;by=`expr $by + 1`
  bsy=`expr $by - $bs`
  hy=$bs;hs=$by;hsy=`expr $hy - $hs`
else
  go="白"      #如果黑棋赢则下一盘白先走
  run="黑"
  hs=`expr $hs + 0`;hy=`expr $hy + 1`
  hsy=`expr $hy - $hs`
  by=$hs;bs=$hy;bsy=`expr $by - $bs`
fi
}
sy1(){      # 显示输赢结果,统计棋局,询问是否继续  
while true;do
   L 19 13;echo $by;L 19 68;echo $hy
   L 20 13;echo $bs;L 20 68;echo $hs
   L 23 15;echo $bsy"  ";L 23 70;echo $hsy"  "
   tput bel;tput bel
   L 6 28;echo $white_b"                      "$black_w
   L 7 28;echo $white_b"    "$run$1"!!!     "$black_w"  "$black_w
   L 8 28;echo $white_b"   再来一盘否[y|n]?   "$black_w"  "$black_w
   L 9 28;echo $white_b"                      "$black_w"  "$black_w
   L 10 30;echo "                      "
 key=`getchar`
 case $key in
  y)
   init_
   count=`expr $count + 1`
   L 23 36;echo "第 $count 局"
   break;;
  n)
   clear;cat abc
   L 7 30;echo $blue_b"                  "$black_w    
   L 8 30;echo $blue_b"    "!!!再见!!!"    "$black_w"  "$black_w
   L 9 30;echo $blue_b"                  "$black_w"  "$black_w
   L 10 30;echo $blue_b"  "Author: c1l2d3"  "$black_w"  "$black_w
   L 11 30;echo $blue_b"                  "$black_w"  "$black_w
   L 12 32;echo $black_w"                  "$black_w 
   tput cnorm
   rm yyy;exit;;
  *);;
 esac
done
}
award()  #判断输赢函数
{
cat abc|sed -n 18,"$"p|awk -F";" '{print $1,$2,$4}'|sed 's/^..//' \
|awk '{print $1,$2,substr($3,2,1)}' >yyy               # 计算输赢临时文件      
grep "$qs$" yyy|sort -r -n +0 +1|awk '$2+=(NR*2)' \
|uniq -c|awk '{print $1}'|grep '[5-9]' >/dev/null 2>&1 
if [ $? -eq 0 ];then sy;sy1 "棋赢啦!   ";fi            # 横连子>=5        
grep "$qs$" yyy|sort -r -n +1|awk '$1+=NR' \
|uniq -c|awk '{print $1}'|grep '[5-9]' >/dev/null 2>&1
if [ $? -eq 0 ];then sy;sy1 "棋赢啦!   " fi           # 竖连子>=5       
grep "$qs$" yyy|sort -r -n +0 +1|awk '$1=$1+$2/2'|sort -r -n \
|awk '$2+=(NR*2)'|uniq -c|awk '{print $1}'|grep '[5-9]' >/dev/null 2>&1
if [ $? -eq 0 ];then sy;sy1 "棋赢啦!   ";fi            # 右斜连子>=5
grep "$qs$" yyy|sort -r -n +0 +1|awk '$1=$1-$2/2'|sort -r -n \
|awk '$2+=(NR*2)'|uniq -c|awk '{print $1}'|grep '[5-9]' >/dev/null 2>&1
if [ $? -eq 0 ];then sy;sy1 "棋赢啦!   ";fi            # 左斜连子>=5
}
count=1    #局数
while true
do
  L 1 4;echo $white_b" 【执白方】 "$black_w
  L 4 5;echo $gray_b" a---左移 "$black_w
  L 6 5;echo $gray_b" d---右移 "$black_w
  L 8 5;echo $gray_b" w---上移 "$black_w
  L 10 5;echo $gray_b" s---下移 "$black_w
  L 12 5;echo $gray_b" p---落子 "$black_w
  L 14 5;echo $gray_b" ]---投降 "$black_w 
  L 1 62;echo $white_b" 【执黑方】 "$black_w
  L 4 63;echo $gray_b" 4---左移 "$black_w
  L 6 63;echo $gray_b" 6---右移 "$black_w
  L 8 63;echo $gray_b" 8---上移 "$black_w
  L 10 63;echo $gray_b" 5---下移 "$black_w
  L 12 63;echo $gray_b" 9---落子 "$black_w
  L 14 63;echo $gray_b" 0---投降 "$black_w
  L 22 1;echo -n 
  L 23 36;echo "第 $count 局"
  cc=`getchar`
 case $cc in
  a|4)
   if [ $ss -eq 0 ] && [ "$cc" = "a" ];then left;fi
   if [ $ss -eq 1 ] && [ "$cc" = "4" ];then left;fi;;
  d|6)
   if [ $ss -eq 0 ] && [ "$cc" = "d" ];then right;fi
   if [ $ss -eq 1 ] && [ "$cc" = "6" ];then right;fi;;
  s|5)
   if [ $ss -eq 0 ] && [ "$cc" = "s" ];then down;fi
   if [ $ss -eq 1 ] && [ "$cc" = "5" ];then down;fi;;
  w|8)
   if [ $ss -eq 0 ] && [ "$cc" = "w" ];then up;fi
   if [ $ss -eq 1 ] && [ "$cc" = "8" ];then up;fi;;
  m)
    run="此局和棋!    ";sy1;;
  p|9) 
   if [ $ss -eq 0 ] && [ "$cc" = "p" ];then 
    sed -n 18,"$"p abc|grep "\[$a1;$a2" 2>&1  
    if [ $? -eq 0 ];then L 10 32;echo "  此处已有棋...";tput bel;sleep 1
      write=$green_b白$black_w
      sss=0
    else
       mm=`L $a1 $a2`[$color2●$black_w
      echo $mm>>abc
      write=$green_b黑$black_w
      sss=1
    fi
    sort -t"[" -n +1 abc 
    qs=7
    award;tput bel    
   fi
   if [ $ss -eq 1 ] && [ "$cc" = "9" ];then
    sed -n 18,"$"p abc|grep "\[$a1;$a2" 2>&1  
    if [ $? -eq 0 ];then L 10 32;echo "  此处已有棋...";tput bel;sleep 1
      write=$green_b黑$black_w
      sss=1
    else
       mm=`L $a1 $a2`"[$color1●$black_w"
      echo $mm>>abc
      write=$green_b白$black_w
      sss=0
    fi
    sort -t"[" -n +1 abc 
    qs=0
    award;tput bel 
   fi
    ss=$sss;;  # 落子方不允许再走,等待对方走棋
  0|])
    if [ "$cc" = "]" ];then go="白";run="白";bs=`expr $bs + 1`
      by=`expr $by + 0`
      bsy=`expr $by - $bs`
      hy=$bs;hs=$by;hsy=`expr $hy - $hs`
      sss=0
    else go="黑";run="黑";hs=`expr $hs + 1`;hy=`expr $hy + 0`
      hsy=`expr $hy - $hs`
      by=$hs;bs=$hy;bsy=`expr $by - $bs`
      sss=1
    fi
      ss=$sss  #谁投降谁下一局先走
    sy1 "棋投降啦";;
  c)
    md=$ccc    # 变换棋盘颜色
     if [ $md -eq 1 ];then
      def1=`expr substr $gray_b 3 8`;def2=`expr substr $gray_w 3 8`
      color1=`expr substr $brown_b 3 6`;color2=`expr substr $brown_w 3 6`
      sed 's/'$def1'/'$color1'/g' abc|sed 's/'$def2'/'$color2'/g' >abc.tmp
      mv abc.tmp abc
      cat abc 
      ccc=`expr $ccc + 1`
     fi    # 桔黄色
     if [ $md -eq 2 ];then
      def1=`expr substr $brown_b 3 6`;def2=`expr substr $brown_w 3 6`
      color1=`expr substr $lt_blue_b 3 8`;color2=`expr substr $lt_blue_w 3 8`
      sed 's/'$def1'/'$color1'/g' abc|sed 's/'$def2'/'$color2'/g' >abc.tmp 
      mv abc.tmp abc
      cat abc
      ccc=`expr $ccc + 1`
     fi    # 浅蓝色
     if [ $md -eq 3 ];then
      def1=`expr substr $lt_blue_b 3 8`;def2=`expr substr $lt_blue_w 3 8`
      color1=`expr substr $mage_b 3 6`;color2=`expr substr $mage_w 3 6`
      sed 's/'$def1'/'$color1'/g' abc|sed 's/'$def2'/'$color2'/g' >abc.tmp 
      mv abc.tmp abc
      cat abc
      ccc=`expr $ccc - 3`
     fi    # 紫色
     if [ $md -eq 0 ];then
      def1=`expr substr $mage_b 3 6`;def2=`expr substr $mage_w 3 6`
      color1=`expr substr $gray_b 3 8`;color2=`expr substr $gray_w 3 8`
      sed 's/'$def1'/'$color1'/g' abc|sed 's/'$def2'/'$color2'/g' >abc.tmp
      mv abc.tmp abc
      cat abc
      ccc=`expr $ccc + 1`
     fi    # 灰色
     L 2 38;echo $write;;
  esac
done
[]     
    
shell游戏:老虎机
文章整理: 文章来源: 网络 
作者：bitbull   
运行环境: 
bash 
80x24终端 
usage: 
           压码按键    赔率 
mouse       1           1 
cat         2           3 
tiger       3          10 
dragon      4          50 
跑动 
RUN:r 
取消已压的码数 
CANCEL:c 
重玩 
NEWGAME:n 
退出 
EXIT:q  
规则: 
按相应键投注,按r游戏开始,如果转盘灯最后停在玩家所压的类上,游戏将按相应赔率付筹码给玩家. 
如此反复,直到玩家破产. 
#!/bin/bash 
#-------------CopyRight------------- 
#   Name:Fruit machice casino 
#   Version Number:1.00 
#   Type:game 
#   Language:bash shell 
#   Date:2005-01-10 
#   Author:BitBull 
#   Email:wengjianyi@tom.com 
#------------Environment------------ 
#   Terminal: column 80 line 24 
#   Linux 2.4.80 i386 
#   GNU Bash 2.05b 
#-----------------------------------    
#--------------variable-------------- 
money=10 
mouse=0 
cat=0 
tiger=0 
dragon=0 
#--------------array----------------- 
#rotary_table "y x colour" 
rt[1]="3 5 46" 
rt[2]="3 13 44" 
rt[3]="3 21 42" 
rt[4]="3 29 43" 
rt[5]="3 37 42" 
rt[6]="3 45 45" 
rt[7]="7 45 43" 
rt[8]="11 45 42" 
rt[9]="15 45 46" 
rt[10]="15 37 42" 
rt[11]="15 29 43" 
rt[12]="15 21 42" 
rt[13]="15 13 44" 
rt[14]="15 5 42" 
rt[15]="11 5 43" 
rt[16]="7 5 42" 
#count_brand "y x name colour multiple" 
cb[1]="21 3 MOUSE 42 1" 
cb[2]="21 18 CAT 46 3" 
cb[3]="21 33 TIGER 44 10" 
cb[4]="21 48 DRAGON 45 50" 
cb[5]="21 63 NULL 43 0" 
#--------------function-------------- 
#echo error 
function Error () { 
   local temp 
   printf "\33[5;31m\33[11;60H$1\33[0m" 
   if read -t 1 -n 1 temp    
   then 
      printf "\33[11;60H                    " 
      continue 
   else 
      printf "\33[11;60H                    " 
   fi 
    
   return 0 
} 
#echo info 
function Info () { 
   printf "\33[5;31m\33[10;24H$1\33[0m" 
   printf "\33[5;31m\33[11;24H$2\33[0m" 
   sleep 1 
   printf "\33[10;24H                " 
   printf "\33[11;24H                " 
    
   if [ -n $3 ] 
   then 
      eval Count_brand 1 ${cb[$3]}    
   fi 
   return 0 
} 
#draw square line4 col8 
function Square () { 
   local x y colr sign txt_colr y2 y3 y4 xX 
    
   y=$1 
   x=$2 
   colr=$3 
   sign=$4 
       
   txt_colr=$(( colr - 10 )) 
   y2=$(( y + 1 )) 
   y3=$(( y + 2 )) 
   y4=$(( y + 3 )) 
   if [ $sign -eq 1 ] 
   then txt_colr=31 
   fi 
   echo -ne "\33[${txt_colr};${colr}m" 
   echo -ne "\33[${y};${x}H  OOOO  "       
   echo -ne "\33[${y2};${x}H OOOOOO " 
   echo -ne "\33[${y3};${x}H OOOOOO " 
   echo -ne "\33[${y4};${x}H  OOOO  " 
   echo -ne "\33[0m" 
    
   case $colr in 
    
      "42" ) xX=1 
      ; 
      "46" ) xX=3 
      ; 
      "44" ) xX=10 
      ; 
      "45" ) xX=50 
      ; 
      "43" ) xX=0 
      ; 
   esac 
   printf "\33[${colr}m\33[${y4};$(( x + 5 ))H %2d\33[0m" $xX 
   return 0 
} 
#draw count_brand 
function Count_brand () { 
   local staus x y name colr multiple y2 
   staus=$1 
   y=$2 
   x=$3 
   name=$4 
   colr=$5 
   multiple=$6 
   y2=$(( y + 2 )) 
    
   printf "\33[${staus};${colr}m\33[${y};${x}H   %6s   " $name 
   printf "\33[${y2};${x}H       X %2d \33[0m" ${multiple} 
   return 0 
} 
#draw screen 
function Draw_screen () { 
   local i j 
   #draw rotary_table     
   for i in $(seq 1 16) 
   do 
      Square ${rt} 0 
   done 
       
   #draw MONEY 
   echo -ne "\33[31m\33[8;64HMoney\33[0m" 
    
   #draw count_brand 
   for j in $(seq 1 5) 
   do 
      Count_brand 1 ${cb[j]} 
   done 
   echo -ne "\33[43m\33[22;63H            \33[0m"    
    
   #draw help 
   echo -ne "\33[20;3H   key:1          key:2          \ 
key:3          key:4" 
   echo -ne "\33[7;31m\33[24;1HRun:r   Cancel:c   NewGame:n   Exit:q\ 
      -- CopyRight -- 2005-01-10 BitBull --\33[0m" 
   return 0    
} 
#draw count 
function Draw_count () { 
    
   printf "\33[31m\33[9;60H%9d\33[0m" $money 
   printf "\33[42m\33[22;3H%12d" $mouse 
   printf "\33[46m\33[22;18H%12d" $cat 
   printf "\33[44m\33[22;33H%12d" $tiger 
   printf "\33[45m\33[22;48H%12d" $dragon 
   echo -ne "\33[0m" 
   return 0 
} 
#money count 
function Money_count () { 
    
   local name num 
    
   name=$2 
   num=$1 
   if [ $money -gt 0 ] 
   then 
      num=$(( num + 1 )) 
      money=$(( money - 1 )) 
      eval $name=$num 
      Draw_count 
   else 
      Error "Money = 0 !!!" 
   fi 
   return 0 
} 
#run light 
function Run_light () { 
   local count_loop count_loop_max stop_num 
    
   count_loop=1 
   count_loop_max=5 
   stop_num=16 
   while [ $count_loop -le $count_loop_max ] 
   do 
      if [ $count_loop -eq $count_loop_max ] 
      then 
         stop_num=$(( RANDOM % 16 + 1 )) 
      fi 
      while [ $lp -le $stop_num ] 
      do 
         Square ${rt[lp]} 1 
         Square ${rt[olp]} 0 
         sleep 0.04 
         olp=$lp 
         lp=$(( lp + 1 )) 
      done 
    
      lp=1 
      count_loop=$(( count_loop + 1 )) 
   done 
    
   return $stop_num 
} 
#run match 
function Result () { 
    
   local run_colr omoney class 
       
   run_colr=$(echo ${rt[$1]}|cut -d" " -f3) 
   omoney=$money 
    
   case $run_colr in 
      "42" ) money=$(( mouse + money )); class=1 
      ; 
      "46" ) money=$(( cat * 3 + money )); class=2 
      ; 
      "44" ) money=$(( tiger * 10 + money )); class=3 
      ; 
      "45" ) money=$(( dragon * 50 + money )); class=4 
      ; 
      "43" ) class=5 
      ; 
   esac 
    
   mouse=0 
   cat=0 
   tiger=0 
   dragon=0 
   if [ "$money" -eq "$omoney" ] 
   then 
      Info "Bad Luck!!!" "You lose!!" $class 
   else 
      Count_brand 5 ${cb[class]} 
      Info "Good Luck!!!" "Money +$(( money - omoney ))!!!" $class 
   fi 
   Draw_count 
   if [ "$money" -eq 0 ] 
   then 
      Game_over 
   fi 
    
   return 0 
} 
#run main 
function Run () { 
   local rl_return 
    
   if [[ ( $mouse = 0 ) && ( $cat = 0 ) && ( $tiger = 0 ) &&\ 
( $dragon = 0 ) ]] 
   then 
      Error "Invest = 0 !!!" 
   else 
      Run_light 
      rl_return=$? 
      Result $rl_return 
   fi    
    
   return 0 
} 
#game over 
function Game_over () { 
   local y_n 
   printf "\33[31;40m" 
   printf "\33[11;21H ------------------------------------------- " 
   printf "\33[12;21H|         ======>Game Over<======           |" 
   printf "\33[13;21H|         Do you want replay?<y/n>          |" 
   printf "\33[14;21H|         ======>Thank You<======           |" 
   printf "\33[15;21H ------------------------------------------- " 
   printf "\33[0m" 
    
   while read -s -n 1 y_n 
   do 
      case $y_n in 
         y ) exec $0 
         ; 
         n ) Game_exit 
         ; 
         * ) continue 
         ; 
      esac 
   done 
} 
#exit 
function Game_exit () { 
   stty $stty_save 
   stty echo 
   clear 
   trap 2 15 
   echo -ne "\33[?25h\33[0;0H\33[0m" 
   exit 0 
} 
#---------------main----------------- 
#backup stty 
stty_save=$(stty -g) 
clear 
trap "Game_exit;" 2 15 
stty -echo 
#hidden cursor 
echo -ne "\33[?25l" 
#draw screen 
Draw_screen 
#draw count 
Draw_count 
#draw red_light 
Square ${rt[3]} 1 
#light pointer 
lp=3 
olp=$(( lp - 1 )) 
#control 
while read -s -n 1 key 
do 
   case $key in 
      "1" ) Money_count $mouse mouse 
      ; 
    
      "2" ) Money_count $cat cat 
      ; 
      "3" ) Money_count $tiger tiger 
      ; 
      "4" ) Money_count $dragon dragon 
      ; 
      [rR] ) Run 
      ; 
      [cC] ) 
         money=$(( mouse + cat + tiger + dragon + money )) 
         mouse=0;cat=0;tiger=0;dragon=0 
         Draw_count 
      ; 
      [nN] ) exec $0 
      ; 
      [qQ] ) Game_exit 
      ; 
       
      * ) : 
      ; 
   esac 
done 
[]     
    
shell游戏:贪吃蛇
文章整理: 文章来源: 网络 
作者：bitbull   
由于程序运行过程中会产生己个临时文件, 
请先确定/tmp目录可写可读..如果权限不够或无此目录,请把游戏 
cpath="/tmp/snake_ctrl_pid.tmp" 
dpath="/tmp/snake_disply_pid.tmp" 
vartmp="/tmp/snake_var_tmpfile.tmp" 
改到有权限读写的目录 
测试环境: 
RHEL4 AS 
bash 3.0 
80x24终端 
usage: 
w上 s下 a左 d右 
p暂停 
n新游戏 
q退出 
规则: 
吃完屏幕上所有的红色果实即可过关,共有6个关卡.碰到任何障碍蛇都将死亡,玩家有4次生命. 
#!/bin/bash 
#-------------CopyRight------------- 
#   Name:Snake 
#   Version Number:1.00 
#   Type:game 
#   Language:bash shell 
#   Date:2005-07-28 
#   Author:BitBull 
#   Email:wengjianyi@tom.com 
#------------Environment------------ 
#   Terminal: column 80 line 24 
#   Linux 2.6.9 i686 
#   GNU Bash 3.00.15 
#----------------------------------- 
#--------------variable-------------- 
#game variable 
level=1 
score=0 
life=3 
length=8 
runtime=0.15 
fruitspare=8 
#game kernel variable 
x=2 #init snake x=2 y=2 
y=2 
direction=0 
shead=1 #snake's head in snake[] 
stail=1 #snake's tail in snake[] 
mappoint=1 #point exactmap[] bottom 
state=on #snake run or stop 
run=off  #if run=on,snake shadow is working 
displaypid="" 
controlpid="" 
#game temp file;if your system's /tmp unwrite or unread, you can change to home 
cpath="/tmp/snake_ctrl_pid.tmp" 
dpath="/tmp/snake_disply_pid.tmp" 
vartmp="/tmp/snake_var_tmpfile.tmp" 
#rename kill sign 
pause=23 
newgame=24 
gameover=25 
gameexit=26 
up=27 
down=28 
left=29 
right=22 
#---------------array---------------                                            
#init exactmap 
exactmap=() 
#map format: y x HowLong "-- or |" ( 1=| 2=-- ) 
map1=("6 14 6 2" "6 50 6 2" "14 14 6 2" "14 50 6 2") 
map2=("2 16 10 1" "2 48 10 1" "7 32 10 1" "7 64 10 1") 
map3=("4 16 24 2" "10 16 24 2" "16 16 24 2" "4 16 11 1") 
map4=("10 4 34 2" "4 20 12 1" "4 40 12 1" "4 60 12 1") 
map5=("5 10 29 2" "15 10 29 2" "5 16 7 1" "7 60 6 1" ) 
map6=("8 4 35 2" "2 50 5 1" "10 4 36 2" "11 30 5 1" ) 
#where is fruit? format:y x 
fruit1=("14 10" "13 56" "2 40" "3 8" "17 50" "18 76" "14 30" "6 66") 
fruit2=("4 14" "2 40" "14 48" "12 68" "9 30" "18 6" "3 76" "18 78") 
fruit3=("7 14" "18 4" "15 40" "11 24" "5 18" "9 56" "3 76" "17 64") 
fruit4=("11 10" "11 62" "9 38" "9 72" "6 58" "14 26" "17 58" "3 6") 
fruit5=("6 14" "16 14" "3 40" "6 22" "14 58" "12 34" "8 50" "9 62") 
fruit6=("2 52" "7 40" "7 60" "4 70" "11 28" "11 32" "15 22" "17 78" ) 
#--------------function-------------- 
#draw screen 
function Draw_line () { 
local i=1 
while [ "$i" -le "80" ] 
do 
echo -ne "\33[${1};${i}H*" 
(( i++ )) 
done 
} 
function Draw_row () { 
local i=2 
while [ "$i" -le "22" ] 
do 
echo -ne "\33[${i};${1}H*" 
(( i++ )) 
done 
} 
function Draw_help () { 
echo -ne "\33[7;31m\33[24;1HPlay:w s a d Pause:p Newgame:n Quit:q      -- CopyRight -- 2005-07-28 BitBull --\33[0m" 
} 
function Screen () { 
        echo -ne "\33[37;44m" 
        Draw_line 1 
        Draw_line 19 
        Draw_line 23 
        Draw_row 1 
        Draw_row 80 
        echo -ne "\33[0m" 
        Draw_help 
} 
#init 
function Init () { 
        stty_save=$(stty -g) #backup stty 
        clear 
        trap "Game_exit;" 2 15 
        stty -echo 
        echo -ne "\33[?25l"  #hidden cursor 
} 
#exit 
function Game_exit () { 
    kill -9 $displaypid>/dev/null 2>&1 #kill display function 
#restore 
stty $stty_save 
stty echo 
clear 
trap 2 15 
echo -ne "\33[?25h\33[0;0H\33[0m" 
rm -f $cpath $dpath >/dev/null 2>&1 
exit 0 
} 
#draw level score life SnakeLong 
function Draw_ls () { 
        echo -ne "\33[31m" 
        echo -ne "\33[21;10HLevel=$level         Score=$score        \ 
 Life=$life        Snake=$length" 
        echo -ne "\33[0m" 
} 
#output info to player 
function Info () { 
title="$1" 
content="$2" 
greeting="$3" 
        printf "\33[31m" 
        printf "\33[11;20H ------------------------------------------- " 
        printf "\33[12;20H|         ======>$title<======           |" 
        printf "\33[13;20H|         $content          |" 
        printf "\33[14;20H|         ======>$greeting<======           |" 
        printf "\33[15;20H ------------------------------------------- " 
        printf "\33[0m" 
} 
#square:draw square in screen.you can define X Y COLOR LETTER 
function Square () { 
local color=$1;line=$2;row=$3;pic=$4 
echo -ne "\33[34444;${color}m\33[${line};${row}H${pic}\33[0m" 
} 
#show fruit 
function Show_fruits () { 
local red=45;fruitxy="" 
for (( i = 0; i < 8; i++ )) 
do 
fruitxy="$(printf "\${fruit%s[$i]}" $level)" 
eval Square $red $fruitxy '@@'  
done 
} 
#exact map:calculate mapXY into exactmap[] 
function Exact_map () { 
local mapin xtmp ytmp long line_row 
for (( i = 0; i < 4; i++ )) 
do 
mapin="$(printf "\${map%s[$i]}" $level)" 
xtmp=$(eval echo $mapin|cut -d" " -f2) 
                ytmp=$(eval echo $mapin|cut -d" " -f1) 
                long=$(eval echo $mapin|cut -d" " -f3) 
                line_row=$(eval echo $mapin|cut -d" " -f4) 
exactmap[$mappoint]="$ytmp $xtmp" 
(( mappoint++ )) 
#judge mapline | or -- 
if [[ "$line_row" == "1" ]] 
then 
for (( j = 0; j <= long; j++ )) 
do 
(( ytmp++ )) 
exactmap[$mappoint]="$ytmp $xtmp" 
(( mappoint++ )) 
done 
else 
for (( k = 0; k <= long; k++ )) 
do 
(( xtmp += 2 )) 
exactmap[$mappoint]="$ytmp $xtmp" 
(( mappoint++ )) 
done 
fi 
done 
} 
#show map 
function Show_map () { 
local mapxy="";blue=46 
Exact_map 
for (( i = 1; i < mappoint; i++ )) 
do 
eval Square $blue ${exactmap[$i]} '[]'  
done 
} 
#test snake is ok ? 
function Test_snake () { 
#snake self 
for (( i = 1; i <= length; i++ )) 
do 
if [[ "${snake[$i]}" == "$y $x" ]] 
then Dead 
fi 
done 
#borderline 
if [[ $x -lt 2 || $x -gt 79 || $y -lt 2 || $y -gt 18 ]] 
then Dead  
fi 
#map line 
for (( i = 0; i < mappoint; i++ )) 
do 
if [[ "${exactmap[$i]}" == "$y $x" ]] 
then Dead 
fi 
done 
} 
#eat 
function Eat () { 
local fruitxy="";xyvalue="";nowarray="" 
for (( i = 0; i < 8; i++ )) 
do 
fruitxy="$(printf "\${fruit%s[$i]}" $level)" 
xyvalue="$(eval echo $fruitxy)" 
if [[ "$xyvalue" = "$y $x" ]] 
then 
nowarray="$(printf "fruit%s[$i]=" $level)" 
eval $nowarray"" 
(( score++ )) 
(( fruitspare-- )) 
Draw_ls 
fi 
done 
if [[ $fruitspare == 0 ]] 
then Next_level 
fi 
} 
#if snake dead 
function Dead () { 
state=off 
if (( "$life" == "0" )) 
then 
kill -$gameover $controlpid  
else  
(( life-- )) 
Info "SnakeDead" "OH!shit!You are a idiot!" "F**k  You" 
sleep 1 
New_game 
fi 
} 
#next level 
function Next_level () { 
(( level++ )) 
(( length += 6 )) 
if [[ $level -gt 6 ]] 
then 
Info "Well Done" "   WOW!Congratulation!  " "Thank You" 
sleep 4 
kill -$gameexit $controlpid 
else 
Info "Well Done" "Level Update! Go Level $level" ".Loading." 
sleep 3 
New_game 
fi 
} 
#newgame 
function New_game () { 
kill -9 $displaypid >/dev/null 2>&1 
if [[ "$1" == "over" ]] 
then  
exec $0 
else 
echo "$level $score $life $length $runtime" > $vartmp 
exec $0 display 
fi 
} 
#game over 
function Game_over () { 
local y_n 
Info "Game Over" "Do you want replay?<y/n>" "Thank You" 
while read -s -n 1 y_n 
do 
case $y_n in 
[yY] ) New_game over  
;; 
[nN] ) Game_exit 
;; 
* ) continue 
;; 
esac 
done 
} 
#main 
function Main () { 
local green=42;count=0 
case $direction in 
"$up" ) (( y-- )) 
;; 
"$down" ) (( y++ )) 
;; 
"$left" ) (( x -= 2 )) 
;; 
"$right" ) (( x += 2 )) 
;; 
*): 
;; 
esac 
Test_snake 
Eat 
#go go go 
Square $green $y $x \#\# 
snake[$shead]="$y $x" 
(( shead++ )) 
if [[ "$shead" == "$length" ]] 
then 
shead=1 
run=on #snake shadow run 
fi 
#snake shadow,it can erase snake's tail,otherwise,snake will very long! 
if [[ "$run" == "on" ]] 
then 
Square 0 ${snake[$stail]} "  " 
(( stail++ )) 
if [[ "$stail" == "$length" ]] 
then  
stail=1 
fi 
fi 
} 
#state change:off=snake stop.on=snake run 
function State_change () { 
if [[ $state == "on" ]] 
then state=off 
else state=on 
fi 
} 
#display 
function Display () { 
trap "State_change;" $pause 
trap "direction=$up;" $up 
trap "direction=$down;" $down 
trap "direction=$left;" $left 
trap "direction=$right;" $right 
echo $$ > $dpath 
read controlpid < $cpath 
if [[ -e $vartmp ]] 
then 
read level score life length runtime< $vartmp 
rm -f $vartmp 
fi 
#drow all 
Init                                                               
Screen 
Draw_ls 
Show_fruits 
Show_map 
Main 
#game main loop 
while : 
do 
if [[ ( "$state" == "on" ) && ( "$direction" != "0" ) ]] 
then  
Main 
sleep $runtime 
fi 
done 
} 
#control 
function Control () { 
local sign="" 
echo $$ > $cpath 
trap "Game_over;" $gameover  
trap "Game_exit;" $gameexit  
while read -s -n 1 key 
do 
case $key in 
[wW]) sign="$up"  
;; 
[sS]) sign="$down" 
;; 
[aA]) sign="$left" 
;; 
[dD]) sign="$right" 
;; 
[pP]) sign="$pause" 
;; 
[nN]) New_game over 
;; 
[qQ]) Game_exit 
;; 
* ) continue 2 
;; 
esac 
eval displaypid=$(cat $dpath) 
kill -$sign $displaypid 
done 
} 
#------------main---------------- 
if [[ "$1" == "display" ]] 
then 
Display 
exit 
else  
bash $0 display& 
Control 
exit 
fi 
[]     
    
shell游戏:扫雷
文章整理: 文章来源: 网络 
作者：bitbull   
运行环境: 
bash 
80x24终端 
usage: 
$chmod 755 mine.sh 
$./mine.sh 
按1-3选择对应难度,4退出 
方向: 
上:w 下:s 左:a 右:d 
标识地雷: 
FLAG:f 
挖: 
DIG:j 
重玩 
NEWGAME:n 
退出 
EXIT:x  
规则: 
玩家可用方向键移动指针,按j挖雷,若挖到地雷,则游戏结束.否则,游戏将在你所挖方块内显示该方块周围8个方块内所有地雷数.若怀疑某方块为地雷,可按f键进行标识,以避免误挖.挖开地图内所有非雷方块则获胜. 
#!/bin/bash 
#-------------CopyRight------------- 
#   Name:Mine Sweeping 
#   Version Number:1.00 
#   Type:game 
#   Language:bash shell 
#   Date:2005-10-26 
#   Author:BitBull 
#   Email:BitBull.cn(at)gmail.com 
#------------Environment------------ 
#   Terminal: column 80 line 24 
#   Linux 2.6.9 i686 
#   GNU Bash 3.00.15 
#----------------------------------- 
#---------------Define-------------- 
ECHO="echo -ne" 
ESC="\033[" 
OK=0 
FALSE=1 
#--------------Variable-------------- 
#ANSI ESC action 
FLASH=5 
REV=7 
#color 
NULL=0 
BLACK=30 
RED=31 
GREEN=32 
ORANGE=33 
BLUE=34 
PURPLE=35 
SBLUE=36 
GREY=37 
#back color 
BBLACK=40 
BRED=41 
BGREEN=42 
BORANGE=43 
BBLUE=44 
BPURPLE=45 
BSBLUE=46 
BGREY=47 
MINE='@' 
FLAG='F' 
NUL=' ' 
SHADOW='X' 
X=0 
Y=0 
CurX=1 #cur's X 
CurY=1 #cur's Y 
OCurX=1 #old cur's X 
OCurY=1 #old cur's Y 
MCount=0 #count mine 
FCount=0 #count flag 
SCount=0 #count shadow 
MXYp=0 #MXY Array's ptr 
#---------------Array---------------- 
#if ${XY[]} == M { mine } 
#if ${XY[]} == F { flag } 
#if ${XY[]} == N { null } 
#if ${XY[]} == S { shadow } 
#if ${XY[]} == [1-8] { tip_num } 
#${XY[]} init in XYInit(i) 
MXY[0]="" 
#--------------Function-------------- 
function SttyInit () 
{ 
stty_save=$(stty -g) #backup stty 
clear 
trap "GameExit;" 2 15 
stty -echo 
$ECHO "${ESC}?25l" #hidden cursor 
return $OK 
} 
function GameExit () 
{ 
stty $stty_save 
stty echo 
clear 
trap 2 15 
$ECHO "${ESC}?25h${ESC}0;0H${ESC}0m" 
exit $OK 
} 
#print help 
function Help () 
{ 
msg="Move:w s a d Dig:j Flag:f NewGame:n Exit:x   --CopyRight-- -2005-10-28 BitBull--" 
$ECHO "${ESC}${REV};${RED}m${ESC}24;1H${msg}${ESC}${NULL}m" 
return $OK 
} 
#print dialog window in screen 
function PMsg () 
{ 
local title="$1" content="$2" greeting="$3" 
        $ECHO "${ESC}${RED}m" 
        $ECHO "${ESC}11;20H ------------------------------------------- " 
        $ECHO "${ESC}12;20H|         ======>$title<======           |" 
        $ECHO "${ESC}13;20H|         $content          |" 
        $ECHO "${ESC}14;20H|         ======>$greeting<======           |" 
        $ECHO "${ESC}15;20H ------------------------------------------- " 
        $ECHO "${ESC}${NULL}m" 
return $OK 
} 
#print menu and player choose level,then ${X,Y,MCount,FCount,SCount} init 
function Menu () 
{ 
local key 
$ECHO "${ESC}6;1H${ESC}${RED}m" 
cat<<MENUEND 
                       +++++++++++++++++++++++++++++ 
                       +        (1) Easy           + 
                       +        (2) Normal         + 
                       +        (3) Hardly         + 
                       +        (4) Exit           + 
                       +++++++++++++++++++++++++++++ 
MENUEND 
$ECHO "${ESC}${NULL}m" 
while read -s -n 1 key 
do 
case $key in 
1) X=10;Y=10;MCount=10;FCount=10;SCount=100;break 
;; 
2) X=20;Y=14;MCount=28;FCount=28;SCount=280;break 
;; 
3) X=36;Y=18;MCount=65;FCount=65;SCount=648;break 
;; 
4) GameExit 
;; 
esac 
done 
return $OK 
} 
#receive CurX CurY,put it into XY[CurX+X*(CurY-1))] 
#if $# == 3;write into XY[] 
#if $# == 2;read from XY[] 
function XYFormat () 
{ 
local XTmp=$1 YTmp=$2 
if [[ $# -eq 3 ]] 
then XY[$XTmp+$X*($YTmp-1)]=$3 
else echo ${XY[$XTmp+$X*($YTmp-1)]} 
fi 
return $OK 
} 
function DrawInit () 
{ 
local DIline DIline2 
DIline=$( for (( i=1; i<$((X*2)); i++ )) do $ECHO '-';done ) 
DIline2=$( for (( i=0; i<X; i++ )) do $ECHO "|${ESC}${SBLUE}mX${ESC}${NULL}m";done ) 
clear 
Help 
$ECHO "${ESC}1;1H+${DIline}+" 
for (( i=0; i<Y; i++ )) 
do 
$ECHO "${ESC}$((i+2));1H${DIline2}|" 
done 
$ECHO "${ESC}$((Y+2));1H+${DIline}+" 
return $OK 
} 
#${XY[*]}=S 
function XYInit () 
{ 
for (( i=1; i<=$X; i++ )) 
do 
for (( j=1; j<=$Y; j++ )) 
do 
XYFormat $i $j S 
done 
done 
return $OK 
} 
#check X Y 
function CheckXY () 
{ 
local XYTmp="$1 $2" 
for(( i=0; i<MXYp; i++ )) 
do 
if [[ "${MXY}" == "$XYTmp" ]] 
then return $FALSE 
fi 
done 
return $OK 
} 
#RANDOM mine's X Y 
function XYRand () 
{ 
local XTmp YTmp 
for(( i=0; i<MCount; i++ )) 
do 
while :  
do 
XTmp=$(( RANDOM % ( X - 1 ) + 1 )) 
YTmp=$(( RANDOM % ( Y - 1 ) + 1 )) 
CheckXY $XTmp $YTmp 
if [[ "$?" == "$OK" ]] 
then 
XYFormat $XTmp $YTmp M 
MXY="$XTmp $YTmp" 
(( ++MXYp )) 
break 
else continue 
fi 
done 
done 
return $OK 
} 
#DEBUG 
# print ${XY[*]} into ./mine.tmp 
#you can read mine.tmp to know where is mine,xixi~~:) 
#M is mine 
function DEBUGPXY () 
{ 
rm mine.tmp>/dev/null 2>&1 
for(( i=1; i<=$Y; i++ )) 
do 
for(( j=1; j<=$X; j++)) 
do 
$ECHO "$(XYFormat $j $i)">>mine.tmp 
done 
$ECHO "\n">>mine.tmp 
done 
return $OK 
} 
#move cur 
#usage:CurMov [UP|DOWN|LEFT|RIGHT] 
function CurMov () 
{ 
local direction=$1 Xmin=1 Ymin=1 Xmax=$X Ymax=$Y 
OCurX=$CurX 
OCurY=$CurY 
case $direction in 
"UP") if [[ $CurY -gt $Ymin ]];then (( CurY-- ));fi 
;; 
"DOWN") if [[ $CurY -lt $Ymax ]];then (( CurY++ ));fi 
;; 
"LEFT") if [[ $CurX -gt $Xmin ]];then (( CurX-- ));fi 
;; 
"RIGHT")if [[ $CurX -lt $Xmax ]];then (( CurX++ ));fi 
;; 
esac 
if [[ $CurX != $OCurX || $CurY != $OCurY ]] 
then DrawPoint $CurX $CurY CUR 
fi 
return $OK 
} 
#display point 
#include cur,flag,mine,shadow,nul,tip [1-8] 
function DrawPoint () 
{ 
local TCurX=$(( $1 * 2 )) TCurY=$(( $2 + 1 )) Type=$3 
local TOCurX=$(( OCurX * 2 )) TOCurY=$(( OCurY + 1 )) 
local colr=0 osign=0 sign=0 
case $Type in 
"CUR") 
case $(XYFormat $OCurX $OCurY) in 
F) colr=$PURPLE;osign=$FLAG;; 
N) colr=$NULL;osign=$NUL;; 
[1-8]) colr=$ORANGE;osign=$(XYFormat $OCurX $OCurY);; 
[SM]) colr=$SBLUE;osign=$SHADOW;; 
esac 
case $(XYFormat $CurX $CurY) in 
F)      sign=$FLAG;; 
N)      sign=$NUL;; 
[1-8]) sign=$(XYFormat $CurX $CurY);; 
[SM])     sign=$SHADOW;; 
esac 
$ECHO "${ESC}${colr}m${ESC}${TOCurY};${TOCurX}H${osign}${ESC}${NULL}m" 
$ECHO "${ESC}${REV};${FLASH};${ORANGE}m${ESC}${TCurY};${TCurX}H${sign}${ESC}${NULL}m" 
;; 
"SHADOW") 
$ECHO "${ESC}${SBLUE}m${ESC}${TCurY};${TCurX}H${SHADOW}${ESC}${NULL}m" 
;; 
"MINE")  
$ECHO "${ESC}${REV};${RED}m${ESC}${TCurY};${TCurX}H${MINE}${ESC}${NULL}m" 
;; 
"FLAG") 
$ECHO "${ESC}${TCurY};${TCurX}H${ESC}${PURPLE}m${FLAG}${ESC}${NULL}m" 
;; 
[1-8]) 
$ECHO "${ESC}${TCurY};${TCurX}H${ESC}${ORANGE}m${Type}${ESC}${NULL}m" 
;; 
"NUL") 
$ECHO "${ESC}${TCurY};${TCurX}H${NUL}" 
esac 
return $OK 
} 
#check xy 
function Loop () 
{ 
local XYTmp="$1 $2" 
for (( i=0; i<MXYp; i++ )) 
do 
if [[ "$XYTmp" == "${MXY}" ]] 
then $ECHO 1 
fi 
done 
return $OK 
} 
#count around mine 
#A B C 
#D X E 
#F G H 
#return mine's number 
function CountM () 
{ 
local Xmin=1 Ymin=1 Xmax=$X Ymax=$Y minecount=0 n=0 
#A 
if [[ ( $CurX -gt $Xmin ) && ( $CurY -gt $Ymin ) ]] 
then 
n=$( Loop $((CurX-1)) $((CurY-1)) ) 
(( minecount += n )) 
n=0 
fi 
#B 
if [[ $CurY -gt $Ymin ]] 
then 
n=$( Loop $CurX $((CurY-1)) ) 
(( minecount += n )) 
n=0 
fi 
#C 
if [[ ( $CurX -lt $Xmax ) && ( $CurY -gt $Ymin ) ]] 
then 
n=$( Loop $((CurX+1)) $((CurY-1)) ) 
(( minecount += n )) 
n=0 
fi 
#D 
if [[ $CurX -gt $Xmin ]] 
then 
n=$( Loop $((CurX-1)) $CurY ) 
(( minecount += n )) 
n=0 
fi 
#E 
if [[ $CurX -lt $Xmax ]] 
then 
n=$( Loop $((CurX+1)) $CurY ) 
(( minecount += n )) 
n=0 
fi 
#F 
if [[ ( $CurX -gt $Xmin ) && ( $CurY -lt $Ymax ) ]] 
then 
n=$( Loop $((CurX-1)) $((CurY+1)) ) 
(( minecount += n )) 
n=0 
fi 
#G 
if [[ $CurY -lt $Ymax ]] 
then  
n=$( Loop $CurX $((CurY+1)) ) 
(( minecount += n )) 
n=0 
fi 
#H 
if [[ ( $CurX -lt $Xmax ) && ( $CurY -lt $Ymax ) ]] 
then 
n=$( Loop $((CurX+1)) $((CurY+1)) ) 
(( minecount += n )) 
n=0 
fi 
return $minecount 
} 
#dig 
#if mine ,gameover 
#else tip around mine's number 
function Dig () 
{ 
local key minenum=0 
case $(XYFormat $CurX $CurY) in 
M) 
DrawPoint $CurX $CurY MINE 
read -s -n 1 key 
GameOver "Game Over" 
;; 
S) 
CountM 
minenum=$? 
if [[ $minenum -eq $NULL ]] 
then 
XYFormat $CurX $CurY N 
DrawPoint $CurX $CurY NUL 
else 
XYFormat $CurX $CurY $minenum 
DrawPoint $CurX $CurY $minenum 
fi 
(( SCount-- )) 
if [[ $SCount -eq $MCount ]] 
then GameOver "Well Done" 
fi 
;; 
esac 
DrawPoint $CurX $CurY CUR 
return $OK 
} 
#draw flag's number 
function DrawFCount () 
{ 
$ECHO "${ESC}22;34H${ESC};${PURPLE}mFLAG=${FCount}  ${ESC}${NULL}m" 
} 
#sign mine 
function Flag () 
{ 
local XYTmp="$CurX $CurY";stat=$FALSE 
case $(XYFormat $CurX $CurY) in 
F) 
for (( i=1; i<MXYp; i++ )) 
do 
if [[ "${MXY}" == "$XYTmp" ]] 
then XYFormat $CurX $CurY M;stat=$OK;break 
fi 
done 
if [[ $stat == $FALSE ]] 
then XYFormat $CurX $CurY S 
fi 
DrawPoint $CurX $CurY SHADOW 
(( FCount++ )) 
DrawFCount 
;; 
[SM]) 
if [[ $FCount -eq $NULL ]] 
then return $FALSE 
fi 
DrawPoint $CurX $CurY FLAG 
XYFormat $CurX $CurY F 
(( FCount-- )) 
DrawFCount 
;; 
esac 
DrawPoint $CurX $CurY CUR 
return $OK 
} 
function GameOver () 
{ 
local key msgtitle=$1 
PMsg "$msgtitle" "Do you want replay?<y/n>" "Thank You" 
while read -s -n 1 key 
do 
case $key in 
[yY]) exec $(dirname $0)/$(basename $0);; 
[nN]) GameExit;; 
*) continue;; 
esac 
done 
return $OK 
} 
#main 
#drawscreen and control 
function Main () 
{ 
local key 
XYInit 
XYRand 
############################ 
# if you enable DEBUGPXY, 
#you can know where is mine 
# DEBUGPXY  #delete this line's # 
#then cat ./mine.tmp 
############################ 
DrawPoint $CurX $CurY CUR 
DrawFCount 
while read -s -n 1 key 
do 
case $key in 
[wW]) CurMov UP;; 
[sS]) CurMov DOWN;; 
[aA]) CurMov LEFT;; 
[dD]) CurMov RIGHT;; 
[jJ]) Dig;; 
[fF]) Flag;; 
[nN]) exec $(dirname $0)/$(basename $0);; 
[xX]) GameExit;; 
esac 
done 
return $OK 
} 
#---------------Main----------------- 
SttyInit 
Menu #X Y MCount FCount SCount OK! 
DrawInit 
Main 
[]     
    
初学者入门教程：Shell编程概述（一）
文章整理: 文章来源: 网络 
作者：hrbpost   
1.1 Shell编程概述 
shell程序是一个包含UNIX命令的普通文件，这个文件的许可权限至少应该为可读和可执行。在shell提示符下键入文件名就可执行shell程序，数据可以通过三种方式传送到shell程序 
－环境变量 
－命令行参数 
－用户的输入 
hell是一个命令解释器，它会解释你在命令提示符下输入的命令。但是，你可能有一组想要多次执行的命令。shell提供了一种功能，让你将这组命令存放在一个文件中，然后你可以象unix系统提供的其他程序一样执行这个文件。这个命令文件就叫做shell程序或者shell脚本。当你运行这个文件，它会象你在命令行输入这些命令一样地执行这些命令。 
为了让shell读取你的shell程序并且执行，shell必须能够读取并能够执行每一行命令。因此，shell脚本的许可权限必须被设置为可读和可执行。为了让shell可以找到你的程序，你可以选择输入完全路径名，或者将这个脚本的路径放在于你的PATH环境变量指定的路径列表中。许多的用户会在他们的HOME目录下创建一个bin目录来存放他们自己开发的script，然后将$HOME/bin加入到他们的PATH环境变量中。 
你可以写出非常复杂的shell脚本，因为shell支持变量，命令行参数，交互式输入，tests（判断））,branches（分支），和loops（循环）。 
1.2 shell程序举例: 
$ cat myprog
#this is the program myprog
date
ls CF
$ myprog
要创建一个shell程序，考虑进行以下步骤： 
$ vi myprog 　　　　　
一个包含shell命令的程序。
＃this is the program myprog
date 
ls CF
$ chmod +x myprog 
增加文件的执行模式
$ myprog
Thu Jul 11 11:10 EDT 1994
F1 f2 memo/ myprog*
首先使用一个文本编辑器来创建一个shell程序myprog。在程序执行之前，这个文件必须被赋予可执行的权限。然后在命令提示符下输入这个程序名。如上例所示，当myprog执行的时候，一个子shell会被创建。 
这个子shell会从shell程序文件myprog读取输入而不是从命令行。这个shell中的每个命令的执行都会创建一个子shell。一旦所有的命令都被执行，所有的子shell会中止，然后会返回到原始的父shell。 
Shell程序中的注释： 
推荐在shell程序中提供注释语句来注明程序的内容。注释由一个#符号开始。Shell不会去执行任何在＃之后的语句。#能够出现在命令行的任何位置。 
注意：你不可以给shell程序取名为test因为test是一个内部的shell命令。 
1.3 传递数据给shell程序: 
$ color = lavender
$ cat color1
echo you are now running program: color1
echo the value of the variable color is : $color
$ chmod +x color1
$ color1
you ar now running program : color1
the value of the variable color is :
$ export color
$ color1
you are now running program : color1
the value of the variable color is : lavender
传递数据给shell脚本的一种方法就是通过环境。在上例中。本地变量color被赋值为lavender。然后创建了shell程序color1；然后更改为可执行权限；然后这个shell程序被执行。color1试图回送color变量的值。 
但是，由于color是一个本地变量，属于父shell私有的，运行color1产生的子shell不能识别这个变量，因此不能打印出它的值。当color被输出到环境中，它就可以被子shell读取。 
同样，由于shell进程不能够更改父进程的环境，对一个子进程中的环境变量重新赋值不会影响到父进程环境中的值。如以下的shell脚本中的color2。 
echo The original value of
the variable color is $color
ech0 This program will set
the value of color to amber
color=amber
echo The value of color is now $color
echo When your program concludes,
display the value of the color variable
观察在你设置了color的值后有什么变化。输出这个变量，然后执行color2: 
$ export color=lavender
$ echo $color
lanvender
$ color2
The original value of the
variable color is lavender
The program will set the
value of color to amber
The value of volor is now amber
When your progam concludes,
display the value of the color variable,
$ echo $color
lanvender
1.4 shell 程序的参数 
命令行： 
$ sh_program arg1 arg2 . . . argx
　　　$0 　　　$1　　 $2 ....　 $X
例子： 
$ cat color3
echo you are now running program: $0
echo The value of command 
line argument \#1 is: $1
echo The value of command 
line argument \#2 is : $2
$ chmod +x color3
$ color3 red green 
You are now running program: color3
The value of command line argument 
#1 is : red
The value of command line argument
#2 is: green
大多数的UNIX系统命令可以接收命令行参数，这些参数通常告诉命令它将要操作的文件或目录（cp f1 f2），另外指定的参数扩展命令的能力（ls Cl）,或者提供文本字符串（banner hi there） 
命令行参数同样对shell程序有效。这在于传送信息给你的程序的时候十分方便。通过开发一个接收命令行参数的程序，你可以传递文件或者目录命令名给你的程序处理，就像你运行UNIX系统命令一样。你也可以定义命令行选项来让命令行使用shell程序额外的功能。 
在shell程序中的命令行参数与参数在命令行的位置相关。这样的参数被称为位置参数，因为对每一个特殊变量的赋值依靠一这些参数在命令行中的位置。这些变量的变量名对应它们在命令行中的数字位置，因此这些特殊的变量名为数字0,1,2等等，一直到最后的参数被传递。 
变量名的存取通过同样的方法，在名字前面加上$ 符号，因此，为了存取你的shell程序中的命令行参数，你可以应用$0,$1,$2等等。在$9以后，必须使用括号：$(10),$(11)，否则，shell会将$10看成是$1后面跟一个0。$0会一直保存程序或命令的名字。 
以下的shell程序会安装一个程序，这个程序作为一个命令行参数被安装到你的bin目录：首先创建程序my_install,注意目录$HOME/bin应该预先存在。 
$ cat > my_install
echo $0 will install 
$1 to your bin directory
chmod +x $1
mv $1 $HOME/bin
echo Installation of $1 is complete
ctrl + d
$ chmod +x my_intalll
$ my_install color3
my_install will install color3
to your bin directory
Installation of color3 is complete
$
这个例子中，一个程序指明第一个命令行参数为一个文件名，然后加上执行权限，然后移动到你当前目录下的bin目录下。 
记住UNIX系统的惯例是存贮程序在一个叫做bin的目录下。你也许想要在你的HOME目录下创建一个bin目录，在这个目录下你可以存储你的程序文件，记住要将你的bin目录放在PATH环境变量中，这样shell才会找到你的程序。 
[]     
    
初学者入门教程：Shell编程概述（二）
文章整理: 文章来源: 网络 
作者：hrbpost  
1.5 一些特殊shell变量－ ＃和* 
# 　命令行参数的数量 
* 　完全的参数字符串 
例子：
$ cat color4
echo There are $＃　
comand line argument
echo They are $*
ehco The first command line argument is $1
$ chmod +x color4
$ color4 red green yellow blue
They are 4 command line arguments
They are red green yellow blue
The first command line argument is red
$
至今为止我们看到的shell程序都不是很灵活。color3需要两个正确的参数，而my_install只需要一个。通常在你创建一个接收命令行参数的shell程序的时候，你想要用户输入一个参数的变量号码。你同时要程序执行成功，不管用户键入1个参数或是20个参数。 
当处理变量参数列表的时候，特殊shell变量会提供你许多的灵活性。通过$#你可以知道有多少参数已经被输入，通过$*可以存取全部的参数列表，而不管参数的数量。请注意参数（$0）不在$*这个参数列表里。 
每一个命令行参数都是互相独立的，你可以通过$*集中检索这些参数，也可以通过$1,$2,$3等等来独立的检索这些参数。一个可以接收多个命令行参数的安装程序的例子： 
$ cat > my_install2
echo $0 will install $# 
files to your bin directory
echo The files to be installed are : $*
chmod +x $*
mv $* $HOME/bin
echo Installaton is complete
ctril + d
$ chmod +x my_install2
$ my_install2 color1 color2
my_intall2 will install 2 
files to your bin directory
The files to be installed are: color1,color2
Intallaiton is complete
这个安装程序更加灵活。如果你有几个脚本要安装，你仅仅需要执行这个程序一次，只要输入多个名字即可。非常重要的是：如果你计划传递整个参数的字符串给一个命令，这个命令必须能够接收多个参数。 
在以下的脚本中，用户提供一个目录名作为一个命令行参数。程序会更改到指定的目录，显示当前的位置，并且列出内容。 
$ cat list_dir 
cd $*
echo You are in the $(pwd) directory
echo The contents of the directory are:
ls CF
$ list_dir dir1 dir2 dir3
h: cd: bad argument count
由于cd命令不能同时进入到多个目录中，这个程序会发生错误。 
1.6 shift 命令 
向左移动所有的在*中的字符串n个位置 
#的数目减少n个（n的默认值是1） 
语法：shift [n] 
例子： 
$ cat color5
orig_args=$*
echo There are $# 
command line arguments
echo They are $*
echo Shifting two arguments
hift 2
echo There are $# 
comand line arguments
echo They are $*
echo Shifting two arguments
hift 2; final_args=$*
echo Original arguments are: $orig_args
echo Final arguments are: $final_args
hift命令会重新分配命令行参数对应位置参数，在shift n以后，所有的*中的参数会向左移动n个位置。同时＃会减n。默认的n为1。Shift命令不会影响到参数0的位置。 
一旦你完成一次移动，被移动出命令行的参数会丢失。如果你想在你的程序中引用这个参数，你需要在执行shift之前存贮这个参数。 
Shift命令被用在：存取一组参数的位置，例如一系列的x,y的坐标从命令行删除命令选项，假定选项在参数之前。例子： 
$ color5 red green yellow orange black
There are 6 command line arguments
They are red green yellow blue orange black
Shifting two arguments
There are 4 command line arguments
They are yellow blue orange black
Shiftging two arguments
Original arguments are: 
red green yellow blue orange black
Final argument are : orange black
$
1.7 read 命令 
语法： 
read variable [variable......]
例子： 
$ cat color6
echo This program prompts for user input
echo “please enter your
favorite two colors -> \c”
read color_a color_b
echo The colors you entered are: 
$color_b $color_a
$ chmod +x color6
$ color6
This program prompts for user input 
Please enter your favorite two colors -> red blue
The colors you entered are: blue red
$ color6
This program prompts for user input
Please enter you favorite two colors -> red blue tan
The color you enterd are :blue tan red
用户使用命令行参数传递信息进程序，在命令执行之前，用户必须知道正确的语法。有一种情况，你想要在用户执行程序的时候提示他输入这些参数。read命令就是用来在程序执行的时候收集终端键入的信息。 
你通常会想要使用echo命令来提供用户一个提示，让他知道程序正在等待一些输入，同时通知用户应该输入的类型。因此，每一个read命令应该在echo命令前面。 
read命令会给出一个变量名的列表，这些变量会被用户在提示符下输入的词赋值。（以空格分隔）。如果read命令定义的变量比输入的词要多，剩余变量会被赋空值。如果用户输入的词要比变量多，剩余的数据会赋给列表中的最后一个变量。 
一旦被赋值，你就可以象其他的shell变量一样存取这些变量。 
注意：不要混淆位置参数和变量read。位置参数在命令被激活时在命令行中定义，read命令给变量赋值是在程序执行之中，通过对输入提示的响应而给变量赋值。 
以下例子提示用户输入要被安装的文件名： 
$ cat > my_install3
echo $0 will install files into your bin directory
echo “Enter the names of the files -> \c”
read filenames
mv $filenames $HOME/bin
echo Instllation is complete
ctrl + d
$ chmod +x my_install13
$ my_install13
my_install13 will install files into your bin directory
Enter the names of the files -> f1 f2
Installaton is complete
这个安装会提示用户输入chmod和移动到$HOME/bin的文件名。这个程序给用户更多的关于应该输入数据情况的指引。而不像install2中用户必须在命令行中提供文件名。用户使用程序不需要特殊的语法。程序让用户确切地知道要输入什么。所有的输入的文件名都会被赋值给变量filenames。 
1.8 另外的技术 
＃号开始的文档为注释部分。 
h shell_program argumetns　 
hell_program 的属性可以不是可执行的。 
hell_program 必须是可读的。 
h Cx shell_program arguments 
每一行在被执行前被打印出来在调试程序时有用处。 
在shell程序中,#符号被用来提供一段注释。shell会忽略＃符号后边的字符，直到一个回车符号为止。 执行一个shell程序的另外一种方法是:sh shell_program arguments 
这种方式激活一个子shell并且指定这个子shell为执行这个程序的命令解释器。这个程序文件不是必须为可执行的。这种方式的用途在：你正在在一种shell下工作，同时想要执行用其他shell命令语言写的shell程序十分有用。 
你也可以在你的shell程序的第一行前加入#!/usr/bin/ shell_name来指定命令行解释器。因此，如果你当前正在POSIX shell下工作，但是想要执行一个C shell的脚本，你的C shell程序的第一行应该为： 
＃!/usr/bin/csh
虽然shell程序没有调试器，命令： 
h Cx shell_program arguments
会在执行每一行时，先在屏幕上打印出shell程序的每一行。这允许你看到shell如何进行文件名产生，变量替代，和命令替代。这个选项对发现打字错误十分有帮助。 
[]     
    
shell编程－shell编程－分支语句（1）
文章整理: 文章来源: 网络 
作者：zhanglin_1981  
  
Shell编程－分支语句（1）
目标：
完成这一章，你将能够作以下事情：
描述条件分支语句中返回值的作用。 
使用test命令来分析一个命令的返回值。 
在shell程序中使用if和case结构。 
 1.返回值
 shell变量“？”中保存上一个被执行命令的返回值：
 0： 　　命令成功地执行（真）
非零：　命令由于出现错误而被终止（假）
 例子：
$ true 　　　　　　　　　　$ false
$ echo $? 　　　 　　　　 $ echo $?
0 　　　　　　　　　　　　 1
$ ls 　　　　　　　　　　　$ cp 
$ echo $? 　　　　　　　 　Usage: cp f1 f2　
0　　　　　　　　　　　　　　　　 cp [-r] f1 ....fn d1
$ echo $?　　　　　　　　　$echo $?
0　　　　　　　　　　　　　 1
　　　　　　　　　　　　 　 $echo $?
　　　　　　　　　　　　　 0
UNIX操作系统的所有命令在结束的时候都会产生一个返回值。这个返回值通常被用来判断命令是正常结束（返回0）还是发生了错误（返回非零值）。通过返回的非零值还可以看出发生的是什么错误。例如，语法错误通常返回1，true命令返回的就是0，而false命令返回的是1。
大多数的shell程序中的判断语句都是通过分析这个返回值来进行流程控制的。shell中定义了一个特殊的变量“？”用来保存上一个命令结束后的返回值。
你可以通过以下方式来观察前一个命令的返回值:
echo $?
当你执行一个条件判断（小于，大于，等于）的时候，返回值会指明这个条件是否为真（返回0）或者为假（返回非零）。
条件判断语句会在下几节中讲述。
 2.test 命令
语法：
test expression 或者 [expression]
test命令对表达式进行测试，并且设置返回值。
 表达式的值 　　返回值
true　　　　　　0
false　　　　　 非零（通常为1）
test命令能够测试的对象有：
整数 
字符串 
文件 
test命令被用来评估表达式并且产生返回值。它用参数组成逻辑表达式并且对表达式的返回值进行评估，test命令不会产生标准输出，你必须必须通过返回值来判断test命令的结果，如果表达式为真，返回值会为0，如果表达式为假，返回值为1。
test命令可以被单独使用，然后你能够看到返回值，但它用的最多的还是在if和while结构中用来提供条件流程控制。
test命令的也可以用[expression]来代替。这种方式可以提高可读性，特别是在处理数字或者字符串的时候。
注意：在"["和"]"符号的周围必须要有空格。
 3.test命令之数字test
语法：
[ number relation number ]　　　通过关系运算符来对数字进行比较
关系运算符：
-lt 　　　小于
-le 　　　小于或者等于
-gt　　　 大于
-ge 　　　大于或者等于
-eq 　　　等于
-ne 　　　不等于
例子（假设X=3):
$ [ "$X" -lt 7]　　　$ [ "$X" -gt 7]
$ echo $? 　　　　　 $ echo $?
0 　　　　　　　　　 1
test命令能被用于比较两个整数之间的数字关系，通常用[.....]语法来调用。test命令的返回值就能说明这个条件为真还是为假。
当test一个变量的值的时候，你应该防止变量不要为空值，例如：
$ [ $XX -eq 3]
sh: test:argument expected
如果变量XX在前面没有被赋值，XX的值会是NULL。当shell执行变量替代的时候，shell会试图执行如下语句：
[ -eg 3]
而这个语句不是一个完整的test语句，并且会导致一个语法错误。解决这个问题的一个简单的方法就是在被测试的变量的周围加上引号。
[ "$XX" -eq 3]
当shell执行变量替代的时候，shell会试图执行如下语句：
["" -eq 3]
这会确保至少有一个NULL值作为一个参数提供给这个test命令使用。
注意：作为一个通用的规则，你应该在所有的$变量加上双引号来避免shell发生不正确的变量的替代。
4.test命令－字符串test
语法：
[ string1 = string2] 判断字符串是否相等
[ string1 !=string2] 判断字符串是否不等
例子；
$ X=abc 　　　　　　　　　$ X=abc
$ [ "$X" = "abc"]　　　　 $ ["$X" 　!＝ "abc"]
$ echo $? 　　　　　　　　$ echo $?
0　　　　　　　　　　　　 1
test命令也能够用来计较两个字符串是否相等。
[...] 语法通常用作字符串的比较。你已经看到在[]周围必须要有空格，同时在操作符周围也必须要有空格存在。
字符串操作包括：
string1 = string2 　　　　如果string1等于string2就为真
string1 != string2 　　　 如果string1不等于string2就为真
-z string　　　　　　　　 如果string的长度为0就为真
-n string　　　　　　　　 如果string的长度为非零就为真
string 　　　　　　　　　 如果string的长度为非零就为真
为了防止变量中包含空白字符，这里引号同样也能够保护字符串的test，，例如：
$ X="yes we will"
$ [ $X=yes] 　　　会导致一个语法错误
shell会解释这个语句为[yes we will = yes ]
$ [ "$x" = yes ] 　正确的语法
shell会解释这个语句为：[ "yes we will" = yes ]
在执行数字比较的时候，shell会将所有的参数当成是数字，在执行字符串比较的时候，shell会把所有的参数当成是字符串。如下例所示：
$ X=03
$ Y=3
$ [ "$X" -eq "$Y" ]　　　 比较数字03和数字3
$ echo $?
0　　　　　　　　　　　　为真，因为它们是相等的数字
$ [ "$X" = "$Y" ]　　　　比较字符串“03”和字符串“3”
$ echo $?
1　　　　　　　　　　　　为假，因为它们是不相同的字符串
 5.test命令－ 文件比较
语法：
test -option filename　　　通过选项对文件进行test
例子：
$ test -f funfile
$ echo $?
0
$ test -d funfile
$ echo $?
1
shell提供的一个有用的test特性是可以用它来test文件的特征，例如文件类型和许可权限。例如：
$ test -f filename
如果文件存在并且是一个普通文件（不是目录或者设备文件），会返回真（0）。
test -s filename
如果文件存在并且其字节数大于0，会返回真（0）。
其它还有许多有用的文件test方式，比如：
-r file　　　　如果文件存在并且是可读的时候为真
-w file 　　　 如果文件存在并且是可写的时候为真
-x file 　　　 如果文件存在并且是可执行的时候为真
-d directory 　目录存在并且是个目录的时候为真
6.test命令－其他操作符
语法：
-o 　　　　OR
-a 　　　　AND
\( 　\) 　 GROUPING
例子：
$ [ "$ANS" = y -o "ANS' = Y ]
$ [ "$NUM -gt 10 -a "$NUM" -lt 20 ]
$ test -s file -a -r file
注意：（）前面必须要用斜杠。
使用Boolean操作符可以同时测试多个条件。
例子：
$ [ "$ANS" = y -o "$ANS" = Y ]
$ [ "$NUM" -gt 10 -a "$NUM" -lt 20 ]
$ test -s file -a -r file -a -x file
NOT操作符（！)被用作连接其他的操作符,特别是在文件test的时候用的很普遍。在！操作符和其他的操作符之间必须要有空格，例如：
test ! -d file
能够用来代替
test -f file -o -c file -o -b file ....
括号被用来对操作符进行分组，但是在shell中括号还有一个特殊的意义就是优先运算的意义。因此，括号前面必须使用\符号来忽略其原有含义。
以下的命令验证：有两个命令行参数，并且第一个命令行参数是一个-m ,并且最后一个命令行参数是一个目录或者是一个字节数大于0的文件：
[ \( $# = 2 \) -a \( "$1" = "-m" \) -a \( -d "$2" -o -s "$2" \) ]　
7.exit命令
语法：
　exit [arg]
例子：
$ cat exit_test
echo exiting program now
exit 99
$ exit_test
exiting_program now
$ echo $?
99
exit命令结束当前shell程序的执行并且设置返回值。通常0被用来说明正常结束，而非0值用来说明一个错误的条件。如果没有特别指明返回值，返回值将被设置为exit命令上一个命令的返回值。
[]     
    
shell编程－shell编程－分支语句（2）
文章整理: 文章来源: 网络 
作者：zhanglin_1981   
  
 shell编程－分支语句（2）
8.if语句
语法：（用于单向判断分支）
if
　　list A
then
　　list B
fi
例子：
if 
　　test -s funfile
then
　　echo funfile exists
fi
echo hello
if 结构是一种基于命令返回值的的流程控制方式。如果测试命令的返回值为0，一个指定的命令列表就会被执行，如果用于判断的命令返回值为非0，指定命令列表会被忽略而不被执行。
上例中表明了if结构的一个通用的格式：每一个命令列表由一个或者多个UNIX系统的shell命令组成，每个命令之间用回车符或者分号分隔，list A中最后被执行的命令决定if语句的结果。
if结构执行的过程如下所示：
1.list A命令被执行。
2.如果list A中的最后一个命令的返回值为0（真），执行list B中的命令，然后继续执行fi以后的命令。
3.如果list A中的最后一个命令的返回值为非0（假），跳到fi并且继续执行fi以后的命令。
test命令通常被用作流程控制，它可以使用任何的UNIX命令，因为所有的UNIX命令都产生一个返回值，以下的例子可以说明：
if
　　grep kingkong /etc/passwd > /dev/null
then
　　echo found kingkong
fi
if结构也能在程序出错的时候提供流程控制。如下例所示：
if 
　　[ $# -ne 3 ]
then
　　echo Incorrect syntax
　　echo Usage: cmd arg1 arg2 arg3
　　exit 99
fi
9.if-else 结构
语法：（用在多分支选择的情况）
if
　　list A
then
　　list B
else
　　list C
fi
例子：
if [ "$X" -lt 10 ]
then
　echo X is less than 10
else
　echo X is not less than 10
fi
if-else结构让你能够在控制命令的返回值为0的情况下执行一系列的命令，或者在控制命令的返回值为非0的情况下执行另外一系列的命令。
这种情况下if结构的执行过程是：
1.执行list A中的命令。
2.如果在list A中最后一个命令的返回值是0（真），执行list B中的命令，然后继续执行fi以后的命令。
3.如果list A中最后一个命令的返回值为非0（假），执行list C中的命令，然后执行fi以后的命令。
注意在list C中可以包含任何的UNIX命令，其中也包括if。例如：
if 
　　[ "$X" -lt 10 ]
then
　　echo X is less than 10
else
　　if
　　　　[ "$X" -gt 10 ]
　　then
　　　　echo X is greater than 10
　　else
　　　　echo X is equal to 10
　　fi
fi
注意：每一个if必须要有一个fi来结束。
10.case结构
语法：（多路分支）
　case word in
　patterm1) list A
　　　　　　　;;
　pattern2)　list B
　　　　　　　;;
　patternN) 　list N
　　　　　　　 ;;
　esac
例子：
case $ANS in
　　yes) echo O.K
　　　　　;;
　　 no) echo no go
　　　　　;;
esac
if-else结构也能支持多路的分支，但是当有两个或者三个分支的之后，程序会变得十分难以阅读。case结构提供了实现多路分支的一种更方便的方法。分支选择是顺序地对一个word与提供的参数之间的比较结果。这些比较是是严格的基于字符串的对比。当一个匹配成功的时候，对应的命令就会被执行。每个命令的列表都以两个分号结束。在完成了相关的比较之后，程序会在esac之后继续执行下去。
word典型的情况下是指向一个shell变量。
pattern的组成格式和文件名的生成原则是一致的。
以下是一些pattern允许的特殊的字符：
* 　　　匹配任何字符串和字符包括空字符
? 　　　匹配任何单个的字符。
[...] 　匹配任何一个括号出现中的字符
另外|字符的意义是OR。
注意：在这个结构中的右括号和分号是必须的。
case结构通常被用于菜单选择或者是需要对几个用户输入选项作出选择的时候。
12.shell编程 －　分支：总结
返回值　　　每一个程序的返回值 － echo $?
数字test　　[ "$num1" -lt "$num2" ]
字符串test　[ $string1 = $string2 ]
文件test 　 test -f filename
exit n 　　 终止程序的允许并且设置返回值
if 　　　　　　　　　　　　　　　　　　　case word in
　　　command listA　　　　　　　　　　　pattern1) command list
then　　　　　　　　　　　　　　　　　　 ;;
　　　command listB　　　　　　　　　　　pattern2) command list
else　　　　　　　　　　　　　　　　　　 ;;
　　　command listC　　　　　　　　　　　*) 　　　　command list
fi 　　　　　　　　　　　　　　　　　　　;;
　　　　　　　　　　　　　　　　　　　　 esac
执行那个语句基于listA中最后一条　　　　　字符串word会与每一个pattern比较
命令的返回值
[]     
    
shell编程－shell编程－循环语句（1）
文章整理: 文章来源: 网络 
作者：zhanglin_1981   
  
 shell编程之循环语句（1）
目标：
完成这一章，你将能够作以下事情：
使用while语句在条件为真的时候重复地执行一段代码。 
使用until语句重复执行一段代码直到条件为真。 
使用交互性的for语句进行循环控制。 
1.循环的简单介绍
目标： 　　　　重复的执行一段命令列表。
控制； 　　　　基于一个关键命令的返回值。
三种格式： 　　while ... do ... done
　　　　　　　 until ... do ... done
　　　　　　　 for ... do ... done
循环语句让你可以重复执行一个命令列表，而决定是继续循环还是跳出循环是基于一个命令的返回值。test命令常常被用来控制一个循环是否继续。
与分支语句不同的是，在分支语句中开始一个分支语句的关键字和结束一个分支语句的关键字是相反的（if/fi 和case/esac)，循环语句由一个关键字和一些条件开始，循环体整个用do/done来包围起来。
2.使用let来进行算术计算
语法：
let expression or (( expression ))
例子：
$ x=10　　　　　　　　　　$ x=12
$ y=2　　　　　　　　　　 $ let "x <10"　　　
$ let x=x+2 　　　　　　　$ echo $?
$ echo $x　　　　　　　　 1
12　　　　　　　　　　　　$ (( x > 10 ))
$ let "x = x / (y+1)" 　　$ echo $?
$ echo $x 　　　　　　　　$ 0
4　　　　　　　　　　　　 $ if ((x > 10 ))
$ (( x = x + 1 ))　　　　 > 　then echo x greater
$ echo $x　　　　　　　　 > 　else echo x not greater
5　　　　　　　　　　　　 fi
　　　　　　　　　　　　　x greater
循环语句通常使用一个增长的数字变量来进行控制。使用let命令，可以在shell脚本中使用算术表达式。这个命令允许使用长的整数运算。在上例中，expression代表一个shell变量的算术表达式和能够被shell识别的操作符，而（（　 ））可以替let命令。shell能够识别的表达式如下所示：
操作符　　　　　描述
-　　　　　 　　减去
!　　　　　 　　逻辑相反
* / %　　　　　 乘，除，余数
+ - 　　　　　　加，减
<= 　>= 　<　>　关系比较
== !=　　　　　 等于不等于
=　　　　　　　 赋值
括号能够被用作改变表达式中计算的顺序，就像在
let "x=x/(y+1)"
中一样
注意双引号被用来忽略括号的特殊含义。同样如果你希望使用空格来分隔操作符和操作符的时候，就必须使用双引号，或者（（ ））语句：
let " x = x + (y / 2)" 或者(( x= x+ (y / 2) ))
当使用逻辑和关系操作符，(!,<=,>=,<,>,++,~=),的时候，shell会返回一个代码变量，?会反映结果是真还是假，再一次说明，必须使用双引号来防止shell将大于和小于运算符当作I/O重定向。
3.while语句
重复执行循环体，直到条件为真 
语法：
while　　　　　　　　　　　　　　
　　 list A
do 
　　 list B
done
例子：
$ cat test_while
X=1
while (( X <= 10 ))
do
　　echo hello X is $X
　　let X=X+1
done
$ test_while
hello X is 1
hello X is 2
.
.
. 
hello X is 10
while语句是shell提供的一种循环机制，当条件为真的时候它允许循环体中的命令（list B)继续执行。条件判断是通过list A中最后一个命令的返回值来进行。通常一个test或者let命令被用作控制循环的执行，但是任何命令都能被用来产生一个返回值。上面的例子中使用的是test命令可以用let命令来代替，如下：
$ X=1
$ while [ $x -le 10 ]
> do
> 　　echo hello X is $X
>　　 let X=X+1
> done
命令执行的过程如下：
1.list A中的命令被执行。
2.如果list A中的最后一个命令的返回值为0（真）,执行list B。
3.回到第一步。
4.如果list A中的最后一个命令的返回值不为0（假）,跳到下面done关键字后的第一个命令。
提醒：注意while循环会无穷执行下去，因为有一些循环的控制命令的返回值永远为真。
$ cat while_infinite
while
　　 true
do 
　　 echo hello
done
$ while_infinite
hello
hello
. 
.
.
ctrl + c
4. while结构举例
例A:　　　　　　　　　　　　　　　例B
如果ans为yes就重复执行 　　　　　　　　　　　当有命令行参数时重复执行
ans=yes　　　　　　　　　　　　　　　while (($# != 0 ))
while 　　　　　　　　　　　　　　　 do
[ "$ans" = yes ] 　　　　　　　　　　　if test -d $1
do 　　　　　　　　　　　　　　　　　　then
　　echo Enter a name　　　　　　　　　　echo contents of $1;
　　read name　　　　　　　　　　　　　　ls -F $1
　　echo $name >> file.names　　　　　 fi
　　echo "Continue?"　　　　　　　　　 shift
　　echo Enter yes or no　　　　　　　 echo There are $# items
　　read ans　　　　　　　　　　　　　 echo left on the cmd line
done 　　　　　　　　　　　　　　　　done　
上例是两个while语句的例子，例A提示用户输入，然后对用户的输入进行判断，来决定是否继续执行循环，例子B中，循环会对命令行中每一个参数进行判断，如果参数是一个目录，这个目录中的内容会被显示出来。如果这个参数不是一个目录，程序会跳过。注意shift命令的用法，它允许一个一个存取每一个参数。和while命令一起使用可以使这个循环非常灵活。它不关心参数的个数是1个还是100个，循环会继续执行直到所有的参数都被存取。
注意，如果你希望循环至少执行一次，就必须进行某些设置。例A中会执行循环体至少一次因为ans已经被设为yes。在例B中，如果程序的执行不带任何参数($#等于0），这个循环就一次都不会执行。
5.until语句
重复循环直到条件为真为止。
语法：　　　　　　例子：
until　　　　　　　$ cat test_until
　list A　　　　　 X=1
do　　　　　　　　 until (( x > 10 ))
　list B　　　　　 do
done　　　　　　　　　echo hello X is $X
　　　　　　　　　　　let X=X+1
　　　　　　　　　 done
　　　　　　　　　 $ test_until
　　　　　　　　　 hello X is 1
　　　　　　　　　 hello X is 2
　　　　　　　　　 hello X is 3
　　　　　　　　　　　.
　　　　　　　　　　　.
　　　　　　　　　　　.
　　　　　　　　　 hello X is 10
until语句是shell提供的另一种循环机制，它会持续执行命令（list B)直到一个条件为真为止。同while循环类似，条件判断由list A中的最后一条命令的返回值来决定的。
命令的执行过程如下：
1.list A中的命令被执行。
2.如果list A中最后一条命令的返回值为非0（假）,执行list B。
3.返回到第一步。
4.如果list A中的最后一条命令的返回值为0（真）,跳到done关键字后的第一条命令。
注意：until循环的无穷执行下去，因为有些循环语句中的控制语句的返回值始终为假。
$ x=1
$ until
> [ $ x -eq 0 ]
> do
> echo hello
> done
hello
hello
hello
.
.
.
ctrl + c
6.until的例子
例A　　　　　　　　　　　　　　　例B
重复执行循环体直到ans为no为止 　　　　　　　重复执行循环直到没有命令行参数为止
ans=yes　　　　　　　　　　　　　　 until (( $# == 0 ))
until 　 　　　　　　　　　　　　　 do
　 [ "$ans" = no ] 　　　　　　　　　 if test -d $1
do 　　　　　　　　　　　　　　　　　 then
echo Enter a name　　　　　　　　　　　 echo context of $1;
　read name 　　　　　　　　　　　　　　ls -F $1
　echo $name >> file.names　　　　　　fi
　echo "Continue?"　　　　　　　　　　shift
　echo Enter yes or no　　　　　　　　echo There are $# items
　read ans 　　　　　　　　　　　　　 echo left on the cmd line.
done　　　　　　　　　　　　　　　　done
上例的结构与while语句中的例子类似，但是使用until语句来。注意在两种语句的test条件的逻辑关系是相反的。
同时请注意用户输入的敏感性由一些轻微的变化。使用while语句，只有用户的输入的字符串为“yes”时循环才会执行，继续执行循环的条件十分严格，使用until语句，循环会在用户使用与no不同的任何字符时都会执行。它对于继续进行循环的条件不太严格，你也许希望在决定那一种结构最符合你的要求的时候考虑这一特征。
预定义ans变量的值不再是必须的，因为它的值会被初始化为NULL,由于NULL不等于no，test会返回假，而循环会被执行。你仅仅需要将$ans用括号引起来，以免在test语句执行时发生语法错误。
[]     
    
shell编程－shell编程－循环语句（2）
文章整理: 文章来源: 网络 
作者：zhanglin_1981   
  
shell编程之循环语句（2）
7.for语句
对列表的每一条目都进行一次循环过程
，每完成一次循环过程就将var赋予列表中下一个条目，直到完成最后一个条目的循环为止
语法： 　　　　　　　　　　　例子：
for var in list　　　　　　　　$ cat test_for
do　　　　　　　　　　　　　　 for X in 1 2 3 4 5
　　　list A　　　　　　　　　 do
done　　　　　　　　　　　　　 echo "2 * $X is \c"
　　　　　　　　　　　　　　　 let X=X*2
　　　　　　　　　　　　　　　 echo $X
　　　　　　　　　　　　　　　 done
　　　　　　　　　　　　　　　 $ test_for
　　　　　　　　　　　　　　　 2 * 1 is 2
　　　　　　　　　　　　　　　 2 * 2 is 4
　　　　　　　　　　　　　　　 2 * 3 is 6
　　　　　　　　　　　　　　　 2 * 4 is 8
　　　　　　　　　　　　　　　 2 * 5 is 10
在上例中，关键字为for,in,do和done，var代表一个shell变量的名字，这个变量的赋值会贯穿for循环的执行过程中，list是一串由空格或者tab分割开的字符串，在每一次循环执行都要将一个串赋值给var。
for循环的执行过程如下：
1.shell变量var被设置等于list中的第一个字符。
2.list A中的命令会被执行。
3.shell变量var被设置等于list中下一个字符。
4.list A中的命令被执行。
5.循环会持续执行，直到每一个list中的条目都执行过循环为止。
8.for循环的例子
例A:
$ cat example_A
for NAME in $(grep home /etc/passwd | cut -f1 -d:)
do
　　mail $NAME < mtg.minutes
　　echo mailed mtg.minutes to $NAME
done
例B
$ cat example_B
for FILE in *
do
　if
　　test -d $FILE
　then
　　ls -F $FILE
　fi
done
for结构是一种非常灵活的循环结构，它能够让循环贯穿任何能产生的列表。使用命令替代可以很容易产生生成列表，就像第一个例子使用管道和过滤器可以产生一个列表。如果你要求多次存取相同的列表，你也许想要将它存储到个文件中。你可以使用cat命令来为你的for循环产生列表，正如下例所示：
　　$ cat students
　　user1
　　user2
　　user3
　　user4
　　$ cat for_student_file_copy
　　for NAME in $(cat students)
　　do
　　cp test.file /home/$NAME
　　chown $NAME /home/$NAME/test.file
　　chmod g-w,o-w /home/$NAME/test.file
　　echo done $NAME
　　done
　　$
存取命令行参数
你可以从命令行参数来产生list：
for i in $*　　　　　　　　　或者　　　　　for i
do　　　　　　　　　　　　　　　　　　　　 do　
　　cp $i $HOME/backups　　　　　　　　　　　　cp $i $HOME/backups
done 　　　　　　　　　　　　　　　　　　　done
9.break,continue,和exit命令
break [n] 　　　　　中止循环过程的执行，并且跳到下一个命令。
continue [n]　　　　停止循环过程的当前一个反复并且跳到循环中的下一个反复过程的开始部分
exit [n] 　　　　　 停止shell程序的执行，并且将返回值设置为n。
在许多情况下，你可能需要在循环的正常中止条件满足之前放弃一个循环的执行。break和continue命令提供了一种无条件的流程控制，通常用在遇到一个错误的情况下来中止当前的循环。而exit命令用在不能从某种情况下恢复出来而必须中止整个程序的运行的时候。
break命令会中止循环并且将控制权传递到done关键字后面的第一个命令。结果是完全跳出这个循环体而继续执行下面的命令。
continue命令有一点不同。当在程序执行过程中遇到这个命令，就会忽略本次循环中剩余的命令，而将控制权交给循环的顶部。这样，continue命令能让你仅仅中止所有循环中的一个循环过程而继续从当前循环的顶部开始执行。
在while和until循环中，这种处理（continue)会导致在初始列表的开始部分继续执行，在for循环中，会将变量设置为列表中的下一个条目，然后继续执行循环。
exit命令停止执行当前的shell程序，并且根据提供的参数为这个shell程序设置一个返回值，如果没有提供返回值参数，当前的shell程序的返回值会被设置为在exit命令之前执行的命令的返回值。
注意：循环的流程控制在正常的情况下应当是通过设置循环开始部分的条件（while,until)，或者是列表中的条目都循环完的（for),的情况来结束循环。而对循环过程进行中断操作仅仅应当在循环执行期间遇到没有规律的或者是错误的条件的时候才应当使用。
10.break和continue的例子
while
　　true
do
　　echo "Enter file to remove: \c"
 　　read FILE
　　if test ! -f $FILE
　　then
　　　　echo $FILE is not a regular file
　　　　continue
　　fi
　　echo removing $FILE
　　rm $FILE
　　break
done
这个例子显示break和continue命令的一次有效的使用。这个命令的执行是在while循环的test条件为真的情况下，会始终产生一个为真的结果；这意味着这个循环会是一个无限的循环，除非循环体中的某些命令能中止循环的运行（这就是bread命令需要做的）。如果输入的文件不是一个普通文件，一个错误信息会打印，同时continue命令会提醒用户再输入一次文件名。如果这个文件是个普通的文件，它会被删除，并且break命令被用来跳出这个无穷循环。
11.shell编程之循环－总结 
let expression 　　　　　　　　　　　　　计算一个算术表达式
((expression)) 　　　　　　　　　　　　　计算一个算术表达式
while condition is true do ...done　　　 while
until condition is true do ... done　　　until
for var in list do ... done 　　　　　　 for
break [n]　　　　　　　　　　　　　　　　break out of loop
continue [n]　　　　　　　　　　　　　　 中止当前循环中的一次循环过程
exit [n]　　　　　　　　　　　　　　　　 中止这个程序
[]     
    
Linux的shell编程(一)
文章整理: 文章来源: 网络 
Shell本身是一个用C语言编写的程序，它是用户使用Linux的桥梁。Shell既是一种命令语言，又是一种程序设计语言。作为命令语言，它交互式地解释和执行用户输入的命令；作为程序设计语言，它定义了各种变量和参数，并提供了许多在高级语言中才具有的控制结构，包括循环和分支。它虽然不是Linux系统核心的一部分，但它调用了系统核心的大部分功能来执行程序、建立文件并以并行的方式协调各个程序的运行。因此，对于用户来说，shell是最重要的实用程序，深入了解和熟练掌握shell的特性极其使用方法，是用好Linux系统的关键。可以说，shell使用的熟练程度反映了用户对Linux使用的熟练程度。 
　　 一、什么是shell 
　　 当一个用户登录Linux系统之后，系统初始化程序init就为每一个用户运行一个称为shell(外壳)的程序。那么，shell是什么呢？确切一点说，shell就是一个命令行解释器，它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序，用户可以用shell来启动、挂起、停止甚至是编写一些程序。 
　　 当用户使用Linux时是通过命令来完成所需工作的。一个命令就是用户和shell之间对话的一个基本单位，它是由多个字符组成并以换行结束的字符串。shell解释用户输入的命令，就象DOS里的command.com所做的一样，所不同的是，在DOS中，command.com只有一个，而在Linux下比较流行的shell有好几个，每个shell都各有千秋。一般的Linux系统都将bash作为默认的shell。 
　　 二、几种流行的shell 
　　 目前流行的shell有ash、bash、ksh、csh、zsh等，你可以用下面的命令来查看你自己的shell类型： 
　　 #echo $SHELL 
　　 $SHELL是一个环境变量，它记录用户所使用的shell类型。你可以用命令： 
　　 #shell-name 
　　 来转换到别的shell，这里shell-name是你想要尝试使用的shell的名称，如ash等。这个命令为用户又启动了一个shell，这个shell在最初登录的那个shell之后，称为下级的shell或子shell。使用命令： 
　　 $exit 
　　 可以退出这个子shell。 
　　 使用不同的shell的原因在于它们各自都有自己的特点，下面作一个简单的介绍： 
　　 1.ash 
　　 ash shell是由Kenneth Almquist编写的，Linux中占用系统资源最少的一个小shell，它只包含24个内部命令，因而使用起来很不方便。 
　　 2.bash 
　　 bash是Linux系统默认使用的shell，它由Brian Fox和Chet Ramey共同完成，是Bourne Again Shell的缩写，内部命令一共有40个。Linux使用它作为默认的shell是因为它有诸如以下的特色： 
　　 (1)可以使用类似DOS下面的doskey的功能，用方向键查阅和快速输入并修改命令。 
　　 (2)自动通过查找匹配的方式给出以某字符串开头的命令。 
　　 (3)包含了自身的帮助功能，你只要在提示符下面键入help就可以得到相关的帮助。 
　　 3.ksh 
　　 ksh是Korn shell的缩写，由Eric Gisin编写，共有42条内部命令。该shell最大的优点是几乎和商业发行版的ksh完全兼容，这样就可以在不用花钱购买商业版本的情况下尝试商业版本的性能了。 
　　 4.csh 
　　 csh是Linux比较大的内核，它由以William Joy为代表的共计47位作者编成，共有52个内部命令。该shell其实是指向/bin/tcsh这样的一个shell，也就是说，csh其实就是tcsh。 
　　 5.zch 
　　 zch是Linux最大的shell之一，由Paul Falstad完成，共有84个内部命令。如果只是一般的用途，是没有必要安装这样的shell的。  
[]     
    
Linux的shell编程(二)
文章整理: 文章来源: 网络 
三. shell程序设计(基础部分) 
　　 其实作为命令语言交互式地解释和执行用户输入的命令只是shell功能的一个方面，shell还可以用来进行程序设计，它提供了定义变量和参数的手段以及丰富的程序控制结构。使用shell编程类似于DOS中的批处理文件，称为shell script，又叫shell程序或shell命令文件。 
　　 1.shell基本语法 
　　 shell的基本语法主要就是如何输入命令运行程序以及如何在程序之间通过shell的一些参数提供便利手段来进行通讯。 
　　 (1)输入输出重定向 
　　 在Linux中，每一个进程都有三个特殊的文件描述指针：标准输入(standard input，文件描述指针为0)、标准输出(standard output，文件描述指针为1)、标准错误输出(standard error，文件描述指针为2)。这三个特殊的文件描述指针使进程在一般情况下接收标准输入终端的输入，同时由标准终端来显示输出，Linux同时也向使用者提供可以使用普通的文件或管道来取代这些标准输入输出设备。在shell中，使用者可以利用“>”和“<”来进行输入输出重定向。如： 
　　 command>file：将命令的输出结果重定向到一个文件。 
　　 command>&file：将命令的标准错误输出一起重定向到一个文件。 
　　 command>>file：将标准输出的结果追加到文件中。 
　　 command>>&file：将标准输出和标准错误输出的结构都追加到文件中。 
　　 command 
　　 (2)管道pipe 
　　 pipe同样可以在标准输入输出和标准错误输出间做代替工作，这样一来，可以将某一个程序的输出送到另一个程序的输入，其语法如下： 
　　 command1| command2[| command3...] 
　　 也可以连同标准错误输出一起送入管道： 
　　 command1| &command2[|& command3...] 
　　 (3)前台和后台 
　　 在shell下面，一个新产生的进程可以通过用命令后面的符号“；”和“&”来分别以前台和后台的方式来执行，语法如下： 
　　 command 
　　 产生一个前台的进程，下一个命令须等该命令运行结束后才能输入。 
　　 command & 
　　 产生一个后台的进程，此进程在后台运行的同时，可以输入其他的命令。 
　　 2。shell程序的变量和参数 
　　 像高级程序设计语言一样，shell也提供说明和使用变量的功能。对shell来讲，所有变量的取值都是一个字符串，shell程序采用$var的形式来引用名为var的变量的值。 
　　 Shell有以下几种基本类型的变量： 
　　 (1)shell定义的环境变量 
　　 shell在开始执行时就已经定义了一些和系统的工作环境有关的变量，这些变量用户还可以重新定义，常用的shell环境变量有： 
　　 HOME：用于保存注册目录的完全路径名。 
　　 PATH：用于保存用冒号分隔的目录路径名，shell将按PATH变量中给出的顺序搜索这些目录，找到的第一个与命令名称一致的可执行文件将被执行。 
　　 TERM：终端的类型。 
　　 UID：当前用户的标识符，取值是由数字构成的字符串。 
　　 PWD：当前工作目录的绝对路径名，该变量的取值随cd命令的使用而变化。 
　　 PS1：主提示符，在特权用户下，缺省的主提示符是“#”，在普通用户下，缺省的主提示符是“$”。 
　　 PS2：在shell接收用户输入命令的过程中，如果用户在输入行的末尾输入“”然后回车，或者当用户按回车键时shell判断出用户输入的命令没有结束时，显示这个辅助提示符，提示用户继续输入命令的其余部分，缺省的辅助提示符是“>”。 
　　 (2)用户定义的变量 
　　 用户可以按照下面的语法规则定义自己的变量： 
　　 变量名=变量值 
　　 要注意的一点是，在定义变量时，变量名前不应加符号“$”，在引用变量的内容时则应在变量名前加“$”；在给变量赋值时，等号两边一定不能留空格，若变量中本身就包含了空格，则整个字符串都要用双引号括起来。 
　　 在编写shell程序时，为了使变量名和命令名相区别，建议所有的变量名都用大写字母来表示。 
　　 有时我们想要在说明一个变量并对它设定为一个特定值后就不在改变它的值，这可以用下面的命令来保证一个变量的只读性： 
　　 readly 变量名 
　　 在任何时候，建立的变量都只是当前shell的局部变量，所以不能被shell运行的其他命令或shell程序所利用，export命令可以将一局部变量提供给shell执行的其他命令使用，其格式为： 
　　 export 变量名 
　　 也可以在给变量赋值的同时使用export命令： 
　　 export 变量名=变量值 
　　 使用export说明的变量，在shell以后运行的所有命令或程序中都可以访问到。 
　　 (3)位置参数 
　　 位置参数是一种在调用shell程序的命令行中按照各自的位置决定的变量，是在程序名之后输入的参数。位置参数之间用空格分隔，shell取第一个位置参数替换程序文件中的$1，第二个替换$2，依次类推。$0是一个特殊的变量，它的内容是当前这个shell程序的文件名，所以，$0不是一个位置参数，在显示当前所有的位置参数时是不包括$0的。 
　　 (4)预定义变量 
　　 预定义变量和环境变量相类似，也是在shell一开始时就定义了的变量，所不同的是，用户只能根据shell的定义来使用这些变量，而不能重定义它。所有预定义变量都是由$符和另一个符号组成的，常用的shell预定义变量有： 
　　 $#：位置参数的数量 
　　 $*：所有位置参数的内容 
　　 $?：命令执行后返回的状态 
　　 $$：当前进程的进程号 
　　 $!：后台运行的最后一个进程号 
　　 $0：当前执行的进程名 
　　 其中，“$?”用于检查上一个命令执行是否正确(在Linux中，命令退出状态为0表示该命令正确执行，任何非0值表示命令出错)。 
　　 “$$”变量最常见的用途是用作临时文件的名字以保证临时文件不会重复。 
　　 (5)参数置换的变量 
　　 shell提供了参数置换能力以便用户可以根据不同的条件来给变量赋不同的值。参数置换的变量有四种，这些变量通常与某一个位置参数相联系，根据指定的位置参数是否已经设置类决定变量的取值，它们的语法和功能分别如下。 
　　 a. 变量=${参数-word}：如果设置了参数，则用参数的值置换变量的值，否则用word置换。即这种变量的值等于某一个参数的值，如果该参数没有设置，则变量就等于word的值。 
　　 b. 变量=${参数=word}：如果设置了参数，则用参数的值置换变量的值，否则把变量设置成word然后再用word替换参数的值。注意，位置参数不能用于这种方式，因为在shell程序中不能为位置参数赋值。 
　　 c. 变量=${参数？word}：如果设置了参数，则用参数的值置换变量的值，否则就显示word并从shell中退出，如果省略了word，则显示标准信息。这种变量要求一定等于某一个参数的值，如果该参数没有设置，就显示一个信息，然后退出，因此这种方式常用于出错指示。 
　　 d. 变量=${参数+word}：如果设置了参数，则用word置换变量，否则不进行置换。 
　　 所有这四种形式中的“参数”既可以是位置参数，也可以是另一个变量，只是用位置参数的情况比较多 
[]     
    
Linux的shell编程(三)
文章整理: 文章来源: 网络 
接下来以bash为例向大家介绍shell程序设计的高级部分：shell编程的流程控制、调试方法及shell程序的运行方法，顺便也向大家介绍一下bash的内部命令。
　　四、shell程序设计的流程控制
　　和其他高级程序设计语言一样，shell提供了用来控制程序执行流程的命令，包括条件分支和循环结构，用户可以用这些命令建立非常复杂的程序。
　　与传统的语言不同的是，shell用于指定条件值的不是布尔表达式而是命令和字符串。
　　1.test测试命令
　　test命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试，其测试符和相应的功能分别如下：
　　(1)数值测试：
　　-eq：等于则为真
　　-ne：不等于则为真
　　-gt：大于则为真
　　-ge：大于等于则为真
　　-lt：小于则为真
　　-le：小于等于则为真
　　(2)字符串测试：
　　=：等于则为真
　　!=：不相等则为真
　　-z字符串：字符串长度伪则为真
　　-n字符串：字符串长度不伪则为真
　　(3)文件测试：
　　-e文件名：如果文件存在则为真
　　-r文件名：如果文件存在且可读则为真
　　-w文件名：如果文件存在且可写则为真
　　-x文件名：如果文件存在且可执行则为真
　　-s文件名：如果文件存在且至少有一个字符则为真
　　-d文件名：如果文件存在且为目录则为真
　　-f文件名：如果文件存在且为普通文件则为真
　　-c文件名：如果文件存在且为字符型特殊文件则为真
　　-b文件名：如果文件存在且为块特殊文件则为真
　　另外，Linux还提供了与(“！”)、或(“-o)、非(“-a”)三个逻辑操作符用于将测试条件连接起来，其优先级为：“！”最高，“-a”次之，“-o”最低。
　　同时，bash也能完成简单的算术运算，格式如下：
　　$[expression]
　　例如：var1=2
　　var2=$[var1*10+1]
　　则：var2的值为21。
　　2.if条件语句
　　shell程序中的条件分支是通过if条件语句来实现的，其一般格式为：
　　if条件命令串
　　then 
　　条件为真时的命令串
　　else 
　　条件为假时的命令串
　　fi 
　　3.for循环
　　for循环对一个变量的可能的值都执行一个命令序列。赋给变量的几个数值既可以在程序内以数值列表的形式提供，也可以在程序以外以位置参数的形式提供。for循环的一般格式为：
　　for变量名
　　[in数值列表]
　　do 
　　若干个命令行
　　done
　　变量名可以是用户选择的任何字符串，如果变量名是var，则在in之后给出的数值将顺序替换循环命令列表中的$var。如果省略了in，则变量var的取值将是位置参数。对变量的每一个可能的赋值都将执行do和done之间的命令列表。
　　4.while和until循环
　　while和until命令都是用命令的返回状态值来控制循环的。While循环的一般格式为：
　　while 
　　若干个命令行1
　　do
　　若干个命令行2
　　done
　　只要while的“若干个命令行1”中最后一个命令的返回状态为真，while循环就继续执行do...done之间的“若干个命令行2”。
　　until命令是另一种循环结构，它和while命令相似，其格式如下：
　　until 
　　若干个命令行1
　　do 
　　若干个命令行2
　　done 
　　until循环和while循环的区别在于：while循环在条件为真时继续执行循环，而until则是在条件为假时继续执行循环。
　　Shell还提供了true和false两条命令用于建立无限循环结构的需要，它们的返回状态分别是总为0或总为非0
　　5.case条件选择
　　if条件语句用于在两个选项中选定一项，而case条件选择为用户提供了根据字符串或变量的值从多个选项中选择一项的方法，其格式如下：
　　case string in 
　　exp-1)
　　若干个命令行1
　　；；
　　exp-2)
　　若干个命令行2
　　；；
　　……
　　*)
　　其他命令行
　　esac 
　　shell通过计算字符串string的值，将其结果依次和表达式exp-1、exp-2等进行比较，直到找到一个匹配的表达式为止，如果找到了匹配项则执行它下面的命令直到遇到一对分号(；；)为止。
　　在case表达式中也可以使用shell的通配符(“*”、“？”、“[ ]”)。通常用“*”作为case命令的最后表达式以便使在前面找不到任何相应的匹配项时执行“其他命令行”的命令。
　　6.无条件控制语句break和continue
　　break用于立即终止当前循环的执行，而contiune用于不执行循环中后面的语句而立即开始下一个循环的执行。这两个语句只有放在do和done之间才有效。
　　7.函数定义
　　在shell中还可以定义函数。函数实际上也是由若干条shell命令组成的，因此它与shell程序形式上是相似的，不同的是它不是一个单独的进程，而是shell程序的一部分。函数定义的基本格式为：
　　functionname
　　{
　　若干命令行
　　}
　　调用函数的格式为：
　　functionname param1 param2……
　　shell函数可以完成某些例行的工作，而且还可以有自己的退出状态，因此函数也可以作为if、while等控制结构的条件。
　　在函数定义时不用带参数说明，但在调用函数时可以带有参数，此时shell将把这些参数分别赋予相应的位置参数$1、$2、...及$*。
　　8.命令分组
　　在shell中有两种命令分组的方法：“()”和“{}”，前者当shell执行()中的命令时将再创建一个新的子进程，然后这个子进程去执行圆括弧中的命令。当用户在执行某个命令时不想让命令运行时对状态集合(如位置参数、环境变量、当前工作目录等)的改变影响到下面语句的执行时，就应该把这些命令放在圆括弧中，这样就能保证所有的改变只对子进程产生影响，而父进程不受任何干扰；{}用于将顺序执行的命令的输出结果用于另一个命令的输入(管道方式)。当我们要真正使用圆括弧和花括弧时(如计算表达式的优先级)，则需要在其前面加上转义符(\)以便让shell知道它们不是用于命令执行的控制所用。
　　9.信号
　　trap命令用于在shell程序中捕捉到信号，之后可以有三种反应方式：
　　(1)执行一段程序来处理这一信号
　　(2)接受信号的默认操作
　　(3)忽视这一信号
　　trap对上面三种方式提供了三种基本形式：
　　第一种形式的trap命令在shell接收到signal list清单中数值相同的信号时，将执行双引号中的命令串。
　　trap 'commands' signal-list
　　trap "commands" signal-list
　　为了恢复信号的默认操作，使用第二种形式的trap命令：
　　trap signal-list
　　第三种形式的trap命令允许忽视信号：
　　trap " " signal-list
　　注意：
　　(1)对信号11(段违例)不能捕捉，因为shell本身需要捕捉该信号去进行内存的转储。
　　(2)在trap中可以定义对信号0的处理(实际上没有这个信号)，shell程序在其终止(如执行exit语句)时发出该信号。
　　(3)在捕捉到signal-list中指定的信号并执行完相应的命令之后，如果这些命令没有将shell程序终止的话，shell程序将继续执行收到信号时所执行的命令后面的命令，这样将很容易导致shell程序无法终止。
　　另外，在trap语句中，单引号和双引号是不同的，当shell程序第一次碰到trap语句时，将把commands中的命令扫描一遍。此时若commands是用单引号括起来的话，那么shell不会对commands中的变量和命令进行替换，否则commands中的变量和命令将用当时具体的值来替换。
　　五、运行shell程序的方法
　　用户可以用任何编辑程序来编写shell程序。因为shell程序是解释执行的，所以不需要编译装配成目标程序，按照shell编程的惯例，以bash为例，程序的第一行一般为“#！/bin/bash”，其中#表示该行是注释，叹号“！”告诉shell运行叹号之后的命令并用文件的其余部分作为输入，也就是运行/bin/bash并让/bin/bash去执行shell程序的内容。
　　执行shell程序的方法有三种：
　　(1)sh shell程序文件名
　　这种方法的命令格式为：
　　bash shell程序文件名
　　这实际上是调用一个新的bash命令解释程序，而把shell程序文件名作为参数传递给它。新启动的shell将去读指定的文件，执行文件中列出的命令，当所有的命令都执行完结束。该方法的优点是可以利用shell调试功能。
　　(2)sh 
　　格式为：
　　bash 
　　这种方式就是利用输入重定向，使shell命令解释程序的输入取自指定的程序文件。
　　(3)用chmod命令使shell程序成为可执行的
　　一个文件能否运行取决于该文件的内容本身可执行且该文件具有执行权。对于shell程序，当用编辑器生成一个文件时，系统赋予的许可权限都是644(rw-r-r--)，因此，当用户需要运行这个文件时，只需要直接键入文件名即可。
　　在这三种运行shell程序的方法中，最好按下面的方式选择：当刚建立一个shell程序，对它的正确性还没有把握时，应当使用第一种方式进行调试。当一个shell程序已经调试好时，应使用第三种方式把它固定下来，以后只要键入相应的文件名即可，并可被另一个程序所调用。 
[]     
    
Linux的shell编程(四)
文章整理: 文章来源: 网络 
六、bash程序的调试
　　在编程过程中难免会出错，有的时候，调试程序比编写程序花费的时间还要多，shell程序同样如此。
　　shell程序的调试主要是利用bash命令解释程序的选择项。调用bash的形式是：
　　bash -选择项shell程序文件名
　　几个常用的选择项是：
　　-e：如果一个命令失败就立即退出
　　-n：读入命令但是不执行它们
　　-u：置换时把未设置的变量看作出错
　　-v：当读入shell输入行时把它们显示出来
　　-x：执行命令时把命令和它们的参数显示出来
　　上面的所有选项也可以在shell程序内部用“set -选择项”的形式引用，而“set +选择项”则将禁止该选择项起作用。如果只想对程序的某一部分使用某些选择项时，则可以将该部分用上面两个语句包围起来。
　　1.未置变量退出和立即退出
　　未置变量退出特性允许用户对所有变量进行检查，如果引用了一个未赋值的变量就终止shell程序的执行。shell通常允许未置变量的使用，在这种情况下，变量的值为空。如果设置了未置变量退出选择项，则一旦使用了未置变量就显示错误信息，并终止程序的运行。未置变量退出选择项为“-u”。
　　当shell运行时，若遇到不存在或不可执行的命令、重定向失败或命令非正常结束等情况时，如果未经重新定向，该出错信息会打印在终端屏幕上，而shell程序仍将继续执行。要想在错误发生时迫使shell程序立即结束，可以使用“-e”选项将shell程序的执行立即终止。
　　2.shell程序的跟踪
　　调试shell程序的主要方法是利用shell命令解释程序的“-v”或“-x”选项来跟踪程序的执行。“-v”选择项使shell在执行程序的过程中，把它读入的每一个命令行都显示出来，而“-x”选择项使shell在执行程序的过程中把它执行一个命令在行首用一个“+”加上命令名显示出来。并把每一个变量和该变量所取的值也显示出来，因此，它们的主要区别在于：在执行命令行之前无“-v”则打印出命令行的原始内容，而有“-v”则打印出经过替换后的命令行的内容。
　　除了使用shell的“-v”和“-x”选择项以外，还可以在shell程序内部采取一些辅助调试的措施。例如，可以在shell程序的一些关键地方使用echo命令把必要的信息显示出来，它的作用相当于C语言中的printf语句，这样就可以知道程序运行到什么地方及程序目前的状态。
　　七、bash的内部命令
　　bash命令解释程序包含了一些内部命令。内部命令在目录列表时是看不见的，它们由shell本身提供。常用的内部命令有：echo、eval、exec、export、readonly、read、shift、wait和点(.)。下面简单介绍其命令格式和功能。
　　1.echo
　　命令格式：echo arg
　　功能：在屏幕上打印出由arg指定的字符串。
　　2.eval
　　命令格式：eval args
　　功能：当shell程序执行到eval语句时，shell读入参数args，并将它们组合成一个新的命令，然后执行。
　　3.exec
　　命令格式：exec命令命令参数
　　功能：当shell执行到exec语句时，不会去创建新的子进程，而是转去执行指定的命令，当指定的命令执行完时，该进程，也就是最初的shell就终止了，所以shell程序中exec后面的语句将不再被执行。
　　4.export
　　命令格式：export变量名或：export变量名=变量值
　　功能：shell可以用export把它的变量向下带入子shell从而让子进程继承父进程中的环境变量。但子shell不能用export把它的变量向上带入父shell。
　　注意：不带任何变量名的export语句将显示出当前所有的export变量。
　　5.readonly
　　命令格式：readonly变量名
　　功能：将一个用户定义的shell变量标识为不可变的。不带任何参数的readonly命令将显示出所有只读的shell变量。
　　6.read
　　命令格式：
　　read变量名表
　　功能：从标准输入设备读入一行，分解成若干字，赋值给shell程序内部定义的变量。
　　7.shift语句
　　功能：shift语句按如下方式重新命名所有的位置参数变量：$2成为$1，$3成为$2……在程序中每使用一次shift语句，都使所有的位置参数依次向左移动一个位置，并使位置参数“$#”减一，直到减到0。
　　8.wait
　　功能：是shell等待在后台启动的所有子进程结束。Wait的返回值总是真。
　　9.exit
　　功能：退出shell程序。在exit之后可有选择地指定一个数字作为返回状态。
　　10.“.”(点)
　　命令格式：. Shell程序文件名
　　功能：使shell读入指定的shell程序文件并依次执行文件中的所有语句。
[]     
    
Shell学习笔记 一
文章整理: 文章来源: 网络 
一.linux文件的安全与权限
Linux文件的属性:
zhyfly: ~/sixiang$ ls -all
total 54
代码:drwxr-xr-x   2 zhyfly zhyfly   192 2005-03-03 11:31 .
drwxr-xr-x  36 zhyfly zhyfly  1976 2005-03-08 16:20 ..
-rw-r--r--   1 zhyfly zhyfly  5186 2005-02-28 13:03 1
-rw-r--r--   1 zhyfly zhyfly  4819 2005-02-28 13:04 2
-rw-r--r--   1 zhyfly zhyfly  5096 2005-02-28 13:05 3
-rw-r--r--   1 zhyfly zhyfly 18923 2005-02-28 13:41 4
-rw-r--r--   1 zhyfly zhyfly  3120 2005-02-28 13:43 5
-rw-r--r--   1 zhyfly zhyfly  1411 2005-02-28 13:43 6其中:
代码:total 54总用量 54：是ls所列出的入口占用空间的字节数(以K为单位)。
代码:-rw-r--r--该文件的权限位
第一个横杠：指定文件类型,表示该文件是一个普通文件。(所创建的文件绝大多数都是普通文件或符号链接文件)。
补充:
代码:-rwxrw-r-- 1 root admin 34890 10月 19 20:17 httpd.conf1.文件类型:
文件类型有七种，它可以从ls -l命令所列出的结果的第一位看出. 
d 目录。
l 符号链接(指向另一个文件)。
s 套接字文件。
b 块设备文件。
c 字符设备文件。
p 命名管道文件。
- 普通文件，或者更准确地说，不属于以上几种类型的文件。
2.文件权限:
前三位：rwx：它的所有者是root，即就是文件所有者，它对httpd.conf这个文件的权限是读写执行；
中间三位：rw-：表示admin组对这个文件的权限是读写
后面位:r--：就是即不是所有者,也不是属组的对文件的权限是读
3.umask及文件权限:
先我看看 x,r,w 的 bit 位元表示方式s
x: 001
w: 010
r: 100
如果⑷部位元做 OR \算就是最K permissionsrwx 的位置都是 111 oQ成十M位就是 7 了。
下面您如果入s
chmod 750 test.ls
您lF嘞成srwxr-x---o至於槭颤N如此o不妨算算看s
1)  750 Q成二M位o就是s111,101,000
2) 分e rwx 的位置代入得srwx,r-x,---
(方法s1 著的嘞蘧痛蜷_o0 的就P])
就@N ^_^
好了o我u已得算自己σn案碛惺颤N拥嘞蕞o也知道如何改n案的嘞拊O定。但是on案被建立的r候oAO@得怎拥嘞弈丞t@值就要靠 umask ?Q定了。如果您F在入 umasko得到 022 的值o@值Q定了n案在建立的r候o要拿掉什N拥嘞蕖Ｔ]有使用 umask 的r候o所建立的n案都是 777 @值的o但\用了 umask 之後呢o目 755o而n案t 644 。那是怎N得出?淼哪丞t是回到二M位吧o然後⑼暾嘞藓 umask M行 NOT 和 AND \算o就是最後的嘞拗怠
在建立目的r候s
1) 首先o我先 unmask M行 NOT \算s
000,010,010 的 NOT \算Y果是s111,101,101 r
2) 然後再和 777o也就是s111,111,111 M行 AND \算r
3) 最後o我得到@拥慕Y果s111,101,101 r
Q成十M位就是 755。
而至於n案的建立s
AO把它的 x (001) 拿掉o其?也是先M行 NOT + AND \算s
1) 先 x 做 NOT \算s001 NOT ==> 110
2) 然後和 111 做 AND \算s
111,111,111
110,110,110 AND
-----------------
110,110,110 ===> 也就是 666o 然後再和 umask 022 做 NOT 跟 AND \算s
111,101,101 AND
-----------------
110,100,100 ===> Q成十M位是 644 o@才是真正的Y果。
我的 umask 值是登入的r候o由 shell 的 profile 分配的(一般t是：user c group 同名 022o否t是 002)o我可以在任何r候改@值s用 umask 命令以新的值作稻涂梢粤拴o如sumask 002 o然後新建立的n案就成 664 的嘞蘖恕
tipss如果您不T用二M位M行算o只能用十M位?硭愕脑o可以蔚倪@铀悌s
目是用 777 扣掉 umask 的值r
n案是用 666 扣掉 umask 的值。
不^oX上面真正的\算是二M位啦o@和我算 IP subnet 的r候是一拥脑理。
查看umask的值:
代码:zhyfly: ~/1$ umask
0022修改umask的值:
代码:zhyfly: ~/1$ umask 0002
zhyfly: ~/1$ umask
0002彻底修改umask的值应修改.profile文件(bash)或.login文件(c shell)
4.修改文件权限chmod:
使用chmod来改变权限位
这一命令有符号模式和绝对模式。 
符号模式
chmod命令的一般格式为：
chmod [who] operator [permission] filename
w h o的含义是： 
代码:u 文件属主权限。
g 属组用户权限。
o 其他用户权限。
a 所有用户(文件属主、属组用户及其他用户)。o p e r a t o r的含义： 
代码:+ 增加权限。
- 取消权限。
= 设定权限。p e r m i s s i o n的含义： 
代码:r 读权限。
w 写权限。
x 执行权限。
s 文件属主和组set-ID。
t 粘性位*。
l 给文件加锁，使其他用户无法访问。
u,g,o 针对文件属主、属组用户及其他用户的操作。
*在列文件或目录时，有时会遇到“ t”位。“t”代表了粘性位。如果在一个目录上出现“t”位，这就意味着该目录中的文件只有其属主才可以删除，即使某个属组用户具有和属主同等的权限。不过有的系统在这一规则上并不十分严格。 
"t"权限用在文件上面是没有意义的，不是什么在交换区的概念，它跟文件的执行没有关系，而主要是为了文件共享设置的。
代码:chmod a-x temp //rw- rw- rw- 收回所有用户的执行权限
chmod og-w temp //rw- r-- r- - 收回属组用户和其他用户的写权限
chmod g+w temp //rw- rw- r- - 赋予属组用户写权限
chmod u+x temp //rwx rw- r- - 赋予文件属主执行权限
chmod go+x temp //rwx rwx r- x 赋予属组用户和其他用户执行权限
绝对模式
chmod命令绝对模式的一般形式为：
chmod [mode] file
其中m o d e是一个八进制数。
在绝对模式中，权限部分有着不同的含义。每一个权限位用一个八进制数来代表，如 
代码:0 4 0 0 文件属主可读
0 2 0 0 文件属主可写
0 1 0 0 文件属主可执行
0 0 4 0 属组用户可读
0 0 2 0 属组用户可写
0 0 1 0 属组用户可执行
0 0 0 4 其他用户可读
0 0 0 2 其他用户可写
0 0 0 1 其他用户可执行在设定权限的时候，只需按照上面查出与文件属主、属组用户和其他用户所具有的权限相对应的数字，并把它们加起来，就是相应的权限表示。
可以看出，文件属主、属组用户和其他用户分别所能够具有的最大权限值就是7。 
e.g
代码:-rwxr--r--  1   root            0 10月 19 20:16 temp相应的权限:
代码:rwx-：0400 + 0200 +0100 (文件属主可读、写、执行) = 0 7 0 0
r--：0 0 4 0 (属组用户可读) = 0 0 4 0
r--：0 0 4 0 (属组用户可读) = 0 0 4 0
0 7 4 4有一个计算八进制权限表示的更好办法，如下：
代码:文件属主：r w x：4 + 2 + 1
属组用户：r w x：4 + 2 + 1
其他用户：r w x：4 + 2 + 1
这上面这相，更容易地计算出相应的权限值，只要分别针对文件属主、属组用户和其他用户把相应权限下面的数字加在一起就可以了。
temp文件具有这样的权限：
代码:r w x     r - - r - -4+2+1 4 4
把相应权限位所对应的值加在一起，就是7 4 4。
如：
代码:chmod 666 rw- rw- rw- 赋予所有用户读和写的权限
chmod 644 rw- r-- r- - 赋予所有文件属主读和写的权限，所有其他用户读权限
chmod 744 rwx r-- r- - 赋予文件属主读、写和执行的权限，所有其他用户读的权限
chmod 664 rw- rw- r- - 赋予文件属主和属组用户读和写的权限，其他用户读权限
chmod 700 rwx --- --- 赋予文件属主读、写和执行的权限
chmod 444 r-- r-- r- - 赋予所有用户读权限
下面举一个例子，假定有一个名为temp的文件，具有如下权限：
代码:-rw-rw-r--  1   root            0 10月 19 20:16 test1
现在希望对该文件可读、写和执行， root组用户对该文件只读，可以键入：
代码:$chmod 740 test1
$ls -l
-rwxr-----  1   root            0 10月 19 20:16 test1
如果文件可读、写和执行，对其他所有用户只读，用：
代码:$chmod 744 test1
$ls -l
-rwxr--r--  1   root            0 10月 19 20:16 test1
如果希望一次设置目录下所有文件的权限，可以用：
代码:$chmod 664*
$ls -l
-rw-r--r--  1   root            0 10月 19 20:16 test1
这将使文件属主和属组用户都具有读和写的权限，其他用户只具有读权限。
还可以通过使用- R选项连同子目录下的文件一起设置：
代码:chmod -R 664 /temp/*
这样就可以一次将/ temp目录下的所有文件连同各个子目录下的文件的权限全部设置为文件属主和属组用户可读和写，其他用户只读。使用- R选项一定要谨慎，只有在需要改变目录树下全部文件权限时才可以使用。
5.修改文件属主chown:
c h o w n命令的一般形式为：
代码:chmod -R -h owner file
- R选项意味着对所有子目录下的文件也都进行同样的操作。
- h选项意味着在改变符号链接文件的属主时不影响该链接所指向的目标文件。
chown举例
如：
代码:# ls -l
drwxrwxr-x    2 sam      sam          4096 10月 26 19:48 sam
# chown gem sam
# ls -l
drwxrwxr-x    2 gem      sam          4096 10月 26 19:48 sam
文件sam的所有权现在由用户sam交给了用户gem。
6.修改文件属组chgrp:
chgrp举例
c h g r p命令和c h o w n命令的格式差不多，下面给出一个例子。
代码:# ls -l
drwxrwxr-x    2 gem      sam          4096 10月 26 19:48 sam
# chgrp group sam
# ls -l
drwxrwxr-x    2 gem      group        4096 10月 26 19:48 sam
现在把该文件sam所属的组由sam变为group。
找出你所属于的用户组
如果你希望知道自己属于哪些用户组，可以用ID这个命令：
代码:# su sam
$ id
uid=506(sam) gid=4(adm) groups=4(adm)
找出其他用户所属于的组
代码:# id
uid=0(root) gid=0(root) groups=0(root),1(bin),2(daemon),3(sys),4(adm),6(disk),10(wheel)查看当前用户所属组
代码:# id gem
uid=507(gem) gid=507(group) groups=507(group),0(root),4(adm)查看其它用户所用组：#id 用户名
代码:# su sam
$ id gem
uid=507(gem) gid=507(group) groups=507(group),0(root),4(adm)查看其它用户所属组
7.suid/sgid
为什么要使用这种类型的脚本？
例如有几个着几个大型的数据库系统，对它们进行备份需要有系统管理权限。可以写几个脚本，并设置了它们的g u i d，这样就可以指定的一些用户来执行这些脚本就能够完成相应的工作，而无须以数据库管理员的身份登录，以免不小心破坏了数据库服务器。通过执行这些脚本，他们可以完成数据库备份及其他管理任务，但是在这些脚本运行结束之后，他们就又回复到他们作为普通用户的权限。
查找suid/sgid命令
有相当一些U N I X命令也设置了s u i d和s g i d。如果想找出这些命令，可以进入/ b i n或/ s b i n目录，执行下面的命令：
代码:$ ls -l | grep '^...s'上面的命令是用来查找s u i d文件的；
代码:$ ls -l | grep '^...s..s'上面的命令是用来查找s u i d和gs g i d的。
设置UID
代码:设置s u i d：将相应的权限位之前的那一位设置为4；
设置g u i d：将相应的权限位之前的那一位设置为2；
两者都置位：将相应的权限位之前的那一位设置为4+2=6。
设置了这一位后x的位置将由s代替。
记住：在设置s u i d或s g i d的同时，相应的执行权限位必须要被设置。
例如，如果希望设置s g i d，那么必须要让该用户组具有执行权限。
如果想要对文件l o g i n[它当前所具有的权限为rwx rw- r-- (741)]设置s u i d，，可在使用c h m o d命令时在该权限数字的前面加上一个4，即chmod 4741，这将使该文件的权限变为r w s rw- r - -。
代码:$ chmod 4741 login
设置suid/sgid的例子
代码:      命令          结果        含义
chmod 4755   rws r-x r- x   文件被设置了s u i d，文件属主具有读、写和执行的权限，其他用户具有读和执行的权限
chmod 6711   rws --s --x    文件被设置了s u i d和g u i d，文件属主具有读、写和执行的权限，其他用户具有执行的权限
chmod 4764   rws rw- r- -   文件被设置了s u i d，文件属主具有读、写和执行的权限，属组用户具有读和执行的权限，用户具有读权限
还可以使用符号方式来设置s u i d / s g i d。如果某个文件具有这样的权限： rwx r-x r- x，那么可以这样设置其s u i d：
代码:chmod u+s <filename>
于是该文件的权限将变为： rws r-x r-x
在查找设置了s u i d的文件时，没准会看到具有这样权限的文件：rwS r-x r- x，其中S为大写。
它表示相应的执行权限位并未被设置，这是一种没有什么用处的s u i d设置，可以忽略它的存在。
注意，c h m o d命令不进行必要的完整性检查，可以给某一个没用的文件赋予任何权限，但chmod 命令并不会对所设置的权限组合做什么检查。因此，不要看到一个文件具有执行权限，就认为它一定是一个程序或脚本.
8.符号链接
存在两种不同类型的链接，软链接和硬链接。修改其中一个，硬连接指向的是节点(inode),而软连接指向的是路径(path) 
软链接文件
　　软链接又叫符号链接，这个文件包含了另一个文件的路径名。可以是任意文件或目录，可以链接不同文件系统的文件。和win下的快捷方式差不多。链接文件甚至可以链接不存在的文件，这就产生一般称之为"断链"的问题(或曰“现象")，链接文件甚至可以循环链接自己。类似于编程语言中的递归。
命令格式：
代码:ln -s source_path target_path
硬链接文件
　　info ln 命令告诉您，硬链接是已存在文件的另一个名字，硬连接的命令是
代码:ln [-d] existfile newfile
硬链接文件有两个限制
　　1、不允许给目录创建硬链接；
　　2、只有在同一文件系统中的文件之间才能创建链接。
　　对硬链接文件进行读写和删除操作时候，结果和软链接相同。但如果我们删除硬链接文件的源文件，硬链接文件仍然存在，而且保留了愿有的内容。这时，系统就“忘记”了它曾经是硬链接文件。而把他当成一个普通文件。修改其中一个，与其连接的文件同时被修改.
补充:Linux的用户和用户组管理
　Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。每个用户账号都拥有一个惟一的用户名和各自的口令。用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。
　　实现用户账号的管理，要完成的工作主要有如下几个方面：
　　・ 用户账号的添加、删除与修改。
　　・ 用户口令的管理。
　　・ 用户组的管理。 
9.Linux系统用户账号的管理
用户账号的管理工作主要涉及到用户账号的添加、修改和删除。
　　添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。 
a.添加新的用户账号使用useradd命令，其语法如下：
代码:useradd 选项 用户名
　　其中各选项含义如下：
代码:　　-c comment 指定一段注释性描述。
　　-d 目录 指定用户主目录，如果此目录不存在，则同时使用-m选项，可以创建主目录。
　　-g 用户组 指定用户所属的用户组。
　　-G 用户组，用户组 指定用户所属的附加组。
　　-s Shell文件 指定用户的登录Shell。
　　-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。　　用户名 指定新账号的登录名。 
例1：
代码:# useradd Cd /usr/sam -m sam
　　此命令创建了一个用户sam，
　　其中-d和-m选项用来为登录名sam产生一个主目录/usr/sam（/usr为默认的用户主目录所在的父目录）。
　　例2：
代码:# useradd -s /bin/sh -g group CG adm,root gem
　　此命令新建了一个用户gem，该用户的登录Shell是/bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。
　　这里可能新建组：#groupadd group及groupadd adm　
　
　　增加用户账号就是在/etc/passwd文件中为新用户增加一条记录，同时更新其他系统文件如/etc/shadow, /etc/group等。
　　Linux提供了集成的系统管理工具userconf，它可以用来对用户账号进行统一管理。 
b.删除帐号
　　如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。删除一个已有的用户账号使用userdel命令，其格式如下：
代码:userdel 选项 用户名
　　常用的选项是-r，它的作用是把用户的主目录一起删除。
　　例如：
　　
代码:# userdel sam
　　此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。 
c.修改帐号
　　修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。
　　修改已有用户的信息使用usermod命令，其格式如下：
代码:usermod 选项 用户名
　　常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。另外，有些系统可以使用如下选项：
代码:-l 新用户名
　　这个选项指定一个新的账号，即将原来的用户名改为新的用户名。
　　例如：
代码:# usermod -s /bin/ksh -d /home/z Cg developer sam
　　此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。 
d.用户口令的管理
　　用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。
　　指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。命令的格式为：
代码:passwd 选项 用户名
　　可使用的选项：
代码:　　-l 锁定口令，即禁用账号。
　　-u 口令解锁。
　　-d 使账号无口令。
　　-f 强迫用户下次登录时修改口令。
　　如果默认用户名，则修改当前用户的口令。
　　例如，假设当前用户是sam，则下面的命令修改该用户自己的口令：
代码:　　$ passwd
　　Old password:******
　　New password:*******
　　Re-enter new password:*******
　　如果是超级用户，可以用下列形式指定任何用户的口令：
代码:　　# passwd sam
　　New password:*******
　　Re-enter new password:*******
　　普通用户修改自己的口令时，passwd命令会先询问原口令，验证后再要求用户输入两遍新口令，如果两次输入的口令一致，则将这个口令指定给用户；而超级用户为用户指定口令时，就不需要知道原口令。
　　为了系统安全起见，用户应该选择比较复杂的口令，例如最好使用8位长的口令，口令中包含有大写、小写字母和数字，并且应该与姓名、生日等不相同。
　　为用户指定空口令时，执行下列形式的命令：
代码:# passwd -d sam
　　此命令将用户sam的口令删除，这样用户sam下一次登录时，系统就不再询问口令。
　　passwd命令还可以用-l(lock)选项锁定某一用户，使其不能登录，例如：
代码:# passwd -l sam[]     
    
Shell学习笔记 二
文章整理: 文章来源: 网络 
10.Linux系统用户组的管理
　　每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。
　　用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。
a.增加一个新的用户组使用groupadd命令。其格式如下：
　　
代码:groupadd 选项 用户组　　可以使用的选项有：
代码:　　-g GID 指定新用户组的组标识号（GID）。
　　-o 一般与-g选项同时使用，表示新用户组的GID可以与系统已有用户组的GID相同。　　例1：
　　
代码:# groupadd group1　　此命令向系统中增加了一个新组group1，新组的组标识号是在当前已有的最大组标识号的基础上加1。
　　例2：
　　
代码:#groupadd -g 101 group2　　此命令向系统中增加了一个新组group2，同时指定新组的组标识号是101。
b.如果要删除一个已有的用户组，使用groupdel命令，其格式如下：
　　
代码:groupdel 用户组　　例如：
　　
代码:#groupdel group1　　此命令从系统中删除组group1。
c.修改用户组的属性使用groupmod命令。其语法如下：
　　
代码:groupmod 选项 用户组　　常用的选项有：
代码:　　-g GID 为用户组指定新的组标识号。
　　-o 与-g选项同时使用，用户组的新GID可以与系统已有用户组的GID相同。
　　-n新用户组 将用户组的名字改为新名字
　　例1：
　　
代码:# groupmod -g 102 group2　　此命令将组group2的组标识号修改为102。
　　例2：
　　
代码:# groupmod Cg 10000 -n group3 group2　　此命令将组group2的标识号改为10000，组名修改为group3。
d.如果一个用户同时属于多个用户组，那么用户可以在用户组之间切换，以便具有其他用户组的权限。用户可以在登录后，使用命令newgrp切换到其他用户组，这个命令的参数就是目的用户组。例如：
　　
代码:$ newgrp root　　这条命令将当前用户切换到root用户组，前提条件是root用户组确实是该用户的主组或附加组。类似于用户账号的管理，用户组的管理也可以通过集成的系统管理工具来完成。
11.与用户账号有关的系统文件
　　完成用户管理的工作有许多种方法，但是每一种方法实际上都是对有关的系统文件进行修改。与用户和用户组相关的信息都存放在一些系统文件中，这些文件包括/etc/passwd, /etc/shadow, /etc/group等。下面分别介绍这些文件的内容。 
a./etc/passwd文件是用户管理工作涉及的最重要的一个文件。Linux系统中的每个用户都在/etc/passwd文件中有一个对应的记录行，它记录了这个用户的一些基本属性。这个文件对所有用户都是可读的。它的内容类似下面的例子：
代码:　　＃ cat /etc/passwd
      root:x:0:0:Superuser:/:
　　daemon:x:1:1:System daemons:/etc:
　　bin:x:2:2:Owner of system commands:/bin:
　　sys:x:3:3:Owner of system files:/usr/sys:
　　adm:x:4:4:System accounting:/usr/adm:
　　uucp:x:5:5:UUCP administrator:/usr/lib/uucp:
　　auth:x:7:21:Authentication administrator:/tcb/files/auth:
　　cron:x:9:16:Cron daemon:/usr/spool/cron:
　　listen:x:37:4:Network daemon:/usr/net/nls:
　　lp:x:71:18:Printer administrator:/usr/spool/lp:
　　sam:x:200:50:Sam san:/usr/sam:/bin/sh
　　从上面的例子我们可以看到，/etc/passwd中一行记录对应着一个用户，每行记录又被冒号(分隔为7个字段，其格式和具体含义如下：
代码:用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell
　　1）“用户名”是代表用户账号的字符串。通常长度不超过8个字符，并且由大小写字母和/或数字组成。登录名中不能有冒号(，因为冒号在这里是分隔符。为了兼容起见，登录名中最好不要包含点字符(.)，并且不使用连字符(-)和加号(+)打头。
　　2）“口令”一些系统中，存放着加密后的用户口令字。。虽然这个字段存放的只是用户口令的加密串，不是 明文，但是由于/etc/passwd文件对所有用户都可读，所以这仍是一个安全隐患。因此，现在许多 Linux 系统（如SVR4）都使用了shadow技术，把真正的加密后的用户口令字存放到/etc/shadow文件中，而在/etc/passwd文件的口令字段中只存放一个特殊的字符，例如“x”或者“*”。
　　3）“用户标识号”是一个整数，系统内部用它来标识用户。一般情况下它与用户名是一一对应的。如果几个用户名对应的用户标识号是一样的，系统内部将把它们视为同一个用户，但是它们可以有不同的口令、不同的主目录以及不同的登录Shell等。
　　通常用户标识号的取值范围是0～65 535。0是超级用户root的标识号，1～99由系统保留，作为管理账号，普通用户的标识号从100开始。在Linux系统中，这个界限是500。
　　4）“组标识号”字段记录的是用户所属的用户组。它对应着/etc/group文件中的一条记录。
　　5)“注释性描述”字段记录着用户的一些个人情况，例如用户的真实姓名、电话、地址等，这个字段并没有什么实际的用途。在不同的Linux 系统中，这个字段的格式并没有统一。在许多Linux系统中，这个字段存放的是一段任意的注释性描述文字，用做finger命令的输出。
　　6)“主目录”，也就是用户的起始工作目录，它是用户在登录到系统之后所处的目录。在大多数系统中，各用户的主目录都被组织在同一个特定的目录下，而用户主目录的名称就是该用户的登录名。各用户对自己的主目录有读、写、执行（搜索）权限，其他用户对此目录的访问权限则根据具体情况设置。
　　7)用户登录后，要启动一个进程，负责将用户的操作传给内核，这个进程是用户登录到系统后运行的命令解释器或某个特定的程序，即Shell。Shell 是用户与Linux系统之间的接口。Linux的Shell有许多种，每种都有不同的特点。常用的有sh(Bourne Shell), csh(C Shell), ksh(Korn Shell), tcsh(TENEX/TOPS-20 type C Shell), bash(Bourne Again Shell)等。系统管理员可以根据系统情况和用户习惯为用户指定某个Shell。如果不指定Shell，那么系统使用sh为默认的登录Shell，即这个字段的值为/bin/sh。
　　用户的登录Shell也可以指定为某个特定的程序（此程序不是一个命令解释器）。利用这一特点，我们可以限制用户只能运行指定的应用程序，在该应用程序运行结束后，用户就自动退出了系统。有些Linux 系统要求只有那些在系统中登记了的程序才能出现在这个字段中。
　　系统中有一类用户称为伪用户（psuedo users），这些用户在/etc/passwd文件中也占有一条记录，但是不能登录，因为它们的登录Shell为空。它们的存在主要是方便系统管理，满足相应的系统进程对文件属主的要求。常见的伪用户如下所示。
代码:伪  用  户         含     义
bin                        拥有可执行的用户命令文件
sys                       拥有系统文件
adm                     拥有帐户文件
uucp                    UUCP使用
lp                         lp或lpd子系统使用
nobody                 NFS使用拥有帐户文件
　　除了上面列出的伪用户外，还有许多标准的伪用户，例如：audit, cron, mail, usenet等，它们也都各自为相关的进程和文件所需要。
　　由于/etc/passwd文件是所有用户都可读的，如果用户的密码太简单或规律比较明显的话，一台普通的计算机就能够很容易地将它破解，因此对安全性要求较高的Linux系统都把加密后的口令字分离出来，单独存放在一个文件中，这个文件是/etc/shadow文件。只有超级用户才拥有该文件读权限，这就保证了用户密码的安全性。
b./etc/shadow中的记录行与/etc/passwd中的一一对应，它由pwconv命令根据/etc/passwd中的数据自动产生。它的文件格式与/etc/passwd类似，由若干个字段组成，字段之间用“:”隔开。这些字段是：
代码:登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志
　　1）“登录名”是与/etc/passwd文件中的登录名相一致的用户账号
　　2）“口令”字段存放的是加密后的用户口令字，长度为13个字符。如果为空，则对应用户没有口令，登录时不需要口令；如果含有不属于集合 { ./0-9A-Za-z }中的字符，则对应的用户不能登录。
　　3）“最后一次修改时间”表示的是从某个时刻起，到用户最后一次修改口令时的天数。时间起点对不同的系统可能不一样。例如在SCO Linux 中，这个时间起点是1970年1月1日。
　　4）“最小时间间隔”指的是两次修改口令之间所需的最小天数。
　　5）“最大时间间隔”指的是口令保持有效的最大天数。
　　6）“警告时间”字段表示的是从系统开始警告用户到用户密码正式失效之间的天数。
　　7）“不活动时间”表示的是用户没有登录活动但账号仍能保持有效的最大天数。
　　8）“失效时间”字段给出的是一个绝对的天数，如果使用了这个字段，那么就给出相应账号的生存期。期满后，该账号就不再是一个合法的账号，也就不能再用来登录了。
　　下面是/etc/shadow的一个例子：
　　
代码:＃ cat /etc/shadow
    root:Dnakfw28zf38w:8764:0:168:7:::
　 daemon:*::0:0::::
　 bin:*::0:0::::
　 sys:*::0:0::::
　 adm:*::0:0::::
　 uucp:*::0:0::::
　 nuucp:*::0:0::::
　 auth:*::0:0::::
　 cron:*::0:0::::
　 listen:*::0:0::::
　 lp:*::0:0::::
　 sam:EkdiSECLWPdSa:9740:0:0::::
c.用户组的所有信息都存放在/etc/group文件中。
将用户分组是Linux 系统中对用户进行管理及控制访问权限的一种手段。每个用户都属于某个用户组；一个组中可以有多个用户，一个用户也可以属于不同的组。当一个用户同时是多个组中的成员时，在/etc/passwd文件中记录的是用户所属的主组，也就是登录时所属的默认组，而其他组称为附加组。用户要访问属于附加组的文件时，必须首先使用newgrp命令使自己成为所要访问的组中的成员。用户组的所有信息都存放在/etc/group文件中。此文件的格式也类似于 /etc/passwd文件，由冒号(隔开若干个字段，这些字段有：
　　
代码:组名:口令:组标识号:组内用户列表
　　1）“组名”是用户组的名称，由字母或数字构成。与/etc/passwd中的登录名一样，组名不应重复。
　　2）“口令”字段存放的是用户组加密后的口令字。一般Linux 系统的用户组都没有口令，即这个字段一般为空，或者是*。
　　3）“组标识号”与用户标识号类似，也是一个整数，被系统内部用来标识组。
　　4）“组内用户列表”是属于这个组的所有用户的列表/b]，不同用户之间用逗号(,)分隔。这个用户组可能是用户的主组，也可能是附加组。
　　/etc/group文件的一个例子如下：
代码:# cat /etc/group
　　root::0:root
　　bin::2:root,bin
　　sys::3:root,uucp
　　adm::4:root,adm
　　daemon::5:root,daemon
　　lp::7:root,lp
　　users::20:root,sam12.添加量用户批 
添加和删除用户对每位Linux系统管理员都是轻而易举的事，比较棘手的是如果要添加几十个、上百个甚至上千个用户时，我们不太可能还使用useradd一个一个地添加，必然要找一种简便的创建大量用户的方法。Linux系统提供了创建大量用户的工具，可以让您立即创建大量用户，方法如下：
　　（1）先编辑一个文本用户文件，每一列按照/etc/passwd密码文件的格式书写，要注意每个用户的用户名、UID、宿主目录都不可以相同，其中密码栏可以留做空白或输入x号。一个范例文件user.txt内容如下：
代码:　　user001::600:100:user:/home/user001:/bin/bash
　　user002::601:100:user:/home/user002:/bin/bash
　　user003::602:100:user:/home/user003:/bin/bash
　　user004::603:100:user:/home/user004:/bin/bash
　　user005::604:100:user:/home/user005:/bin/bash
　　user006::605:100:user:/home/user006:/bin/bash　　（2）以root身份执行命令/usr/sbin/newusers，从刚创建的用户文件user.txt中导入数据，创建用户：
代码:# newusers < user.txt
　　然后可以执行命令vipw或vi /etc/passwd检查/etc/passwd文件是否已经出现这些用户的数据，并且用户的宿主目录是否已经创建。
　　（3）执行命令/usr/sbin/pwunconv，将/etc/shadow产生的shadow密码解码，然后回写到/etc/passwd中，并将/etc/shadow的shadow密码栏删掉。这是为了方便下一步的密码转换工作，即先取消shadow password功能。
代码:# pwunconv
　　（4）编辑每个用户的密码对照文件，范例文件passwd.txt内容如下：
代码:　　user001:密码
　　user002:密码
　　user003:密码
　　user004:密码
　　user005:密码
　　user006:密码　　（5）以root身份执行命令/usr/sbin/chpasswd，创建用户密码，chpasswd会将经过/usr/bin/passwd命令编码过的密码写入/etc/passwd的密码栏。
　　
代码:# chpasswd < passwd.txt
　　（6）确定密码经编码写入/etc/passwd的密码栏后，执行命令/usr/sbin/pwconv将密码编码为shadow password，并将结果写入/etc/shadow。
代码:# pwconv
　　这样就完成了大量用户的创建了，之后您可以到/home下检查这些用户宿主目录的权限设置是否都正确，并登录验证用户密码是否正确。
13.赋予普通用户特殊权限
　　在Linux系统中，管理员往往不止一人，若每位管理员都用root身份进行管理工作，根本无法弄清楚谁该做什么。所以最好的方式是：管理员创建一些普通用户，分配一部分系统管理工作给他们。
　　我们不可以使用su让他们直接变成root，因为这些用户都必须知道root的密码，这种方法很不安全，而且也不符合我们的分工需求。一般的做法是利用权限的设置，依工作性质分类，让特殊身份的用户成为同一个工作组，并设置工作组权限。例如：要wwwadm这位用户负责管理网站数据，一般Apache Web Server的进程httpd的所有者是www，您可以设置用户wwwadm与www为同一工作组，并设置Apache默认存放网页目录 /usr/local/httpd/htdocs的工作组权限为可读、可写、可执行，这样属于此工作组的每位用户就可以进行网页的管理了。
　　但这并不是最好的解决办法，例如管理员想授予一个普通用户关机的权限，这时使用上述的办法就不是很理想。这时您也许会想，我只让这个用户可以以root身份执行shutdown命令就行了。完全没错，可惜在通常的Linux系统中无法实现这一功能，不过已经有了工具可以实现这样的功能――sudo。
　　sudo通过维护一个特权到用户名映射的数据库将特权分配给不同的用户，这些特权可由数据库中所列的一些不同的命令来识别。为了获得某一特权项，有资格的用户只需简单地在命令行输入sudo与命令名之后，按照提示再次输入口令（用户自己的口令，不是root用户口令）。例如，sudo允许普通用户格式化磁盘，但是却没有赋予其他的root用户特权。
sudo工具由文件/etc/sudoers进行配置，该文件包含所有可以访问sudo工具的用户列表并定义了他们的特权。一个典型的/etc/sudoers条目如下：
代码:liming ALL=(ALL) ALL
　　这个条目使得用户liming作为超级用户访问所有应用程序，如用户liming需要作为超级用户运行命令，他只需简单地在命令前加上前缀sudo。因此，要以root用户的身份执行命令format，liming可以输入如下命令：
代码:# sudo /usr/sbin/useradd sam
　　注意：命令要写绝对路径，/usr/sbin默认不在普通用户的搜索路径中，或者加入此路径：PATH=$PATH:/usr/sbin;export PATH。另外，不同系统命令的路径不尽相同，可以使用命令“whereis 命令名”来查找其路径。
　　这时会显示下面的输出结果：
代码:　　We trust you have received the usual lecture from the local System
　　Administrator. It usually boils down to these two things:
　　#1) Respect the privacy of others.
　　#2) Think before you type.
　　Password:　　如果liming正确地输入了口令，命令useradd将会以root用户身份执行。
　　注意：配置文件/etc/sudoers必须使用命令 Visudo来编辑。
　　只要把相应的用户名、主机名和许可的命令列表以标准的格式加入到文件/etc/sudoers，并保存就可以生效，再看一个例子。
例子：管理员需要允许gem用户在主机sun上执行reboot和shutdown命令，在/etc/sudoers中加入：
代码:gem sun=/usr/sbin/reboot，/usr/sbin/shutdown　　注意：命令一定要使用绝对路径，以避免其他目录的同名命令被执行，从而造成安全隐患。
　　然后保存退出，gem用户想执行reboot命令时，只要在提示符下运行下列命令：
代码:$ sudo /usr/sbin/reboot　　输入正确的密码，就可以重启服务器了。
　　如果您想对一组用户进行定义，可以在组名前加上%，对其进行设置，如：
代码:%cuug ALL=(ALL) ALL另外，还可以利用别名来简化配置文件。别名类似组的概念，有用户别名、主机别名和命令别名。多个用户可以首先用一个别名来定义，然后在规定他们可以执行什么命令的时候使用别名就可以了，这个配置对所有用户都生效。主机别名和命令别名也是如此。注意使用前先要在/etc/sudoers中定义：User_Alias, Host_Alias, Cmnd_Alias项，在其后面加入相应的名称，也以逗号分隔开就可以了，举例如下：
代码:　　Host_Alias SERVER=no1
　　User_Alias ADMINS=liming，gem
　　Cmnd_Alias SHUTDOWN=/usr/sbin/halt，/usr/sbin/shutdown，/usr/sbin/reboot
　　ADMINS SERVER=SHUTDOWN再看这个例子：
代码:ADMINS ALL=(ALL) NOPASSWD: ALL　　表示允许ADMINS不用口令执行一切操作，其中“NOPASSWD:”项定义了用户执行操作时不需要输入口令。
sudo命令还可以加上一些参数，完成一些辅助的功能，如
代码:$ sudo Cl　　会显示出类似这样的信息：
代码:　　User liming may run the following commands on this host:
　　(root) /usr/sbin/reboot　　说明root允许用户liming执行/usr/sbin/reboot命令。这个参数可以使用户查看自己目前可以在sudo中执行哪些命令。
在命令提示符下键入sudo命令会列出所有参数，其他一些参数如下：
代码:　　-V 显示版本编号。
　　-h 显示sudo命令的使用参数。
　　-v 因为sudo在第一次执行时或是在N分钟内没有执行（N预设为5）会询问密码。这个参数是重新做一次确认，如果超过N分钟，也会问密码。
　　-k 将会强迫使用者在下一次执行sudo时询问密码（不论有没有超过N分钟）。
　　-b 将要执行的命令放在背景执行。
　　-p prompt 可以更改问密码的提示语，其中%u会替换为使用者的账号名称，%h会显示主机名称。
　　-u username/#uid 不加此参数，代表要以root的身份执行命令，而加了此参数，可以以username的身份执行命令（#uid为该username的UID）。
　　-s 执行环境变量中的 SHELL 所指定的 Shell ，或是 /etc/passwd 里所指定的 Shell。
　　-H 将环境变量中的HOME（宿主目录）指定为要变更身份的使用者的宿主目录。（如不加-u参数就是系统管理者root。）　　 要以系统管理者身份（或以-u更改为其他人）执行的命令。 
[]     
    
Shell学习笔记 三
文章整理: 文章来源: 网络 
二.Linux文件查找命令find,xargs详述
1.find
由于f i n d具有强大的功能，所以它的选项也很多，其中大部分选项都值得我们花时间来了解一下。即使系统中含有网络文件系统( N F S )，f i n d命令在该文件系统中同样有效，只你具有相应的权限。
在运行一个非常消耗资源的f i n d命令时，很多人都倾向于把它放在后台执行，因为遍历一个大的文件系统可能会花费很长的时间(这里是指3 0 G字节以上的文件系统)。
F i n d命令的一般形式为：
代码:find pathname -options [-print -exec -ok ...]让我们来看看该命令的参数：
代码:pathname: find命令所查找的目录路径。例如用.来表示当前目录，用/来表示系统根目录。
-print： find命令将匹配的文件输出到标准输出。
-exec： find命令对匹配的文件执行该参数所给出的s h e l l命令。相应命令的形式为' command' {} \;，注意{ }和\；之间的空格。
-ok： 和- e x e c的作用相同，只不过以一种更为安全的模式来执行该参数所给出的s h e l l命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。find命令选项
代码:-name：按照文件名查找文件。
-perm：按照文件权限来查找文件。
-prune：使用这一选项可以使f i n d命令不在当前指定的目录中查找，如果同时使用-depth选项，那么-prune将被f i n d命令忽略。
-user： 按照文件属主来查找文件。
-group：按照文件所属的组来查找文件。
-mtime -n +n：按照文件的更改时间来查找文件， - n表示文件更改时间距现在n天以内，+ n表示文件更改时间距现在n天以前。F i n d命令还有- a t i m e和- c t i m e选项，但它们都和- m t i m e选项。
-nogroup：查找无有效所属组的文件，即该文件所属的组在/ e t c / g r o u p s中不存在。
-nouser：查找无有效属主的文件，即该文件的属主在/ e t c / p a s s w d中不存在。
-newer file1 ! file2：查找更改时间比文件f i l e 1新但比文件f i l e 2旧的文件。
-type 查找某一类型的文件，诸如：
b - 块设备文件。
d - 目录。
c - 字符设备文件。
p - 管道文件。
l - 符号链接文件。
f - 普通文件。
-size n：[c] 查找文件长度为n块的文件，带有c时表示文件长度以字节计。
-depth：在查找文件时，首先查找当前目录中的文件，然后再在其子目录中查找。
-fstype：查找位于某一类型文件系统中的文件，这些文件系统类型通常可以在配置文件/ e t c / f s t a b中找到，该配置文件中包含了本系统中有关文件系统的信息。
-mount：在查找文件时不跨越文件系统m o u n t点。
-follow：如果f i n d命令遇到符号链接文件，就跟踪至链接所指向的文件。
-cpio：对匹配的文件使用c p i o命令，将这些文件备份到磁带设备中。另外,下面三个的区别:
代码:
     -amin n
　　查找系统中最后N分钟访问的文件
　　-atime n
　　查找系统中最后n*24小时访问的文件
　　-cmin n
　　查找系统中最后N分钟被改变文件状态的文件
　　-ctime n
　　查找系统中最后n*24小时被改变文件状态的文件
   　-mmin n
　　查找系统中最后N分钟被改变文件数据的文件
　　-mtime n
　　查找系统中最后n*24小时被改变文件数据的文件使用exec或ok来执行shell命令
使用find时，只要把想要的操作写在一个文件里，就可以用exec来配合find查找，很方便的
（在有些操作系统中只允许- e x e c选项执行诸如l s或ls -l这样的命令）。大多数用户使用这一选项是为了查找旧文件并删除它们。建议在真正执行r m命令删除文件之前，最好先用l s命令看一下，确认它们是所要删除的文件。
e x e c选项后面跟随着所要执行的命令或脚本，然后是一对儿{ }，一个空格和一个\，最后是一个分号。
为了使用e x e c选项，必须要同时使用p r i n t选项。如果验证一下f i n d命令，会发现该命令只输出从当前路径起的相对路径及文件名。
例如：为了用ls -l命令列出所匹配到的文件，可以把ls -l命令放在f i n d命令的- e x e c选项中
代码:# find . -type f -exec ls -l {} \;
-rw-r--r--    1 root     root        34928 2003-02-25  ./conf/httpd.conf
-rw-r--r--    1 root     root        12959 2003-02-25  ./conf/magic
-rw-r--r--    1 root     root          180 2003-02-25  ./conf.d/README上面的例子中，f i n d命令匹配到了当前目录下的所有普通文件，并在- e x e c选项中使用ls -l命令将它们列出。
在/ l o g s目录中查找更改时间在5日以前的文件并删除它们：
代码:$ find logs -type f -mtime +5 -exec rm {} \;记住，在s h e l l中用任何方式删除文件之前，应当先查看相应的文件，一定要小心！当使用诸如m v或r m命令时，可以使用- e x e c选项的安全模式。它将在对每个匹配到的文件进行操作之前提示你。
在下面的例子中， f i n d命令在当前目录中查找所有文件名以. L O G结尾、更改时间在5日以上的文件，并删除它们，只不过在删除之前先给出提示。
代码:$ find . -name "*.conf"  -mtime +5 -ok rm {} \;
< rm ... ./conf/httpd.conf > ? n按y键删除文件，按n键不删除。
任何形式的命令都可以在- e x e c选项中使用。
在下面的例子中我们使用g r e p命令。f i n d命令首先匹配所有文件名为“ passwd*”的文件，例如passwd、passwd.old、passwd.bak，然后执
行grep命令看看在这些文件中是否存在一个sam用户。
代码:# find /etc -name "passwd*" -exec grep "sam" {} \;
sam:x:501:501::/usr/sam:/bin/bash
find命令的例子
查找当前用户主目录下的所有文件，下面两种方法都可以使用：
代码:$ find $HOME -print
$ find ~ -print为了在当前目录中文件属主具有读、写权限，并且文件所属组的用户和其他用户具有读权限的文件，可以用：
代码:$ find . -type f -perm 644 -exec ls -l {} \;为了查找系统中所有文件长度为0的普通文件，并列出它们的完整路径，可以用：
代码:$ find / -type f -size 0 -exec ls -l {} \;查找/var/logs目录中更改时间在7日以前的普通文件，并在删除之前询问它们:
代码:$ find /var/logs -type f -mtime +7 -ok rm {} \;为了查找系统中所有属于root组的文件，可以用：
代码:$find . -group root -exec ls -l {} \;
-rw-r--r--    1 root     root          595 10月 31 01:09 ./fie1
下面的find命令将删除当目录中访问时间在7日以来、含有数字后缀的admin.log文件。该命令只检查三位数字，所以相应文件的后缀不要超过999。
先建几个admin.log*的文件 ，才能使用下面这个命令
代码:$ find . -name "admin.log[0-9][0-9][0-9]" -atime -7  -ok
rm {} \;
< rm ... ./admin.log001 > ? n
< rm ... ./admin.log002 > ? n
< rm ... ./admin.log042 > ? n
< rm ... ./admin.log942 > ? n为了查找当前文件系统中的所有目录并排序，可以用：
代码:$ find . -type d  |sort为了查找系统中所有的r m t磁带设备，可以用：
代码:$ find /dev/rmt -print2.xargs
在使用f i n d命令的- e x e c选项处理匹配到的文件时， f i n d命令将所有匹配到的文件一起传递给e x e c执行。但有些系统对能够传递给e x e c的命令长度有限制，这样在f i n d命令运行几分钟之后，就会出现溢出错误。错误信息通常是“参数列太长”或“参数列溢出”。这就是x a rg s命令的用处所在，特别是与f i n d命令一起使用。
F i n d命令把匹配到的文件传递给x a rg s命令，而x a rg s命令每次只获取一部分文件而不是全部，不像- e x e c选项那样。这样它可以先处理最先获取的一部分文件，然后是下一批，并如此继续下去。
在有些系统中，使用- e x e c选项会为处理每一个匹配到的文件而发起一个相应的进程，并非将匹配到的文件全部作为参数一次执行；这样在有些情况下就会出现进程过多，系统性能下降的问题，因而效率不高；
而使用x a rg s命令则只有一个进程。另外，在使用x a rg s命令时，究竟是一次获取所有的参数，还是分批取得参数，以及每一次获取参数的数目都会根据该命令的选项及系统内核中相应的可调参数来确定。
来看看x a rg s命令是如何同f i n d命令一起使用的，并给出一些例子。
下面的例子查找系统中的每一个普通文件，然后使用x a rg s命令来测试它们分别属于哪类文件
代码:#find . -type f -print | xargs file
./.kde/Autostart/Autorun.desktop: UTF-8 Unicode English text
./.kde/Autostart/.directory:      ISO-8859 text......在整个系统中查找内存信息转储文件(core dump) ，然后把结果保存到/tmp/core.log 文件中：
代码:$ find / -name "core" -print | xargs echo "" >/tmp/core.log上面这个执行太慢，我改成在当前目录下查找
代码:#find . -name "file*" -print | xargs echo "" > /temp/core.log
# cat /temp/core.log
./file6在当前目录下查找所有用户具有读、写和执行权限的文件，并收回相应的写权限：
代码:
# ls -l
drwxrwxrwx    2 sam      adm          4096 10月 30 20:14 file6
-rwxrwxrwx    2 sam      adm             0 10月 31 01:01 http3.conf
-rwxrwxrwx    2 sam      adm             0 10月 31 01:01 httpd.conf
# find . -perm -7 -print | xargs chmod o-w
# ls -l
drwxrwxr-x    2 sam      adm          4096 10月 30 20:14 file6
-rwxrwxr-x    2 sam      adm             0 10月 31 01:01 http3.conf
-rwxrwxr-x    2 sam      adm             0 10月 31 01:01 httpd.conf用g r e p命令在所有的普通文件中搜索hostname这个词：
代码:# find . -type f -print | xargs grep "hostname"
./httpd1.conf:#     different IP addresses or hostnames and have them handled by the
./httpd1.conf:# VirtualHost: If you want to maintain multiple domains/hostnames
on your用g r e p命令在当前目录下的所有普通文件中搜索hostnames这个词：
代码:# find . -name \* -type f -print | xargs grep "hostnames"
./httpd1.conf:#     different IP addresses or hostnames and have them handled by the
./httpd1.conf:# VirtualHost: If you want to maintain multiple domains/hostnames
on your注意，在上面的例子中， \用来取消f i n d命令中的*在s h e l l中的特殊含义。
3.f i n d命令配合使用e x e c和x a rg s可以使用户对所匹配到的文件执行几乎所有的命令。
下面是find一些常用参数的例子，有用到的时候查查就行了，像上面前几个贴子，都用到了其中的的一些参数，也可以用man或查看论坛里其它贴子有find的命令手册
a.使用name选项
文件名选项是f i n d命令最常用的选项，要么单独使用该选项，要么和其他选项一起使用。
可以使用某种文件名模式来匹配文件，记住要用引号将文件名模式引起来。
不管当前路径是什么，如果想要在自己的根目录$ H O M E中查找文件名符合* . t x t的文件，使用~作为' p a t h n a m e参数，波浪号~代表了你的$ H O M E目录。
代码:$ find ~ -name "*.txt" -print想要在当前目录及子目录中查找所有的‘ * . t x t’文件，可以用：
代码:$ find . -name "*.txt" -print想要的当前目录及子目录中查找文件名以一个大写字母开头的文件，可以用：
代码:$ find . -name "[A-Z]*" -print想要在/ e t c目录中查找文件名以h o s t开头的文件，可以用：
代码:$ find /etc -name "host*" -print想要查找$ H O M E目录中的文件，可以用：
代码:$ find ~ -name "*" -print 或find . -print要想让系统高负荷运行，就从根目录开始查找所有的文件。
代码:$ find / -name "*" -print如果想在当前目录查找文件名以两个小写字母开头，跟着是两个数字，最后是. t x t的文件，下面的命令就能够返回名为a x 3 7 . t x t的文件：
代码:$find . -name "[a-z][a-z][0--9][0--9].txt" -print
b.用perm选项
按照文件权限模式用- p e r m选项。
按文件权限模式来查找文件的话。最好使用八进制的权限表示法。
如在当前目录下查找文件权限位为7 5 5的文件，即文件属主可以读、写、执行，其他用户可以读、执行的文件，可以用：
代码:$ find . -perm 755 -print还有一种表达方法：在八进制数字前面要加一个横杠-，表示都匹配，如-007就相当于777，-006相当于666
代码:# ls -l
-rwxrwxr-x    2 sam      adm             0 10月 31 01:01 http3.conf
-rw-rw-rw-    1 sam      adm         34890 10月 31 00:57 httpd1.conf
-rwxrwxr-x    2 sam      adm             0 10月 31 01:01 httpd.conf
drw-rw-rw-    2 gem      group        4096 10月 26 19:48 sam
-rw-rw-rw-    1 root     root         2792 10月 31 20:19 temp
# find . -perm 006
# find . -perm -006
./sam
./httpd1.conf
./temp-perm mode:文件许可正好符合mode
-perm +mode:文件许可部分符合mode
-perm -mode: 文件许可完全符合mode
c.忽略某个目录
如果在查找文件时希望忽略某个目录，因为你知道那个目录中没有你所要查找的文件，那么可以使用- p r u n e选项来指出需要忽略的目录。在使用- p r u n e选项时要当心，因为如果你同时使用了- d e p t h选项，那么- p r u n e选项就会被f i n d命令忽略。
如果希望在/ a p p s目录下查找文件，但不希望在/ a p p s / b i n目录下查找，可以用：
代码:$ find /apps -path "/apps/bin" -prune -o -print补充:
使用find查找文件的时候怎么避开某个文件目录
比如要在/usr/sam目录下查找不在dir1子目录之内的所有文件
代码:find /usr/sam -path "/usr/sam/dir1" -prune -o -print
find [-path ..] [expression] 在路径列表的后面的是表达式
-path "/usr/sam" -prune -o -print 是 -path "/usr/sam" -a -prune -o -print 的简写表达式按顺序求值, -a 和 -o 都是短路求值，与 shell 的 && 和 || 类似如果 -path "/usr/sam" 为真，则求值 -prune , -prune 返回真，与逻辑表达式为真；否则不求值 -prune ，与逻辑表达式为假。如果 -path "/usr/sam" -a -prune 为假，则求值 -print ，-print 返回真，或逻辑表达式为真；否则不求值 -print，或逻辑表达式为真。
这个表达式组合特例可以用伪码写为
代码:if -path "/usr/sam"  then
          -prune
else
          -print避开多个文件夹
代码:find /usr/sam \( -path /usr/sam/dir1 -o -path /usr/sam/file1 \) -prune -o -print圆括号表示表达式的结合。
\ 表示引用，即指示 shell 不对后面的字符作特殊解释，而留给 find 命令去解释其意义。
查找某一确定文件，-name等选项加在-o 之后
代码:#find /usr/sam  \(-path /usr/sam/dir1 -o -path /usr/sam/file1 \) -prune -o -name "temp" -print4.使用user和nouser选项
按文件属主查找文件，如在$ H O M E目录中查找文件属主为sam的文件，可以用：
代码:$ find ~ -user sam -print在/ e t c目录下查找文件属主为u u c p的文件：
代码:$ find /etc -user uucp -print为了查找属主帐户已经被删除的文件，可以使用- n o u s e r选项。这样就能够找到那些属主在/ e t c / p a s s w d文件中没有有效帐户的文件。在使用- n o u s e r选项时，不必给出用户名； f i n d命令能够为你完成相应的工作。
例如，希望在/ h o m e目录下查找所有的这类文件，可以用：
代码:$ find /home -nouser -print5、使用group和nogroup选项
就像u s e r和n o u s e r选项一样，针对文件所属于的用户组， f i n d命令也具有同样的选项，为了在/ a p p s目录下查找属于gem用户组的文件，可以用：
代码:$ find /apps -group gem -print要查找没有有效所属用户组的所有文件，可以使用n o g r o u p选项。下面的f i n d命令从文件系统的根目录处查找这样的文件
代码:$ find / -nogroup-print6、按照更改时间或访问时间等查找文件
如果希望按照更改时间来查找文件，可以使用m t i m e,atime或ctime选项。如果系统突然没有可用空间了，很有可能某一个文件的长度在此期间增长迅速，这时就可以用m t i m e选项来查找这样的文件。
用减号-来限定更改时间在距今n日以内的文件，而用加号+来限定更改时间在距今n日以前的文件。
希望在系统根目录下查找更改时间在5日以内的文件，可以用：
代码:$ find / -mtime -5 -print为了在/ v a r / a d m目录下查找更改时间在3日以前的文件，可以用：
代码:$ find /var/adm -mtime +3 -print7、查找比某个文件新或旧的文件
如果希望查找更改时间比某个文件新但比另一个文件旧的所有文件，可以使用- n e w e r选项。它的一般形式为：
代码:newest_file_name ! oldest_file_name其中，！是逻辑非符号。
查找更改时间比文件sam新但比文件temp旧的文件：
例：有两个文件
代码:-rw-r--r--    1 sam      adm             0 10月 31 01:07 fiel
-rw-rw-rw-    1 sam      adm         34890 10月 31 00:57 httpd1.conf
-rwxrwxr-x    2 sam      adm             0 10月 31 01:01 httpd.conf
drw-rw-rw-    2 gem      group        4096 10月 26 19:48 sam
-rw-rw-rw-    1 root     root         2792 10月 31 20:19 temp
# find -newer httpd1.conf  ! -newer temp -ls
1077669    0 -rwxrwxr-x   2 sam      adm             0 10月 31 01:01 ./httpd.conf
1077671    4 -rw-rw-rw-   1 root     root         2792 10月 31 20:19 ./temp
1077673    0 -rw-r--r--   1 sam      adm             0 10月 31 01:07 ./fiel
查找更改时间在比temp文件新的文件：
代码:$ find . -newer temp -print8、使用type选项
在/ e t c目录下查找所有的目录，可以用：
代码:$ find /etc -type d -print在当前目录下查找除目录以外的所有类型的文件，可以用：
代码:$ find . ! -type d -print在/ e t c目录下查找所有的符号链接文件，可以用：
代码:$ find /etc -type l -print9、使用size选项
可以按照文件长度来查找文件，这里所指的文件长度既可以用块（ b l o c k）来计量，也可以用字节来计量。以字节计量文件长度的表达形式为N c；以块计量文件长度只用数字表示即可。
在按照文件长度查找文件时，一般使用这种以字节表示的文件长度，在查看文件系统的大小，因为这时使用块来计量更容易转换。
在当前目录下查找文件长度大于1 M字节的文件：
代码:$ find . -size +1000000c -print在/ h o m e / a p a c h e目录下查找文件长度恰好为1 0 0字节的文件：
代码:$ find /home/apache -size 100c -print在当前目录下查找长度超过1 0块的文件（一块等于5 1 2字节）：
代码:$ find . -size +10 -print10、使用depth选项
在使用f i n d命令时，可能希望先匹配所有的文件，再在子目录中查找。使用d e p t h选项就可以使f i n d命令这样做。这样做的一个原因就是，当在使用f i n d命令向磁带上备份文件系统时，希望首先备份所有的文件，其次再备份子目录中的文件。
在下面的例子中， f i n d命令从文件系统的根目录开始，查找一个名为C O N . F I L E的文件。
它将首先匹配所有的文件然后再进入子目录中查找。
代码:$ find / -name "CON.FILE" -depth -print11、使用mount选项
在当前的文件系统中查找文件（不进入其他文件系统），可以使用f i n d命令的m o u n t选项。
从当前目录开始查找位于本文件系统中文件名以X C结尾的文件：
代码:$ find . -name "*.XC" -mount -printLinux其他查找文件的相关命令如下:
　more [文件名]
　　分页显示一个文件或任何输出结果
　　其实more不是用来寻找文件的，但是一般人却十有八九是在找文件时把它派上用场。
　　因为 more 主要的作用是把输出结果显示在屏幕上，一页停止一次，所以例如当我们用 ls 命令去找一个 x字母开头的文件，而下达了 ls x* 却仍然列出太多文件，一个屏幕看不完时，就可以配合管道符号和 more 命令：
　　ls x* | more
　　它会一屏停止一下，等待您按空白键才继续往上卷。于是 more 俨然犹如 DOS 的 DIR 命令 /P 选项的地位了。而 more 当主角的时候，是用做一页一次显示文章，例如我们想要看 /etc 里面的 XF86Config 文件，可以下如下命令：
　　more /etc/XF86Config
　　这样，我们就可以不断按空白键把这个文件慢慢看完。但是，因为more 先天的设计，如果您看完了这页，想要回头看上一页，很抱歉，是不行的，您必须从头再来！于是大家在使用中就干脆摒弃这个命令，而代之以 vi 或者pico, joe等文书编辑器来看文字文件了！
　　pico /etc/XF86Config
　　到最后，很少人再用more了。所以more经常配合 ls在找文件的场合出现，每天都可以上场十几次。
　　所以，相信把失去主要舞台的 more归类为找寻文件的相关命令虽不合法，但合情合理也合于现状。
　　练习：
　　请您用 more 去看一个文字文件，与用 pico 去看一个文字文件相比较，哪一个比较方便？
　less [文件名]
　　分页显示一个文件并且可以回头
　　less命令很好笑，取名时就故意与more 命令打对台，你叫“更多”，我就叫“更少”，就好像你叫黑人牙膏我就叫白人牙膏一样。事实上与什么“更多”、“更少”都没有关系。它最主要只是为了改进一点：more 不能回头看的问题！
　　less 的优点就是可以随时回头，最简单的用【PgUp】键就可以向上翻。
　　可是依我们的孤陋之见，还是用文书编辑器去阅读文件就好了嘛，更何况 less 本身还有高达 42 个选项，何必那么麻烦！
　　所以，为了您好，选项我们也不介绍了。这个命令目前只在 Linux 系统可以使用，其他 UNIX 家族尚无。
　　练习：
　　（1）请您用 less 去看一个文字文件，与用 pico 去看一个文字文件相比，哪一个比较方便？
　　（2）less命令能像more命令一样配合管道符号，让ls的列示文件能够回头翻看吗？
　　whereis 文件名
　　寻找文件工具
　　whereis 是一个小巧好用的文件寻找工具，它专门用来寻找可执行的程序、原始程序和使用手册。
　　例如执行命令：
　　whereis bzip2
　　它就会告诉您，bzip2 放在 /usr/bin 。通常，如果您确定某个东西是程序，而用 whereis 找不到的话，那就表示本系统没有安装该程序了，例如：
　　whereis cjoe
　　表示这套系统中没有装 cjoe，否则应该会找到才对。
　　练习：
　　（1）找找您的系统上有没有xpaint这个程序？因为这个程序在 KDE 和 GNOME 的默认主菜单上都没有列出来，但并不表示一定没有。
　　（2）能用 whereis 命令去找到XF86Config设置文件在哪里吗？为什么？
　　locate 文件名
　　寻找文件工具
　　locate 也是一个寻找文件的工具，但是它不像 whereis 只能找程序文件等几种文件，也不像find那么复杂，可以算是“中庸之道”！
　　中庸之道，往往就是大部分人最佳的选择。
　　whereis找不到的文件，find要一大串命令，还花了很久的时间才找到的XF86Config设置文件，而用locate一下子就简单找到了！
　　练习：
　　（1）用 locate 找找有没有一个inittab文件？
　　（2）用 locate 找找有哪些 .pcf 字形文件。如果找不到的话，找找看已经压缩过的字形文件 .pcf.Z 或者 .pcf.gz。
　　grep [-选项] [字串] [文件名]
　　寻找某字串内容工具
　　有些时候，我们存储文件时随手乱取了一个文件名，事后自己都忘了那个文件名叫什么，连开头第一个字母都想不起来。那么，如果您还记得该文件一点特殊的词语，应该可以用 grep 命令找到。
　　例如，我们想在一个目录的200个文件里面，找出哪一个文件提到“排版”这个词语：
　　grep 排版 *.txt
　　找到了两个文件有此字样。然后您再自行调出看看到底哪一篇才是您所要的即可。寻找时注意尽量寻找特殊词语，如果您输入“然后”、“这样”、“不是”、“电脑”……这类太普遍的词语，可能几百篇文章中都有，那就失去了用 grep 找文件的意义了。
　　因为例子中第二篇文章出现了两次，所以列出了3行，其实只有两个文件符合。如果您想要让它凡是符合条件的只出现一次的话，加上 -l 选项就可以了.
　　其他常用的选项还有：
　　-n 同时列出该词语出现在文章的第几行。
　　-c 计算一下该字串出现的次数。
　　-i 比对的时候，不计较大小写的不同。
　　练习：
　　当我们要为系统增加一个用户时，往往担心添加一个已经存在的用户名字。如果用 grep 命令，可不可以避免这个问题？如何避免？
　env
　　查看环境设置
　　env 命令可以设置很多环境变量，例如终端机的类型、使用的浏览器、用户主目录（Home Directory）的所在等等。
　　但是我们现在把焦点集中在其中一项：PATH环境变量。
　　因为 PATH 这个环境变量掌管了您下达命令的时候，它会到下面几个目录去找您命令的程序：
　　/usr/bin
　　/sbin
　　/usr/sbin
　　/usr/X11R6/bin
　　/root/bin
　　那么您用 env 命令，让它把所有的环境变量列出来的时候，就可以看到有一行PATH 设置，把上述几个目录用分号分开，然后串成一串。这就是它所谓寻找命令的“路径”。DOS 系统也有一个同名而且意义非常相似的路径设置。
　　如果您想在它查找命令的路径上增加一个 /usr/bin/he，而把 /root/bin 去掉，那么您可以重新下达：
　　env PATH=/usr/bin;/sbin;/usr/sbin;/usr/X11R6/bin;/usr/bin/he
　　当然env 其他的变量也可以这样改变。但是因为涉及面太广，我们就只把焦点集中在改变查找路径上，其他暂时不谈 
[]     
    
Shell学习笔记 四
文章整理: 文章来源: 网络 
三.Linux后台运行命令详述
本次主要讲述后台运行命令(crontab,at,&,nohup)及(*,?,[])等
? 设置c r o n t a b文件，并用它来提交作业。
? 使用a t命令来提交作业。
? 在后台提交作业。
? 使用n o h u p命令提交作业。 
名词解释：
cron：系统调度进程。可以使用它在每天的非高峰负荷时间段运行作业，或在一周或一月中的不同时段运行。
at命令：使用它在一个特定的时间运行一些特殊的作业，或在晚一些的非负荷高峰时间段或高峰负荷时间段运行。
&：使用它在后台运行一个占用时间不长的进程。
nohup：用它在后台运行一个命令，即使在用户退出时也不受影响
1.cron and crontab
c r o n是系统主要的调度进程，可以在无需人工干预的情况下运行作业。c r o n t a b命令允许用户提交、编辑或删除相应的作业。每一个用户都可以有一个c r o n t a b文件来保存调度信息。可以使用它运行任意一个s h e l l脚本或某个命令，每小时运行一次，或一周三次，这完全取决于你。每一个用户都可以有自己的c r o n t a b文件，但在一个较大的系统中，系统管理员一般会禁止这些文件，而只在整个系统保留一个这样的文件。系统管理员是通过c r o n . d e n y和c r o n . a l l o w这两个文件来禁止或允许用户拥有自己的c r o n t a b文件。 
crontab的域
为了能够在特定的时间运行作业，需要了解c r o n t a b文件每个条目中各个域的意义和格式。
下面就是这些域：
代码:第1列分钟1～5 9
第2列小时1～2 3（0表示子夜）
第3列日1～3 1
第4列月1～1 2
第5列星期0～6（0表示星期天）
第6列要运行的命令下面是c r o n t a b的格式：
代码:分< >时< >日< >月< >星期< >要运行的命令其中< >表示空格。
c r o n t a b文件的一个条目是从左边读起的，第一列是分，最后一列是要运行的命令，它位于星期的后面。
可以用横杠-来表示一个时间范围，例如你希望星期一至星期五运行某个作业，那么可以在星期域使用1 - 5来表示。
还可以在这些域中使用逗号“,”，例如你希望星期一和星期四运行某个作业，只需要使用1 , 4来表示。
可以用星号*来表示连续的时间段。如果你对某个表示时间的域没有特别的限定，也应该在该域填入*。该文件的每一个条目必须含有5个时间域，而且每个域之间要用空格分隔。
该文件中所有的注释行要在行首用#来表示。
c r o n t a b文件例子：
代码:30 21* * * /apps/bin/cleanup.sh上面的例子表示每晚的2 1 : 3 0运行/ a p p s / b i n目录下的c l e a n u p . s h。
代码:45 4 1,10,22 * * /apps/bin/backup.sh上面的例子表示每月1、1 0、2 2日的4 : 4 5运行/ a p p s / b i n目录下的b a c k u p . s h。
代码:10 1 * * 6,0 /bin/find -name "core" -exec rm {} \;上面的例子表示每周六、周日的1 : 1 0运行一个f i n d命令。
代码:0,30 18-23 * * * /apps/bin/dbcheck.sh上面的例子表示在每天1 8 : 0 0至2 3 : 0 0之间每隔3 0分钟运行/ a p p s / b i n目录下的d b c h e c k . s h。
代码:0 23 * * 6 /apps/bin/qtrend.sh上面的例子表示每星期六的11 : 0 0 p m运行/ a p p s / b i n目录下的q t r e n d . s h。
你可能已经注意到上面的例子中，每个命令都给出了绝对路径。当使用c r o n t a b运行s h e l l脚本时，要由用户来给出脚本的绝对路径，设置相应的环境变量。记住，既然是用户向c r o n提交了这些作业，就要向c r o n提供所需的全部环境。不要假定c r o n知道所需要的特殊环境，它其实并不知道。所以你要保证在s h e l l脚本中提供所有必要的路径和环境变量，除了一些自动设置的全局变量。
如果c r o n不能运行相应的脚本，用户将会收到一个邮件说明其中的原因。
c r o n t a b命令的一般形式为：
代码:crontab [-u user] -e -l -r其中：
-u 用户名。
-e 编辑c r o n t a b文件。
-l 列出c r o n t a b文件中的内容。
-r 删除c r o n t a b文件。
如果使用自己的名字登录，就不用使用- u选项，因为在执行c r o n t a b命令时，该命令能够知道当前的用户。
创建一个新的crontab文件
在向c r o n进程提交一个c r o n t a b文件之前，要先设置环境变量E D I TO R.c r o n进程根据它来确定使用哪个编辑器编辑c r o n t a b文件。大部份的U N I X和L I N U X用户都使用v i，如果你也是这样，那么你就编辑$ H O M E目录下的. p r o f i l e文件，在其中加入这样一行：
代码:EDITOR=vi; export EDITOR然后保存并退出。
创建一个名为< u s e r > c r o n的文件，其中< u s e r >是用户名，例如， samcron。在该文件中加入如下的内容。
代码:#(put your own initials here) echo the date to the console every
#15 minutes between 6pm and 6am
0,15,30,45 18-06 * * * /bin/echo 'date' > /dev/console保存并退出。确信前面5个域用空格分隔。
在上面的例子中，系统将每隔1 5分钟向控制台输出一次当前时间。如果系统崩溃或挂起，从最后所显示的时间就可以一眼看出系统是什么时间停止工作的。在有些系统中，用t t y 1来表示控制台，可以根据实际情况对上面的例子进行相应的修改。
为了提交你刚刚创建的c r o n t a b文件，可以把这个新创建的文件作为c r o n命令的参数：
代码:$su sam
crontab samcron为了方便演示，切换到sam用户环境下，然后用crontab samcron提交给c r o n进程，它将每隔1 5分钟运行一次。
同时，新创建文件的一个副本已经被放在/ v a r / s p o o l / c r o n目录中，文件名就是用户名（即sam）。
代码:#su
# cat /var/spool/cron/sam
# DO NOT EDIT THIS FILE - edit the master and reinstall.
# (samcron installed on Wed Nov 10 21:41:55 2004)
# (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)
#(put your own initials here) echo the date to the console every
#15 minutes between 6pm and 6am
0,15,30,45 18-06 * * * /bin/echo 'date' > /dev/console回到root下，查看/var/spool/cron/sam
列出crontab文件
为了列出c r o n t a b文件，可以用：
代码:$ crontab -l
# DO NOT EDIT THIS FILE - edit the master and reinstall.
# (samcron installed on Wed Nov 10 21:41:55 2004)
# (Cron version -- $Id: crontab.c,v 2.13 1994/01/17 03:20:37 vixie Exp $)
#(put your own initials here) echo the date to the console every
#15 minutes between 6pm and 6am
0,15,30,45 18-06 * * * /bin/echo 'date' > /dev/console你将会看到和上面类似的内容。可以使用这种方法在$ H O M E目录中对c r o n t a b文件做一备份：
代码:$ crontab -l > $HOME/mycron这样，一旦不小心误删了c r o n t a b文件，可以用上一节所讲述的方法迅速恢复。
编辑crontab文件
如果希望添加、删除或编辑c r o n t a b文件中的条目，而E D I TO R环境变量又设置为v i，那么就可以用v i来编辑c r o n t a b文件，相应的命令为：
代码:$ crontab -e可以像使用v i编辑其他任何文件那样修改c r o n t a b文件并退出。如果修改了某些条目或添加了新的条目，那么在保存该文件时， c r o n会对其进行必要的完整性检查。如果其中的某个域出现了超出允许范围的值，它会提示你。
例如，加入下面的一条：
代码:#DT:delete core files,at 3:30am on 1,7,14,21,26 days of each month
30 3 1,7,14,21,26 * * /bin/find -name "core" -exec rm {} \;现在保存并退出。最好在c r o n t a b文件的每一个条目之上加入一条注释，这样就可以知道它的功能、运行时间，更为重要的是，知道这是哪位用户的作业。
现在让我们使用前面讲过的crontab -l命令列出它的全部信息：
代码:#(put your own initials here) echo the date to the console every
#15 minutes between 6pm and 6am
0,15,30,45 18-06 * * * /bin/echo 'date' > /dev/console
#DT:delete core files,at 3:30am on 1,7,14,21,26 days of each month
30 3 1,7,14,21,26 * * /bin/find -name "core" -exec rm {} \;
删除crontab文件
为了删除c r o n t a b文件，可以用：
代码:$ crontab -r恢复丢失的crontab文件
如果不小心误删了c r o n t a b文件，假设你在自己的$ H O M E目录下还有一个备份，那么可以将其拷贝到/ v a r / s p o o l / c r o n / < u s e r n a m e >，其中< u s e r n a m e >是用户名。如果由于权限问题无法完成拷贝，可以用：
代码:$ crontab <filename>其中，< f i l e n a m e >是你在$ H O M E目录中副本的文件名。
建议在自己的$ H O M E目录中保存一个该文件的副本。编辑副本，然后重新提交新的文件。
有些c r o n t a b的变体有些怪异，所以在使用c r o n t a b命令时要格外小心。如果遗漏了任何选项，c r o n t a b可能会打开一个空文件，或者看起来像是个空文件。这时敲d e l e t e键退出，不要按< C t r l - D >，否则你将丢失c r o n t a b文件。
2.at
a t命令允许用户向c r o n守护进程提交作业，使其在稍后的时间运行。一旦一个作业被提交， a t命令将会保留所有当前的环境变量，包括路径，不象c r o n t a b，只提供缺省的环境。该作业的所有输出都将以电子邮件的形式发送给用户，除非你对其输出进行了重定向，绝大多数情况下是重定向到某个文件中。
和c r o n t a b一样，根用户可以通过/ e t c目录下的a t . a l l o w和a t . d e n y文件来控制哪些用户可以使用a t命令，哪些用户不行。不过一般来说，对a t命令的使用不如对c r o n t a b的使用限制那么严格。
a t命令的基本形式为：
代码:at [-f script] [-m -l -r] [time] [date]其中，
-f：script 是所要提交的脚本或命令。
-l：列出当前所有等待运行的作业。a t q命令具有相同的作用。
-r：清除作业。为了清除某个作业，还要提供相应的作业标识（ I D）；有些U N I X变体只接受a t r m作为清除命令。
-m：作业完成后给用户发邮件。
time：at命令的时间格式非常灵活；可以是H、H H . H H M M、H H : M M或H : M，其中H和M分别是小时和分钟。还可以使用a . m .或p . m .。
date：日期格式可以是月份数或日期数，而且a t命令还能够识别诸如t o d a y、t o m o r r o w这样的词。
使用at命令提交命令或脚本
使用a t命令提交作业有几种不同的形式，可以通过命令行方式，也可以使用a t命令提示符。一般来说在提交若干行的系统命令时，使用a t命令提示符方式，在提交s h e l l脚本时，使用命令行方式。
提示符方式：
代码:以在a t命令后面跟上日期/时间并回车。然后就进入了a t命令提示符，这时只需逐条输入相应的命令，然后按‘ < C T R L - D >’退出。命令行方式：
代码:at [-f script] [-m -l -r] [time] [date]
例一：提示符方式
代码:# su sam
$ at 10:40
warning: commands will be executed using (in order) a) $SHELL b) login shell c) /bin/sh
at> find /etc -name "passwd" -print
at> <EOT>
job 1 at 2004-11-02 10:40其中， < E O T >就是< C T R L - D >。在10:40系统将执行一个简单的f i n d命令。提交的作业被分配了一个唯一标识job 1。该命令在完成以后会将全部结果以邮件的形式发送给我。
下面这些日期/时间格式都是a t命令可以接受的：
代码:at 5.00am May23
at 11.20pm
at now +2 hour
at 9am tomorrow
at 15:00 May24
at now + 10 minutes例二：命令行方式
如果希望向a t命令提交一个s h e l l脚本，使用其命令行方式即可。在提交脚本时使用- f选项。
如：
代码:$ touch db_table.sh
$ at 3:00pm tomorrow -f db_table.sh
warning: commands will be executed using (in order) a) $SHELL b) login shell c) /bin/sh
job 3 at 2004-11-02 15:00在上面的例子中，一个叫做d b _ t a b l e . s h的脚本将在2004-11-02 15:00运行。
还可以使用e c h o命令向a t命令提交作业：
代码:$ echo find /etc -name "passwd" -print | at now +1 minute
warning: commands will be executed using (in order) a) $SHELL b) login shell c) /bin/sh
job 4 at 2004-11-01 19:07
列出所提交的作业
一个作业被提交后，可以使用at -l命令来列出所有的作业：
代码:$ at -l
1       2004-11-02 10:40 a sam
3       2004-11-02 15:00 a sam
4       2004-11-01 19:07 a sam其中，第一行是作业标识，后面是作业运行的日期/时间。最后一列a代表a t。
还可以使用a t q命令来完成同样的功能，它是a t命令的一个链接。
直接>atq,相当于>at -l
当提交一个作业后，它就被拷贝到/ v a r / s p o o l / a t目录中，准备在要求的时间运行。
代码:# pwd
/var/spool/at
# ls -l清除一个作业
清除作业的命令格式为：
代码:atrm [job no] 或at -r [job no]要清除某个作业，首先要执行at -l命令，以获取相应的作业标识，然后对该作业标识使用at -r 命令，清除该作业。
代码:$ at -l
1       2004-11-02 10:40 a sam
3       2004-11-02 15:00 a sam
4       2004-11-01 19:07 a sam
$at -r 3
$at -l
1       2004-11-02 10:40 a sam
4       2004-11-01 19:07 a sam
有些系统使用at-r [job no]命令清除作业。
3.&
当在前台运行某个作业时，终端被该作业占据；而在后台运行作业时，它不会占据终端。可以使用&命令把作业放到后台执行。
该命令的一般形式为：
代码:命令&
在后台运行作业时要当心：需要用户交互的命令不要放在后台执行，因为这样你的机器就会在那里傻等。
不过，作业在后台运行一样会将结果输出到屏幕上，干扰你的工作。如果放在后台运行的作业会产生大量的输出，最好使用下面的方法把它的输出重定向到某个文件中：
代码:command >out.file 2>&1 &在上面的例子中，2>&1表示所有的标准输出和错误输出都将被重定向到一个叫做out.file 的文件中。
当你成功地提交进程以后，就会显示出一个进程号，可以用它来监控该进程，或杀死它。
例一：
查找名为“httpd.conf”的文件，并把所有标准输出和错误输出重定向到f i n d . d t的文件中：
代码:# find /etc/httpd/ -name "httpd.conf" -print >find.dt 2>&1 &
[2] 7832
[1]   Done                    find /etc/ -name "httpd.conf" -print >find.dt 2>&1 &成功提交该命令之后，系统给出了它的进程号7832。
代码:# cat find.dt
/etc/httpd/conf/httpd.conf
[2]+  Done                    find /etc/httpd/ -name "httpd.conf" -print >find.dt 2>&1 &查看find.dt,可以看到执行结果
例二：
在后台执行脚本，如：有一个叫psl的脚本
代码:$ps psl &
[7878]用ps命令查看进程
用提交命令时所得到的进程号来监控它的运行。用p s命令和g r e p命令列出这个进程：
代码:# ps -x |grep 7832
7868 pts/0    S      0:00 grep 7832如果系统不支持ps x命令，可以用：
代码:# ps -ef |grep 7832
root      7866  7790  0 23:40 pts/0    00:00:00 grep 7832在用p s命令列出进程时，它无法确定该进程是运行在前台还是后台。
杀死后台进程
杀死后台进程可以使用k i l l命令。当一个进程被放到后台运行时， s h e l l会给出一个进程号，我们可以根据这个进程号，用k i l l命令杀死该进程。该命令的基本形式为：
代码:kill -signal [process_number]现在暂且不要考虑其中的各种不同信号。
在杀进程的时候，执行下面的命令(你的进程号可能会不同)并按回车键。系统将会给出相应的信息告诉用户进程已经被杀死。
代码:$kill 7832如果系统没有给出任何信息，告诉你进程已经被杀死，那么不妨等一会儿，也许系统正在杀该进程，如果还没有回应，就再执行另外一个k i l l命令，这次带上一个信号选项：
代码:$kill - 9 7868如果用上述方法提交了一个后台进程，那么在退出时该进程将会被终止。为了使后台进程能够在退出后继续运行，可以使用n o h u p命令。
4.nohug
如果你正在运行一个进程，而且你觉得在退出帐户时该进程还不会结束，那么可以使用n o h u p命令。该命令可以在你退出帐户之后继续运行相应的进程。n o h u p就是不挂起的意思( no hang up)。
该命令的一般形式为：
代码:nohup command &使用nohup命令提交作业
如果使用n o h u p命令提交作业，那么在缺省情况下该作业的所有输出都被重定向到一个名为n o h u p . o u t的文件中，除非另外指定了输出文件：
代码:nohup command > myout.file 2>&1在上面的例子中，输出被重定向到m y o u t . f i l e文件中。
让我们来看一个例子，验证一下在退出帐户后相应的作业是否能够继续运行。我们先提交一个名为p s 1的日志清除进程：
代码:$nobup ps1 &现在退出该s h e l l，再重新登录，然后执行下面的命令：
代码:$ps x |grep ps1我们看到，该脚本还在运行。如果系统不支持ps x命令，使用ps -ef|grep ps1命令。
5.一次提交几个作业
如果希望一次提交几个命令，最好能够把它们写入到一个s h e l l脚本文件中，并用n o h u p命令来执行它。
例如，下面的所有命令都用管道符号连接在一起；我们可以把这些命令存入一个文件，并使该文件可执行。
代码:cat /home/accounts/qrt_0499 | /apps/bin/trials.awk | sort | lp
$cat > quarterend
cat /home/accounts/qtr_0499 | /apps/bin/trials.awk | sort | lp
<ctrl-D>现在让它可执行：
代码:$ chmod 744 quarterend我们还将该脚本的所有输出都重定向到一个名为q t r. o u t的文件中。
代码:nobup ./quarterend > qtr.out 2>后台运行作业的:
有时我们必须要对大文件进行大量更改，或执行一些复杂的查找，这些工作最好能够在系统负荷较低时执行。
创建一个定时清理日志文件或完成其他特殊工作的脚本，这样只要提交一次，就可以每天晚上运行，而且无需你干预，只要看看相应的脚本日志就可以了。c r o n和其他工具可以使系统管理任务变得更轻松。
6.*，？，[...]，[!...]等
? 匹配文件名中的任何字符串。
? 匹配文件名中的单个字符。
? 匹配文件名中的字母或数字字符。
下面就是这些特殊字符：
* 匹配文件名中的任何字符串，包括空字符串。
？ 匹配文件名中的任何单个字符。
[...] 匹配[ ]中所包含的任何字符。
[!...] 匹配[ ]中非感叹号！之后的字符。
当s h e l l遇到上述字符时，就会把它们当作特殊字符，而不是文件名中的普通字符，这样用户就可以用它们来匹配相应的文件名。
a、*：使用星号*可以匹配文件名中的任何字符串。就不用多说了，和win下差不多
b、？：使用可以匹配文件名中的任何单个字符。和win差不多
c、[]：使用[ . . . ]可以用来匹配方括号[ ]中的任何字符。可以使用一个横杠-来连接两个字母或数字，以此来表示一个范围。
1)列出以i或o开头的文件名：
代码:#ls [io]*2)列出log.开头、后面跟随一个数字、然后可以是任意字符串的文件名：
代码:#ls log.[0-9]*3)与例二相反，列出log.开头、后面不跟随一个数字、然后可以是任意字符串的文件名
代码:#ls log.[!0-9]*4)列出所有以LPS开头、中间可以是任何两个字符，最后以1结尾的文件名：
代码:#ls LPS??15)列出所有以大写字母开头的文件名：
代码:$ ls [A-Z]*6)列出所有以小写字母开头的文件名：
代码:$ ls [a-z]*7)为了列出所有以数字开头的文件名：
代码:$ ls [0-9]*8)列出所有以. 开头的文件名（隐含文件，例如. p r o f i l e、. r h o s t s、. h i s t o r y等）:
代码:$ ls .*
      
zhy2111314
查看公开信息
访问 zhy2111314 的个人网站
查找 zhy2111314 发表的更多帖子
 05-03-17, 08:44 第 8 帖 
zhy2111314 vbmenu_register("postmenu_1067721", true); 
 
  
 
版主 
  注册日期: Oct 2004 
  我的住址: China QD 
  帖子: 782 
  精华: 11 
 
四.Linux输入和输出命令详述
1.echo
首先,在LINUX中，要使转义符生效，需加参数-e
从echo的变量开始说起
如：e c h o命令输出转义符以及变量。
代码:# echo -e "\007your home is $HOME , you are connected on `tty`"
your home is /root , you are connected on /dev/pts/1
# echo -e "\ayour home is $HOME , you are connected on `tty`"
your home is /root , you are connected on /dev/pts/1
#本例中
\007或\a你可以让终端铃响一声
显示出$ H O M E目录，
并且可以让系统执行t t y命令(注意，该命令用键盘左上角的符号，法语中的抑音符引起来，不是单引号 )。
在e c h o命令输出之后附加换行，可以使用\ n选项：
代码:$ cat echod
#!/bin/sh
echo -e "this echo's 3 new lines\n\n\n"
echo "OK"编辑一个新echod，如上内容，然后运行输出如下：
代码:$ ./echod
this echo's 3 new lines
OK
$在e c h o语句中使用跳格符，记住别忘了加反斜杠\：
代码:$ echo -e "here is a tab\there are two tabs\t\tok"
here is a tab   here are two tabs               ok
$把一个字符串输出到文件中，使用重定向符号>。
在下面的例子中一个字符串被重定向到一个名为m y f i l e的文件中：
代码:$ echo "The log files have all been done"> myfile或者可以追加到一个文件的末尾，这意味着不覆盖原有的内容：
代码:$ echo "$LOGNAME carried them out at `date`">>myfile现在让我们看一下m y f i l e文件中的内容：
代码:The log files have all been done
sam carried them out at 六 11月 13 12:54:32 CST 2004引号是一个特殊字符，所以必须要使用反斜杠\来使s h e l l忽略它的特殊含义。
假设你希望使用e c h o命令输出这样的字符串：“/ d e v / r m t 0”，那么我们只要在引号前面加上反斜杠\即可：
代码:$ echo "\"/dev/rmt0"\"
"/dev/rmt0"
$上面说过,
代码:在LINUX中，要使转义符生效，需加参数-e那么echo可以用的转义字符有下面这些:
代码:\a 鸣叫beep
\n 换行
\t 水平制表
\v 垂直制表
\b 退格
\r 回车
\f 换页
\\ \' '
\" "
\ddd 一到三位八进制数ddd所代表的字符
\xhh 一到二位十六进制数hh所代表的字符
 (这两个都是ASCII码)
\c 取消末行换行符,等价于echo -n ...ps:注意其中\n和\r的区别,可以自己实验......
补充:
echo的特殊用法
a.把字符串输出到标准显示的指定位置：
代码:r= #指定行
c= #指定列
echo -e "\033[${r};${c}H我在这里"b.隐藏光标：
代码:echo -ne "\033[?25l"其中25后面是字母l
c.ANSI控制码
例如:
代码:echo -ne "\033[32m"  #可以将字符的显示颜色改为绿色
echo -ne "\033[3;1H" #可以将光标移到第3行第1列处具体的摘抄一些如下：
代码:\033[0m #关闭所有属性
\033[1m #设置高亮度
\033[4m #下划线
\033[5m #闪烁
\033[7m #反显
\033[8m #消隐
\033[30m -- \33[37m #设置前景色
\033[40m -- \33[47m #设置背景色
\033[nA #光标上移n行
\033[nB #光标下移n行
\033[nC #光标右移n行
\033[nD #光标左移n行
\033[y;xH #设置光标位置
\033[2J #清屏
\033[K #清除从光标到行尾的内容
\033[s #保存光标位置
\033[u #恢复光标位置
\033[?25l #隐藏光标
\033[?25h #显示光标下面是摘抄的shell中俄罗斯方块程序,我也没有具体研究,先放到这里,有兴趣可以研究一下
运行于GNU bash, version 2.05a.0(1)-release (i686-pc-linux-gnu)
代码:
#!/bin/bash
# Tetris Game
# 10.21.2003 xhchen<xhchen@winbond.com.tw>
#颜色定义
cRed=1
cGreen=2
cYellow=3
cBlue=4
cFuchsia=5
cCyan=6
cWhite=7
colorTable=($cRed $cGreen $cYellow $cBlue $cFuchsia $cCyan $cWhite)
#位置和大小
iLeft=3
iTop=2
((iTrayLeft = iLeft + 2))
((iTrayTop = iTop + 1))
((iTrayWidth = 10))
((iTrayHeight = 15))
#颜色设置
cBorder=$cGreen
cScore=$cFuchsia
cScoreValue=$cCyan
#控制信号
#改游戏使用两个进程，一个用于接收输入，一个用于游戏流程和显示界面;
#当前者接收到上下左右等按键时，通过向后者发送signal的方式通知后者。
sigRotate=25
sigLeft=26
sigRight=27
sigDown=28
sigAllDown=29
sigExit=30
#七中不同的方块的定义
#通过旋转，每种方块的显示的样式可能有几种
box0=(0 0 0 1 1 0 1 1)
box1=(0 2 1 2 2 2 3 2 1 0 1 1 1 2 1 3)
box2=(0 0 0 1 1 1 1 2 0 1 1 0 1 1 2 0)
box3=(0 1 0 2 1 0 1 1 0 0 1 0 1 1 2 1)
box4=(0 1 0 2 1 1 2 1 1 0 1 1 1 2 2 2 0 1 1 1 2 0 2 1 0 0 1 0 1 1 1 2)
box5=(0 1 1 1 2 1 2 2 1 0 1 1 1 2 2 0 0 0 0 1 1 1 2 1 0 2 1 0 1 1 1 2)
box6=(0 1 1 1 1 2 2 1 1 0 1 1 1 2 2 1 0 1 1 0 1 1 2 1 0 1 1 0 1 1 1 2)
#所有其中方块的定义都放到box变量中
box=(${box0[@]} ${box1[@]} ${box2[@]} ${box3[@]} ${box4[@]} ${box5[@]} ${box6[@]})
#各种方块旋转后可能的样式数目
countBox=(1 2 2 2 4 4 4)
#各种方块再box数组中的偏移
offsetBox=(0 1 3 5 7 11 15)
#每提高一个速度级需要积累的分数
iScoreEachLevel=50   #be greater than 7
#运行时数据
sig=0      #接收到的signal
iScore=0   #总分
iLevel=0   #速度级
boxNew=()   #新下落的方块的位置定义
cBoxNew=0   #新下落的方块的颜色
iBoxNewType=0   #新下落的方块的种类
iBoxNewRotate=0   #新下落的方块的旋转角度
boxCur=()   #当前方块的位置定义
cBoxCur=0   #当前方块的颜色
iBoxCurType=0   #当前方块的种类
iBoxCurRotate=0   #当前方块的旋转角度
boxCurX=-1   #当前方块的x坐标位置
boxCurY=-1   #当前方块的y坐标位置
iMap=()      #背景方块图表
#初始化所有背景方块为-1, 表示没有方块
for ((i = 0; i < iTrayHeight * iTrayWidth; i++)); do iMap[$i]=-1; done
#接收输入的进程的主函数
function RunAsKeyReceiver()
{
   local pidDisplayer key aKey sig cESC sTTY
   pidDisplayer=$1
   aKey=(0 0 0)
   cESC=`echo -ne "\33"`
   cSpace=`echo -ne "\40"`
   #保存终端属性。在read -s读取终端键时，终端的属性会被暂时改变。
   #如果在read -s时程序被不幸杀掉，可能会导致终端混乱，
   #需要在程序退出时恢复终端属性。
   sTTY=`stty -g`
   
   #捕捉退出信号
   trap "MyExit;" INT TERM
   trap "MyExitNoSub;" $sigExit
   
   #隐藏光标
   echo -ne "\33[?25l"
   
   while (( 1 ))
   do
      #读取输入。注-s不回显，-n读到一个字符立即返回
      read -s -n 1 key
      
      aKey[0]=${aKey[1]}
      aKey[1]=${aKey[2]}
      aKey[2]=$key
      sig=0
      #判断输入了何种键
      if [[ $key == $cESC && ${aKey[1]} == $cESC ]]
      then
         #ESC键
         MyExit
      elif [[ ${aKey[0]} == $cESC && ${aKey[1]} == "[" ]]
      then
         if [[ $key == "A" ]]; then sig=$sigRotate   #<向上键>
         elif [[ $key == "B" ]]; then sig=$sigDown   #<向下键>
         elif [[ $key == "D" ]]; then sig=$sigLeft   #<向左键>
         elif [[ $key == "C" ]]; then sig=$sigRight   #<向右键>
         fi
      elif [[ $key == "W" || $key == "w" ]]; then sig=$sigRotate   #W, w
      elif [[ $key == "S" || $key == "s" ]]; then sig=$sigDown   #S, s
      elif [[ $key == "A" || $key == "a" ]]; then sig=$sigLeft   #A, a
      elif [[ $key == "D" || $key == "d" ]]; then sig=$sigRight   #D, d
      elif [[ "[$key]" == "[]" ]]; then sig=$sigAllDown   #空格键
      elif [[ $key == "Q" || $key == "q" ]]         #Q, q
      then
         MyExit
      fi
      if [[ $sig != 0 ]]
      then
         #向另一进程发送消息
         kill -$sig $pidDisplayer
      fi
   done
}
#退出前的恢复
function MyExitNoSub()
{
   local y
   
   #恢复终端属性
   stty $sTTY
   ((y = iTop + iTrayHeight + 4))
   #显示光标
   echo -e "\33[?25h\33[${y};0H"
   exit
}
function MyExit()
{
   #通知显示进程需要退出
   kill -$sigExit $pidDisplayer
   
   MyExitNoSub
}
#处理显示和游戏流程的主函数
function RunAsDisplayer()
{
   local sigThis
   InitDraw
   #挂载各种信号的处理函数
   trap "sig=$sigRotate;" $sigRotate
   trap "sig=$sigLeft;" $sigLeft
   trap "sig=$sigRight;" $sigRight
   trap "sig=$sigDown;" $sigDown
   trap "sig=$sigAllDown;" $sigAllDown
   trap "ShowExit;" $sigExit
   while (( 1 ))
   do
      #根据当前的速度级iLevel不同，设定相应的循环的次数
      for ((i = 0; i < 21 - iLevel; i++))
      do
         sleep 0.02
         sigThis=$sig
         sig=0
         #根据sig变量判断是否接受到相应的信号
         if ((sigThis == sigRotate)); then BoxRotate;   #旋转
         elif ((sigThis == sigLeft)); then BoxLeft;   #左移一列
         elif ((sigThis == sigRight)); then BoxRight;   #右移一列
         elif ((sigThis == sigDown)); then BoxDown;   #下落一行
         elif ((sigThis == sigAllDown)); then BoxAllDown;   #下落到底
         fi
      done
      #kill -$sigDown $$
      BoxDown   #下落一行
   done
}
#BoxMove(y, x), 测试是否可以把移动中的方块移到(x, y)的位置, 返回0则可以, 1不可以
function BoxMove()
{
   local j i x y xTest yTest
   yTest=$1
   xTest=$2
   for ((j = 0; j < 8; j += 2))
   do
      ((i = j + 1))
      ((y = ${boxCur[$j]} + yTest))
      ((x = ${boxCur[$i]} + xTest))
      if (( y < 0 || y >= iTrayHeight || x < 0 || x >= iTrayWidth))
      then
         #撞到墙壁了
         return 1
      fi
      if ((${iMap[y * iTrayWidth + x]} != -1 ))
      then
         #撞到其他已经存在的方块了
         return 1
      fi
   done
   return 0;
}
#将当前移动中的方块放到背景方块中去,
#并计算新的分数和速度级。(即一次方块落到底部)
function Box2Map()
{
   local j i x y xp yp line
   #将当前移动中的方块放到背景方块中去
   for ((j = 0; j < 8; j += 2))
   do
      ((i = j + 1))
      ((y = ${boxCur[$j]} + boxCurY))
      ((x = ${boxCur[$i]} + boxCurX))
      ((i = y * iTrayWidth + x))
      iMap[$i]=$cBoxCur
   done
   
   #消去可被消去的行
   line=0
   for ((j = 0; j < iTrayWidth * iTrayHeight; j += iTrayWidth))
   do
      for ((i = j + iTrayWidth - 1; i >= j; i--))
      do
         if ((${iMap[$i]} == -1)); then break; fi
      done
      if ((i >= j)); then continue; fi
   
      ((line++))   
      for ((i = j - 1; i >= 0; i--))
      do
         ((x = i + iTrayWidth))
         iMap[$x]=${iMap[$i]}
      done
      for ((i = 0; i < iTrayWidth; i++))
      do
         iMap[$i]=-1
      done
   done
   
   if ((line == 0)); then return; fi
   #根据消去的行数line计算分数和速度级
   ((x = iLeft + iTrayWidth * 2 + 7))
   ((y = iTop + 11))
   ((iScore += line * 2 - 1))
   #显示新的分数
   echo -ne "\33[1m\33[3${cScoreValue}m\33[${y};${x}H${iScore}         "
   if ((iScore % iScoreEachLevel < line * 2 - 1))
   then
      if ((iLevel < 20))
      then
         ((iLevel++))
         ((y = iTop + 14))
         #显示新的速度级
         echo -ne "\33[3${cScoreValue}m\33[${y};${x}H${iLevel}        "
      fi
   fi
   echo -ne "\33[0m"
   #重新显示背景方块
   for ((y = 0; y < iTrayHeight; y++))
   do
      ((yp = y + iTrayTop + 1))
      ((xp = iTrayLeft + 1))
      ((i = y * iTrayWidth))
      echo -ne "\33[${yp};${xp}H"
      for ((x = 0; x < iTrayWidth; x++))
      do
         ((j = i + x))
         if ((${iMap[$j]} == -1))
         then
            echo -ne "  "
         else
            echo -ne "\33[1m\33[7m\33[3${iMap[$j]}m\33[4${iMap[$j]}m[]\33[0m"
         fi
      done
   done
}
#下落一行
function BoxDown()
{
   local y s
   ((y = boxCurY + 1))   #新的y坐标
   if BoxMove $y $boxCurX   #测试是否可以下落一行
   then
      s="`DrawCurBox 0`"   #将旧的方块抹去
      ((boxCurY = y))
      s="$s`DrawCurBox 1`"   #显示新的下落后方块
      echo -ne $s
   else
      #走到这儿, 如果不能下落了
      Box2Map      #将当前移动中的方块贴到背景方块中
      RandomBox   #产生新的方块
   fi
}
#左移一列
function BoxLeft()
{
   local x s
   ((x = boxCurX - 1))
   if BoxMove $boxCurY $x
   then
      s=`DrawCurBox 0`
      ((boxCurX = x))
      s=$s`DrawCurBox 1`
      echo -ne $s
   fi
}
#右移一列
function BoxRight()
{
   local x s
   ((x = boxCurX + 1))
   if BoxMove $boxCurY $x
   then
      s=`DrawCurBox 0`
      ((boxCurX = x))
      s=$s`DrawCurBox 1`
      echo -ne $s
   fi
}
#下落到底
function BoxAllDown()
{
   local k j i x y iDown s
   iDown=$iTrayHeight
   #计算一共需要下落多少行
   for ((j = 0; j < 8; j += 2))
   do
      ((i = j + 1))
      ((y = ${boxCur[$j]} + boxCurY))
      ((x = ${boxCur[$i]} + boxCurX))
      for ((k = y + 1; k < iTrayHeight; k++))
      do
         ((i = k * iTrayWidth + x))
         if (( ${iMap[$i]} != -1)); then break; fi
      done
      ((k -= y + 1))
      if (( $iDown > $k )); then iDown=$k; fi
   done
   
   s=`DrawCurBox 0`   #将旧的方块抹去
   ((boxCurY += iDown))   
   s=$s`DrawCurBox 1`   #显示新的下落后的方块
   echo -ne $s
   Box2Map      #将当前移动中的方块贴到背景方块中
   RandomBox   #产生新的方块
}
#旋转方块
function BoxRotate()
{
   local iCount iTestRotate boxTest j i s
   iCount=${countBox[$iBoxCurType]}   #当前的方块经旋转可以产生的样式的数目
   #计算旋转后的新的样式
   ((iTestRotate = iBoxCurRotate + 1))
   if ((iTestRotate >= iCount))
   then
      ((iTestRotate = 0))
   fi
   #更新到新的样式, 保存老的样式(但不显示)
   for ((j = 0, i = (${offsetBox[$iBoxCurType]} + $iTestRotate) * 8; j < 8; j++, i++))
   do
      boxTest[$j]=${boxCur[$j]}
      boxCur[$j]=${box[$i]}
   done
   if BoxMove $boxCurY $boxCurX   #测试旋转后是否有空间放的下
   then
      #抹去旧的方块
      for ((j = 0; j < 8; j++))
      do
         boxCur[$j]=${boxTest[$j]}
      done
      s=`DrawCurBox 0`
      #画上新的方块
      for ((j = 0, i = (${offsetBox[$iBoxCurType]} + $iTestRotate) * 8; j < 8; j++, i++))
      do
         boxCur[$j]=${box[$i]}
      done
      s=$s`DrawCurBox 1`
      echo -ne $s
      iBoxCurRotate=$iTestRotate
   else
      #不能旋转，还是继续使用老的样式
      for ((j = 0; j < 8; j++))
      do
         boxCur[$j]=${boxTest[$j]}
      done
   fi
}
#DrawCurBox(bDraw), 绘制当前移动中的方块, bDraw为1, 画上, bDraw为0, 抹去方块。
function DrawCurBox()
{
   local i j t bDraw sBox s
   bDraw=$1
   s=""
   if (( bDraw == 0 ))
   then
      sBox="\40\40"
   else
      sBox="[]"
      s=$s"\33[1m\33[7m\33[3${cBoxCur}m\33[4${cBoxCur}m"      
   fi
   
   for ((j = 0; j < 8; j += 2))
   do
      ((i = iTrayTop + 1 + ${boxCur[$j]} + boxCurY))
      ((t = iTrayLeft + 1 + 2 * (boxCurX + ${boxCur[$j + 1]})))
      #\33[y;xH, 光标到(x, y)处
      s=$s"\33[${i};${t}H${sBox}"
   done
   s=$s"\33[0m"
   echo -n $s
}
#更新新的方块
function RandomBox()
{
   local i j t
   #更新当前移动的方块
   iBoxCurType=${iBoxNewType}
   iBoxCurRotate=${iBoxNewRotate}
   cBoxCur=${cBoxNew}
   for ((j = 0; j < ${#boxNew[@]}; j++))
   do
      boxCur[$j]=${boxNew[$j]}
   done
   
   #显示当前移动的方块
   if (( ${#boxCur[@]} == 8 ))
   then
      #计算当前方块该从顶端哪一行"冒"出来
      for ((j = 0, t = 4; j < 8; j += 2))
      do
         if ((${boxCur[$j]} < t)); then t=${boxCur[$j]}; fi
      done
      ((boxCurY = -t))
      for ((j = 1, i = -4, t = 20; j < 8; j += 2))
      do
         if ((${boxCur[$j]} > i)); then i=${boxCur[$j]}; fi
         if ((${boxCur[$j]} < t)); then t=${boxCur[$j]}; fi
      done
      ((boxCurX = (iTrayWidth - 1 - i - t) / 2))
      #显示当前移动的方块
      echo -ne `DrawCurBox 1`
      #如果方块一出来就没处放，Game over!
      if ! BoxMove $boxCurY $boxCurX
      then
         kill -$sigExit ${PPID}
         ShowExit
      fi
   fi
   
   
   #清除右边预显示的方块
   for ((j = 0; j < 4; j++))
   do
      ((i = iTop + 1 + j))
      ((t = iLeft + 2 * iTrayWidth + 7))
      echo -ne "\33[${i};${t}H        "
   done
   #随机产生新的方块
   ((iBoxNewType = RANDOM % ${#offsetBox[@]}))
   ((iBoxNewRotate = RANDOM % ${countBox[$iBoxNewType]}))
   for ((j = 0, i = (${offsetBox[$iBoxNewType]} + $iBoxNewRotate) * 8; j < 8; j++, i++))
   do
      boxNew[$j]=${box[$i]};
   done
   ((cBoxNew = ${colorTable[RANDOM % ${#colorTable[@]}]}))
   
   #显示右边预显示的方块
   echo -ne "\33[1m\33[7m\33[3${cBoxNew}m\33[4${cBoxNew}m"
   for ((j = 0; j < 8; j += 2))
   do
      ((i = iTop + 1 + ${boxNew[$j]}))
      ((t = iLeft + 2 * iTrayWidth + 7 + 2 * ${boxNew[$j + 1]}))
      echo -ne "\33[${i};${t}H[]"
   done
   echo -ne "\33[0m"
}
#初始绘制
function InitDraw()
{
   clear
   RandomBox   #随机产生方块，这时右边预显示窗口中有方快了
   RandomBox   #再随机产生方块，右边预显示窗口中的方块被更新，原先的方块将开始下落
   local i t1 t2 t3
   #显示边框
   echo -ne "\33[1m"
   echo -ne "\33[3${cBorder}m\33[4${cBorder}m"
   
   ((t2 = iLeft + 1))
   ((t3 = iLeft + iTrayWidth * 2 + 3))
   for ((i = 0; i < iTrayHeight; i++))
   do
      ((t1 = i + iTop + 2))
      echo -ne "\33[${t1};${t2}H||"
      echo -ne "\33[${t1};${t3}H||"
   done
   
   ((t2 = iTop + iTrayHeight + 2))
   for ((i = 0; i < iTrayWidth + 2; i++))
   do
      ((t1 = i * 2 + iLeft + 1))
      echo -ne "\33[${iTrayTop};${t1}H=="
      echo -ne "\33[${t2};${t1}H=="
   done
   echo -ne "\33[0m"
   
   #显示"Score"和"Level"字样
   echo -ne "\33[1m"
   ((t1 = iLeft + iTrayWidth * 2 + 7))
   ((t2 = iTop + 10))
   echo -ne "\33[3${cScore}m\33[${t2};${t1}HScore"
   ((t2 = iTop + 11))
   echo -ne "\33[3${cScoreValue}m\33[${t2};${t1}H${iScore}"
   ((t2 = iTop + 13))
   echo -ne "\33[3${cScore}m\33[${t2};${t1}HLevel"
   ((t2 = iTop + 14))
   echo -ne "\33[3${cScoreValue}m\33[${t2};${t1}H${iLevel}"
   echo -ne "\33[0m"
}
#退出时显示GameOVer!
function ShowExit()
{
   local y
   ((y = iTrayHeight + iTrayTop + 3))
   echo -e "\33[${y};0HGameOver!\33[0m"
   exit
}
#游戏主程序在这儿开始.
if [[ $1 != "--show" ]]
then
   bash $0 --show&   #以参数--show将本程序再运行一遍
   RunAsKeyReceiver $!   #以上一行产生的进程的进程号作为参数
   exit
else
   #当发现具有参数--show时，运行显示函数
   RunAsDisplayer   
   exit
fi2.read
格式:
代码:read [-ers] [-u fd] [-t timeout] [-a aname] [-p prompt] [-n nchars] [-d delim] [name ...]当read命令没有参数[name ...]时，直接设在REPLY上。 
可以用$REPLY引用.
其他命令参数看下面运行实例:
代码:zhyfly: ~/1$ read
what
zhyfly: ~/1$ echo $REPLY
what
zhyfly: ~/1$ read name
zhyfly
zhyfly: ~/1$ echo $name
zhyfly
zhyfly: ~/1$ read name veb name1
i love you
zhyfly: ~/1$ echo $name $veb $name1
i love you
zhyfly: ~/1$ read name veb name1
i love
zhyfly: ~/1$ echo "$name,$veb,$name1"
i,love,
zhyfly: ~/1$ read name veb
i love you
zhyfly: ~/1$ echo "$name,$veb"
i,love you
zhyfly: ~/1$ read -p "how old r u?" age
how old r u?23
zhyfly: ~/1$ echo $age
23
zhyfly: ~/1$ read -p "some words?" -a words
some words?i love u!
zhyfly: ~/1$ echo ${words[*]}
i love u!
zhyfly: ~/1$ read -p "passwd:" -s passwd
passwd:#输入密码zhyfly: ~/1$ echo $passwd
zhyfly
zhyfly: ~/1$ read -p "type the string end with n characters:" -n 5
type the string end with n characters:34352zhyfly: ~/1$
zhyfly: ~/1$ read -p "type the string end with the letter you set:" -dp
type the string end with the letter you set:hahaw^?^?pzhyfly: ~/1$
zhyfly: ~/1$ read -p "type the string in the seconds you set:" -t 5 test
type the string in the seconds you set:zhyfly: ~/1$
#5秒钟不反应自动退出
zhyfly: ~/1$ read -p 'the \ will work as a metacharater!' a
the \ will work as a metacharater!bc\$d
zhyfly: ~/1$ echo $a
bc$d
zhyfly: ~/1$ read -r -p 'the \ will not work as a metacharater!' A
the \ will not work as a metacharater!bc\$d
zhyfly: ~/1$ echo $A
bc\$d一个echo和read的例子:
代码:zhyfly: ~/1$ cat test
#!/bin/bash
echo -n "First name:"
read firstname
echo -n "Middle name:"
read middlename
echo -e "Last name:\c"
read lastname
echo "$firstname,$middlename,$lastname"
zhyfly: ~/1$ sudo chmod +x test
zhyfly: ~/1$ ./test
First name:zhy
Middle name:2
Last name:fly
zhy,2,fly3.cat
cat：显示文件内容，创建文件，还可以用它来显示控制字符。
注意:在文件分页符处不会停下来；会一下显示完整个文件。因此，可以使用m o r e命令或把c a t命令的输出通过管道传递到另外一个具有分页功能的命令中，使用命令less file可实现相同的功能。
如下形式
代码:$cat myfile | more或 
代码:$cat myfile | pg或 
代码:$cat myfile | lessc a t命令的一般形式为：
代码:cat [options] filename1 ... filename2 ...a、显示名为m y f i l e的文件：
代码:$ cat myfileb、显示m y f i l e 1、m y f i l e 2、m y f i l e 3这三个文件，可以用：
代码:$ cat myfile1 myfile2 myfile3c、创建一个包含上述三个文件的内容，名为b i g f i l e的文件，可以用输出重定向到新文件中：
代码:$ cat myfile1 myfile2 myfile3 > bigfiled、如果cat的命令行中没有参数,输入的每一行都立刻被cat命令输出到屏幕上,输入完毕后按< C T R L - D >结束
代码:$ cat
Hello world
Hello world 
<ctrl+d>
$e、新建文件
代码:$cat >myfile
This is great
<ctrl-d>
$cat myfile
This is great
cat：参数选项
使用方式：
代码:cat [-AbeEnstTuv] [--help] [--version] fileName说明：把档案串连接后传到基本输出（萤幕或加 > fileName 到另一个档案）
参数：
-n 或 --number 由 1 开始对所有输出的行数编号
-b 或 --number-nonblank 和 -n 相似，只不过对于空白行不编号
-s 或 --squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行
-v 或 --show-nonprinting 显示非打印字符
例：
显示时加上行号
代码:$cp /etc/httpd/conf/httpd /usr/sam
$ cat -n httpd.conf把 httpd.conf 的内容加上行号后输入 httpd1.conf 这个文件里
代码:$cat -n httpd.conf > httpd1.conf对文件httpd.conf加上行号(空白不加)后显示
代码:$ cat -b httpd.conf把 textfile1 和 textfile2 的档案内容加上行号（空白行不加）之后将内容附加到 textfile3 里。
代码:$ cat -b textfile1 textfile2 >> textfile3清空/etc/test.txt档案内容
代码:$cat /dev/null > /etc/test.txt使用 sed 与 cat 除去空白行
代码:$ cat -s /etc/X11/XF86Config | sed '/^[[:space:]]*$/d'cat 还可以在您查看包含如制表符这样的非打印字符的文件时起帮助作用。您可以用以下选项来显示制表符：
* -T 将制表符显示为 ^I
* -v 显示非打印字符，除了换行符和制表符，它们使用各自效果相当的“控制序列”。例如，当您处理一个在 Windows 系统中生成的文件时，这个文件将使用 Control-M（^M）来标记行的结束。对于代码大于 127 的字符，它们的前面将会被加上 M-（表示“meta”），这与其它系统中在字符前面加上 Alt- 相当。
* -E 在每一行的结束处添加美元符（$）。
显示非打印字符
代码:$ cat -t /etc/X11/XF86Config
...
# Multiple FontPath entries are allowed (they are concatenated together)
# By default, Red Hat 6.0 and later now use a font server independent of
# the X server to render fonts.
^IFontPath^I"/usr/X11R6/lib/X11/fonts/TrueType"
^IFontPath^I"unix/:7100"
EndSection
...
代码:$ cat -E /etc/X11/XF86Config
...
# Multiple FontPath entries are allowed (they are concatenated together)$
# By default, Red Hat 6.0 and later now use a font server independent of$
# the X server to render fonts.$
$
FontPath "/usr/X11R6/lib/X11/fonts/TrueType"$
FontPath "unix/:7100"$
$
EndSection$
...
代码:$ cat -v /etc/X11/XF86Config
...
^@^@^@^@^@^@^@^@^@^@^@^@^@^@^@M-|M-8^X^@^@^@
P^@^O"M-X^O M-@^M^@^@^@M-^@^O"M-@M-k^@M-8*^@
@M-^H$M-@M-9|A(M-@)M-yM-|M-sM-*M-hW^A^@^@j^@
M-|M-sM-%1M-@M-9^@^B^@^@M-sM-+fM-^A= ^@ ^@
F^@^@ ^@M-9^@^H^@^@M-sM-$M-G^E(l!M-@M-^?
^IM-A5^@^@^D^@PM-^]M-^\X1M-H%^@^@^D^@tyM-G
...4.tee
tee：读取标准输入的数据，并将其内容输出成文件。
　　语 　 法：tee [-ai][--help][--version][文件…]
　　补充说明：tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备,同时保存成文件。我们可利用tee把管道导入的数据存成文件，甚至一次保存数份文件。
　　参 　 数：-a 附加到既有文件的面，而非覆盖它。如果给予tee指令的文件名称已经存在，预设会覆盖该文件的内容。加上此参数，数据会新增在该文件内容的最面，而不会删除原先之内容。
　　　　　　　-i 忽略中断信号
　　　　　　　--help 在线帮助
　　　　　　　--version 显示版本信息
　　例一：
　　列出文本文件slayers.story的内容，同时复制3份副本，文件名称分别为ss-copy1、ss-copy2、ss-copy3：
代码:$ cat slayers.story |tee ss-copy1 ss-copy2 ss-copy3　　例二： 把列出当前目录，并把结果结到myfile里
代码:$ls -l |tee myfile
管道：可以通过管道把一个命令的输出传递给另一个命令作为输入。管道用竖杠|表示。它的一般形式为：
命令1 |命令2
其中|是管道符号。
[]     
    
Shell学习笔记 五
文章整理: 文章来源: 网络 
5.标准输入、输出和错误
当我们在s h e l l中执行命令的时候，每个进程都和三个打开的文件相联系，并使用文件描述符来引用这些文件。由于文件描述符不容易记忆， s h e l l同时也给出了相应的文件名。
下面就是这些文件描述符及它们通常所对应的文件名：
文件文件描述符
输入文件―标准输入stdin 0：它是命令的输入，缺省是键盘，也可以是文件或其他命令的输出。
输出文件―标准输出stdout 1：它是命令的输出，缺省是屏幕，也可以是文件。
错误输出文件―标准错误stderr 2：这是命令错误的输出，缺省是屏幕，同样也可以是文件。
如果没有特别指定文件说明符，命令将使用缺省的文件说明符（你的屏幕，更确切地说是你的终端）。
系统中实际上有1 2个文件描述符，但是正如我们在上表中所看到的， 0、1、2是标准输入、输出和错误。可以任意使用文件描述符3到9。
在执行命令时，可以指定命令的标准输入、输出和错误，要实现这一点就需要使用文件重定向。下面列出了最常用的重定向组合，并给出了相应的文件描述符。
在对标准错误进行重定向时，必须要使用文件描述符，但是对于标准输入和输出来说，这不是必需的。
常用文件重定向命令
command > filename 把标准输出重定向到一个新文件中
command >> filename 把标准输出重定向到一个文件中(追加)
command 1 > fielname 把标准输出重定向到一个文件中
command > filename 2>&1 把标准输出和标准错误一起重定向到一个文件中
command 2> filename 把标准错误重定向到一个文件中
command 2>> filename 把标准输出重定向到一个文件中(追加)
command >> filename 2>&1 把标准输出和标准错误一起重定向到一个文件中(追加)
command < filename >filename2 把c o m m a n d命令以f i l e n a m e文件作为标准输入，以f i l e n a m e 2文件作为标准输出
command < filename 把c o m m a n d命令以f i l e n a m e文件作为标准输入
command << delimiter 把从标准输入中读入，直至遇到d e l i m i t e r分界符
command <&m 把文件描述符m作为标准输入
command >&m 把标准输出重定向到文件描述符m中
command <&- 关闭标准输入
补充
File Descriptor (FD)
程式的\算，在大部份情r下都是M行(data)的理，
@些?哪淖xM？又，送出到哪e呢？
@就是 file descriptor (FD) 的功用了。
在 shell 程式中，最常使用的 FD 大概有三，分e椋
0: Standard Input (STDIN)
1: Standard Output (STDOUT)
2: Standard Error Output (STDERR)
在是r下，@些 FD 分e跟如下O(device)P：
stdin(0): keyboard
stdout(1): monitor
stderr(2): monitor
我可以用如下下命令y一下：
代码:$ mail -s test root
this is a test mail.
please skip.
^d (同r按 crtl 跟 d I)很明@，mail 程式所xM的，就是? stdin 也就是 keyboard xM的。
不^，不得每程式的 stdin 都跟 mail 一? keyboard xM，
因槌淌阶髡呖梢?n案底xM stdin ，如： 
代码:$ cat /etc/passwd但，要是 cat 之後]有n案t又如何呢？
哦，您自己玩玩看.... ^_^
代码:$ cat(留意出到哪e去了，最後e忘了按 ^d x_...) 
事?上，stderr ]甚Ny理解的：f穿了就是"e`信息"要往哪送而已...
比方f，若xM的n案凳遣淮嬖诘模那我在 monitor 上就看到了： 
代码:$ ls no.such.file
ls: no.such.file: No such file or directory若，一命令同ra生 stdout c stderr 呢？
那不危都送到 monitor ?砭秃昧耍[code]
$ touch my.file
$ ls my.file no.such.file
ls: no.such.file: No such file or directory
my.file
[/code]
okay，至此，P於 FD 及其名Q、有相P的O洌相信你已]}了吧？
那好，接下?碜我看看如何改@些 FD 的AO通道，
我可用 < ?砀淖xM的通道(stdin)，使之?闹付ǖn案xM。
我可用 > ?砀淖送出的通道(stdout, stderr)，使之出到指定的n案。
比方f： 
代码:$ cat < my.file就是? my.file xM 
代码:$ mail -s test root < /etc/passwdt是? /etc/passwd xM...
@右?恚stdin ⒉辉偈? keyboard xM，而是?n案xM了...
栏?碚f，< 符之前需要指定一 FD 的(之g不能有空白)，
但因 0 是 < 的AO值，因此 < c 0< 是一拥末u
那，要是用 << 又是啥呢？
@是所^的 HERE Document ，它可以我入一段文本，直到x到 << 後指定的字串。
比方f：
代码:$ cat <<FINISH
first line here
second line there
third line nowhere
FINISH@拥脑，cat xM 3 行句子，而o需? keyboard xM且要等 ^d Y束入。
你搞懂了 0< 原?砭褪歉淖 stdin 的入通道之後，相信要理解如下 redirection 就不y了：
* 1>
* 2>
前者是改 stdout 的出通道，後者是改 stderr 的出通道。
烧叨际⒃本要送出到 monitor 的D向出到指定n案去。
由於 1 是 > 的AO值，因此，1> c > 是相同的，都是改 stdout 。
用上面的 ls 例子?碚f明一下好了：
代码:$ ls my.file no.such.file 1>file.out
ls: no.such.file: No such file or directory@ monitor 就只剩下 stderr 而已。因 stdout oM file.out 去了。
代码:$ ls my.file no.such.file 2>file.err
my.file@ monitor 就只剩下 stdout ，因 stderr M了 file.err 。
代码:$ ls my.file no.such.file 1>file.out 2>file.err@ monitor 就啥也]有，因 stdout c stderr 都oD到n案去了...
不^，有些地方是要注意一下.
首先，是 file locking 的}。比方如下@例子：
代码:$ ls my.file no.such.file 1>file.both 2>file.both? file system 的角度?碚f，我n案在我rg龋只能被我坏 FD 作入。
假如 stdout(1) c stderr(2) 都同r在入 file.both 的，
t要看它在入r否碰到同r的情形了，基本上是"先先A"的原t。
我用"慢R^"?砜匆幌 stdout c stderr 同r入 file.out 的情形好了：
* 第 1, 2, 3 秒 stdout 入
* 第 3, 4, 5 秒 stderr 入
那N，@r候 stderr 的第 3 秒所的就?G失掉了u
要是我能控制 stderr 必等 stdout 完再，或倒^?恚stdout 等 stderr 完再，那}就能解Q。
但?募夹g上，^y掌控的，尤其是 FD 在作"L期性"的入r...
那，如何解Q呢？所^山不D路D、路不D人D嘛，
我可以Q一思S： stderr нM stdout 或 stdout нM sterr ，而不是大家在同一份n案，不就行了u
bingou就是@永玻
* 2>&1 就是 stderr ?氵M stdout 作出
* 1>&2 或 >&2 就是 stdout ?氵M stderr 作出
於是，前面的e`操作可以改椋
代码:$ ls my.file no.such.file 1>file.both 2>&1或
代码:$ ls my.file no.such.file 2>file.both >&2在 Linux n案系ye，有On位於 /dev/null 。
S多人都^我那是甚N玩意海磕蔷褪"空"啦u
]eu空空如也的空就是 null 了.... 
@ null 在 I/O Redirection 中可有用得很呢：
* 若 FD1 跟 FD2 D到 /dev/null 去，就可 stdout c stderr 弄不掉。
* 若 FD0 接到 /dev/null ?恚蔷褪亲xM nothing 。
比方f，我在绦幸程式r，面同r送出 stdout 跟 stderr ，
假如你不想看到 stderr (也不想存到n案去)，那可以：
代码:$ ls my.file no.such.file 2>/dev/null
my.file若要相反：只想看到 stderr 呢？不惟u stdout 弄到 null 就行：
代码:$ ls my.file no.such.file >/dev/null
ls: no.such.file: No such file or directory那接下?恚偃渭只跑程式；想看到任何出Y果呢？
除了用 >/dev/null 2>&1 之外，你可以如此：
代码:$ ls my.file no.such.file &>/dev/null(提示： &> Q成 >& 也行啦~~! )
另外,看下面:
代码:$ echo "1" > file.out
$ cat file.out
1
$ echo "2" > file.out
$ cat file.out
2看?恚在重 stdout 或 stderr M一份n案r，似乎永h只@得最後一次入的Y果。
那，之前的热菽兀
呵~~~ 要解Q@提很卫玻 > Q成 >> 就好：
$ echo "3" >> file.out
$ cat file.out
2
3
如此一?恚恢У哪n案之热?K不失去，而新的热t一直增加在最後面去。
但，只要你再一次用回我坏 > ?碇У脑ＧN，f的热葸是被"洗"掉的u
@r，你要如何避免呢？
----浞荸u yes ，我到了u不^.... 有更好的幔
代码:$ set -o noclobber
$ echo "4" > file.out
-bash: file: cannot overwrite existing file那，要如何取消@"限制"呢？
哦， set -o Q成 set +o 就行： 
代码:$ set +o noclobber
$ echo "5" > file.out
$ cat file.out
5再：那... 有k法不取消而又"Rr"w目n案
代码:$ set -o noclobber
$ echo "6" >| file.out
$ cat file.out
6留意到]有：在 > 後面再加" | "就好(注意： > c | 之g不能有空白哦)....
再?磉有一y}要你去⑼傅哪兀
代码:$ echo "some text here" > file
$ cat < file
some text here
$ cat < file > file.bak
$ cat < file.bak
some text here
$ cat < file > file
$ cat < file嗯？u注意到]有？uu
---- 怎N最後那 cat 命令看到的 file 竟是空的？u
why? why? why?
要理解@一F像其?不y，@只是 priority 的}而已：
* 在 IO Redirection 中，stdout c stderr 的管道先浜茫才? stdin xMY料。
也就是f，在上例中，> file 先 file 清空，然後才xM < file ，
但@r候n案已被清空了，因此就成x不M任何Y料了...
哦~~~ 原?砣绱~~~~ ^_^
那... 如下衫又如何呢？
代码:$ cat <> file
$ cat < file >> filepipe line
到 pipe line ，我相信不少人都不陌生：
我在很多 command line 上常看到的" | "符就是 pipe line 了。
不^，究竟 pipe line 是甚N||呢？
e急e急... 先查一下英?h字典，看看 pipe 是甚N意思？
]eu它就是"水管"的意思...
那N，你能想像一下水管是怎N一根接著一根的幔
又，每根水管之g的 input 跟 output 又如何呢？
嗯？？
`光一W：原? pipe line 的 I/O 跟水管的 I/O 是一模一拥模
* 上一命令的 stdout 接到下一命令的 stdin 去了u
的_如此... 不管在 command line 上你使用了多少 pipe line ，
前後 command 的 I/O 都是彼此B接的u(恭喜：你K於_[了u ^_^ )
不^... 然而... 但是... ... stderr 呢？
好}u不^也容易理解：
* 若水管漏水怎Nk？
也就是f：在 pipe line 之g，前一命令的 stderr 是不接M下一命令的 stdin 的，
其出，若不用 2> У file 去的，它是送到O器上面?愆u
@c你在 pipe line \用上毡匾注意的。
那，或S你又：
* 有k法 stderr 也jM下一命令的 stdin 去幔
方法然是有，而且你早已W^了u ^_^
我提示一下就好：
* 你如何 stderr 合?氵M stdout 一同出呢?
或S，你仍意尤未Mu或S，你曾碰到^下面的}：
* 在 cm1 | cm2 | cm3 ... @段 pipe line 中，若要 cm2 的Y果存到某一n案呢？
若你成 cm1 | cm2 > file | cm3 的，
那你肯定lF cm3 的 stdin 是空的u(然啦，你都⑺管接到e的水池了u)
明的你或S如此解Q：
cm1 | cm2 > file ; cm3 < file
是的，你的_可以@幼觯但最大的奶是：@右?恚file I/O p倍u
在 command 绦械恼^程中，file I/O 是最常的最大效能⑹帧
凡是有的 shell 操作者，都M量避免或降低 file I/O 的l率。
那，上面}有更好方法幔
有的，那就是 tee 命令了。
* 所^ tee 命令是在不影原本 I/O 的情r下， stdout }u一份到n案去。
因此，上面的命令行可以如此打：
cm1 | cm2 | tee file | cm3
在AO上，tee 改目n案，若你要改樵黾热莸脑，那可用 -a 颠_成。
基本上，pipe line 的用在 shell 操作上是非常?V泛的，尤其是在 text filtering 方面，
凡e cat, more, head, tail, wc, expand, tr, grep, sed, awk, ... 等等文字理工具，
搭配起 pipe line ?硎褂茫@X command line 原?硎腔畹萌绱司实末u
6.exec
e x e c命令可以用来替代当前s h e l l；换句话说，并没有启动子s h e l l。使用这一命令时任何现有环境都将会被清除，并重新启动一个s h e l l。它的一般形式为：
代码:exec command其中的c o m m a n d通常是一个s h e l l脚本。
我所能够想像得出的描述e x e c命令最贴切的说法就是：当这个脚本结束时，相应的会话可能就结束了。e x e c命令的一个常见用法就是在用户的. p r o f i l e最后执行时，用它来执行一些用于增强安全性的脚本。如果用户的输入无效，该s h e l l将被关闭，然后重新回到登录提示符。e x e c还常常被用来通过文件描述符打开文件。文件描述符:file descriptor(FD)
e x e c在对文件描述符进行操作的时候（也只有在这时），它不会覆盖你当前的s h e l l。
source和exec的区别
1,他们带的参数不一样
source通常是shell脚本,而exec不但可以把一个脚本当成参数,而且还可以把一个系统命令当参数,例如: exec ls
2,另外一个不同就是,exec任务执行完毕后,会执行类似logout的操作,而source执行完一个任务后返回当前的shell. 
[]
--------------------
制作工具：小说下载阅读器 http://www.mybook66.com<PIXTEL_MMI_EBOOK_2005>3                                                           </PIXTEL_MMI_EBOOK_2005>

http://wenku.baidu.com/view/68e3668102d276a200292ed5.html