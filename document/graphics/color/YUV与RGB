前几天碰到一个问题，需要做一张全黑的raw data给encode压码测试，因为raw data的格式是YUV的，于是相当然的就把所有值全置为0，因为Y值（亮度）置为0了，所以以为R码出来的frame就应该是黑色的，可压完才发现是粉色的，这下晕了，因为全黑对于RGB就意味着全0, 于是赶紧找找RGB跟YUV格式转换的算法。

这 是YUV转RGB的

R= 1.0Y + 0 +1.402(V-128)  
G= 1.0Y - 0.34413 (U-128)-0.71414(V-128)  
B= 1.0Y + 1.772 (U-128)+0

看完这一下就清楚了，YUV为全0时，RGB并不为全0，要想压全黑的，必须是：

Y = 0；

U = V = 128；

于是重新做了一份raw data， 压完一看，果然全黑了。

附RGB转YUV如下：

Y = 0.257R′ + 0.504G′ + 0.098B′ + 16
Cb = -0.148R′ - 0.291G′ + 0.439B′ + 128
Cr = 0.439R′ - 0.368G′ - 0.071B′ + 128



本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/leesphone/archive/2010/05/09/5572822.aspx



/**  
*：YUV420SP解码的方式  
*yuv420sp[]为原始的数据  
*width为图片位图长，height为图片位图高  
*rgbBuf[]是用于存贮原始数据经过解码后的r g b三元色数据  
*/  
static public void decodeYUV420SP(byte[] rgbBuf, byte[] yuv420sp, int width, int height) {      
              //定义单通道数据长度   
        final int frameSize = width * height;      
             //如果传进来的rgbBuf 为空，则抛出空指针异常   
    if (rgbBuf == null)      
        throw new NullPointerException("buffer 'rgbBuf' is null");      //如果传进来的rgbBuf 为比三通道数据长度小，则抛出异常,并打出相应信息   
    if (rgbBuf.length < frameSize * 3)      
        throw new IllegalArgumentException("buffer 'rgbBuf' size "     
                 + rgbBuf.length + " < minimum " + frameSize * 3);      
       //如果传进来的yuv420sp 为空，则抛出空指针异常   
    if (yuv420sp == null)      
        throw new NullPointerException("buffer 'yuv420sp' is null");      
      //如果传进来的rgbBuf 为比三通道数据长度的一半小，则抛出异常,并打出相应信息   
    if (yuv420sp.length < frameSize * 3 / 2)      
        throw new IllegalArgumentException("buffer 'yuv420sp' size " + yuv420sp.length      
                 + " < minimum " + frameSize * 3 / 2);      
           //经过上面的叛断，我们正式进行解码了   
        int i = 0, y = 0;      
        int uvp = 0, u = 0, v = 0;     
               //r g b 三元色初始化    
        int y1192 = 0, r = 0, g = 0, b = 0;      
             //下面的两个for循环都只是为了把第一个像素点的的R G B读取出来，就是一行一行循环读取.   
        for (int j = 0, yp = 0; j < height; j++) {      
             uvp = frameSize + (j >> 1) * width;      
             u = 0;      
             v = 0;      
            for (i = 0; i < width; i++, yp++) {      
                 y = (0xff & ((int) yuv420sp[yp])) - 16;      
                if (y < 0) y = 0;      
                if ((i & 1) == 0) {      
                     v = (0xff & yuv420sp[uvp++]) - 128;      
                     u = (0xff & yuv420sp[uvp++]) - 128;      
                 }      
                      
                 y1192 = 1192 * y;      
                 r = (y1192 + 1634 * v);      
                 g = (y1192 - 833 * v - 400 * u);      
                 b = (y1192 + 2066 * u);      
                   //始终持 r g b在0 - 262143   
                if (r < 0) r = 0; else if (r > 262143) r = 262143;      
                if (g < 0) g = 0; else if (g > 262143) g = 262143;      
                if (b < 0) b = 0; else if (b > 262143) b = 262143;      
                   //安位运算，分别将一个像素点中的r g b 存贮在rgbBuf中   
                 rgbBuf[yp * 3] = (byte)(r >> 10);      
                 rgbBuf[yp * 3 + 1] = (byte)(g >> 10);      
                 rgbBuf[yp * 3 + 2] = (byte)(b >> 10);      
             }      
         }      
       }     
  
通过这样的解码，我们就可以得到我们想要的rgbBuf[],相应的还原机制也就是返过来而已。  

/**
*：YUV420SP解码的方式
*yuv420sp[]为原始的数据
*width为图片位图长，height为图片位图高
*rgbBuf[]是用于存贮原始数据经过解码后的r g b三元色数据RGB565
*/
static public void decodeYUV420SP(byte[] rgbBuf, byte[] yuv420sp, int width, int height) {   
              //定义单通道数据长度
	    final int frameSize = width * height;   
             //如果传进来的rgbBuf 为空，则抛出空指针异常
	if (rgbBuf == null)   
	    throw new NullPointerException("buffer 'rgbBuf' is null");      //如果传进来的rgbBuf 为比三通道数据长度小，则抛出异常,并打出相应信息
	if (rgbBuf.length < frameSize * 3)   
	    throw new IllegalArgumentException("buffer 'rgbBuf' size "  
	             + rgbBuf.length + " < minimum " + frameSize * 3);   
	   //如果传进来的yuv420sp 为空，则抛出空指针异常
	if (yuv420sp == null)   
	    throw new NullPointerException("buffer 'yuv420sp' is null");   
	  //如果传进来的rgbBuf 为比三通道数据长度的一半小，则抛出异常,并打出相应信息
	if (yuv420sp.length < frameSize * 3 / 2)   
	    throw new IllegalArgumentException("buffer 'yuv420sp' size " + yuv420sp.length   
	             + " < minimum " + frameSize * 3 / 2);   
	       //经过上面的叛断，我们正式进行解码了
	    int i = 0, y = 0;   
	    int uvp = 0, u = 0, v = 0;  
               //r g b 三元色初始化 
	    int y1192 = 0, r = 0, g = 0, b = 0;   
             //下面的两个for循环都只是为了把第一个像素点的的R G B读取出来，就是一行一行循环读取.
	    for (int j = 0, yp = 0; j < height; j++) {   
	         uvp = frameSize + (j >> 1) * width;   
	         u = 0;   
	         v = 0;   
	        for (i = 0; i < width; i++, yp++) {   
	             y = (0xff & ((int) yuv420sp[yp])) - 16;   
	            if (y < 0) y = 0;   
	            if ((i & 1) == 0) {   
	                 v = (0xff & yuv420sp[uvp++]) - 128;   
	                 u = (0xff & yuv420sp[uvp++]) - 128;   
	             }   
	               
	             y1192 = 1192 * y;   
	             r = (y1192 + 1634 * v);   
	             g = (y1192 - 833 * v - 400 * u);   
	             b = (y1192 + 2066 * u);   
	               //始终持 r g b在0 - 262143
	            if (r < 0) r = 0; else if (r > 262143) r = 262143;   
	            if (g < 0) g = 0; else if (g > 262143) g = 262143;   
	            if (b < 0) b = 0; else if (b > 262143) b = 262143;   
	               //安位运算，分别将一个像素点中的r g b 存贮在rgbBuf中
	             rgbBuf[yp * 3] = (byte)(r >> 10);   
	             rgbBuf[yp * 3 + 1] = (byte)(g >> 10);   
	             rgbBuf[yp * 3 + 2] = (byte)(b >> 10);   
	         }   
	     }   
	   }  

	   
还可以参考:Converting between Y'UV and RGB
http://en.wikipedia.org/wiki/YUV#Y.27UV444