shilong
用坐标变换算来算去算死人啊...
要是有一个函数就好了

输入转动的向量V1,轴V2,角度a
输出转后的向量V3

--------------------------------------------------------------------------------

jerrydong
用四元数处理旋转问题计算量比用变换矩阵的效率高些。
一个绕向量A旋转x角的四元数为：q=cos( x/2 )+A*sin( x/2 );
然后就有公式将此四元数转化成变换公式，好像转化公式是：
R=| 1-2*y*y-2*z*z 2*x*y-z*w*z 2*x*z+2*w*y |
| 2*x*y+2*w*z 1-2*x*x-2*z*z 2*y*z-2*w*x |
| 2*x*z-2*w*y 2*y*z+2*w*x 1-2*x*x-2*y*y |
若q写成q=s+v的形式，则w=s, v=(x,y,z);
www.gametutorials.com有有一个四元数的例子，可以参考。

--------------------------------------------------------------------------------

wohoa
用四元数处理旋转问题计算量比用变换矩阵的效率高些。
一个绕向量A旋转x角的四元数为：q=cos( x/2 )+A*sin( x/2 );
然后就有公式将此四元数转化成变换公式，好像转化公式是：
R=| 1-2*y*y-2*z*z 2*x*y-z*w*z 2*x*z+2*w*y |
| 2*x*y+2*w*z 1-2*x*x-2*z*z 2*y*z-2*w*x |
| 2*x*z-2*w*y 2*y*z+2*w*x 1-2*x*x-2*y*y |
若q写成q=s+v的形式，则w=s, v=(x,y,z);
www.gametutorials.com有有一个四元数的例子，可以参考。
不用这么复杂吧，用一般的矩阵变换就实现了，再说四元数也不是解决这个问题的。



a，b都是空间向量，b沿a旋转s度后的新向量是多少。旋转方向符合右手规则，即右手拇指指向a，其他四指握拳指向的方向。 
如果有必要可以设a，b都是单位向量 
会不会是一个3*3的矩阵后面写b的形式
 共0条评论...

在3维向量空间中沿向量a旋转s°的变换. 
由于这是一个线性变换,所以只要表示出其矩阵即可. 

1. 
先设a1=a/||a||(用列向量表示), 
再取一个a2垂直于a1的单位向量, 
最后设a3=(a1)×(a2). 

2. 
这时沿向量a旋转s°有两种变换,我们只讨论a1向a2旋转s° 
的变换. 
. 
a2旋转s°后为b1,则b1=ua2+va3, 
且(a2)*(b1)=cos(s°) 
(a3)*(b1)=cos(90°-s°) 
==> 
u=cos(s°),v=sin(s°), 
==> 
b1=cos(s°)a2+sin(s°)a3. 

. 
a3旋转s°后为b2,则b1=xa2+ya3, 
且(a2)*(b2)=cos(90°+s°) 
(a3)*(b2)=cos(s°) 
==> 
x=-sin(s°),y=cos(s°), 
==> 
b2=-sin(s°)a2+cos(s°)a3, 

3. 
设B为这个线性变换的变换矩阵, 
则有 B(a1)=a1, 
B(a2)=b1, 
B(a3)=b2, 
==> 
B(a1,a2,a3)=(a1,b1,b2) 
==> 
B=(a1,b1,b2)(a1,a2,a3)^(-1)= 
=(a1,a2,a3)C(a1,a2,a3)^(-1), 
C= 
1, 0, 0 
0,cos(s°),-sin(s°) 
0,sin(s°),cos(s°) 

注意:(a1,a2,a3)是正交矩阵,且和a2的选择无关. 
而任意b沿a旋转s度后的新向量是Bb.(b用列向量表示) 
回答：2007-12-03 10:03
提问者对答案的评价：
好像C_s° C_-s°等于对角线都是1的一个矩阵，还可以写成比较简化的形式 






进行三维软件的开发,旋转是必不可少而且非常重要的一部分.

下面谈谈我对旋转的理解,偶的文字表述能力非常差,如果你觉得表述有问题,请无视.

旋转有两种方式:旋转场景或对象,旋转摄像机.

1.旋转场景或对象.

    这是对场景或对象直接操作,操作之后物体的坐标值在应用矩阵后是发生了变化的.可用图形开发库提供的命令执行,或者直接操作三维矩阵.

    1.1用图形开发库提供的命令执行.

           比如在opengl中

              glrotatef rotangle,rotaxis.x,rotaxis.y,rotaxis.z

              绘制场景或对象

    1.2 对三维矩阵操作.

          有两种情况:

          一.你不会写旋转矩阵:让opengl代替这部分工作

             glloadidentity

             glrotatef rotangle,rotaxis.x,rotaxis.y,rotaxis.z

             glgetdoublev glmodelviewmatrix ,m'此时得到的就是旋转矩阵

             '此次的旋转应该和以前对场景的操作起作用,使用矩阵相乘

             glloadmatrixd 之前操作场景的矩阵

             glmultmatrixd m'也可以自己写矩阵相乘.

          二.你会计算旋转矩阵

             '自己算出当前的旋转矩阵

             '与之前的矩阵相乘.

2.旋转摄像机

      这种情况,保持了场景或物体的坐标值不变,只是移动了摄像机.可以创建一个摄像机类,最基本的属性有

        eyepos

        lookcenter

        up

        right

       旋转前,即鼠标按下时获得旋转的中心rotcenter,在鼠标移动时:

             计算旋转轴

             围绕旋转轴旋转eyepos,lookcenter,up,right

       下一次渲染时直接glulookat eyepos,lookcenter,up即可.

关于旋转中心的问题:

        旋转中心可以是:场景原点,物体包围盒的中心,鼠标拾取的位置,或者即时计算出的位置.

即时计算旋转中心(适合整个场景只有一个大的对象,由于移动,缩放等操作,仅有它的一部分可见,可见部分在视区是随意的):

      每次旋转时找出所有在可见区的点

      计算出这些点的包围盒

      求出中心

这样很精确,但有一个缺点,当数据量很大时,电脑就会死掉.改进的方法是找出物体关键位置,只计算这些关键位置与视区的交.这些关键位置要能保证查找的旋转中心基本正确,又能大幅度降低计算开销.








最近这两天没事的时候乱翻了翻加拿大人robert penner写的<Flash Mx编程与创意实现>(英文原名为programming macromedia flash mx＞，讲的flash的版本是比较旧的了，不过书里的内容跟flash版本基本没关系，主要讲的是怎么把数学物理等知识应用到actionscript编程中，看完了确实是有不小收获，最恨的就是把当初数学课上学的那些定理基本上全忘光了，另外回想起当初，觉得中学的那帮子老师真的基本上都是只会空谈大论的家伙，讲的东西不是没用，其实是非常的有用（如果你用flash编程的话，你就能知道那些枯燥无聊的公式是多么多么的有用，当然还有其他方面的工作，但中学甚至到大学毕了业你可能都不知道它们怎么去解决实际的问题），但那帮子家伙除了会用那些东西去解决一堆子无聊枯燥狗屁用都没有的垃圾习题让我们去应付考试以外，基本上就不会别的了（不联系实际的理论是最无聊的东西，谁会有兴趣去学习让人觉得没实际意义的东西）。其实那些公式在实现各种动画效果上有决定性的作用。其实理论跟现实应用感觉只隔着一层纸一样，看了这书就有纸被捅破豁然开朗的感觉，会觉得原来这个以前学过的数学公式是这样使用的，这样用就能做出这样的效果等等。所以嘛，找老师一定要找明师（名师－－那些所谓的著名教师未必都是名副其实），明师不非得是会说话的人，只要他（它）的思想能给你启发让你进步，那就是明师。好了，不废话了，下面就记录几个三维效果里面很基本的几个有用的公式吧（也许准确说不能算公式，不过也是从公式推导过来的，具有普遍性）。

三维向量旋转：
绕x轴旋转（以y,z都大于0的范围内从y轴向z轴方向旋转，旋转角度a，x不变)：
function Rotate (a:Number)
{
rotatedY = y * cos(a) - z * sin(a)
rotatedZ = y * sin(a) + z * cos(a)
}

公式由来根据：2维向量的旋转，相当于绕Z轴旋转：
function Rotate (a:Number)
{
rotatedX = x * cos(a) - y * sin(a)
rotatedY = x * sin(a) + y * cos(a)
}
2维向量旋转公式是根据cos(a+b) = cos(a)* cos(b) - sin(a)*sin(b)和sin(a+b)=sin(a)*cos(b) + cos(a) * sin(b)这两个三角和公式推导而来。

同理绕y轴旋转（在x,z都为正的区域中由z向x方向旋转）的公式：
function Rotate (a:Number)
{
rotatedZ = z * cos(a) - x * sin(a)
rotatedX = z * sin(a) + x * cos(a)
}

绕z轴旋转同2维向量旋转

向量的投影（我没专业知识，只是取书中给出的方法记录于此以备没书的时候查阅用，我估计书里讲的是最简单一种，有不对的地方请别笑话，欢迎指证）
求物体的缩放比例：
视距（眼睛到投影面的距离）/ (z + 视距)
视距让效果产生类似窥视孔的那种效果

三维点的投影
projectedX = x * 缩放比例
projectedY = y * 缩放比例

利用以上公式可以在flash中实现物体（影片剪辑）的绕x,y,z三轴的旋转效果，也可以得出例如同时绕xy轴旋转的效果等等。我参照书中的示例，利用上面的公式制作出一个简单的绕X轴旋转的三维粒子墙的效果，感觉不错，效果挺逼真的，呵呵。









http://wenku.baidu.com/view/b2c1f7b069dc5022aaea003e.html
http://hi.baidu.com/windwin/blog/item/7e571b8b3e5495dbfc1f1064.html
0221关于M3G相机多轴旋转代码
http://blog.163.com/bp_dragon/blog/static/128594692006412125510/
