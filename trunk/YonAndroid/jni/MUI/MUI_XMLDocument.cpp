#include "MUI_XMLDocument.h"

namespace mui{
namespace xml{

	//----------------------------------------------------------------------//
	// class Element
	//----------------------------------------------------------------------//
Element::Element(const core::stringc& name, Element* parent, ElementType type, const core::stringc& content) :
	m_name(name),
	m_content(content),
	m_pParent(parent),
	m_type(type)
{
}

Element::~Element()
{
	/*for (VectorElement::iterator iter = mChilds.begin(); iter != mChilds.end(); ++iter)
	{
		delete *iter;
	}
	mChilds.clear();*/
	clear();
}

/*void Element::save(std::ostream& _stream, size_t _level)
{
	// §ã§ß§Ñ§é§Ñ§Ý§Ñ §ä§Ñ§Ò§å§Ý§ñ§è§Ú§Ú §ß§Ñ§Þ§å§ä§Ú§Þ
	for (size_t tab = 0; tab < _level; ++tab)
		_stream  << "    ";

	// §ä§Ö§á§Ö§â§î §Ù§Ñ§Ô§à§Ý§à§Ó§à§Ü §ä§Ö§Ô§Ñ
	if (mType == ElementType::Declaration)
		_stream << "<?";
	else if (mType == ElementType::Comment)
		_stream << "<!--";
	else
		_stream << "<";

	_stream << mName;

	for (VectorAttributes::iterator iter = mAttributes.begin(); iter != mAttributes.end(); ++iter)
	{
		_stream << " " << iter->first << "=\"" << utility::convert_to_xml(iter->second) << "\"";
	}

	bool empty = mChilds.empty();
	// §Ö§ã§Ý§Ú §Õ§Ö§ä§Ö§Û §ß§Ö§ä §ä§à §Ù§Ñ§Ü§â§í§Ó§Ñ§Ö§Þ
	if (empty && mContent.empty())
	{
		if (mType == ElementType::Declaration)
			_stream << "?>\n";
		else if (mType == ElementType::Comment)
			_stream << "-->\n";
		else
			_stream << "/>\n";
	}
	else
	{
		_stream << ">";
		if (!empty)
			_stream << "\n";
		// §Ö§ã§Ý§Ú §Ö§ã§ä§î §ä§Ö§Ý§à §ä§à §ã§ß§Ñ§é§Ñ§Ý§à §à§ß§à
		if (!mContent.empty())
		{
			if (!empty)
			{
				for (size_t tab = 0; tab <= _level; ++tab) _stream  << "    ";
			}
			_stream << utility::convert_to_xml(mContent);

			if (!empty)
				_stream << "\n";
		}
		// §Ö§ã§Ý§Ú §Ö§ã§ä§î §Õ§Ö§ä§Ú§ê§Ü§Ú §á§å§ä§î §ã§à§ç§â§Ñ§ß§ñ§ä§ã§ñ
		for (size_t child = 0; child < mChilds.size(); child++)
		{
			mChilds[child]->save(_stream, _level + 1);
		}

		if (!empty)
		{
			for (size_t tab = 0; tab < _level; ++tab)
				_stream  << "    ";
		}
		_stream << "</" << mName << ">\n";
	}
}*/

Element* Element::createChild(const core::stringc& name, const core::stringc& content, ElementType type)
{
	Element* node = new Element(name, this, type, content);
	m_children.push_back(node);
	return node;
}

void Element::removeChild(Element* child)
{
	/*VectorElement::iterator item = std::find(mChilds.begin(), mChilds.end(), _child);
	if (item != mChilds.end())
	{
		delete (*item);
		mChilds.erase(item);
	}*/
	for(u32 i=0;i<m_children.size();++i)
	{
		if(m_children[i]==child)
		{
			delete m_children[i];
			m_children.erase(i);
		}
	}
}

void Element::clear()
{
	/*for (VectorElement::iterator iter = mChilds.begin(); iter != mChilds.end(); ++iter) delete *iter;
	mChilds.clear();
	mContent.clear();
	mAttributes.clear();*/
	for(u32 i=0;i<m_children.size();++i)
	{
		delete m_children[i];
	}
	m_children.clear();
	m_content="";
	m_attributes.clear()
}

bool Element::findAttribute(const core::stringc& name, core::stringc& value)
{
	/*for (VectorAttributes::iterator iter = mAttributes.begin(); iter != mAttributes.end(); ++iter)
	{
		if ( (*iter).first == _name)
		{
			_value = (*iter).second;
			return true;
		}
	}
	return false;*/
	for(u32 i=0;i<m_attributes.size();++i)
	{
		if(m_attributes[i].Key==name)
		{
			value=m_attributes[i].Value;
			return true;
		}
	}
	return false;
}

core::stringc Element::findAttribute(const core::stringc& name)
{
	/*for (VectorAttributes::iterator iter = mAttributes.begin(); iter != mAttributes.end(); ++iter)
	{
		if ((*iter).first == _name)
			return (*iter).second;
	}
	return "";*/

	core::stringc value;
	findAttribute(name,value);
	return value;
}

void Element::addAttribute(const core::stringc& key, const core::stringc& value)
{
	m_attributes.push_back(PairAttribute(key, value));
}

void Element::removeAttribute(const core::stringc& key)
{
	for(u32 index = 0; index < m_attributes.size(); ++index)
	{
		if (m_attributes[index].Key == key)
		{
			m_attributes.erase(index);
			return;
		}
	}
}

Element* Element::createCopy()
{
	Element* elem = new Element(m_name, NULL, m_type, m_content);
	elem->m_attributes = m_attributes;

	/*for (VectorElement::iterator iter = mChilds.begin(); iter != mChilds.end(); ++iter)
	{
		Element* child = (*iter)->createCopy();
		child->mParent = elem;
		elem->mChilds.push_back(child);
	}*/
	for(u32 i=0;i<m_children.size();++i)
	{
		Element* child = *m_children[i]->createCopy();
		child->m_pParent = elem;
		elem->m_children.push_back(child);
	}
	return elem;
}

void Element::setAttribute(const core::stringc& key, const core::stringc& value)
{
	for (u32 index = 0; index < m_attributes.size(); ++index)
	{
		if (m_attributes[index].Key == key)
		{
			m_attributes[index].Value = value;
			return;
		}
	}
	m_attributes.push_back(PairAttribute(key, value));
}

void Element::addContent(const core::stringc& content)
{
	if (m_content.empty())
	{
		m_content = content;
	}
	else
	{
		m_content += " ";
		m_content += content;
	}
}

void Element::setContent(const core::stringc& content)
{
	m_content = content;
}

const core::stringc& Element::getName() const
{
	return m_name;
}

const core::stringc& Element::getContent() const
{
	return m_content;
}

const core::array<PairAttribute>& Element::getAttributes() const
{
	return m_attributes;
}

Element* Element::getParent() const
{
	return m_pParent;
}

/*ElementEnumerator Element::getElementEnumerator()
{
	return ElementEnumerator(mChilds.begin(), mChilds.end());
}*/

Element* Element::getType() const
{
	return m_type;
}

/*
#if MYGUI_COMPILER == MYGUI_COMPILER_MSVC && !defined(STLPORT)
inline void open_stream(std::ofstream& _stream, const std::wstring& _wide)
{
	_stream.open(_wide.c_str());
}
inline void open_stream(std::ifstream& _stream, const std::wstring& _wide)
{
	_stream.open(_wide.c_str());
}
#else
inline void open_stream(std::ofstream& _stream, const std::wstring& _wide)
{
	_stream.open(UString(_wide).asUTF8_c_str());
}
inline void open_stream(std::ifstream& _stream, const std::wstring& _wide)
{
	_stream.open(UString(_wide).asUTF8_c_str());
}
#endif
*/

//----------------------------------------------------------------------//
// class Document
//----------------------------------------------------------------------//
Document::Document():
m_pRoot(NULL),
m_pDeclaration(NULL),
m_lastErrorFile(),
m_uLine(0),
m_uColumn(0)
{
}

Document::~Document()
{
	clear();
}

bool Document::open(const core::stringc& filename)
{
	/*std::ifstream stream;
	stream.open(_filename.c_str());

	if (!stream.is_open())
	{
		mLastError = ErrorType::OpenFileFail;
		setLastFileError(_filename);
		return false;
	}

	bool result = open(stream);

	stream.close();
	return result;*/

	//TODO
}

bool Document::save(const core::stringc& filename)
{
	/*std::ofstream stream;
	stream.open(_filename.c_str());

	if (!stream.is_open())
	{
		mLastError = ErrorType::CreateFileFail;
		setLastFileError(_filename);
		return false;
	}

	bool result = save(stream);

	if (!result)
	{
		setLastFileError(_filename);
	}

	stream.close();
	return result;*/

	//TODO
}

/*
bool Document::open(const std::wstring& _filename)
{
	std::ifstream stream;
	open_stream(stream, _filename);

	if (!stream.is_open())
	{
		mLastError = ErrorType::OpenFileFail;
		setLastFileError(_filename);
		return false;
	}

	bool result = open(stream);

	stream.close();
	return result;
}


bool Document::open(const std::wstring& _filename)
{
	std::ifstream stream;
	open_stream(stream, _filename);

	if (!stream.is_open())
	{
		mLastError = ErrorType::OpenFileFail;
		setLastFileError(_filename);
		return false;
	}

	bool result = open(stream);

	stream.close();
	return result;
}
bool Document::open(std::istream& _stream)
{
	DataStream* data = new DataStream(&_stream);

	bool result = open(data);
	delete data;

	return result;
}

// §ã§à§ç§â§Ñ§ß§ñ§Ö§ä §æ§Ñ§Û§Ý, §Ú§Þ§ñ §æ§Ñ§Û§Ý§Ñ §Ó §Ü§à§Õ§Ú§â§à§Ó§Ü§Ö utf16 §Ú§Ý§Ú utf32
bool Document::save(const std::wstring& _filename)
{
	std::ofstream stream;
	open_stream(stream, _filename);

	if (!stream.is_open())
	{
		mLastError = ErrorType::CreateFileFail;
		setLastFileError(_filename);
		return false;
	}

	bool result = save(stream);

	if (!result)
	{
		setLastFileError(_filename);
	}

	stream.close();
	return result;
}

// §à§ä§Ü§â§í§Ó§Ñ§Ö§ä §à§Ò§í§é§ß§í§Þ §á§à§ä§à§Ü§à§Þ
bool Document::open(IDataStream* _stream)
{
	clear();

	// §ï§ä§à §ä§Ö§Ü§å§ë§Ñ§ñ §ã§ä§â§à§Ü§Ñ §Õ§Ý§ñ §â§Ñ§Ù§Ò§à§â§Ñ
	std::string line;
	// §ï§ä§à §ã§ä§â§à§Ü§Ñ §Ú§Ù §æ§Ñ§Û§Ý§Ñ
	std::string read;
	// §ä§Ö§Ü§å§ë§Ú§Û §å§Ù§Ö§Ý §Õ§Ý§ñ §â§Ñ§Ù§Ò§à§â§Ñ
	ElementPtr currentNode = 0;

	while (!_stream->eof())
	{
		// §Ò§Ö§â§Ö§Þ §ß§à§Ó§å§ð §ã§ä§â§à§Ü§å
		_stream->readline(read, '\n');
		if (read.empty())
			continue;
		if (read[read.size() - 1] == '\r')
			read.erase(read.size() - 1, 1);
		if (read.empty())
			continue;

		mLine ++;
		mCol = 0; // §á§à§ä§à§Þ §á§â§à§Ó§Ö§â§Ú§ä§î §ß§Ñ §Þ§ß§à§Ô§à§ã§ä§â§à§é§ß§í§ç §ä§ï§Ô§Ñ§ç
		if (read.empty())
			continue;
		// §ä§Ö§Ü§å§ë§Ñ§ñ §ã§ä§â§à§Ü§Ñ §Õ§Ý§ñ §â§Ñ§Ù§Ò§à§â§Ñ §Ú §ä§à §é§ä§à §Ö§ë§Ö §á§â§à§é§Ú§ä§Ñ§Ý§Ú
		line += read;

		if (!parseLine(line, currentNode))
		{
			return false;
		}

	} // while (!stream.eof())

	if (currentNode)
	{
		mLastError = ErrorType::NotClosedElements;
		return false;
	}

	return true;
}

bool Document::save(std::ostream& _stream)
{
	if (!mDeclaration)
	{
		mLastError = ErrorType::NoXMLDeclaration;
		return false;
	}

	// §Ù§Ñ§Ô§à§Ý§à§Ó§à§Ü utf8
	_stream << (char)0xEFu;
	_stream << (char)0xBBu;
	_stream << (char)0xBFu;

	mDeclaration->save(_stream, 0);
	if (mRoot)
		mRoot->save(_stream, 0);

	return true;
}
*/
void Document::clear()
{
	clearDeclaration();
	clearRoot();
	m_uLine = 0;
	m_uColumn = 0;
}

bool Document::parseTag(Element*& currentNode, core::stringc content)
{
	/*
	// §å§Ò§Ö§â§Ñ§Ö§Þ §Ý§Ú§ê§ß§Ö§Ö
	MyGUI::utility::trim(_content);

	if (_content.empty())
	{
		// §ã§à§Ù§Õ§Ñ§Ö§Þ §á§å§ã§ä§à§Û §ä§Ö§Ô
		if (_currentNode)
		{
			_currentNode = _currentNode->createChild("");
		}
		else
		{
			_currentNode = new Element("", 0);
			// §Ö§ã§Ý§Ú §ï§ä§à §á§Ö§â§Ó§í§Û §ä§à §Ù§Ñ§á§à§Þ§Ú§ß§Ñ§Ö§Þ
			if (!mRoot)
				mRoot = _currentNode;
		}
		return true;
	}

	char simbol = _content[0];
	bool tagDeclaration = false;

	// §á§â§à§Ó§Ö§â§ñ§Ö§Þ §ß§Ñ §Ü§à§Þ§Ö§ß§ä§Ñ§â§Ú§Ú
	if (simbol == '!')
	{
		if (_currentNode != 0)
		{
			//_currentNode->createChild("", _content, ElementType::Comment);
		}
		return true;
	}
	// §á§â§à§Ó§Ö§â§ñ§Ö§Þ §ß§Ñ §Ú§ß§æ§à§â§Þ§Ñ§è§Ú§à§ß§ß§í§Û §ä§Ö§Ô
	else if (simbol == '?')
	{
		tagDeclaration = true;
		_content.erase(0, 1); // §å§Õ§Ñ§Ý§ñ§Ö§Þ §á§Ö§â§Ó§í§Û §ã§Ú§Þ§Ó§à§Ý
	}

	size_t start = 0;
	size_t end = 0;
	// §á§â§à§Ó§Ö§â§ñ§Ö§Þ §ß§Ñ §Ù§Ñ§Ü§â§í§ä§Ú§Ö §ä§Ö§Ô§Ñ
	if (simbol == '/')
	{
		if (_currentNode == 0)
		{
			// §é§Ö§ä§Ñ §Þ§í §Ù§Ñ§Ü§â§í§Ó§Ñ§Þ §Ñ §ß§Ú§é§Ö §Õ§Ñ§Ø§Ö §Ú §ß§Ö §à§ä§Ü§â§í§ä§à
			if (!mRoot)
			{
				mLastError = ErrorType::CloseNotOpenedElement;
				return false;
			}
		}
		// §à§Ò§â§Ö§Ù§Ñ§Ö§Þ §Ú§Þ§ñ §ä§ï§Ô§Ñ
		start = _content.find_first_not_of(" \t", 1);
		if (start == _content.npos)
		{
			// §ä§Ö§Ô §á§å§ã§ä§à§Û
			_content.clear();
		}
		else
		{
			end = _content.find_last_not_of(" \t");
			_content = _content.substr(start, end - start + 1);
		}
		// §á§â§à§Ó§Ö§â§ñ§Ö§Þ §ã§à§à§ä§Ó§Ö§ä§ã§ä§Ó§Ú§Ö §à§ä§Ü§â§í§Ó§Ñ§ð§ë§Ö§Ô§à §Ú §Ù§Ñ§Ü§â§í§Ó§Ñ§ð§ë§Ö§Ô§à §ä§Ö§Ô§à§Ó
		if (_currentNode->getName() != _content)
		{
			mLastError = ErrorType::InconsistentOpenCloseElements;
			return false;
		}
		// §Ñ §ä§Ö§á§Ö§â§î §ã§ß§Ú§Ø§Ñ§Ö§Þ §ä§Ö§Ü§å§ë§Ú§Û §å§Ù§Ö§Ý §Ó§ß§Ú§Ù
		_currentNode = _currentNode->getParent();
	}
	else
	{
		// §Ó§í§Õ§Ö§Ý§ñ§Ö§Þ §Ú§Þ§ñ §Õ§à §á§Ö§â§Ó§à§Ô§à §á§â§à§Ò§Ö§Ý§Ñ §Ú§Ý§Ú §Ù§Ñ§Ü§â§í§Ó§Ñ§ð§ë§Ö§Ô§à §ä§Ö§Ô§Ñ
		std::string cut = _content;
		start = _content.find_first_of(" \t/?", 1); // << §á§â§Ö§Ó§Ö§Õ
		if (start != _content.npos)
		{
			cut = _content.substr(0, start);
			_content = _content.substr(start);
		}
		else
		{
			_content.clear();
		}

		if (_currentNode)
		{
			_currentNode = _currentNode->createChild(cut);
		}
		else
		{
			if (tagDeclaration)
			{
				// §Ú§ß§æ§à§â§Þ§Ñ§è§Ú§à§ß§ß§í§Û §ä§Ö§Ô
				if (mDeclaration)
				{
					mLastError = ErrorType::MoreThanOneXMLDeclaration;
					return false;
				}
				_currentNode = new Element(cut, 0, ElementType::Declaration);
				mDeclaration = _currentNode;
			}
			else
			{
				// §â§å§ä§à§Ó§í§Û §ä§Ö§Ô
				if (mRoot)
				{
					mLastError = ErrorType::MoreThanOneRootElement;
					return false;
				}
				_currentNode = new Element(cut, 0, ElementType::Normal);
				mRoot = _currentNode;
			}
		}

		// §á§â§à§Ó§Ö§â§Ú§Þ §ß§Ñ §á§å§ã§ä§à§ä§å
		start = _content.find_last_not_of(" \t");
		if (start == _content.npos)
			return true;

		// §ã§â§Ñ§Ù§å §à§ä§Õ§Ö§Ý§Ú§Þ §Ù§Ñ§Ü§â§í§Ó§Ñ§ð§ë§Ú§Û§ã§ñ §ä§ï§Ô
		bool close = false;
		if ((_content[start] == '/') || (_content[start] == '?'))
		{
			close = true;
			// §ß§Ö §Ò§å§Õ§Ö§Þ §â§Ö§Ù§Ñ§ä§î §ã§ä§â§à§Ü§å, §á§â§à§ã§ä§à §á§à§ã§ä§Ñ§Ó§Ú§Þ §á§â§à§Ò§Ö§Ý
			_content[start] = ' ';
			// §á§â§à§Ó§Ö§â§Ú§Þ §ß§Ñ §á§å§ã§ä§à§ä§å
			start = _content.find_last_not_of(" \t");
			if (start == _content.npos)
			{
				// §Ó§à§Ù§Ó§â§Ñ§ë§Ñ§Ö§Þ §Ó§ã§Ö §ß§Ñ§Ù§Ñ§Õ §Ú §å§ç§à§Õ§Ú§Þ
				_currentNode = _currentNode->getParent();
				return true;
			}
		}

		// §Ñ §Ó§à§ä §Ù§Õ§Ö§ã§î §å§Ø§Ö §Ó §è§Ú§Ü§Ý§Ö §â§Ñ§Ù§Ò§Ú§Ó§Ñ§Ö§Þ §ß§Ñ §Ñ§ä§â§Ú§Ò§å§ä§í
		while (true)
		{
			// §Ú§ë§Ö§Þ §â§Ñ§Ó§ß§à
			start = _content.find('=');
			if (start == _content.npos)
			{
				mLastError = ErrorType::IncorrectAttribute;
				return false;
			}
			// §Ú§ë§Ö§Þ §Ó§ä§à§â§í§Ö §Ü§à§Ó§í§é§Ü§Ú
			end = _content.find_first_of("\"\'", start + 1);
			if (end == _content.npos)
			{
				mLastError = ErrorType::IncorrectAttribute;
				return false;
			}
			end = _content.find_first_of("\"\'", end + 1);
			if (end == _content.npos)
			{
				mLastError = ErrorType::IncorrectAttribute;
				return false;
			}

			std::string key = _content.substr(0, start);
			std::string value = _content.substr(start + 1, end - start);

			// §á§â§à§Ó§Ö§â§Ü§Ñ §ß§Ñ §Ó§Ñ§Ý§Ú§Õ§ß§à§ã§ä§î
			if (! checkPair(key, value))
			{
				mLastError = ErrorType::IncorrectAttribute;
				return false;
			}

			// §Õ§à§Ò§Ñ§Ó§Ý§ñ§Ö§Þ §á§Ñ§â§å §Ó §å§Ù§Ö§Ý
			_currentNode->addAttribute(key, value);

			// §ã§Ý§Ö§Õ§å§ð§ë§Ú§Û §Ü§å§ã§à§Ü
			_content = _content.substr(end + 1);

			// §Ó §ã§ä§â§à§Ü§Ö §ß§Ö §à§ã§ä§Ñ§Ý§à§ã§î §ã§Ú§Þ§Ó§à§Ý§à§Ó
			start = _content.find_first_not_of(" \t");
			if (start == _content.npos)
				break;

			mCol += start;
		}

		// §Ò§í§Ý §Ù§Ñ§Ü§â§í§Ó§Ñ§ð§ë§Ú§Û §ä§Ö§Ô §Õ§Ý§ñ §ä§Ö§Ü§å§ë§Ö§Ô§à §ä§Ö§Ô§Ñ
		if (close)
		{
			// §ß§Ö §á§â§à§Ó§Ö§â§ñ§Ö§Þ §Ú§Þ§Ö§ß§Ñ, §á§à§ä§à§Þ§å §é§ä§à §ï§ä§à §ß§Ñ§ê §ä§ï§Ô
			_currentNode = _currentNode->getParent();
		}

	}
	return true;
	*/

	//MyGUI::utility::trim(_content);
	content.trim();

	if (content.empty())
	{
		if (currentNode)
		{
			currentNode = currentNode->createChild("");
		}
		else
		{
			currentNode = new Element("", 0);
			if (!m_pRoot)
				m_pRoot = currentNode;
		}
		return true;
	}

	c8 simbol = content[0];
	bool tagDeclaration = false;

	if (simbol == '!')
	{
		if (currentNode != 0)
		{
			//_currentNode->createChild("", _content, ElementType::Comment);
		}
		return true;
	}
	else if (simbol == '?')
	{
		tagDeclaration = true;
		content.erase(0, 1);
	}

	size_t start = 0;
	size_t end = 0;
	if (simbol == '/')
	{
		if (currentNode == 0)
		{
			if (!mRoot)
			{
				m_lastError = ErrorType::CloseNotOpenedElement;
				return false;
			}
		}
		start = content.find_first_not_of(" \t", 1);
		if (start == content.npos)
		{
			content.clear();
		}
		else
		{
			end = content.find_last_not_of(" \t");
			content = content.substr(start, end - start + 1);
		}
		if (currentNode->getName() != content)
		{
			m_lastError = ErrorType::InconsistentOpenCloseElements;
			return false;
		}
		currentNode = currentNode->getParent();
	}
	else
	{
		core::stringc cut = content;
		start = _content.find_first_of(" \t/?", 1);
		if (start != _content.npos)
		{
			cut = content.substr(0, start);
			content = content.substr(start);
		}
		else
		{
			content.clear();
		}

		if (currentNode)
		{
			currentNode = currentNode->createChild(cut);
		}
		else
		{
			if (tagDeclaration)
			{
				if (mDeclaration)
				{
					m_lastError = ErrorType::MoreThanOneXMLDeclaration;
					return false;
				}
				currentNode = new Element(cut, 0, ElementType::Declaration);
				m_pDeclaration = currentNode;
			}
			else
			{
				if (m_pRoot)
				{
					m_lastError = ErrorType::MoreThanOneRootElement;
					return false;
				}
				currentNode = new Element(cut, 0, ElementType::Normal);
				m_pRoot = currentNode;
			}
		}

		start = content.findFirstCharNotInList(" \t",3);
		if (start == content.npos)
			return true;

		bool close = false;
		if ((content[start] == '/') || (content[start] == '?'))
		{
			close = true;
			content[start] = ' ';
			start = _content.find_last_not_of(" \t");
			if (start == _content.npos)
			{
				currentNode = currentNode->getParent();
				return true;
			}
		}

		while (true)
		{
			start = _content.find('=');
			if (start == _content.npos)
			{
				m_lastError = ErrorType::IncorrectAttribute;
				return false;
			}
			end = content.find("\"\'", start + 1);
			if (end == _content.npos)
			{
				m_lastError = ErrorType::IncorrectAttribute;
				return false;
			}
			end = content.find("\"\'", end + 1);
			if (end == _content.npos)
			{
				m_lastError = ErrorType::IncorrectAttribute;
				return false;
			}

			core::stringc key = content.subString(0, start);
			core::stringc value = content.subString(start + 1, end - start);

			if (! checkPair(key, value))
			{
				m_lastError = ErrorType::IncorrectAttribute;
				return false;
			}

			currentNode->addAttribute(key, value);

			content = content.substr(end + 1);

			start = content.findFirstCharNotInList(" \t");
			if (start == _content.npos)
				break;

			mCol += start;
		}

		if (close)
		{
			currentNode = currentNode->getParent();
		}

	}
	return true;
}

bool Document::checkPair(core::string& key, core::string& value)
{
	// §Ó §Ü§Ý§ð§é§Ö §ß§Ö §Õ§à§Ý§Ø§ß§à §Ò§í§ä§î §Ü§à§Ó§í§é§Ö§Ü §Ú §á§â§à§Ò§Ö§Ý§à§Ó
	MyGUI::utility::trim(_key);
	if (_key.empty())
		return false;
	size_t start = _key.find_first_of(" \t\"\'&");
	if (start != _key.npos)
		return false;

	// §Ó §Ù§ß§Ñ§é§Ö§ß§Ú§Ú, §Ü§à§Ó§í§é§Ü§Ú §á§à §Ò§à§Ü§Ñ§Þ
	MyGUI::utility::trim(_value);
	if (_value.size() < 2)
		return false;
	if (((_value[0] != '"') || (_value[_value.length() - 1] != '"')) &&
		((_value[0] != '\'') || (_value[_value.length() - 1] != '\'')))
		return false;
	bool ok = true;
	_value = utility::convert_from_xml(_value.substr(1, _value.length() - 2), ok);
	return ok;
}

s32 Document::find(const core::stringc& text, c8 c, u32 start)
{
	//kind of value
	bool kov = false;

	c8 buff[16] = "\"_\0";
	buff[1] = c;

	//size_t pos = _start;
	s32 pos = (s32)start;

	while (true)
	{
		//pos = _text.find_first_of(buff, pos);
		pos=text.findFirstChar(buff,(u32)pos);

		//if (pos == _text.npos)
		if(pos==-1)
		{
			break;
		}
		//TODO Èç´ËÅÐ¶Ï£¬Èç¹ûvalueÖÐÊ¹ÓÃÁËË«ÒýºÅÊÇ·ñÓÐÎÊÌâ£¿
		else if (text[pos] == '"')
		{
			kov = !kov;
			++pos;
		}
		//ËÑµ½c²ÎÊýÖ¸¶¨µÄ×Ö·û
		//Ó¦¸ÃÊÇÖ¸½áÊøË«ÒýºÅºóµ÷¹ýÒ»¸ö¿Õ¸ñ
		else if (kov)
		{
			++pos;
		}
		else
		{
			break;
		}
	}

	return pos;
}

void Document::clearDeclaration()
{
	if (m_pDeclaration)
	{
		delete m_pDeclaration;
		m_pDeclaration = NULL;
	}
}

void Document::clearRoot()
{
	if (m_pRoot)
	{
		delete m_pRoot;
		m_pRoot = NULL;
	}
}

Element* Document::createDeclaration(const core::stringc& version, const core::stringc& encoding)
{
	clearDeclaration();
	m_pDeclaration = new Element("xml", NULL, ElementType::Declaration);
	m_pDeclaration->addAttribute("version", version);
	m_pDeclaration->addAttribute("encoding", encoding);
	return m_pDeclaration;
}

Element* Document::createRoot(const core::stringc& name)
{
	clearRoot();
	m_pRoot = new Element(name, 0, ElementType::Normal);
	return m_pRoot;
}

bool Document::parseLine(core::stringc& line, Element*& element)
{
	while (true)
	{
		/*
		size_t start = find(_line, '<');
		if (start == _line.npos)
			break;
		size_t end = _line.npos;

		if ((start + 3 < _line.size()) && (_line[start + 1] == '!') && (_line[start + 2] == '-') && (_line[start + 3] == '-'))
		{
			end = _line.find("-->", start + 4);
			if (end == _line.npos)
				break;
			end += 2;
		}
		else
		{
			end = find(_line, '>', start + 1);
			if (end == _line.npos)
				break;
		}
		size_t body = _line.find_first_not_of(" \t<");
		if (body < start)
		{
			std::string body_str = _line.substr(0, start);
			mCol = 0;

			if (_element != 0)
			{
				bool ok = true;
				_element->setContent(utility::convert_from_xml(body_str, ok));
				if (!ok)
				{
					mLastError = ErrorType::IncorrectContent;
					return false;
				}
			}
		}
		if (!parseTag(_element, _line.substr(start + 1, end - start - 1)))
		{
			return false;
		}
		_line = _line.substr(end + 1);
		*/

		s32 start=find(line, '<');
		if(start==-1)
			break;
		s32 end=-1;
		//ÓÐ¿ÉÄÜÊÇ×¢ÊÍ
		if ((start + 3 < line.length()) && (line[start + 1] == '!') && (line[start + 2] == '-') && (line[start + 3] == '-'))
		{
			end = line.find("-->", start + 4);
			if (end == -1)
				break;
			end += 2;
		}
		else
		{
			end = find(line, '>', start + 1);
			if (end == -1)
				break;
		}

		s32 body = line.findFirstCharNotInList(" \t<");
		if (body < start)
		{
			core::stringc body_str = line.subString(0, start);
			m_uColumn = 0;

			if (element != 0)
			{
				bool ok = true;
				element->setContent(utility::convert_from_xml(body_str, ok));
				if (!ok)
				{
					m_lastError = ErrorType::IncorrectContent;
					return false;
				}
			}
		}
		if (!parseTag(element, line.subString(start + 1, end - start - 1)))
		{
			return false;
		}
		line = line.subString(end + 1);
	}
	return true;
}

core::stringc Document::getLastError()
{
	const core::stringc& error = m_lastError.print();
	if (error.empty())
		return error;
	//return MyGUI::utility::toString("'", error, "' ,  file='", mLastErrorFile, "' ,  line=", mLine, " ,  col=", mCol);
	return core::stringc("Error:%s in file:%s(%d,%d)",error.c_str(),m_lastErrorFile.c_str(),m_uLine,m_uColumn);
}

/*bool Document::open(const UString& _filename)
{
	return open(_filename.asWStr());
}

bool Document::save(const UString& _filename)
{
	return save(_filename.asWStr());
}*/

void Document::clearLastError()
{
	m_lastError = ErrorType::COUNT;
}

Element* Document::getRoot() const
{
	return m_pRoot;
}

void Document::setLastFileError(const core::stringc& filename)
{
	m_lastErrorFile = filename;
}

/*void Document::setLastFileError(const std::wstring& _filename)
{
	mLastErrorFile = UString(_filename).asUTF8();
}*/

}
}