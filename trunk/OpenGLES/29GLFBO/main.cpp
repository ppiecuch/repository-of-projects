#include <GL/glut.h>
// in order to get function prototypes from glext.h, define GL_GLEXT_PROTOTYPES before including glext.h
#define GL_GLEXT_PROTOTYPES
#include "glext.h"
#include "glInfo.h"
#include <iostream>
#include <sstream>
#include <string>

#include "teapot.h"
#include "FPSCounter.h"
#include <string.h>
#include <stdio.h>
#pragma comment(lib,"utility.lib")
FPSCounter fpsCounter;
GLdouble angle = 0;//Ðý×ª½Ç¶È

const int SCREEN_WIDTH = 640;
const int SCREEN_HEIGHT = 480;
const int TEXTURE_WIDTH = 256;
const int TEXTURE_HEIGHT = 256;
bool mouseLeftDown;
bool mouseRightDown;
float mouseX, mouseY;
float cameraAngleX;
float cameraAngleY;
float cameraDistance;
int drawMode = 0;
GLuint fboId;                       // ID of FBO
GLuint textureId;                   // ID of texture
GLuint rboId;                       // ID of Renderbuffer object
bool fboSupported;
bool fboUsed;

using namespace std;

// function pointers for FBO extension
// Windows needs to get function pointers from ICD OpenGL drivers,
// because opengl32.dll does not support extensions higher than v1.1.
#ifdef _WIN32
// Framebuffer object
PFNGLGENFRAMEBUFFERSEXTPROC                     pglGenFramebuffersEXT = 0;                      // FBO name generation procedure
PFNGLDELETEFRAMEBUFFERSEXTPROC                  pglDeleteFramebuffersEXT = 0;                   // FBO deletion procedure
PFNGLBINDFRAMEBUFFEREXTPROC                     pglBindFramebufferEXT = 0;                      // FBO bind procedure
PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC              pglCheckFramebufferStatusEXT = 0;               // FBO completeness test procedure
PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC pglGetFramebufferAttachmentParameterivEXT = 0;  // return various FBO parameters
PFNGLGENERATEMIPMAPEXTPROC                      pglGenerateMipmapEXT = 0;                       // FBO automatic mipmap generation procedure
PFNGLFRAMEBUFFERTEXTURE2DEXTPROC                pglFramebufferTexture2DEXT = 0;                 // FBO texdture attachement procedure
PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC             pglFramebufferRenderbufferEXT = 0;              // FBO renderbuffer attachement procedure
// Renderbuffer object
PFNGLGENRENDERBUFFERSEXTPROC                    pglGenRenderbuffersEXT = 0;                     // renderbuffer generation procedure
PFNGLDELETERENDERBUFFERSEXTPROC                 pglDeleteRenderbuffersEXT = 0;                  // renderbuffer deletion procedure
PFNGLBINDRENDERBUFFEREXTPROC                    pglBindRenderbufferEXT = 0;                     // renderbuffer bind procedure
PFNGLRENDERBUFFERSTORAGEEXTPROC                 pglRenderbufferStorageEXT = 0;                  // renderbuffer memory allocation procedure
PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC          pglGetRenderbufferParameterivEXT = 0;           // return various renderbuffer parameters
PFNGLISRENDERBUFFEREXTPROC                      pglIsRenderbufferEXT = 0;                       // determine renderbuffer object type

#define glGenFramebuffersEXT                        pglGenFramebuffersEXT
#define glDeleteFramebuffersEXT                     pglDeleteFramebuffersEXT
#define glBindFramebufferEXT                        pglBindFramebufferEXT
#define glCheckFramebufferStatusEXT                 pglCheckFramebufferStatusEXT
#define glGetFramebufferAttachmentParameterivEXT    pglGetFramebufferAttachmentParameterivEXT
#define glGenerateMipmapEXT                         pglGenerateMipmapEXT
#define glFramebufferTexture2DEXT                   pglFramebufferTexture2DEXT
#define glFramebufferRenderbufferEXT                pglFramebufferRenderbufferEXT

#define glGenRenderbuffersEXT                       pglGenRenderbuffersEXT
#define glDeleteRenderbuffersEXT                    pglDeleteRenderbuffersEXT
#define glBindRenderbufferEXT                       pglBindRenderbufferEXT
#define glRenderbufferStorageEXT                    pglRenderbufferStorageEXT
#define glGetRenderbufferParameterivEXT             pglGetRenderbufferParameterivEXT
#define glIsRenderbufferEXT                         pglIsRenderbufferEXT

#endif

void initLights();
void setCamera(float posX, float posY, float posZ, float targetX, float targetY, float targetZ);
bool checkFramebufferStatus();
void printFramebufferInfo();

void printFPS(){
	//Update frames per second counter
	fpsCounter.update();

	//Print fps
	static char fpsString[32];
	sprintf_s(fpsString, "FPS:%.2f", fpsCounter.getFPS());

	//Set matrices for ortho
	glMatrixMode(GL_PROJECTION);
	glPushMatrix();
	glLoadIdentity();
	gluOrtho2D(-1.0f, 1.0f, -1.0f, 1.0f);

	glMatrixMode(GL_MODELVIEW);
	glPushMatrix();
	glLoadIdentity();

	//Print text
	glRasterPos2f(-1.0f, 0.9f);
	for(unsigned int i=0; i<strlen(fpsString); ++i)
		glutBitmapCharacter(GLUT_BITMAP_HELVETICA_18, fpsString[i]);

	//reset matrices
	glMatrixMode(GL_PROJECTION);
	glPopMatrix();
	glMatrixMode(GL_MODELVIEW);
	glPopMatrix();
}
///////////////////////////////////////////////////////////////////////////////
// draw a textured cube
///////////////////////////////////////////////////////////////////////////////
void draw()
{
	glBindTexture(GL_TEXTURE_2D, textureId);

	glBegin(GL_QUADS);
	glColor4f(1, 1, 1, 1);

	// face v0-v1-v2-v3
	glNormal3f(0,0,1);
	glTexCoord2f(1, 1);  glVertex3f(1,1,1);
	glTexCoord2f(0, 1);  glVertex3f(-1,1,1);
	glTexCoord2f(0, 0);  glVertex3f(-1,-1,1);
	glTexCoord2f(1, 0);  glVertex3f(1,-1,1);

	// face v0-v3-v4-v5
	glNormal3f(1,0,0);
	glTexCoord2f(0, 1);  glVertex3f(1,1,1);
	glTexCoord2f(0, 0);  glVertex3f(1,-1,1);
	glTexCoord2f(1, 0);  glVertex3f(1,-1,-1);
	glTexCoord2f(1, 1);  glVertex3f(1,1,-1);

	// face v0-v5-v6-v1
	glNormal3f(0,1,0);
	glTexCoord2f(1, 0);  glVertex3f(1,1,1);
	glTexCoord2f(1, 1);  glVertex3f(1,1,-1);
	glTexCoord2f(0, 1);  glVertex3f(-1,1,-1);
	glTexCoord2f(0, 0);  glVertex3f(-1,1,1);

	// face  v1-v6-v7-v2
	glNormal3f(-1,0,0);
	glTexCoord2f(1, 1);  glVertex3f(-1,1,1);
	glTexCoord2f(0, 1);  glVertex3f(-1,1,-1);
	glTexCoord2f(0, 0);  glVertex3f(-1,-1,-1);
	glTexCoord2f(1, 0);  glVertex3f(-1,-1,1);

	// face v7-v4-v3-v2
	glNormal3f(0,-1,0);
	glTexCoord2f(0, 0);  glVertex3f(-1,-1,-1);
	glTexCoord2f(1, 0);  glVertex3f(1,-1,-1);
	glTexCoord2f(1, 1);  glVertex3f(1,-1,1);
	glTexCoord2f(0, 1);  glVertex3f(-1,-1,1);

	// face v4-v7-v6-v5
	glNormal3f(0,0,-1);
	glTexCoord2f(0, 0);  glVertex3f(1,-1,-1);
	glTexCoord2f(1, 0);  glVertex3f(-1,-1,-1);
	glTexCoord2f(1, 1);  glVertex3f(-1,1,-1);
	glTexCoord2f(0, 1);  glVertex3f(1,1,-1);
	glEnd();

	glBindTexture(GL_TEXTURE_2D, 0);
}
int a=0;
void display(void) { 
	// adjust viewport and projection matrix to texture dimension
	//glViewport(0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT);
	glEnable(GL_SCISSOR_TEST);
	if(++a%200==0)
	{
		glScissor(TEXTURE_WIDTH/2, TEXTURE_HEIGHT/2, TEXTURE_WIDTH/2, TEXTURE_HEIGHT/2);
		glViewport(TEXTURE_WIDTH/2, TEXTURE_HEIGHT/2, TEXTURE_WIDTH/2, TEXTURE_HEIGHT/2);
	}
	else
	{
		glScissor(0,0,TEXTURE_WIDTH/2, TEXTURE_HEIGHT/2);
		glViewport(0, 0, TEXTURE_WIDTH/2, TEXTURE_HEIGHT/2);
	}

	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(60.0f, (float)(TEXTURE_WIDTH)/TEXTURE_HEIGHT, 1.0f, 100.0f);
	glMatrixMode(GL_MODELVIEW);

	// with FBO
	// render directly to a texture
	if(fboUsed)
	{
		// set the rendering destination to FBO
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, fboId);

		// clear buffer
		glClearColor(1, 1, 1, 0);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		// draw a rotating teapot
		glPushMatrix();
		glRotatef(angle*0.5f, 1, 0, 0);
		glRotatef(angle, 0, 1, 0);
		glRotatef(angle*0.7f, 0, 0, 1);
		glTranslatef(0, -1.575f, 0);
		drawTeapot();
		glPopMatrix();

		// back to normal window-system-provided framebuffer
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0); // unbind

		// trigger mipmaps generation explicitly
		// NOTE: If GL_GENERATE_MIPMAP is set to GL_TRUE, then glCopyTexSubImage2D()
		// triggers mipmap generation automatically. However, the texture attached
		// onto a FBO should generate mipmaps manually via glGenerateMipmapEXT().
		glBindTexture(GL_TEXTURE_2D, textureId);
		glGenerateMipmapEXT(GL_TEXTURE_2D);
		glBindTexture(GL_TEXTURE_2D, 0);
	}

	// without FBO
	// render to the backbuffer and copy the backbuffer to a texture
	else
	{
		// clear buffer
		glClearColor(0,0,0,0);
		glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);

		glPushAttrib(GL_COLOR_BUFFER_BIT | GL_PIXEL_MODE_BIT); // for GL_DRAW_BUFFER and GL_READ_BUFFER
		glDrawBuffer(GL_BACK);
		glReadBuffer(GL_BACK);

		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);
		glEnable(GL_ALPHA_TEST);

		// draw a rotating teapot
		glPushMatrix();
		glRotatef(angle*0.5f, 1, 0, 0);
		glRotatef(angle, 0, 1, 0);
		glRotatef(angle*0.7f, 0, 0, 1);
		glTranslatef(0, -1.575f, 0);
		drawTeapot();
		glPopMatrix();

		// copy the framebuffer pixels to a texture
		glBindTexture(GL_TEXTURE_2D, textureId);
		glCopyTexSubImage2D(GL_TEXTURE_2D, 0, 0, 0, 0, 0, TEXTURE_WIDTH, TEXTURE_HEIGHT);
		glBindTexture(GL_TEXTURE_2D, 0);

		glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);
		glDisable(GL_ALPHA_TEST);

		glPopAttrib(); // GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT
	}

	// back to normal viewport and projection matrix
	//glViewport(-96, -96, SCREEN_WIDTH-96, SCREEN_HEIGHT-96);
	glDisable(GL_SCISSOR_TEST);
	glViewport(0, 0, SCREEN_WIDTH, SCREEN_HEIGHT);
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	gluPerspective(60.0f, (float)(SCREEN_WIDTH)/SCREEN_HEIGHT, 1.0f, 100.0f);
	glMatrixMode(GL_MODELVIEW);

	// clear framebuffer
	glClearColor(0.5f,0.5f,0.5f,0);
	glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

	glPushMatrix();

	// tramsform camera
	glTranslatef(0, 0, cameraDistance);
	glRotatef(cameraAngleX, 1, 0, 0);   // pitch
	glRotatef(cameraAngleY, 0, 1, 0);   // heading

	// draw a cube with the dynamic texture
	draw();

	glPopMatrix();

	printFPS();

	angle+=0.5f;

	glutSwapBuffers();
}
void init()
{
	

	mouseLeftDown = mouseRightDown = false;
	cameraAngleX = cameraAngleY = 45;
	cameraDistance = 0;

	glShadeModel(GL_SMOOTH);                    // shading mathod: GL_SMOOTH or GL_FLAT
	glPixelStorei(GL_UNPACK_ALIGNMENT, 4);      // 4-byte pixel alignment

	// enable /disable features
	glHint(GL_PERSPECTIVE_CORRECTION_HINT, GL_NICEST);
	//glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
	//glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);
	glEnable(GL_DEPTH_TEST);
	glEnable(GL_LIGHTING);
	glEnable(GL_TEXTURE_2D);
	glEnable(GL_CULL_FACE);

	// track material ambient and diffuse from surface color, call it before glEnable(GL_COLOR_MATERIAL)
	glColorMaterial(GL_FRONT_AND_BACK, GL_AMBIENT_AND_DIFFUSE);
	glEnable(GL_COLOR_MATERIAL);

	glClearColor(0, 0, 0, 0);                   // background color
	glClearStencil(0);                          // clear stencil buffer
	glClearDepth(1.0f);                         // 0 is near, 1 is far
	glDepthFunc(GL_LEQUAL);

	initLights();
	setCamera(0, 0, 6, 0, 0, 0);

	glGenTextures(1, &textureId);
	glBindTexture(GL_TEXTURE_2D, textureId);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
	glTexParameterf(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
	glTexParameteri(GL_TEXTURE_2D, GL_GENERATE_MIPMAP, GL_TRUE); // automatic mipmap generation included in OpenGL v1.4
	glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, TEXTURE_WIDTH, TEXTURE_HEIGHT, 0, GL_RGBA, GL_UNSIGNED_BYTE, 0);
	glBindTexture(GL_TEXTURE_2D, 0);

	bool ScissorTest=glIsEnabled(GL_SCISSOR_TEST)==GL_TRUE;
	printf("ScissorTest:%d\n",ScissorTest);
	glEnable(GL_SCISSOR_TEST);
	ScissorTest=glIsEnabled(GL_SCISSOR_TEST)==GL_TRUE;
	printf("ScissorTest:%d\n",ScissorTest);
	//glScissor(16,16,512,256);

	// get OpenGL info
	glInfo glInfo;
	glInfo.getInfo();
	glInfo.printSelf();

#ifdef _WIN32
	// check if FBO is supported by your video card
	if(glInfo.isExtensionSupported("GL_EXT_framebuffer_object"))
	{
		// get pointers to GL functions
		glGenFramebuffersEXT                     = (PFNGLGENFRAMEBUFFERSEXTPROC)wglGetProcAddress("glGenFramebuffersEXT");
		glDeleteFramebuffersEXT                  = (PFNGLDELETEFRAMEBUFFERSEXTPROC)wglGetProcAddress("glDeleteFramebuffersEXT");
		glBindFramebufferEXT                     = (PFNGLBINDFRAMEBUFFEREXTPROC)wglGetProcAddress("glBindFramebufferEXT");
		glCheckFramebufferStatusEXT              = (PFNGLCHECKFRAMEBUFFERSTATUSEXTPROC)wglGetProcAddress("glCheckFramebufferStatusEXT");
		glGetFramebufferAttachmentParameterivEXT = (PFNGLGETFRAMEBUFFERATTACHMENTPARAMETERIVEXTPROC)wglGetProcAddress("glGetFramebufferAttachmentParameterivEXT");
		glGenerateMipmapEXT                      = (PFNGLGENERATEMIPMAPEXTPROC)wglGetProcAddress("glGenerateMipmapEXT");
		glFramebufferTexture2DEXT                = (PFNGLFRAMEBUFFERTEXTURE2DEXTPROC)wglGetProcAddress("glFramebufferTexture2DEXT");
		glFramebufferRenderbufferEXT             = (PFNGLFRAMEBUFFERRENDERBUFFEREXTPROC)wglGetProcAddress("glFramebufferRenderbufferEXT");
		glGenRenderbuffersEXT                    = (PFNGLGENRENDERBUFFERSEXTPROC)wglGetProcAddress("glGenRenderbuffersEXT");
		glDeleteRenderbuffersEXT                 = (PFNGLDELETERENDERBUFFERSEXTPROC)wglGetProcAddress("glDeleteRenderbuffersEXT");
		glBindRenderbufferEXT                    = (PFNGLBINDRENDERBUFFEREXTPROC)wglGetProcAddress("glBindRenderbufferEXT");
		glRenderbufferStorageEXT                 = (PFNGLRENDERBUFFERSTORAGEEXTPROC)wglGetProcAddress("glRenderbufferStorageEXT");
		glGetRenderbufferParameterivEXT          = (PFNGLGETRENDERBUFFERPARAMETERIVEXTPROC)wglGetProcAddress("glGetRenderbufferParameterivEXT");
		glIsRenderbufferEXT                      = (PFNGLISRENDERBUFFEREXTPROC)wglGetProcAddress("glIsRenderbufferEXT");

		// check once again FBO extension
		if(glGenFramebuffersEXT && glDeleteFramebuffersEXT && glBindFramebufferEXT && glCheckFramebufferStatusEXT &&
			glGetFramebufferAttachmentParameterivEXT && glGenerateMipmapEXT && glFramebufferTexture2DEXT && glFramebufferRenderbufferEXT &&
			glGenRenderbuffersEXT && glDeleteRenderbuffersEXT && glBindRenderbufferEXT && glRenderbufferStorageEXT &&
			glGetRenderbufferParameterivEXT && glIsRenderbufferEXT)
		{
			fboSupported = fboUsed = true;
			cout << "Video card supports GL_EXT_framebuffer_object." << endl;
		}
		else
		{
			fboSupported = fboUsed = false;
			cout << "Video card does NOT support GL_EXT_framebuffer_object." << endl;
		}
	}

#else // for linux, do not need to get function pointers, it is up-to-date
	if(glInfo.isExtensionSupported("GL_EXT_framebuffer_object"))
	{
		fboSupported = fboUsed = true;
		cout << "Video card supports GL_EXT_framebuffer_object." << endl;
	}
	else
	{
		fboSupported = fboUsed = false;
		cout << "Video card does NOT support GL_EXT_framebuffer_object." << endl;
	}
#endif

	

	if(fboSupported)
	{
		//´´½¨Ò»¸öFBOÈÝÆ÷
		glGenFramebuffersEXT(1,&fboId);
		//glBindFramebufferEXT¿ÉÒÔÓÃÓÚFBOÖ®¼ä½øÐÐÇÐ»»£¬°ó¶¨µ½Ãû³Æ0½«»á½â³ýµ±Ç°°ó¶¨µÄFBO£¬²¢°ÑäÖÈ¾ÖØÐÂ¶¨Ïòµ½´°¿ÚµÄÖ¡»º³åÇø
		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT,fboId);

		//´´½¨Ò»¸öRBO¶ÔÏóÓÃÓÚ´æ´¢Éî¶ÈÐÅÏ¢
		//×¢Òâ£ºFBO±ØÐë¹Ò½ÓÒ»ÕÅ´æ·ÅÉî¶ÈÐÅÏ¢µÄÍ¼Ïñ£¬·ñÔòÒòÎªÉî¶È²âÊÔµÄÈ±Ê§»áµ¼ÖÂÊä³ö½á¹û´íÂÒ
		//Èç¹ûÄãÍ¬Ê±ÐèÒªÄ£°å²âÊÔ£¬ÄÇÃ´FBO»¹ÐèÒª¹Ò½ÓÒ»¸öÓÃÓÚ´æ·ÅÄ£°åÐÅÏ¢µÄÍ¼Ïñ
		glGenRenderbuffersEXT(1,&rboId);
		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT,rboId);
		glRenderbufferStorageEXT(GL_RENDERBUFFER_EXT,GL_DEPTH_COMPONENT,TEXTURE_WIDTH,TEXTURE_HEIGHT);
		glBindRenderbufferEXT(GL_RENDERBUFFER_EXT,0);//ÎªÊ²Ã´ÐèÒªÕâ¸ö£¿

		//¹Ò½ÓÒ»ÕÅÎÆÀí
		glFramebufferTexture2DEXT(GL_FRAMEBUFFER_EXT,GL_COLOR_ATTACHMENT0_EXT,GL_TEXTURE_2D,textureId,0);

		//¹Ò½ÓRBO
		glFramebufferRenderbufferEXT(GL_FRAMEBUFFER_EXT,GL_DEPTH_ATTACHMENT_EXT,GL_RENDERBUFFER_EXT,rboId);

		//@ disable color buffer if you don't attach any color buffer image,
		//@ for example, rendering depth buffer only to a texture.
		//@ Otherwise, glCheckFramebufferStatusEXT will not be complete.
		//glDrawBuffer(GL_NONE);
		//glReadBuffer(GL_NONE);

		// check FBO status
		printFramebufferInfo();
		bool status = checkFramebufferStatus();
		if(!status)
			fboUsed = false;

		glBindFramebufferEXT(GL_FRAMEBUFFER_EXT, 0);
	}
}
void resize(int width,int height)
{
}
void idle()
{
	//glutPostRedisplay ±ê¼Çµ±Ç°´°¿ÚÐèÒªÖØÐÂ»æÖÆ¡£Í¨¹ýglutMainLoopÏÂÒ»´ÎÑ­»·Ê±£¬´°¿ÚÏÔÊ¾½«±»»Øµ÷ÒÔÖØÐÂÏÔÊ¾´°¿ÚµÄÕý³£Ãæ°å¡£
	//¶à´Îµ÷ÓÃglutPostRedisplay£¬ÔÚÏÂÒ»¸öÏÔÊ¾»Øµ÷Ö»²úÉúµ¥Ò»µÄÖØÐÂÏÔÊ¾»Øµ÷¡£ 
	glutPostRedisplay();
}
void key(unsigned char key, int x, int y)
{
	switch(key)
	{
	case 27: // ESCAPE
		exit(0);
		break;

	case ' ':
		if(fboSupported)
			fboUsed = !fboUsed;
		cout << "FBO mode: " << (fboUsed ? "on" : "off") << endl;
		break;

	case 'd': // switch rendering modes (fill -> wire -> point)
	case 'D':
		drawMode = ++drawMode % 3;
		if(drawMode == 0)        // fill mode
		{
			glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
			glEnable(GL_DEPTH_TEST);
			glEnable(GL_CULL_FACE);
		}
		else if(drawMode == 1)  // wireframe mode
		{
			glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
			glDisable(GL_DEPTH_TEST);
			glDisable(GL_CULL_FACE);
		}
		else                    // point mode
		{
			glPolygonMode(GL_FRONT_AND_BACK, GL_POINT);
			glDisable(GL_DEPTH_TEST);
			glDisable(GL_CULL_FACE);
		}
		break;

	default:
		;
	}
}
void mouse(int button, int state, int x, int y)
{
	mouseX = x;
	mouseY = y;

	if(button == GLUT_LEFT_BUTTON)
	{
		if(state == GLUT_DOWN)
		{
			mouseLeftDown = true;
		}
		else if(state == GLUT_UP)
			mouseLeftDown = false;
	}

	else if(button == GLUT_RIGHT_BUTTON)
	{
		if(state == GLUT_DOWN)
		{
			mouseRightDown = true;
		}
		else if(state == GLUT_UP)
			mouseRightDown = false;
	}
}
void motion(int x, int y)
{
	if(mouseLeftDown)
	{
		cameraAngleY += (x - mouseX);
		cameraAngleX += (y - mouseY);
		mouseX = x;
		mouseY = y;
	}
	if(mouseRightDown)
	{
		cameraDistance += (y - mouseY) * 0.2f;
		mouseY = y;
	}
}

void destroy()
{

	//glDeleteTextures(1, &textureId);

	// clean up FBO, RBO
	if(fboSupported)
	{
		glDeleteFramebuffersEXT(1, &fboId);
		glDeleteRenderbuffersEXT(1, &rboId);
	}

	printf("destroy");
}
int main(int argc, char **argv)
{
	atexit(destroy);
	//³õÊ¼»¯GLUT
	//Void glutInit(int*argc,char**argv)£» 
	//²ÎÊý£º 
	//Argc£ºÒ»¸öÖ¸Õë£¬Ö¸Ïò´Ómain£¨£©º¯Êý´«µÝ¹ýÀ´µÄÃ»¸ü¸ÄµÄargc±äÁ¿¡£ 
	//Argv£ºÒ»¸öÖ¸Õë£¬Ö¸Ïò´Ómain£¨£©º¯Êý´«µÝ¹ýÀ´µÄÃ»¸ü¸ÄµÄargv±äÁ¿¡£
	glutInit(&argc, argv);
	//¶¨ÒåÏÔÊ¾·½Ê½¡£ 
	//Void glutInitDisplayMode(unsighed int mode) 
	//²ÎÊý£º 
	//Mode¨D¨D¿ÉÒÔÖ¸¶¨ÏÂÁÐÏÔÊ¾Ä£Ê½ 
	//Mode²ÎÊýÊÇÒ»¸öGLUT¿âÀïÔ¤¶¨ÒåµÄ¿ÉÄÜµÄ²¼¶û×éºÏ¡£ÄãÊ¹ÓÃmodeÈ¥Ö¸¶¨ÑÕÉ«Ä£Ê½£¬ÊýÁ¿ºÍ»º³åÇøÀàÐÍ¡£ 
	//Ö¸¶¨ÑÕÉ«Ä£Ê½µÄÔ¤¶¨Òå³£Á¿ÓÐ£º 
	//1£ºGLUT_RGBA»òÕßGLUT_RGB¡£Ö¸¶¨Ò»¸öRGBA´°¿Ú£¬ÕâÊÇÒ»¸öÄ¬ÈÏµÄÑÕÉ«Ä£Ê½¡£ 
	//2£ºGLUT_INDEX¡£Ö¸¶¨ÑÕÉ«Ë÷ÒýÄ£Ê½¡£ 
	//Õâ¸öÏÔÊ¾Ä£Ê½»¹ÔÊÐíÄãÑ¡Ôñµ¥»º³åÇø»òË«»º³åÇø´°¿Ú¡£ 
	//1£ºGLUT_SINGLE.µ¥»º³åÇø´°¿Ú¡£ 
	//2£ºGLUT_BUFFER.Ë«»º³åÇø´°¿Ú£¬ÕâÊÇ²úÉúÁ÷³©¶¯»­±ØÐëÑ¡µÄ¡£ 
	//»¹¿ÉÒÔÖ¸¶¨¸ü¶à£¬Èç¹ûÄãÏëÖ¸¶¨Ò»×éÌØÊâµÄ»º³åµÄ»°£¬ÓÃÏÂÃæµÄ±äÁ¿£º 
	//1£ºGLUT_ACCUM.ÀÛ»ý»º³åÇø¡£ 
	//2£ºGLUT_STENCIL.Ä£°å»º³åÇø¡£ 
	//3£ºGLUT_DEPTH.Éî¶È»º³åÇø¡£ 
	//ÓÃ¡°»ò¡°£¨|£©²Ù×÷·ûÀ´½¨Á¢ÄãÏëÒªµÄÏÔÊ¾Ä£Ê½¡£ 
	glutInitDisplayMode(GLUT_RGB | GLUT_DOUBLE | GLUT_ALPHA);
	//È·¶¨´°¿ÚÎ»ÖÃ£¨ËüÄ¬ÈÏµÄÊÇÆÁÄ»×óÉÏ½Ç£©£¬ÎÒÃÇÊ¹ÓÃº¯ÊýglutInitWindowPosition£¨£©¡£ 
	//Void glutInitWindowPositon(int x,int y); 
	//²ÎÊý£º 
	//X: ¾àÀëÆÁÄ»×ó±ßµÄÏñËØÊý¡££­1ÊÇÄ¬ÈÏÖµ£¬ÒâË¼¾ÍÊÇÓÉ´°¿Ú¹ÜÀí³ÌÐò¾ö¶¨´°¿Ú³öÏÖÔÚÄÄÀï¡£Èç¹û²»Ê¹ÓÃÄ¬ÈÏÖµ£¬ÄÇÄã¾Í×Ô¼ºÉèÖÃÒ»¸öÖµ¡£ 
	//Y£º¾àÀëÆÁÄ»ÉÏ±ßµÄÏñËØÊý¡£ºÍXÒ»Ñù¡£ 
	//×¢Òâ£¬²ÎÊý½ö½öÊÇ¶Ô´°¿Ú¹ÜÀí³ÌÐòµÄÒ»¸ö½¨Òé¡£¾¡¹ÜÄã¾«ÐÄµÄÉèÖÃÁË´°¿ÚÎ»ÖÃ£¬window·µ»ØµÄ¿ÉÄÜÊÇ²»Í¬µÄÎ»ÖÃ¡£Èç¹ûÄãÉèÖÃÁË£¬Ò»°ã»áµÃµ½ÄãÏëÒªµÄ½á¹û¡£
	glutInitWindowPosition(100,100); 
	//ÉèÖÃ´°¿Ú´óÐ¡£¬Ê¹ÓÃº¯ÊýglutInitWindowSize£¨£©¡£ 
	//Void glutInitWindowSize(int width,int height); 
	//²ÎÊý£º 
	//Width£º´°¿ÚµÄ¿í¶È¡£ 
	//Height£º´°¿ÚµÄ¸ß¶È¡£ 
	//Í¬Ñùwidth£¬heightÒ²Ö»ÊÇÒ»¸ö²Î¿¼Êý×Ö¡£±ÜÃâÊ¹ÓÃ¸ºÊý¡£ 
	glutInitWindowSize(SCREEN_WIDTH,SCREEN_HEIGHT); 
	//µ÷ÓÃº¯ÊýglutCreateWindow()À´´´½¨´°¿Ú
	//Int glutCreateWindow(char* title); 
	//²ÎÊý£º 
	//Title£ºÉèÖÃ´°¿ÚµÄ±êÌâ¡£ 
	//glutCreateWindow£¨£©µÄ·µ»ØÖµÊÇÒ»¸ö´°¿Ú±êÊ¶·û¡£
	(void) glutCreateWindow("GL Framework");


	//¸æËßGLUTÊ¹ÓÃÎÒÃÇÉÏÃæµÄº¯ÊýÀ´½øÐÐäÖÈ¾¡£Õâ¸ö½Ð¼Ä´æ»Øµ÷¡£¡£ÈÃÎÒÃÇ¸æËßGLUTÕâ¸öº¯ÊýrenderSceneÓ¦¸Ã±»Ê¹ÓÃ¡£
	//µ±ÐèÒªÖØ»­µÄÊ±ºòGLUTÓÐÒ»¸öÖ»´«µÝÒ»¸öº¯ÊýÃû³Æ²ÎÊýµÄº¯Êý£¨ÒÔº¯ÊýÃûÎªÐÎ²ÎµÄº¯Êý£©¾Í»á±»µ÷ÓÃ¡£ 
	//void glutDisplayFunc(void (*func)(void)); 
	//²ÎÊý£º 
	//func: µ±´°¿ÚÐèÒª±»ÖØ»æÊÇµ÷ÓÃµÄº¯ÊýµÄÃû³Æ¡£×¢ÒâÊ¹ÓÃNULL×÷ÎªÊµ²ÎÊÇ´íÎóµÄ¡£
	glutDisplayFunc(display);
	//ÔÚglutIdleFunc(void (*func)(void))»Øµ÷º¯ÊýÖÐÖ¸¶¨Ò»¸öº¯Êý£¬Èç¹û²»´æÔÚÆäËûÉÐÎ´Íê³ÉµÄÊÂ¼þ£¨ÀýÈç£¬µ±ÊÂ¼þÑ­»·´¦ÓÚ¿ÕÏÐµÄÊ±ºò£©£¬¾ÍÖ´ÐÐÕâ¸öº¯Êý¡£
	//Õâ¸ö»Øµ÷º¯Êý½ÓÊÜÒ»¸öº¯ÊýÖ¸Õë×÷ÎªËüµÄÎ¨Ò»²ÎÊý¡£Èç¹ûÏòËü´«µÝNULL(0),¾ÍÏàµ±ÓÚ½ûÓÃÕâ¸öº¯Êý¡£
	glutIdleFunc(idle);
	//´°¿Ú·¢Éú±ä»¯Ê±,ÊÓ´°ÐèÒªÖØÐÂ¼ÆËã.
	//void glutReshapeFunc(void (*func)(int width, int height)); 
	//²ÎÊý: 
	//func -- The name of the function that will be responsible forsetting the correct perspective when the window changes size. 
	glutReshapeFunc(resize);
	//void glutKeyboardFunc(void (*func)(unsigned char key, int x, int y))
	// key Îª¼üÅÌ°´¼üµÄASCIIÂë
	glutKeyboardFunc(key);
	//¼ì²âÊó±êClicks
	//ºÍ¼üÅÌ´¦ÀíÒ»Ñù£¬GLUTÎªÄãµÄ×¢²áº¯Êý£¨Ò²¾ÍÊÇ´¦ÀíÊó±êclicksÊÂ¼þµÄº¯Êý£©Ìá¹©ÁËÒ»¸ö·½·¨¡£º¯ÊýglutMouseFunc,Õâ¸öº¯ÊýÒ»°ãÔÚ³ÌÐò³õÊ¼»¯½×¶Î±»µ÷ÓÃ¡£º¯ÊýÔ­ÐÍÈçÏÂ£º
	//void glutMouseFunc(void(*func)(int button,int state,int x,int y));
	//²ÎÊý£º
	//func£º´¦ÀíÊó±êclickÊÂ¼þµÄº¯ÊýµÄº¯ÊýÃû¡£
	//´ÓÉÏÃæ¿ÉÒÔ¿´µ½µ½£¬´¦ÀíÊó±êclickÊÂ¼þµÄº¯Êý£¬Ò»¶¨ÓÐ4¸ö²ÎÊý¡£
	//µÚÒ»¸ö²ÎÊý±íÃ÷ÄÄ¸öÊó±ê¼ü±»°´ÏÂ»òËÉ¿ª£¬Õâ¸ö±äÁ¿¿ÉÒÔÊÇÏÂÃæµÄÈý¸öÖµÖÐµÄÒ»¸ö£º
	//GLUT_LEFT_BUTTON
	//GLUT_MIDDLE_BUTTON
	//GLUT_RIGHT_BUTTON
	//µÚ¶þ¸ö²ÎÊý±íÃ÷£¬º¯Êý±»µ÷ÓÃ·¢ÉúÊ±£¬Êó±êµÄ×´Ì¬£¬Ò²¾ÍÊÇÊÇ±»°´ÏÂ£¬»òËÉ¿ª£¬¿ÉÄÜÈ¡ÖµÈçÏÂ£º
	//GLUT_DOWN
	//GLUT_UP
	//µ±º¯Êý±»µ÷ÓÃÊ±£¬stateµÄÖµÊÇGLUT_DOWN£¬ÄÇÃ´³ÌÐò¿ÉÄÜ»á¼Ù¶¨½«»áÓÐ¸öGLUT_UPÊÂ¼þ£¬ÉõÖÁÊó±êÒÆ¶¯µ½´°¿ÚÍâÃæ£¬Ò²Èç´Ë¡£
	//È»¶ø£¬Èç¹û³ÌÐòµ÷ÓÃglutMouseFunc´«µÝNULL×÷Îª²ÎÊý£¬ÄÇÃ´GLUT½«²»»á¸Ä±äÊó±êµÄ×´Ì¬¡£
	//Ê£ÏÂµÄÁ½¸ö²ÎÊý£¨x,y£©Ìá¹©ÁËÊó±êµ±Ç°µÄ´°¿Ú×ø±ê£¨ÒÔ×óÉÏ½ÇÎªÔ­µã£©¡£
	glutMouseFunc(mouse);
	//¼ì²â¶¯×÷£¨motion£©
	//GLUTÌá¹©Êó±êmotion¼ì²âÄÜÁ¦¡£ÓÐÁ½ÖÖGLUT´¦ÀíµÄmotion£ºactive motionºÍpassive motion¡£
	//Active motionÊÇÖ¸Êó±êÒÆ¶¯²¢ÇÒÓÐÒ»¸öÊó±ê¼ü±»°´ÏÂ¡££¨ÍÏ¶¯Êó±ê£©
	//Passive motionÊÇÖ¸µ±Êó±êÒÆ¶¯Ê±£¬²¢ÓÐÃ»Êó±ê¼ü°´ÏÂ¡££¨ÒÆ¶¯Êó±ê£©
	//Èç¹ûÒ»¸ö³ÌÐòÕýÔÚ×·×ÙÊó±ê£¬ÄÇÃ´Êó±êÒÆ¶¯ÆÚ¼ä£¬Ã»Ò»Ö¡½«²úÉúÒ»¸ö½á¹û¡£
	//ºÍÒÔÇ°Ò»Ñù£¬Äã±ØÐë×¢²á½«´¦ÀíÊó±êÊÂ¼þµÄº¯Êý£¨¶¨Òåº¯Êý£©¡£GLUTÈÃÎÒÃÇ¿ÉÒÔÖ¸¶¨Á½¸ö²»Í¬µÄº¯Êý£¬Ò»¸ö×·×Ùpassive motion£¬ÁíÒ»¸ö×·×Ùactive motion
	//ËüÃÇµÄº¯ÊýÔ­ÐÍ£¬ÈçÏÂ£º
	//void glutMotionFunc(void(*func)(int x,int y));
	//void glutPassiveMotionFunc(void (*func)(int x,int y));
	//²ÎÊý£º
	//Func£º´¦Àí¸÷×ÔÀàÐÍmotionµÄº¯ÊýÃû¡£
	//´¦ÀímotionµÄ²ÎÊýº¯ÊýµÄ²ÎÊý£¨x,y£©ÊÇÊó±êÔÚ´°¿ÚµÄ×ø±ê¡£ÒÔ×óÉÏ½ÇÎªÔ­µã¡£
	glutMotionFunc(motion);

	init();

	//¼ì²âÊó±ê½øÈë»òÀë¿ª´°¿Ú
	//GLUT»¹ÄÜ¼ì²âÊó±êÊó±êÀë¿ª£¬½øÈë´°¿ÚÇøÓò¡£Ò»¸ö»Øµ÷º¯Êý¿ÉÒÔ±»¶¨ÒåÈ¥´¦ÀíÕâÁ½¸öÊÂ¼þ¡£GLUTÀï£¬µ÷ÓÃÕâ¸öº¯ÊýµÄÊÇglutEntryFunc,º¯ÊýÔ­ÐÍÈçÏÂ£º
	//void glutEntryFunc(void(*func)£¨int state£©);
	//²ÎÊý£º
	//Func£º´¦ÀíÕâÐ©ÊÂ¼þµÄº¯ÊýÃû¡£
	//ÉÏÃæº¯ÊýµÄ²ÎÊýÖÐ£¬stateÓÐÁ½¸öÖµ£º
	//GLUT_LEFT      Êó±êÀë¿ª´°¿Ú
	//GLUT_ENTERED  Êó±ê½øÈë´°¿Ú
	//±íÃ÷£¬ÊÇÀë¿ª£¬»¹ÊÇ½øÈë´°¿Ú¡£
	//glutEntryFunc(entry);
	//glutVisibilityFunc(vis);
	//glutCreateMenu(menu);
	//glutAddMenuEntry("Toggle showing projection", 's');
	//glutAddMenuEntry("Switch texture", 't');
	//glutAddMenuEntry("Switch object", 'o');
	//glutAddMenuEntry("Toggle filtering", 'l');
	//glutAddMenuEntry("Quit", 666);
	//glutAttachMenu(GLUT_RIGHT_BUTTON);
	//Èç¹ûÓÃ¶¨Ê±Æ÷µÄ»°£¬³õÊ¼µÄÊ±ºò×¢²áÒ»¸ö¶¨Ê±Æ÷µÄ»Øµ÷º¯Êý£¬Ô­ÐÍÊÇ
	//glutTimerFunc(unsigned int millis, void (*func)(int value), int value);
	//ÕâÑùÊ¹ÓÃglutTimerFunc(ºÁÃëÊý, »Øµ÷º¯ÊýÖ¸Õë, Çø±ðÖµ);
	//Ð´×Ô¼ºµÄ»Øµ÷º¯Êý
	//void OnTimer(int value);
	//ÓÃvalueÇø·ÖÊÇÄÄ¸ö¶¨Ê±Æ÷
	//ÔÚº¯ÊýÀï¸Ä±äºÍÎ»ÖÃÓÐ¹ØµÄ±äÁ¿£¬È»ºóµ÷ÓÃglutPostRedisplay();ÓÃÀ´ÖØ»æ
	//×îºóÔÙ´Îµ÷ÓÃglutTimerFunc£¬ÒòÎªglutµÄ¶¨Ê±Æ÷ÊÇµ÷ÓÃÒ»´Î²Å²úÉúÒ»´Î¶¨Ê±£¬ËùÒÔÈç¹ûÒª³ÖÐø²úÉú¶¨Ê±µÄ»°£¬ÔÚ¶¨Ê±º¯ÊýÄ©Î²ÔÙ´Îµ÷ÓÃglutTimerFunc


	//¸æËßGLUTÎÒÃÇ×¼±¸½øÈëÓ¦ÓÃ³ÌÐòÊÂ¼þ´¦ÀíÑ­»·¡£GLUTÌá¹©ÁËÒ»¸öº¯ÊýÈÃ³ÌÐò½øÈëÒ»¸öÓÀ²»½áÊøµÄÑ­»·¡£Ò»Ö±µÈ´ý´¦ÀíÏÂÒ»¸öÊÂ¼þ¡£º¯ÊýÊÇglutMainLoop£¨£©¡£ 
	//glutMainLoop()Ò»µ©½øÈëÑ­»·¾ÍÔÙÒ²²»·µ»Ø
	//glutMainLoop()  ×è¶ÏÁËÏµÍ³µÄÕý³£Á÷³Ì£¬ÔÚ¹Ø±ÕglutCreateWindow()´´½¨µÄ´°¿Úºó£¬glutMainLoop()Ö±½ÓÓÃexit(0)ÍË³ö³ÌÐò£¬¶ø²»»á¼ÌÐøÖ´ÐÐglutMainLoop()ºóµÄÓï¾ä£¬
	//Õâ¾ÍÊ¹Ò»Ð©ÀàµÄÊÍ·Å¼°×ÊÔ´»ØÊÕ¹¤×÷ÎÞ·¨½øÐÐ£¬´Ó¶øÔì³ÉÄÚ´æÐ¹Â©¡£¾ÀÕý´ËÎÊÌâ£¬ÓÐ3¸ö°ì·¨£º
	//1¡¢Ê¹ÓÃglutLeaveMainLoop()´úÌæglutMainLoop()¡£
	//2¡¢´¦Àí´úÂëÖÐexit(0)µÄ²¿·Ö¡£ 
	//3¡¢ÔÚglutMainLoopÖ®Ç°ÏÈÉèÖÃ£º 
	//glutSetOption(GLUT_ACTION_ON_WINDOW_CLOSE, GLUT_ACTION_GLUTMAINLOOP_RETURNS); 
	//È»ºóÔÙÓÃglutMainLoop();Ôò glutMainLoop()»áÔÚÍË³öºó£¬¼ÌÐøÖ´ÐÐÆäºóµÄ´úÂë¡£
	//4¡¢´´½¨µ¥ÀýÀà¶ÔÏó£¬²¢ÔÚÆäÏú»Ùº¯ÊýÖÐµ÷ÓÃÄãµÄ×ÊÔ´ÊÍ·Å´¦Àí
	//Ê¹ÓÃÒÔÉÏ·½·¨£¬¿ÉÒÔÓÐÐ§´¦ÀíglutMainLoop()Ôì³ÉµÄÄÚ´æÐ¹Â©£¡
	//void glutMainLoop(void) 
	glutMainLoop();
	return 0;             /* ANSI C requires main to return int. */
}


///////////////////////////////////////////////////////////////////////////////
// initialize lights
///////////////////////////////////////////////////////////////////////////////
void initLights()
{
	// set up light colors (ambient, diffuse, specular)
	GLfloat lightKa[] = {.2f, .2f, .2f, 1.0f};  // ambient light
	GLfloat lightKd[] = {.7f, .7f, .7f, 1.0f};  // diffuse light
	GLfloat lightKs[] = {1, 1, 1, 1};           // specular light
	glLightfv(GL_LIGHT0, GL_AMBIENT, lightKa);
	glLightfv(GL_LIGHT0, GL_DIFFUSE, lightKd);
	glLightfv(GL_LIGHT0, GL_SPECULAR, lightKs);

	// position the light
	float lightPos[4] = {0, 0, 20, 1}; // positional light
	glLightfv(GL_LIGHT0, GL_POSITION, lightPos);

	glEnable(GL_LIGHT0);                        // MUST enable each light source after configuration
}



///////////////////////////////////////////////////////////////////////////////
// set camera position and lookat direction
///////////////////////////////////////////////////////////////////////////////
void setCamera(float posX, float posY, float posZ, float targetX, float targetY, float targetZ)
{
	glMatrixMode(GL_MODELVIEW);
	glLoadIdentity();
	gluLookAt(posX, posY, posZ, targetX, targetY, targetZ, 0, 1, 0); // eye(x,y,z), focal(x,y,z), up(x,y,z)
}


///////////////////////////////////////////////////////////////////////////////
// convert OpenGL internal format enum to string
///////////////////////////////////////////////////////////////////////////////
std::string convertInternalFormatToString(GLenum format)
{
	std::string formatName;

	switch(format)
	{
	case GL_STENCIL_INDEX:
		formatName = "GL_STENCIL_INDEX";
		break;
	case GL_DEPTH_COMPONENT:
		formatName = "GL_DEPTH_COMPONENT";
		break;
	case GL_ALPHA:
		formatName = "GL_ALPHA";
		break;
	case GL_RGB:
		formatName = "GL_RGB";
		break;
	case GL_RGBA:
		formatName = "GL_RGBA";
		break;
	case GL_LUMINANCE:
		formatName = "GL_LUMINANCE";
		break;
	case GL_LUMINANCE_ALPHA:
		formatName = "GL_LUMINANCE_ALPHA";
		break;
	case GL_ALPHA4:
		formatName = "GL_ALPHA4";
		break;
	case GL_ALPHA8:
		formatName = "GL_ALPHA8";
		break;
	case GL_ALPHA12:
		formatName = "GL_ALPHA12";
		break;
	case GL_ALPHA16:
		formatName = "GL_ALPHA16";
		break;
	case GL_LUMINANCE4:
		formatName = "GL_LUMINANCE4";
		break;
	case GL_LUMINANCE8:
		formatName = "GL_LUMINANCE8";
		break;
	case GL_LUMINANCE12:
		formatName = "GL_LUMINANCE12";
		break;
	case GL_LUMINANCE16:
		formatName = "GL_LUMINANCE16";
		break;
	case GL_LUMINANCE4_ALPHA4:
		formatName = "GL_LUMINANCE4_ALPHA4";
		break;
	case GL_LUMINANCE6_ALPHA2:
		formatName = "GL_LUMINANCE6_ALPHA2";
		break;
	case GL_LUMINANCE8_ALPHA8:
		formatName = "GL_LUMINANCE8_ALPHA8";
		break;
	case GL_LUMINANCE12_ALPHA4:
		formatName = "GL_LUMINANCE12_ALPHA4";
		break;
	case GL_LUMINANCE12_ALPHA12:
		formatName = "GL_LUMINANCE12_ALPHA12";
		break;
	case GL_LUMINANCE16_ALPHA16:
		formatName = "GL_LUMINANCE16_ALPHA16";
		break;
	case GL_INTENSITY:
		formatName = "GL_INTENSITY";
		break;
	case GL_INTENSITY4:
		formatName = "GL_INTENSITY4";
		break;
	case GL_INTENSITY8:
		formatName = "GL_INTENSITY8";
		break;
	case GL_INTENSITY12:
		formatName = "GL_INTENSITY12";
		break;
	case GL_INTENSITY16:
		formatName = "GL_INTENSITY16";
		break;
	case GL_R3_G3_B2:
		formatName = "GL_R3_G3_B2";
		break;
	case GL_RGB4:
		formatName = "GL_RGB4";
		break;
	case GL_RGB5:
		formatName = "GL_RGB4";
		break;
	case GL_RGB8:
		formatName = "GL_RGB8";
		break;
	case GL_RGB10:
		formatName = "GL_RGB10";
		break;
	case GL_RGB12:
		formatName = "GL_RGB12";
		break;
	case GL_RGB16:
		formatName = "GL_RGB16";
		break;
	case GL_RGBA2:
		formatName = "GL_RGBA2";
		break;
	case GL_RGBA4:
		formatName = "GL_RGBA4";
		break;
	case GL_RGB5_A1:
		formatName = "GL_RGB5_A1";
		break;
	case GL_RGBA8:
		formatName = "GL_RGBA8";
		break;
	case GL_RGB10_A2:
		formatName = "GL_RGB10_A2";
		break;
	case GL_RGBA12:
		formatName = "GL_RGBA12";
		break;
	case GL_RGBA16:
		formatName = "GL_RGBA16";
		break;
	default:
		formatName = "Unknown Format";
	}

	return formatName;
}

///////////////////////////////////////////////////////////////////////////////
// return texture parameters as string using glGetTexLevelParameteriv()
///////////////////////////////////////////////////////////////////////////////
std::string getTextureParameters(GLuint id)
{
	if(glIsTexture(id) == GL_FALSE)
		return "Not texture object";

	int width, height, format;
	std::string formatName;
	glBindTexture(GL_TEXTURE_2D, id);
	glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_WIDTH, &width);            // get texture width
	glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_HEIGHT, &height);          // get texture height
	glGetTexLevelParameteriv(GL_TEXTURE_2D, 0, GL_TEXTURE_INTERNAL_FORMAT, &format); // get texture internal format
	glBindTexture(GL_TEXTURE_2D, 0);

	formatName = convertInternalFormatToString(format);

	std::stringstream ss;
	ss << width << "x" << height << ", " << formatName;
	return ss.str();
}



///////////////////////////////////////////////////////////////////////////////
// return renderbuffer parameters as string using glGetRenderbufferParameterivEXT
///////////////////////////////////////////////////////////////////////////////
std::string getRenderbufferParameters(GLuint id)
{
	if(glIsRenderbufferEXT(id) == GL_FALSE)
		return "Not Renderbuffer object";

	int width, height, format;
	std::string formatName;
	glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, id);
	glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_WIDTH_EXT, &width);    // get renderbuffer width
	glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_HEIGHT_EXT, &height);  // get renderbuffer height
	glGetRenderbufferParameterivEXT(GL_RENDERBUFFER_EXT, GL_RENDERBUFFER_INTERNAL_FORMAT_EXT, &format); // get renderbuffer internal format
	glBindRenderbufferEXT(GL_RENDERBUFFER_EXT, 0);

	formatName = convertInternalFormatToString(format);

	std::stringstream ss;
	ss << width << "x" << height << ", " << formatName;
	return ss.str();
}


///////////////////////////////////////////////////////////////////////////////
// check FBO completeness
///////////////////////////////////////////////////////////////////////////////
bool checkFramebufferStatus()
{
	// check FBO status
	GLenum status = glCheckFramebufferStatusEXT(GL_FRAMEBUFFER_EXT);
	switch(status)
	{
	case GL_FRAMEBUFFER_COMPLETE_EXT:
		std::cout << "Framebuffer complete." << std::endl;
		return true;

	case GL_FRAMEBUFFER_INCOMPLETE_ATTACHMENT_EXT:
		std::cout << "[ERROR] Framebuffer incomplete: Attachment is NOT complete." << std::endl;
		return false;

	case GL_FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT_EXT:
		std::cout << "[ERROR] Framebuffer incomplete: No image is attached to FBO." << std::endl;
		return false;

	case GL_FRAMEBUFFER_INCOMPLETE_DIMENSIONS_EXT:
		std::cout << "[ERROR] Framebuffer incomplete: Attached images have different dimensions." << std::endl;
		return false;

	case GL_FRAMEBUFFER_INCOMPLETE_FORMATS_EXT:
		std::cout << "[ERROR] Framebuffer incomplete: Color attached images have different internal formats." << std::endl;
		return false;

	case GL_FRAMEBUFFER_INCOMPLETE_DRAW_BUFFER_EXT:
		std::cout << "[ERROR] Framebuffer incomplete: Draw buffer." << std::endl;
		return false;

	case GL_FRAMEBUFFER_INCOMPLETE_READ_BUFFER_EXT:
		std::cout << "[ERROR] Framebuffer incomplete: Read buffer." << std::endl;
		return false;

	case GL_FRAMEBUFFER_UNSUPPORTED_EXT:
		std::cout << "[ERROR] Unsupported by FBO implementation." << std::endl;
		return false;

	default:
		std::cout << "[ERROR] Unknow error." << std::endl;
		return false;
	}
}


///////////////////////////////////////////////////////////////////////////////
// print out the FBO infos
///////////////////////////////////////////////////////////////////////////////
void printFramebufferInfo()
{
	cout << "\n***** FBO STATUS *****\n";

	// print max # of colorbuffers supported by FBO
	int colorBufferCount = 0;
	glGetIntegerv(GL_MAX_COLOR_ATTACHMENTS_EXT, &colorBufferCount);
	cout << "Max Number of Color Buffer Attachment Points: " << colorBufferCount << endl;

	int objectType;
	int objectId;

	// print info of the colorbuffer attachable image
	for(int i = 0; i < colorBufferCount; ++i)
	{
		glGetFramebufferAttachmentParameterivEXT(GL_FRAMEBUFFER_EXT,
			GL_COLOR_ATTACHMENT0_EXT+i,
			GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT,
			&objectType);
		if(objectType != GL_NONE)
		{
			glGetFramebufferAttachmentParameterivEXT(GL_FRAMEBUFFER_EXT,
				GL_COLOR_ATTACHMENT0_EXT+i,
				GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT,
				&objectId);

			std::string formatName;

			cout << "Color Attachment " << i << ": ";
			if(objectType == GL_TEXTURE)
				cout << "GL_TEXTURE, " << getTextureParameters(objectId) << endl;
			else if(objectType == GL_RENDERBUFFER_EXT)
				cout << "GL_RENDERBUFFER_EXT, " << getRenderbufferParameters(objectId) << endl;
		}
	}

	// print info of the depthbuffer attachable image
	glGetFramebufferAttachmentParameterivEXT(GL_FRAMEBUFFER_EXT,
		GL_DEPTH_ATTACHMENT_EXT,
		GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT,
		&objectType);
	if(objectType != GL_NONE)
	{
		glGetFramebufferAttachmentParameterivEXT(GL_FRAMEBUFFER_EXT,
			GL_DEPTH_ATTACHMENT_EXT,
			GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT,
			&objectId);

		cout << "Depth Attachment: ";
		switch(objectType)
		{
		case GL_TEXTURE:
			cout << "GL_TEXTURE, " << getTextureParameters(objectId) << endl;
			break;
		case GL_RENDERBUFFER_EXT:
			cout << "GL_RENDERBUFFER_EXT, " << getRenderbufferParameters(objectId) << endl;
			break;
		}
	}

	// print info of the stencilbuffer attachable image
	glGetFramebufferAttachmentParameterivEXT(GL_FRAMEBUFFER_EXT,
		GL_STENCIL_ATTACHMENT_EXT,
		GL_FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE_EXT,
		&objectType);
	if(objectType != GL_NONE)
	{
		glGetFramebufferAttachmentParameterivEXT(GL_FRAMEBUFFER_EXT,
			GL_STENCIL_ATTACHMENT_EXT,
			GL_FRAMEBUFFER_ATTACHMENT_OBJECT_NAME_EXT,
			&objectId);

		cout << "Stencil Attachment: ";
		switch(objectType)
		{
		case GL_TEXTURE:
			cout << "GL_TEXTURE, " << getTextureParameters(objectId) << endl;
			break;
		case GL_RENDERBUFFER_EXT:
			cout << "GL_RENDERBUFFER_EXT, " << getRenderbufferParameters(objectId) << endl;
			break;
		}
	}

	cout << endl;
}