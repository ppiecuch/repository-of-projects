
#define __GLU_INIT_SWAP_IMAGE void *tmpImage
#define __GLU_SWAP_IMAGE(a,b) tmpImage = a; a = b; b = tmpImage;

static int computeLog(GLuint value)
{
	int i;

	i = 0;

	/* Error! */
	if (value == 0) return -1;

	for (;;) {
		if (value & 1) {
			/* Error ! */
			if (value != 1) return -1;
			return i;
		}
		value = value >> 1;
		i++;
	}
}

/*
** Compute the nearest power of 2 number.  This algorithm is a little
** strange, but it works quite well.
*/
static int nearestPower(GLuint value)
{
	int i;

	i = 1;

	/* Error! */
	if (value == 0) return -1;

	for (;;) {
		if (value == 1) {
			return i;
		} else if (value == 3) {
			return i*4;
		}
		value = value >> 1;
		i *= 2;
	}
}

static void halve1DimagePackedPixel(int components,
									void (*extractPackedPixel)
									(int, const void *,GLfloat []),
									void (*shovePackedPixel)
									(const GLfloat [],int, void *),
									GLint width, GLint height,
									const void *dataIn, void *dataOut,
									GLint pixelSizeInBytes,
									GLint rowSizeInBytes, GLint isSwap)
{
	int halfWidth= width / 2;
	int halfHeight= height / 2;
	const char *src= (const char *) dataIn;
	int jj;

	assert(width == 1 || height == 1); /* must be 1D */
	assert(width != height);	/* can't be square */

	if (height == 1) {	/* 1 row */
		int outIndex= 0;

		assert(width != 1);	/* widthxheight can't be 1x1 */
		halfHeight= 1;

		/* one horizontal row with possible pad bytes */

		for (jj= 0; jj< halfWidth; jj++) {
#define BOX2 2
			float totals[4];	/* 4 is maximum components */
			float extractTotals[BOX2][4]; /* 4 is maximum components */
			int cc;

			/* average two at a time, instead of four */
			(*extractPackedPixel)(isSwap,src,
				&extractTotals[0][0]);
			(*extractPackedPixel)(isSwap,(src+pixelSizeInBytes),
				&extractTotals[1][0]);		        
			for (cc = 0; cc < components; cc++) {
				int kk;

				/* grab 2 pixels to average */
				totals[cc]= 0.0;
				/* totals[RED]= extractTotals[0][RED]+extractTotals[1][RED];
				* totals[RED]/= 2.0;
				*/
				for (kk = 0; kk < BOX2; kk++) {
					totals[cc]+= extractTotals[kk][cc];
				}
				totals[cc]/= (float)BOX2;
			}
			(*shovePackedPixel)(totals,outIndex,dataOut);

			outIndex++;
			/* skip over to next group of 2 */
			src+= pixelSizeInBytes + pixelSizeInBytes;
		}

		{
			int padBytes= rowSizeInBytes - (width*pixelSizeInBytes);
			src+= padBytes;	/* for assertion only */
		}
		assert(src == &((const char *)dataIn)[rowSizeInBytes]);
		assert(outIndex == halfWidth * halfHeight);
	}
	else if (width == 1) { /* 1 column */
		int outIndex= 0;

		assert(height != 1);	/* widthxheight can't be 1x1 */
		halfWidth= 1;
		/* one vertical column with possible pad bytes per row */
		/* average two at a time */

		for (jj= 0; jj< halfHeight; jj++) {
#define BOX2 2
			float totals[4];	/* 4 is maximum components */
			float extractTotals[BOX2][4]; /* 4 is maximum components */
			int cc;

			/* average two at a time, instead of four */
			(*extractPackedPixel)(isSwap,src,
				&extractTotals[0][0]);
			(*extractPackedPixel)(isSwap,(src+rowSizeInBytes),
				&extractTotals[1][0]);		        
			for (cc = 0; cc < components; cc++) {
				int kk;

				/* grab 2 pixels to average */
				totals[cc]= 0.0;
				/* totals[RED]= extractTotals[0][RED]+extractTotals[1][RED];
				* totals[RED]/= 2.0;
				*/
				for (kk = 0; kk < BOX2; kk++) {
					totals[cc]+= extractTotals[kk][cc];
				}
				totals[cc]/= (float)BOX2;
			}
			(*shovePackedPixel)(totals,outIndex,dataOut);

			outIndex++;
			src+= rowSizeInBytes + rowSizeInBytes; /* go to row after next */
		}

		assert(src == &((const char *)dataIn)[rowSizeInBytes*height]);
		assert(outIndex == halfWidth * halfHeight);
	}
} /* halve1DimagePackedPixel() */

/* rowSizeInBytes is at least the width (in bytes) due to padding on
*  inputs; not always equal. Output NEVER has row padding.
*/
static void halveImagePackedPixel(int components,
								  void (*extractPackedPixel)
								  (int, const void *,GLfloat []),
								  void (*shovePackedPixel)
								  (const GLfloat [],int, void *),
								  GLint width, GLint height,
								  const void *dataIn, void *dataOut,
								  GLint pixelSizeInBytes,
								  GLint rowSizeInBytes, GLint isSwap)
{
	/* handle case where there is only 1 column/row */
	if (width == 1 || height == 1) {
		assert(!(width == 1 && height == 1)); /* can't be 1x1 */
		halve1DimagePackedPixel(components,extractPackedPixel,shovePackedPixel,
			width,height,dataIn,dataOut,pixelSizeInBytes,
			rowSizeInBytes,isSwap);
		return;
	}

	{
		int ii, jj;

		int halfWidth= width / 2;
		int halfHeight= height / 2;
		const char *src= (const char *) dataIn;
		int padBytes= rowSizeInBytes - (width*pixelSizeInBytes);
		int outIndex= 0;

		for (ii= 0; ii< halfHeight; ii++) {
			for (jj= 0; jj< halfWidth; jj++) {
#define BOX4 4
				float totals[4];	/* 4 is maximum components */
				float extractTotals[BOX4][4]; /* 4 is maximum components */
				int cc;

				(*extractPackedPixel)(isSwap,src,
					&extractTotals[0][0]);
				(*extractPackedPixel)(isSwap,(src+pixelSizeInBytes),
					&extractTotals[1][0]);
				(*extractPackedPixel)(isSwap,(src+rowSizeInBytes),
					&extractTotals[2][0]);
				(*extractPackedPixel)(isSwap,
					(src+rowSizeInBytes+pixelSizeInBytes),
					&extractTotals[3][0]);
				for (cc = 0; cc < components; cc++) {
					int kk;

					/* grab 4 pixels to average */
					totals[cc]= 0.0;
					/* totals[RED]= extractTotals[0][RED]+extractTotals[1][RED]+
					*	       extractTotals[2][RED]+extractTotals[3][RED];
					* totals[RED]/= 4.0;
					*/
					for (kk = 0; kk < BOX4; kk++) {
						totals[cc]+= extractTotals[kk][cc];
					}
					totals[cc]/= (float)BOX4;
				}
				(*shovePackedPixel)(totals,outIndex,dataOut);

				outIndex++;
				/* skip over to next square of 4 */
				src+= pixelSizeInBytes + pixelSizeInBytes;
			}
			/* skip past pad bytes, if any, to get to next row */
			src+= padBytes;

			/* src is at beginning of a row here, but it's the second row of
			* the square block of 4 pixels that we just worked on so we
			* need to go one more row.
			* i.e.,
			*		      OO...
			*	      here -->OO...
			*	  but want -->OO...
			*		      OO...
			*		      ...
			*/
			src+= rowSizeInBytes;
		}

		/* both pointers must reach one byte after the end */
		assert(src == &((const char *)dataIn)[rowSizeInBytes*height]);
		assert(outIndex == halfWidth * halfHeight);
	}
} /* halveImagePackedPixel() */

static int gluBuild2DMipmapLevelsCore(GLenum target, GLint internalFormat,
									  GLsizei width, GLsizei height,
									  GLsizei widthPowerOf2,
									  GLsizei heightPowerOf2,
									  GLenum format, GLenum type,
									  GLint userLevel,
									  GLint baseLevel,GLint maxLevel,
									  const void *data)
{
	GLint newwidth, newheight;
	GLint level, levels;
	const void *usersImage; /* passed from user. Don't touch! */
	void *srcImage, *dstImage; /* scratch area to build mipmapped images */
	__GLU_INIT_SWAP_IMAGE;
	GLint memreq;
	GLint cmpts;

	GLint myswap_bytes, groups_per_line, element_size, group_size;
	GLint rowsize, padding;
	PixelStorageModes psm;

	assert(checkMipmapArgs(internalFormat,format,type) == 0);
	assert(width >= 1 && height >= 1);

	if(type == GL_BITMAP) {
		return bitmapBuild2DMipmaps(target, internalFormat, width, height,
			format, type, data);
	}

	srcImage = dstImage = NULL;

	newwidth= widthPowerOf2;
	newheight= heightPowerOf2;
	levels = computeLog(newwidth);
	level = computeLog(newheight);
	if (level > levels) levels=level;

	levels+= userLevel;

	retrieveStoreModes(&psm);
	myswap_bytes = psm.unpack_swap_bytes;
	cmpts = elements_per_group(format,type);
	if (psm.unpack_row_length > 0) {
		groups_per_line = psm.unpack_row_length;
	} else {
		groups_per_line = width;
	}

	element_size = bytes_per_element(type);
	group_size = element_size * cmpts;
	if (element_size == 1) myswap_bytes = 0;

	rowsize = groups_per_line * group_size;
	padding = (rowsize % psm.unpack_alignment);
	if (padding) {
		rowsize += psm.unpack_alignment - padding;
	}
	usersImage = (const GLubyte *) data + psm.unpack_skip_rows * rowsize +
		psm.unpack_skip_pixels * group_size;

	glPixelStorei(GL_UNPACK_SKIP_ROWS, 0);
	glPixelStorei(GL_UNPACK_SKIP_PIXELS, 0);
	glPixelStorei(GL_UNPACK_ROW_LENGTH, 0);

	level = userLevel;

	/* already power-of-two square */
	if (width == newwidth && height == newheight) {
		/* Use usersImage for level userLevel */
		if (baseLevel <= level && level <= maxLevel) {
			glTexImage2D(target, level, internalFormat, width,
				height, 0, format, type,
				usersImage);
		}
		if(levels == 0) { /* we're done. clean up and return */
			glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
			glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
			glPixelStorei(GL_UNPACK_SKIP_PIXELS, psm.unpack_skip_pixels);
			glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
			glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);
			return 0;
		}
		{
			int nextWidth= newwidth/2;
			int nextHeight= newheight/2;

			/* clamp to 1 */
			if (nextWidth < 1) nextWidth= 1;
			if (nextHeight < 1) nextHeight= 1;
			memreq = image_size(nextWidth, nextHeight, format, type);
		}

		switch(type) {
	case GL_UNSIGNED_BYTE:
		dstImage = (GLubyte *)malloc(memreq);
		break;
	case GL_BYTE:
		dstImage = (GLbyte *)malloc(memreq);
		break;
	case GL_UNSIGNED_SHORT:
		dstImage = (GLushort *)malloc(memreq);
		break;
	case GL_SHORT:
		dstImage = (GLshort *)malloc(memreq);
		break;
	case GL_UNSIGNED_INT:
		dstImage = (GLuint *)malloc(memreq);
		break;
	case GL_INT:
		dstImage = (GLint *)malloc(memreq);
		break;
	case GL_FLOAT:
		dstImage = (GLfloat *)malloc(memreq);
		break;
	case GL_UNSIGNED_BYTE_3_3_2:
	case GL_UNSIGNED_BYTE_2_3_3_REV:
		dstImage = (GLubyte *)malloc(memreq);
		break;
	case GL_UNSIGNED_SHORT_5_6_5:
	case GL_UNSIGNED_SHORT_5_6_5_REV:
	case GL_UNSIGNED_SHORT_4_4_4_4:
	case GL_UNSIGNED_SHORT_4_4_4_4_REV:
	case GL_UNSIGNED_SHORT_5_5_5_1:
	case GL_UNSIGNED_SHORT_1_5_5_5_REV:
		dstImage = (GLushort *)malloc(memreq);
		break;
	case GL_UNSIGNED_INT_8_8_8_8:
	case GL_UNSIGNED_INT_8_8_8_8_REV:
	case GL_UNSIGNED_INT_10_10_10_2:
	case GL_UNSIGNED_INT_2_10_10_10_REV:
		dstImage = (GLuint *)malloc(memreq);  
		break;
	default:
		return GLU_INVALID_ENUM;
		}
		if (dstImage == NULL) {
			glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
			glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
			glPixelStorei(GL_UNPACK_SKIP_PIXELS, psm.unpack_skip_pixels);
			glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
			glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);
			return GLU_OUT_OF_MEMORY;
		}
		else
			switch(type) {
	  case GL_UNSIGNED_BYTE:
		  halveImage_ubyte(cmpts, width, height,
			  (const GLubyte *)usersImage, (GLubyte *)dstImage,
			  element_size, rowsize, group_size);
		  break;
	  case GL_BYTE:
		  halveImage_byte(cmpts, width, height,
			  (const GLbyte *)usersImage, (GLbyte *)dstImage,
			  element_size, rowsize, group_size);
		  break;
	  case GL_UNSIGNED_SHORT:
		  halveImage_ushort(cmpts, width, height,
			  (const GLushort *)usersImage, (GLushort *)dstImage,
			  element_size, rowsize, group_size, myswap_bytes);
		  break;
	  case GL_SHORT:
		  halveImage_short(cmpts, width, height,
			  (const GLshort *)usersImage, (GLshort *)dstImage,
			  element_size, rowsize, group_size, myswap_bytes);
		  break;
	  case GL_UNSIGNED_INT:
		  halveImage_uint(cmpts, width, height,
			  (const GLuint *)usersImage, (GLuint *)dstImage,
			  element_size, rowsize, group_size, myswap_bytes);
		  break;
	  case GL_INT:
		  halveImage_int(cmpts, width, height,
			  (const GLint *)usersImage, (GLint *)dstImage,
			  element_size, rowsize, group_size, myswap_bytes);
		  break;
	  case GL_FLOAT:
		  halveImage_float(cmpts, width, height,
			  (const GLfloat *)usersImage, (GLfloat *)dstImage,
			  element_size, rowsize, group_size, myswap_bytes);
		  break;
	  case GL_UNSIGNED_BYTE_3_3_2:
		  assert(format == GL_RGB);
		  halveImagePackedPixel(3,extract332,shove332,
			  width,height,usersImage,dstImage,
			  element_size,rowsize,myswap_bytes);
		  break;
	  case GL_UNSIGNED_BYTE_2_3_3_REV:
		  assert(format == GL_RGB);
		  halveImagePackedPixel(3,extract233rev,shove233rev,
			  width,height,usersImage,dstImage,
			  element_size,rowsize,myswap_bytes);
		  break;
	  case GL_UNSIGNED_SHORT_5_6_5:
		  halveImagePackedPixel(3,extract565,shove565,
			  width,height,usersImage,dstImage,
			  element_size,rowsize,myswap_bytes);
		  break;
	  case GL_UNSIGNED_SHORT_5_6_5_REV:
		  halveImagePackedPixel(3,extract565rev,shove565rev,
			  width,height,usersImage,dstImage,
			  element_size,rowsize,myswap_bytes);
		  break;
	  case GL_UNSIGNED_SHORT_4_4_4_4:
		  halveImagePackedPixel(4,extract4444,shove4444,
			  width,height,usersImage,dstImage,
			  element_size,rowsize,myswap_bytes);
		  break;
	  case GL_UNSIGNED_SHORT_4_4_4_4_REV:
		  halveImagePackedPixel(4,extract4444rev,shove4444rev,
			  width,height,usersImage,dstImage,
			  element_size,rowsize,myswap_bytes);
		  break;
	  case GL_UNSIGNED_SHORT_5_5_5_1:
		  halveImagePackedPixel(4,extract5551,shove5551,
			  width,height,usersImage,dstImage,
			  element_size,rowsize,myswap_bytes);
		  break;
	  case GL_UNSIGNED_SHORT_1_5_5_5_REV:
		  halveImagePackedPixel(4,extract1555rev,shove1555rev,
			  width,height,usersImage,dstImage,
			  element_size,rowsize,myswap_bytes);
		  break;
	  case GL_UNSIGNED_INT_8_8_8_8:
		  halveImagePackedPixel(4,extract8888,shove8888,
			  width,height,usersImage,dstImage,
			  element_size,rowsize,myswap_bytes);
		  break;
	  case GL_UNSIGNED_INT_8_8_8_8_REV:
		  halveImagePackedPixel(4,extract8888rev,shove8888rev,
			  width,height,usersImage,dstImage,
			  element_size,rowsize,myswap_bytes);
		  break;
	  case GL_UNSIGNED_INT_10_10_10_2:
		  halveImagePackedPixel(4,extract1010102,shove1010102,
			  width,height,usersImage,dstImage,
			  element_size,rowsize,myswap_bytes);
		  break;
	  case GL_UNSIGNED_INT_2_10_10_10_REV:
		  halveImagePackedPixel(4,extract2101010rev,shove2101010rev,
			  width,height,usersImage,dstImage,
			  element_size,rowsize,myswap_bytes);
		  break;
	  default:
		  assert(0);
		  break;
		}
		newwidth = width/2;
		newheight = height/2;
		/* clamp to 1 */
		if (newwidth < 1) newwidth= 1;
		if (newheight < 1) newheight= 1;

		myswap_bytes = 0;
		rowsize = newwidth * group_size;
		memreq = image_size(newwidth, newheight, format, type);
		/* Swap srcImage and dstImage */
		__GLU_SWAP_IMAGE(srcImage,dstImage);
		switch(type) {
	case GL_UNSIGNED_BYTE:
		dstImage = (GLubyte *)malloc(memreq);
		break;
	case GL_BYTE:
		dstImage = (GLbyte *)malloc(memreq);
		break;
	case GL_UNSIGNED_SHORT:
		dstImage = (GLushort *)malloc(memreq);
		break;
	case GL_SHORT:
		dstImage = (GLshort *)malloc(memreq);
		break;
	case GL_UNSIGNED_INT:
		dstImage = (GLuint *)malloc(memreq);
		break;
	case GL_INT:
		dstImage = (GLint *)malloc(memreq);
		break;
	case GL_FLOAT:
		dstImage = (GLfloat *)malloc(memreq);
		break;
	case GL_UNSIGNED_BYTE_3_3_2:
	case GL_UNSIGNED_BYTE_2_3_3_REV:
		dstImage = (GLubyte *)malloc(memreq);
		break;
	case GL_UNSIGNED_SHORT_5_6_5:
	case GL_UNSIGNED_SHORT_5_6_5_REV:
	case GL_UNSIGNED_SHORT_4_4_4_4:
	case GL_UNSIGNED_SHORT_4_4_4_4_REV:
	case GL_UNSIGNED_SHORT_5_5_5_1:
	case GL_UNSIGNED_SHORT_1_5_5_5_REV:
		dstImage = (GLushort *)malloc(memreq);
		break;
	case GL_UNSIGNED_INT_8_8_8_8:
	case GL_UNSIGNED_INT_8_8_8_8_REV:
	case GL_UNSIGNED_INT_10_10_10_2:
	case GL_UNSIGNED_INT_2_10_10_10_REV:
		dstImage = (GLuint *)malloc(memreq);
		break;
	default:
		return GLU_INVALID_ENUM;
		}
		if (dstImage == NULL) {
			glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
			glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
			glPixelStorei(GL_UNPACK_SKIP_PIXELS, psm.unpack_skip_pixels);
			glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
			glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);
			return GLU_OUT_OF_MEMORY;
		}
		/* level userLevel+1 is in srcImage; level userLevel already saved */
		level = userLevel+1;
	} else { /* user's image is *not* nice power-of-2 sized square */
		memreq = image_size(newwidth, newheight, format, type);
		switch(type) {
		case GL_UNSIGNED_BYTE:
			dstImage = (GLubyte *)malloc(memreq);
			break;
		case GL_BYTE:
			dstImage = (GLbyte *)malloc(memreq);
			break;
		case GL_UNSIGNED_SHORT:
			dstImage = (GLushort *)malloc(memreq);
			break;
		case GL_SHORT:
			dstImage = (GLshort *)malloc(memreq);
			break;
		case GL_UNSIGNED_INT:
			dstImage = (GLuint *)malloc(memreq);
			break;
		case GL_INT:
			dstImage = (GLint *)malloc(memreq);
			break;
		case GL_FLOAT:
			dstImage = (GLfloat *)malloc(memreq);
			break;
		case GL_UNSIGNED_BYTE_3_3_2:
		case GL_UNSIGNED_BYTE_2_3_3_REV:
			dstImage = (GLubyte *)malloc(memreq);
			break;
		case GL_UNSIGNED_SHORT_5_6_5:
		case GL_UNSIGNED_SHORT_5_6_5_REV:
		case GL_UNSIGNED_SHORT_4_4_4_4:
		case GL_UNSIGNED_SHORT_4_4_4_4_REV:
		case GL_UNSIGNED_SHORT_5_5_5_1:
		case GL_UNSIGNED_SHORT_1_5_5_5_REV:
			dstImage = (GLushort *)malloc(memreq);
			break;
		case GL_UNSIGNED_INT_8_8_8_8:
		case GL_UNSIGNED_INT_8_8_8_8_REV:
		case GL_UNSIGNED_INT_10_10_10_2:
		case GL_UNSIGNED_INT_2_10_10_10_REV:
			dstImage = (GLuint *)malloc(memreq);
			break;
		default:
			return GLU_INVALID_ENUM;
		}

		if (dstImage == NULL) {
			glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
			glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
			glPixelStorei(GL_UNPACK_SKIP_PIXELS, psm.unpack_skip_pixels);
			glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
			glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);
			return GLU_OUT_OF_MEMORY;
		}

		switch(type) {
	case GL_UNSIGNED_BYTE:
		scale_internal_ubyte(cmpts, width, height,
			(const GLubyte *)usersImage, newwidth, newheight,
			(GLubyte *)dstImage, element_size,
			rowsize, group_size);
		break;
	case GL_BYTE:
		scale_internal_byte(cmpts, width, height,
			(const GLbyte *)usersImage, newwidth, newheight,
			(GLbyte *)dstImage, element_size,
			rowsize, group_size);
		break;
	case GL_UNSIGNED_SHORT:
		scale_internal_ushort(cmpts, width, height,
			(const GLushort *)usersImage, newwidth, newheight,
			(GLushort *)dstImage, element_size,
			rowsize, group_size, myswap_bytes);
		break;
	case GL_SHORT:
		scale_internal_short(cmpts, width, height,
			(const GLshort *)usersImage, newwidth, newheight,
			(GLshort *)dstImage, element_size,
			rowsize, group_size, myswap_bytes);
		break;
	case GL_UNSIGNED_INT:
		scale_internal_uint(cmpts, width, height,
			(const GLuint *)usersImage, newwidth, newheight,
			(GLuint *)dstImage, element_size,
			rowsize, group_size, myswap_bytes);
		break;
	case GL_INT:
		scale_internal_int(cmpts, width, height,
			(const GLint *)usersImage, newwidth, newheight,
			(GLint *)dstImage, element_size,
			rowsize, group_size, myswap_bytes);
		break;
	case GL_FLOAT:
		scale_internal_float(cmpts, width, height,
			(const GLfloat *)usersImage, newwidth, newheight,
			(GLfloat *)dstImage, element_size,
			rowsize, group_size, myswap_bytes);
		break;
	case GL_UNSIGNED_BYTE_3_3_2:
		scaleInternalPackedPixel(3,extract332,shove332,
			width, height,usersImage,
			newwidth,newheight,(void *)dstImage,
			element_size,rowsize,myswap_bytes);
		break;
	case GL_UNSIGNED_BYTE_2_3_3_REV:
		scaleInternalPackedPixel(3,extract233rev,shove233rev,
			width, height,usersImage,
			newwidth,newheight,(void *)dstImage,
			element_size,rowsize,myswap_bytes);
		break;
	case GL_UNSIGNED_SHORT_5_6_5:
		scaleInternalPackedPixel(3,extract565,shove565,
			width, height,usersImage,
			newwidth,newheight,(void *)dstImage,
			element_size,rowsize,myswap_bytes);
		break;
	case GL_UNSIGNED_SHORT_5_6_5_REV:
		scaleInternalPackedPixel(3,extract565rev,shove565rev,
			width, height,usersImage,
			newwidth,newheight,(void *)dstImage,
			element_size,rowsize,myswap_bytes);
		break;
	case GL_UNSIGNED_SHORT_4_4_4_4:
		scaleInternalPackedPixel(4,extract4444,shove4444,
			width, height,usersImage,
			newwidth,newheight,(void *)dstImage,
			element_size,rowsize,myswap_bytes);
		break;
	case GL_UNSIGNED_SHORT_4_4_4_4_REV:
		scaleInternalPackedPixel(4,extract4444rev,shove4444rev,
			width, height,usersImage,
			newwidth,newheight,(void *)dstImage,
			element_size,rowsize,myswap_bytes);
		break;
	case GL_UNSIGNED_SHORT_5_5_5_1:
		scaleInternalPackedPixel(4,extract5551,shove5551,
			width, height,usersImage,
			newwidth,newheight,(void *)dstImage,
			element_size,rowsize,myswap_bytes);
		break;
	case GL_UNSIGNED_SHORT_1_5_5_5_REV:
		scaleInternalPackedPixel(4,extract1555rev,shove1555rev,
			width, height,usersImage,
			newwidth,newheight,(void *)dstImage,
			element_size,rowsize,myswap_bytes);
		break;
	case GL_UNSIGNED_INT_8_8_8_8:
		scaleInternalPackedPixel(4,extract8888,shove8888,
			width, height,usersImage,
			newwidth,newheight,(void *)dstImage,
			element_size,rowsize,myswap_bytes);
		break;
	case GL_UNSIGNED_INT_8_8_8_8_REV:
		scaleInternalPackedPixel(4,extract8888rev,shove8888rev,
			width, height,usersImage,
			newwidth,newheight,(void *)dstImage,
			element_size,rowsize,myswap_bytes);
		break;
	case GL_UNSIGNED_INT_10_10_10_2:
		scaleInternalPackedPixel(4,extract1010102,shove1010102,
			width, height,usersImage,
			newwidth,newheight,(void *)dstImage,
			element_size,rowsize,myswap_bytes);
		break;
	case GL_UNSIGNED_INT_2_10_10_10_REV:
		scaleInternalPackedPixel(4,extract2101010rev,shove2101010rev,
			width, height,usersImage,
			newwidth,newheight,(void *)dstImage,
			element_size,rowsize,myswap_bytes);
		break;
	default:
		assert(0);
		break;
		}
		myswap_bytes = 0;
		rowsize = newwidth * group_size;
		/* Swap dstImage and srcImage */
		__GLU_SWAP_IMAGE(srcImage,dstImage);

		if(levels != 0) { /* use as little memory as possible */
			{
				int nextWidth= newwidth/2;
				int nextHeight= newheight/2;
				if (nextWidth < 1) nextWidth= 1;
				if (nextHeight < 1) nextHeight= 1; 

				memreq = image_size(nextWidth, nextHeight, format, type);
			}

			switch(type) {
		case GL_UNSIGNED_BYTE:
			dstImage = (GLubyte *)malloc(memreq);
			break;
		case GL_BYTE:
			dstImage = (GLbyte *)malloc(memreq);
			break;
		case GL_UNSIGNED_SHORT:
			dstImage = (GLushort *)malloc(memreq);
			break;
		case GL_SHORT:
			dstImage = (GLshort *)malloc(memreq);
			break;
		case GL_UNSIGNED_INT:
			dstImage = (GLuint *)malloc(memreq);
			break;
		case GL_INT:
			dstImage = (GLint *)malloc(memreq);
			break;
		case GL_FLOAT:
			dstImage = (GLfloat *)malloc(memreq);
			break;
		case GL_UNSIGNED_BYTE_3_3_2:
		case GL_UNSIGNED_BYTE_2_3_3_REV:
			dstImage = (GLubyte *)malloc(memreq);
			break;
		case GL_UNSIGNED_SHORT_5_6_5:
		case GL_UNSIGNED_SHORT_5_6_5_REV:
		case GL_UNSIGNED_SHORT_4_4_4_4:
		case GL_UNSIGNED_SHORT_4_4_4_4_REV:
		case GL_UNSIGNED_SHORT_5_5_5_1:
		case GL_UNSIGNED_SHORT_1_5_5_5_REV:
			dstImage = (GLushort *)malloc(memreq);
			break;
		case GL_UNSIGNED_INT_8_8_8_8:
		case GL_UNSIGNED_INT_8_8_8_8_REV:
		case GL_UNSIGNED_INT_10_10_10_2:
		case GL_UNSIGNED_INT_2_10_10_10_REV:
			dstImage = (GLuint *)malloc(memreq);
			break;
		default:
			return GLU_INVALID_ENUM;
			}
			if (dstImage == NULL) {
				glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
				glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
				glPixelStorei(GL_UNPACK_SKIP_PIXELS, psm.unpack_skip_pixels);
				glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
				glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);
				return GLU_OUT_OF_MEMORY;
			}
		}
		/* level userLevel is in srcImage; nothing saved yet */
		level = userLevel;
	}

	glPixelStorei(GL_UNPACK_SWAP_BYTES, GL_FALSE);
	if (baseLevel <= level && level <= maxLevel) {
		glTexImage2D(target, level, internalFormat, newwidth, newheight, 0,
			format, type, (void *)srcImage);
	}

	level++; /* update current level for the loop */
	for (; level <= levels; level++) {
		switch(type) {
		case GL_UNSIGNED_BYTE:
			halveImage_ubyte(cmpts, newwidth, newheight,
				(GLubyte *)srcImage, (GLubyte *)dstImage, element_size,
				rowsize, group_size);
			break;
		case GL_BYTE:
			halveImage_byte(cmpts, newwidth, newheight,
				(GLbyte *)srcImage, (GLbyte *)dstImage, element_size,
				rowsize, group_size);
			break;
		case GL_UNSIGNED_SHORT:
			halveImage_ushort(cmpts, newwidth, newheight,
				(GLushort *)srcImage, (GLushort *)dstImage, element_size,
				rowsize, group_size, myswap_bytes);
			break;
		case GL_SHORT:
			halveImage_short(cmpts, newwidth, newheight,
				(GLshort *)srcImage, (GLshort *)dstImage, element_size,
				rowsize, group_size, myswap_bytes);
			break;
		case GL_UNSIGNED_INT:
			halveImage_uint(cmpts, newwidth, newheight,
				(GLuint *)srcImage, (GLuint *)dstImage, element_size,
				rowsize, group_size, myswap_bytes);
			break;
		case GL_INT:
			halveImage_int(cmpts, newwidth, newheight,
				(GLint *)srcImage, (GLint *)dstImage, element_size,
				rowsize, group_size, myswap_bytes);
			break;
		case GL_FLOAT:
			halveImage_float(cmpts, newwidth, newheight,
				(GLfloat *)srcImage, (GLfloat *)dstImage, element_size,
				rowsize, group_size, myswap_bytes);
			break;
		case GL_UNSIGNED_BYTE_3_3_2:
			halveImagePackedPixel(3,extract332,shove332,
				newwidth,newheight,
				srcImage,dstImage,element_size,rowsize,
				myswap_bytes);
			break;
		case GL_UNSIGNED_BYTE_2_3_3_REV:
			halveImagePackedPixel(3,extract233rev,shove233rev,
				newwidth,newheight,
				srcImage,dstImage,element_size,rowsize,
				myswap_bytes);
			break;
		case GL_UNSIGNED_SHORT_5_6_5:
			halveImagePackedPixel(3,extract565,shove565,
				newwidth,newheight,
				srcImage,dstImage,element_size,rowsize,
				myswap_bytes);
			break;
		case GL_UNSIGNED_SHORT_5_6_5_REV:
			halveImagePackedPixel(3,extract565rev,shove565rev,
				newwidth,newheight,
				srcImage,dstImage,element_size,rowsize,
				myswap_bytes);
			break;
		case GL_UNSIGNED_SHORT_4_4_4_4:
			halveImagePackedPixel(4,extract4444,shove4444,
				newwidth,newheight,
				srcImage,dstImage,element_size,rowsize,
				myswap_bytes);
			break;
		case GL_UNSIGNED_SHORT_4_4_4_4_REV:
			halveImagePackedPixel(4,extract4444rev,shove4444rev,
				newwidth,newheight,
				srcImage,dstImage,element_size,rowsize,
				myswap_bytes);
			break;
		case GL_UNSIGNED_SHORT_5_5_5_1:	        
			halveImagePackedPixel(4,extract5551,shove5551,
				newwidth,newheight,
				srcImage,dstImage,element_size,rowsize,
				myswap_bytes);
			break;
		case GL_UNSIGNED_SHORT_1_5_5_5_REV: 	        
			halveImagePackedPixel(4,extract1555rev,shove1555rev,
				newwidth,newheight,
				srcImage,dstImage,element_size,rowsize,
				myswap_bytes);
			break;
		case GL_UNSIGNED_INT_8_8_8_8:
			halveImagePackedPixel(4,extract8888,shove8888,
				newwidth,newheight,
				srcImage,dstImage,element_size,rowsize,
				myswap_bytes);
			break;
		case GL_UNSIGNED_INT_8_8_8_8_REV:
			halveImagePackedPixel(4,extract8888rev,shove8888rev,
				newwidth,newheight,
				srcImage,dstImage,element_size,rowsize,
				myswap_bytes);
			break;
		case GL_UNSIGNED_INT_10_10_10_2:
			halveImagePackedPixel(4,extract1010102,shove1010102,
				newwidth,newheight,
				srcImage,dstImage,element_size,rowsize,
				myswap_bytes);
			break;
		case GL_UNSIGNED_INT_2_10_10_10_REV:
			halveImagePackedPixel(4,extract2101010rev,shove2101010rev,
				newwidth,newheight,
				srcImage,dstImage,element_size,rowsize,
				myswap_bytes);
			break;
		default:
			assert(0);
			break;
		}

		__GLU_SWAP_IMAGE(srcImage,dstImage);

		if (newwidth > 1) { newwidth /= 2; rowsize /= 2;}
		if (newheight > 1) newheight /= 2;
		{
			/* compute amount to pad per row, if any */
			int rowPad= rowsize % psm.unpack_alignment;

			/* should row be padded? */
			if (rowPad == 0) {	/* nope, row should not be padded */
				/* call tex image with srcImage untouched since it's not padded */
				if (baseLevel <= level && level <= maxLevel) {
					glTexImage2D(target, level, internalFormat, newwidth, newheight, 0,
						format, type, (void *) srcImage);
				}
			}
			else {			/* yes, row should be padded */
				/* compute length of new row in bytes, including padding */
				int newRowLength= rowsize + psm.unpack_alignment - rowPad;
				int ii; unsigned char *dstTrav, *srcTrav; /* indices for copying */

				/* allocate new image for mipmap of size newRowLength x newheight */
				void *newMipmapImage= malloc((size_t) (newRowLength*newheight));
				if (newMipmapImage == NULL) {
					/* out of memory so return */
					glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
					glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
					glPixelStorei(GL_UNPACK_SKIP_PIXELS, psm.unpack_skip_pixels);
					glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
					glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);
					return GLU_OUT_OF_MEMORY;
				}

				/* copy image from srcImage into newMipmapImage by rows */
				for (ii= 0,
					dstTrav= (unsigned char *) newMipmapImage,
					srcTrav= (unsigned char *) srcImage;
				ii< newheight;
				ii++,
					dstTrav+= newRowLength, /* make sure the correct distance... */
					srcTrav+= rowsize) {    /* ...is skipped */
						memcpy(dstTrav,srcTrav,rowsize);
						/* note that the pad bytes are not visited and will contain
						* garbage, which is ok.
						*/
				}

				/* ...and use this new image for mipmapping instead */
				if (baseLevel <= level && level <= maxLevel) {
					glTexImage2D(target, level, internalFormat, newwidth, newheight, 0,
						format, type, newMipmapImage);
				}
				free(newMipmapImage); /* don't forget to free it! */
			} /* else */
		}
	} /* for level */
	glPixelStorei(GL_UNPACK_ALIGNMENT, psm.unpack_alignment);
	glPixelStorei(GL_UNPACK_SKIP_ROWS, psm.unpack_skip_rows);
	glPixelStorei(GL_UNPACK_SKIP_PIXELS, psm.unpack_skip_pixels);
	glPixelStorei(GL_UNPACK_ROW_LENGTH, psm.unpack_row_length);
	glPixelStorei(GL_UNPACK_SWAP_BYTES, psm.unpack_swap_bytes);

	free(srcImage); /*if you get to here, a srcImage has always been malloc'ed*/
	if (dstImage) { /* if it's non-rectangular and only 1 level */
		free(dstImage);
	}
	return 0;
} /* gluBuild2DMipmapLevelsCore() */


GLint GLAPIENTRY
gluBuild3DMipmaps(GLenum target, GLint internalFormat,
				  GLsizei width, GLsizei height, GLsizei depth,
				  GLenum format, GLenum type, const void *data)
{
	GLint widthPowerOf2, heightPowerOf2, depthPowerOf2;
	int level, levels;

	int rc= checkMipmapArgs(internalFormat,format,type);
	if (rc != 0) return rc;

	if (width < 1 || height < 1 || depth < 1) {
		return GLU_INVALID_VALUE;
	}

	if(type == GL_BITMAP) {
		return GLU_INVALID_ENUM;
	}

	closestFit3D(target,width,height,depth,internalFormat,format,type,
		&widthPowerOf2,&heightPowerOf2,&depthPowerOf2);

	levels = computeLog(widthPowerOf2);
	level = computeLog(heightPowerOf2);
	if (level > levels) levels=level;
	level = computeLog(depthPowerOf2);
	if (level > levels) levels=level;

	return gluBuild3DMipmapLevelsCore(target, internalFormat,
		width, height, depth,
		widthPowerOf2, heightPowerOf2,
		depthPowerOf2,
		format, type, 0, 0, levels,
		data);
} /* gluBuild3DMipmaps() */

static int checkMipmapArgs(GLenum internalFormat, GLenum format, GLenum type)
{
	if (!legalFormat(format) || !legalType(type)) {
		return GLU_INVALID_ENUM;
	}
	if (format == GL_STENCIL_INDEX) {
		return GLU_INVALID_ENUM;
	}

	if (!isLegalFormatForPackedPixelType(format, type)) {
		return GLU_INVALID_OPERATION;
	}

	return 0;
} /* checkMipmapArgs() */

static GLboolean legalFormat(GLenum format)
{
	switch(format) {
	  case GL_COLOR_INDEX:
	  case GL_STENCIL_INDEX:
	  case GL_DEPTH_COMPONENT:
	  case GL_RED:
	  case GL_GREEN:
	  case GL_BLUE:
	  case GL_ALPHA:
	  case GL_RGB:
	  case GL_RGBA:
	  case GL_LUMINANCE:
	  case GL_LUMINANCE_ALPHA:
	  case GL_BGR:
	  case GL_BGRA:
		  return GL_TRUE;
	  default:
		  return GL_FALSE;
	}
}

static GLboolean legalType(GLenum type)
{
	switch(type) {
	  case GL_BITMAP:
	  case GL_BYTE:
	  case GL_UNSIGNED_BYTE:
	  case GL_SHORT:
	  case GL_UNSIGNED_SHORT:
	  case GL_INT:
	  case GL_UNSIGNED_INT:
	  case GL_FLOAT:
	  case GL_UNSIGNED_BYTE_3_3_2:
	  case GL_UNSIGNED_BYTE_2_3_3_REV:  
	  case GL_UNSIGNED_SHORT_5_6_5:
	  case GL_UNSIGNED_SHORT_5_6_5_REV:
	  case GL_UNSIGNED_SHORT_4_4_4_4:
	  case GL_UNSIGNED_SHORT_4_4_4_4_REV:
	  case GL_UNSIGNED_SHORT_5_5_5_1:
	  case GL_UNSIGNED_SHORT_1_5_5_5_REV:
	  case GL_UNSIGNED_INT_8_8_8_8:
	  case GL_UNSIGNED_INT_8_8_8_8_REV:
	  case GL_UNSIGNED_INT_10_10_10_2:
	  case GL_UNSIGNED_INT_2_10_10_10_REV:
		  return GL_TRUE;
	  default:
		  return GL_FALSE;
	}
}

/* Determines if the packed pixel type is compatible with the format */
static GLboolean isLegalFormatForPackedPixelType(GLenum format, GLenum type)
{
	/* if not a packed pixel type then return true */
	if (!isTypePackedPixel(type)) {
		return GL_TRUE;
	}

	/* 3_3_2/2_3_3_REV & 5_6_5/5_6_5_REV are only compatible with RGB */
	if ((type == GL_UNSIGNED_BYTE_3_3_2 || type == GL_UNSIGNED_BYTE_2_3_3_REV||
		type == GL_UNSIGNED_SHORT_5_6_5|| type == GL_UNSIGNED_SHORT_5_6_5_REV)
		&& format != GL_RGB)
		return GL_FALSE;

	/* 4_4_4_4/4_4_4_4_REV & 5_5_5_1/1_5_5_5_REV & 8_8_8_8/8_8_8_8_REV &
	* 10_10_10_2/2_10_10_10_REV are only compatible with RGBA, BGRA & ABGR_EXT.
	*/
	if ((type == GL_UNSIGNED_SHORT_4_4_4_4 ||
		type == GL_UNSIGNED_SHORT_4_4_4_4_REV ||
		type == GL_UNSIGNED_SHORT_5_5_5_1 ||
		type == GL_UNSIGNED_SHORT_1_5_5_5_REV ||
		type == GL_UNSIGNED_INT_8_8_8_8 ||
		type == GL_UNSIGNED_INT_8_8_8_8_REV ||
		type == GL_UNSIGNED_INT_10_10_10_2 ||
		type == GL_UNSIGNED_INT_2_10_10_10_REV) &&
		(format != GL_RGBA &&
		format != GL_BGRA)) {
			return GL_FALSE;
	}

	return GL_TRUE;
} /* isLegalFormatForPackedPixelType() */

/* */
static GLboolean isTypePackedPixel(GLenum type)
{
	assert(legalType(type));

	if (type == GL_UNSIGNED_BYTE_3_3_2 ||
		type == GL_UNSIGNED_BYTE_2_3_3_REV ||
		type == GL_UNSIGNED_SHORT_5_6_5 ||
		type == GL_UNSIGNED_SHORT_5_6_5_REV ||
		type == GL_UNSIGNED_SHORT_4_4_4_4 ||
		type == GL_UNSIGNED_SHORT_4_4_4_4_REV ||
		type == GL_UNSIGNED_SHORT_5_5_5_1 ||
		type == GL_UNSIGNED_SHORT_1_5_5_5_REV ||
		type == GL_UNSIGNED_INT_8_8_8_8 ||
		type == GL_UNSIGNED_INT_8_8_8_8_REV ||
		type == GL_UNSIGNED_INT_10_10_10_2 ||
		type == GL_UNSIGNED_INT_2_10_10_10_REV) {
			return 1;
	}
	else return 0;
} /* isTypePackedPixel() */

/* Given user requested texture size, determine if it fits. If it
* doesn't then halve both sides and make the determination again
* until it does fit (for IR only).
* Note that proxy textures are not implemented in RE* even though
* they advertise the texture extension.
* Note that proxy textures are implemented but not according to spec in
* IMPACT*.
*/
static void closestFit(GLenum target, GLint width, GLint height,
					   GLint internalFormat, GLenum format, GLenum type,
					   GLint *newWidth, GLint *newHeight)
{
	/* Use proxy textures if OpenGL version is >= 1.1 */
	if ( (strtod((const char *)glGetString(GL_VERSION),NULL) >= 1.1)
		) {
			GLint widthPowerOf2= nearestPower(width);
			GLint heightPowerOf2= nearestPower(height);       
			GLint proxyWidth;

			do {
				/* compute level 1 width & height, clamping each at 1 */
				GLint widthAtLevelOne= (widthPowerOf2 > 1) ?
					widthPowerOf2 >> 1 :
				widthPowerOf2;
				GLint heightAtLevelOne= (heightPowerOf2 > 1) ?
					heightPowerOf2 >> 1 :
				heightPowerOf2;
				GLenum proxyTarget;
				assert(widthAtLevelOne > 0); assert(heightAtLevelOne > 0);

				/* does width x height at level 1 & all their mipmaps fit? */
				if (target == GL_TEXTURE_2D || target == GL_PROXY_TEXTURE_2D) {
					proxyTarget = GL_PROXY_TEXTURE_2D;
					glTexImage2D(proxyTarget, 1, /* must be non-zero */
						internalFormat,
						widthAtLevelOne,heightAtLevelOne,0,format,type,NULL);
				} else
#if defined(GL_ARB_texture_cube_map)
					if ((target == GL_TEXTURE_CUBE_MAP_POSITIVE_X_ARB) ||
						(target == GL_TEXTURE_CUBE_MAP_NEGATIVE_X_ARB) ||
						(target == GL_TEXTURE_CUBE_MAP_POSITIVE_Y_ARB) ||
						(target == GL_TEXTURE_CUBE_MAP_NEGATIVE_Y_ARB) ||
						(target == GL_TEXTURE_CUBE_MAP_POSITIVE_Z_ARB) ||
						(target == GL_TEXTURE_CUBE_MAP_NEGATIVE_Z_ARB)) {
							proxyTarget = GL_PROXY_TEXTURE_CUBE_MAP_ARB;
							glTexImage2D(proxyTarget, 1, /* must be non-zero */
								internalFormat,
								widthAtLevelOne,heightAtLevelOne,0,format,type,NULL);
					} else
#endif /* GL_ARB_texture_cube_map */
					{
						assert(target == GL_TEXTURE_1D || target == GL_PROXY_TEXTURE_1D);
						proxyTarget = GL_PROXY_TEXTURE_1D;
						glTexImage1D(proxyTarget, 1, /* must be non-zero */
							internalFormat,widthAtLevelOne,0,format,type,NULL);
					}
					glGetTexLevelParameteriv(proxyTarget, 1,GL_TEXTURE_WIDTH,&proxyWidth);
					/* does it fit??? */
					if (proxyWidth == 0) { /* nope, so try again with these sizes */
						if (widthPowerOf2 == 1 && heightPowerOf2 == 1) {
							/* An 1x1 texture couldn't fit for some reason, so
							* break out.  This should never happen. But things
							* happen.  The disadvantage with this if-statement is
							* that we will never be aware of when this happens
							* since it will silently branch out.
							*/
							goto noProxyTextures;
						}
						widthPowerOf2= widthAtLevelOne;
						heightPowerOf2= heightAtLevelOne;
					}
					/* else it does fit */
			} while (proxyWidth == 0);
			/* loop must terminate! */

			/* return the width & height at level 0 that fits */
			*newWidth= widthPowerOf2;
			*newHeight= heightPowerOf2;
			/*printf("Proxy Textures\n");*/
	} /* if gluCheckExtension() */
	else {			/* no texture extension, so do this instead */
		GLint maxsize;

noProxyTextures:

		glGetIntegerv(GL_MAX_TEXTURE_SIZE, &maxsize);
		/* clamp user's texture sizes to maximum sizes, if necessary */
		*newWidth = nearestPower(width);
		if (*newWidth > maxsize) *newWidth = maxsize;
		*newHeight = nearestPower(height);
		if (*newHeight > maxsize) *newHeight = maxsize;
		/*printf("NO proxy textures\n");*/
	}
} /* closestFit() */