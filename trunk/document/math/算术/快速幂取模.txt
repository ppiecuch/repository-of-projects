利用二进制扫描的方法快速的计算ab mod c，显然用常规方法计算74237 mod 4233计算量过大。

基本原理：（a×b）mod c=((a mod c)×b）mod c

例如：35 mod 7=3(101)2 mod 7=((3(100)2 mod 7)×3）mod 7=((9(10)2 mod 7)×3）mod 7=(((9 mod 7)(10)2 mod 7)×3）mod 7=((2(10)2 mod 7)×3）mod 7=((4(1)2 mod 7)×3）mod 7=(4×3）mod 7=5

实现代码如下（C语言版）

[cpp] view plaincopyprint?int exp_mod(int a,int b,int n){  
    int r=1;  
    while(b){  
        if(b&1)r=(r*a)%n;  
        a=(a*a)%n;  
        b>>=1;          
    }  
    return r;  
}  
int exp_mod(int a,int b,int n){
	int r=1;
	while(b){
		if(b&1)r=(r*a)%n;
		a=(a*a)%n;
		b>>=1;		
	}
	return r;
}时间复杂度分析：若a、b、n都是β位数，则所需算术运算的次数是O(β)，所需位操作总次数是O(β3)
http://blog.csdn.net/kingwolfofsky/article/details/7209327