3维向量―axis-angle

首先，所有转动以及转动的组合都可以找到一个等价的转动方式：绕空间中的某一轴，转动某一角度。这是用3维向量表示转动的基础。

在这种表示用，有一个3元素的vector表示转动。Vector的方向表示转动得轴，其长度表示转动得角度。一般为表示弧度。其长度的范围为从0到pi。

 

这种表示方式的优点是紧凑，转动只有3个自由度，axis-angle法以最少的项表示了转动。但是这种表示有一个重要的缺陷，如果有两个vector分别表示了两个转动，两个转动叠加后的转动，无法用简单的方式从这两个vector中计算得出。即：axis-angle表示法无法有效进行转动叠加的计算。

虽然如此，以axis-angle方式来表示转动速度时，却可以有效得计算转度速度的叠加。用vector表示转动速度时，vector的方向表示转动轴，vector的长度表示转动的速度，一般为弧度/秒。要计算两个转动速度的叠加时，将两个向量进行向量相加即可。

 

四元数法quaternion

四元数是一个四维向量：[w, x, y, z] =

[        cos angle/2 ,

x * sin angle/2

y * sin angle/2

z * sin angle/2 ]

其中，[x,y,z]是旋转的轴（x^2 + y^2 +z^2 = 1即这个向量长度为1），angle是旋转的角度。即四元数表示可以从3维向量表示中得出。

四元数表示法的数学理论基础是复数理论，即一个四元数是有一个实数(w)与3个虚数(xyz)相加得到。

四元数来表示转动时，其性质是length=1，即sqrt(w^2 + x^2 + y^2 + z^2) = 1。所以将一个四元数normalize即可使其代表一个转动。

四元数来做转动的表示方式，可以很方便得对转动进行叠加。若q1(w1,x1,y1,z1)与q2(w2,x2,y2,z2)代表两个旋转，其叠加后的旋转可以用四元数q来表示，并且有q = q1 * q2 =

[

         w1*w2 C x1*x2 C y1*y2 C z1*z2 ,

         w1*x2 + x1*w2 + y1*z2 Cz1*y2 ,

         w1*y2 C x1*z2 + y1*w2 + z1*x2 ,

         w1*z2 + x1*y2 C y1*x2 + z1*w2

]（到底是先进行q1旋转还是q2旋转现在还每搞清楚。。。）

 

四元数法与3维向量表示的转动速度相结合，也可方便得对转动进行更新。

 

矩阵法matrices

3*3矩阵在右乘一个3维向量时，可以对这个向量进行变换。当向量代表一个顶点，并且矩阵取某些值得时候，对3维向量进行变换等同于对其进行绕某一轴旋转。所以矩阵可以代表一个转动。所以这种表示的方式的优点也是可以对3维向量进行旋转变换。

V’ = M*V

同时矩阵表示法也可以方便得进行转动得叠加。假设矩阵M1，M2代表两个旋转，一个先做M1再做M2的转动，可表示为矩阵M = M2*M1.

 旋转矩阵有些非常有用的性质，首先旋转矩阵都是正交阵。这意味着旋转矩阵一定有逆，并且其逆矩阵等于其转置矩阵。

假设有一局部坐标系在世界坐标系中三个轴可以表示为3个向量 v1 (x轴),  v2 (y轴),  v3 (z轴)，则矩M = [v1, v2, v3], 就是从世界坐标旋转到局部坐标系的旋转矩阵。

3种表示方式的转换

四元数和3维向量法可以很直观地方便的转换。从3维向量表示到矩阵表示的转换也比较自然：

M =

[

 tx^2 + c          txy + sz   txz - sy

 txy C sz                    ty^2 + c   tyz + sx

 txz + sy            tyz C sx   tz^2 + x

]

 

四元数与矩阵的相互转换，矩阵到3维向量的转换的算法则相对比较复杂。

虽然这3种方式的相互转化方法都是存在的，但必须明确的是， 四元数法来表示转动时，不具有唯一性。每个四元数可以表示一种唯一的转动，而每一个转动可以用两个不同的四元数来表示。实际上，这两个四元数的每个项都是另一个的负。如果axis-angle的角度值是从0到2*pi，则每一个axis-angle表示法都可以表示唯一的一个转动，而每一个转动都可以有两个不同的axis-angle表示法来表示。这两个不同的3维向量方向相反，长度加起来等于2*pi。而矩阵的表示法则是唯一的，一个转动，只有一个矩阵来表示它。不存在有两个不同的矩阵表示同一个转动。所以在相互转化时，需要考虑转化结果的唯一性问题。

欧拉角

欧拉角也是一种表示旋转的方式。相当于用3个旋转角度来表示一个旋转。这个旋转是这个3个绕坐标轴的旋转的叠加。一般这3个旋转的名称为pitch, yaw, roll。但是每个旋转对应哪个轴，貌似没有规定，只要相邻的两个旋转不是同一个轴就可以。如xyz，xzx都是可以的。需要注意的是这3个旋转轴都是以旋转物体的自身坐标系为参考的，即进行第一个旋转之后，后两个旋转绕的转动轴也会转动。这个旋转不方便进计算，但是比较容易让人理解，所以许多做旋转的交互式，会以这种方式作为旋转的输入形式。

 

 

更多详细的信息可以参考http://blog.csdn.net/gogoda/archive/2009/06/22/4287455.aspx

 

bullet的linearMath中quaternion相乘测试

 

btQuaternion x90(0.707107, 0, 0, 0.707107); //绕x轴90度
 btQuaternion y90(0, 0.707107, 0, 0.707107); //绕x轴90度

 btQuaternion xy = x90;
 xy*=y90;

 btQuaternion yx = y90;
 yx*=x90;

 btMatrix3x3 mx,my,mxy,myx;

 
 mx.setRotation(x90);
 my.setRotation(y90);
 mxy.setRotation(xy);
 myx.setRotation(yx);

 btVector3 v(10,0,1);
 btVector3 v1,v2;

 mat_mult(mx, v, v1);
 cout<<"x90: "; print(v1);

 mat_mult(my, v, v1);
 cout<<"y90: "; print(v1);

 mat_mult(mx, v, v1);
 mat_mult(my, v1, v2);
 cout<<"x90 and y90: "; print(v2);
 mat_mult(mxy, v, v1);
 cout<<"xy: "; print(v1);

 mat_mult(my, v, v1);
 mat_mult(mx, v1, v2);
 cout<<"y90 and x90: "; print(v2);
 mat_mult(myx, v, v1);
 cout<<"yx: "; print(v1);

 /**************************************/

测试结果：

 x90: 10 -1      0
y90: 1  0       -10
x90 and y90: 0  -1      -10
xy: 1   10      0
y90 and x90: 1  10      0
yx: 0   -1      -10

在bullet中，四元数相乘采用的是上述的算反，q1*=q2 相当于 q1 = q1 * q2 

结果说明相乘的结果的旋转顺序是：先进行右边项的旋转，再进行左边项的旋转。在这里则是q1 * q2,会先进行q2的旋转，再进行q1的旋转。跟矩阵相乘变换顶点的顺序一致

http://hi.baidu.com/%C4%A6%F4%C9%D1%DB%C0%E1/blog/item/5b4967ed0a743626b80e2d88.html