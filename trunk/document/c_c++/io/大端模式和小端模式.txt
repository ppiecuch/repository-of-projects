大端格式：
在这种格式中，字数据的高字节存储在低地址中，而字数据的低字节则存放在高地址中，如图2.1所示：
 

小端格式：
与大端存储格式相反，在小端存储格式中，低地址中存放的是字数据的低字节，高地址存放的是字数据的高字节。如图2.2所示：
 

 请写一个C函数，若处理器是Big_endian的，则返回0；若是Little_endian的，则返回1
解答：
int checkCPU( )
{
    {
           union w
           {  
                  int  a;
                  char b;
           } c;
           c.a = 1;
           return(c.b ==1);
    }
}
剖析：
嵌入式系统开发者应该对Little-endian和Big-endian模式非常了解。例如，16bit宽的数0x1234在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：
内存地址
0x4000
0x4001
存放内容
0x34
0x12
而在Big-endian模式CPU内存中的存放方式则为：
内存地址
0x4000
0x4001
存放内容
0x12
0x34
 
32bit宽的数0x12345678在Little-endian模式CPU内存中的存放方式（假设从地址0x4000开始存放）为：
内存地址
0x4000
0x4001
0x4002
0x4003
存放内容
0x78
0x56
0x34
0x12
而在Big-endian模式CPU内存中的存放方式则为：
内存地址
0x4000
0x4001
0x4002
0x4003
存放内容
0x12
0x34
0x56
0x78
联合体union的存放顺序是所有成员都从低地址开始存放。
=============== 呵呵 还是附上 另一段代码吧，摘自一个开源项目 ====
int  big_endian (void)
     {
       union{
          long l;
          char c[sizeof(long)];
       }u;
 
       u.l = 1;
       return  (u.c[sizeof(long) - 1] == 1);
     }
  
 
有时候，用C语言写程序时需要知道是大端模式还是小端模式。 所谓的大端模式，是指数据的低位保存在内存的高地址中，而数据的高位，保存在内存的低地址中；所谓的小端模式，是指数据的低位保存在内存的低地址中，而数据的高位保存在内存的高地址中。为什么会有大小端模式之分呢？这是因为在计算机系统中，我们是以字节为单位的，每个地址单元都对应着一个字节，一个字节为8bit。但是在C语言中除了8bit的char之外，还有16bit的short型，32bit的long型（要看具体的编译器），另外，对于位数大于8位的处理器，例如16位或者32位的处理器，由于寄存器宽度大于一个字节，那么必然存在着一个如果将多个字节安排的问题。因此就导致了大端存储模式和小端存储模式。例如一个16bit的short型x，在内存中的地址为0x0010，x的值为0x1122，那么0x11为高字节，0x22为低字节。对于大端模式，就将0x11放在低地址中，即0x0010中，0x22放在高地址中，即0x0011中。小端模式，刚好相反。我们常用的X86结构是小端模式，而KEIL C51则为大端模式。很多的ARM，DSP都为小端模式。有些ARM处理器还可以由硬件来选择是大端模式还是小端模式。
 
下面这段代码可以用来测试一下你的编译器是大端模式还是小端模式：
 
short int x;

char x0,x1;

x=0x1122;

x0=((char*)&x)[0];  //低地址单元
x1=((char*)&x)[1];  //高地址单元

若x0=0x11,则是大端; 若x0=0x22,则是小端......

http://www.cnblogs.com/TsuiLei/archive/2008/10/29/1322504.html