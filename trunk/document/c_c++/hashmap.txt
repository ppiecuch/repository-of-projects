2010-1-30 created

1.hash_map属于非标准STL
2.g++使用的是HP/SGI的hash_map
3.存在目录<ext/hashmap>下面，放在了namespace __gnu_cxx下面
4.typedef hash_map<Key,Value> HashMap，对于Key需要提供hash函数和equal_to函数.
5.对于初始化的时候会指定一个n表示桶的大小..并且随着元素增多桶会自动扩容
6.对于一些基本类型已经提供了hash和equal_to函数，尤其是const char*特别有用.
7.个人感觉hash_map很多东西都不好handle住..
但是使用起来就像是map一样...没有太大的差别:-)
1  #include <ext/hash_map>
2  #include <string>
3  #include <iostream>
4  using namespace std;
5  using namespace __gnu_cxx;
6  int main()
7  {
8      typedef hash_map<const char *,string>HashMap;
9      HashMap mp(100);
10      mp["hello"]="fuckyou";
11      mp["hello2"]="fuckyou2";
12      mp.erase("hello");
13      for(HashMap::iterator it=mp.begin();it!=mp.end();++it){
14          cout<<it->first<<" "<<it->second<<endl;
15      }
16      return 0;
17  }
那些基本类型的hash函数[函数对象]是hash<int>,...hash<const char*>等..比如:
1  #include <ext/hash_map>
2  #include <string>
3  #include <iostream>
4  using namespace std;
5  using namespace __gnu_cxx;
6  int main()
7  {
8      hash<const char*> Hash;
9      cout<<Hash("hello,world")<<endl;
10      return 0;
11  }
如果Key使用自定义类型的话，需要提供hash以及equal_to函数
1  #include <ext/hash_map>
2  #include <string>
3  #include <iostream>
4  using namespace std;
5  using namespace __gnu_cxx;
6  struct A
7  {
8      string _txt;
9      A(const string &txt):_txt(txt){}
10      string txt() const
11      {
12          return _txt;
13      }
14      friend ostream & operator<<(ostream &os,const A &a);
15  };

16  ostream & operator<<(ostream &os,const A &a)
17  {
18      os<<a.txt();
19      return os;
20  }

21  struct HashA
22  {
23      size_t operator()(const A &p) const
24      {
25          hash<const char*> tmp;
26          return tmp(p.txt().c_str());
27      }
28  };
29  struct EqualA
30  {
31      bool operator()(const A &a,const A&b)const
32      {
33          return a.txt()==b.txt();
34      }
35  };

36  int main()
37  {
38      typedef hash_map<A,string,HashA,EqualA>HashMap;
39      HashMap mp;
40      mp[A("hello")]="fuck";
41      mp[A("hello2")]="fuck2";
42      for(HashMap::iterator it=mp.begin();it!=mp.end();++it){
43          cout<<it->first<<" "<<it->second<<endl;
44      }
45      return 0;
46  }
http://hi.baidu.com/dirlt/blog/item/4e6734a98f0843f71e17a239.html