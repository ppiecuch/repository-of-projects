程序的内存划分为三类。 
1：静态内存区，主要存放全局变量和用用static定义的变量，这部分内存在程序编译时刻已经 
分配好，并且在整个程序运行期间都存在。 
2：在栈（statc）创建内存，这部分主要是程序运行期间，定义的临时对象，调用函数时在函数 
内部定义的变量，比如 
fun（） 
{ 
int   i；//   栈上创建 

} 
当结束临时对象的生命期时，或者调用函数结束时，在栈上创建的对象，会被系统自动回收 
这就是为什么我们 
定义   int   i； 
或者   class   A；A   a; 
不会产生内存泄露的原因，因为系统自动回收了这部分内存。 
在栈上创建对象的好处是：栈内存分配运算内置于处理器的指令集 
中，效率很高，但是分配的内存容量有限。 
3：在堆（heap）创建对象，主要是用户通过调用new/delete或者malloc/free来创建销毁对象 
好处是：用户可以根据自己要求创建内存大小，非常灵活。 
缺点是：这部分内存必须有用户自己来销毁，也就是这部分最容易造成内存泄露。执行速度相对于在栈上的速度要慢。 
例子说明 
int   iTemp(10);//   静态存储区 
static   char   chTemp[]   =   "test ";//静态存储区 
int   fun   (int   i) 
{ 
int   j   =   i;//j,i都是在栈上创建 
cout   < <   j; 
ruturn   j*2；//   返回值是在栈上创建 
} 
int   fun1()//   以下是错误定义，仅为说明问题 
{ 
int   *p   =   new   int(10);//堆上创建 
int   *p1   =   (int*)malloc   (sizeof(int));//堆上创建 
return   (*p); 
} 
int   main() 
{ 
int   itemp;//栈上创建 
int   *p   =   new   int(10);//堆上创建 
int   *p1   =   (int*)malloc   (sizeof(int));//堆上创建 
} 
还有把new   和delete   与malloc   和free   混在一起用也是个坏想法。对一个用new 
获取来的指针调用free，或者对一个用malloc   获取来的指针调用delete，其后 
果是不可预测的 
原因是：new是C++的操作符，用new可以创建class对象，可以申请适合class对象大小的内存 
并可以执行class的构造函数，创建类对象，用delete时，不但可以销毁new的内存，并且还可以 
对class对象，调用析购函数，释放class申请的资源。如果用是class对象，用new申请，用free 
释放，会有什么发生那？free只是释放内存空间，并没有析购class对象，也就是说对象并没有 
被销毁，造成内存泄露。 
如果用malloc申请，用delete释放那，理论上来说是没有问题的，但是我想谁也不乐意这么做。 

还有使用new和malloc，一定要和delete和free成对出现、要注意防止内存泄露。 
当然如果你用STL的auto_ptr可以不用显示delete，由系统帮你delete。

http://topic.csdn.net/t/20051027/09/4353236.html