C++ 虚函数表解析

 

陈皓

http://blog.csdn.net/haoel

 

 

前言
 

C++中的虚函数的作用主要是实现了多态的机制。关于多态，简而言之就是用父类型别的指针指向其子类的实例，然后通过父类的指针调用实际子类的成员函数。这种技术可以让父类的指针有“多种形态”，这是一种泛型技术。所谓泛型技术，说白了就是试图使用不变的代码来实现可变的算法。比如：模板技术，RTTI技术，虚函数技术，要么是试图做到在编译时决议，要么试图做到运行时决议。

 

 

关于虚函数的使用方法，我在这里不做过多的阐述。大家可以看看相关的C++的书籍。在这篇文章中，我只想从虚函数的实现机制上面为大家 一个清晰的剖析。

 

当然，相同的文章在网上也出现过一些了，但我总感觉这些文章不是很容易阅读，大段大段的代码，没有图片，没有详细的说明，没有比较，没有举一反三。不利于学习和阅读，所以这是我想写下这篇文章的原因。也希望大家多给我提意见。

 

言归正传，让我们一起进入虚函数的世界。

 

 

虚函数表
 

对C++ 了解的人都应该知道虚函数（Virtual Function）是通过一张虚函数表（Virtual Table）来实现的。简称为V-Table。在这个表中，主是要一个类的虚函数的地址表，这张表解决了继承、覆盖的问题，保证其容真实反应实际的函数。这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中，所以，当我们用父类的指针来操作一个子类的时候，这张虚函数表就显得由为重要了，它就像一个地图一样，指明了实际所应该调用的函数。

 

这里我们着重看一下这张虚函数表。C++的编译器应该是保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证取到虚函数表的有最高的性能――如果有多层继承或是多重继承的情况下）。 这意味着我们通过对象实例的地址得到这张虚函数表，然后就可以遍历其中函数指针，并调用相应的函数。

 

听我扯了那么多，我可以感觉出来你现在可能比以前更加晕头转向了。 没关系，下面就是实际的例子，相信聪明的你一看就明白了。

 

假设我们有这样的一个类：

 

class Base {

     public:

            virtual void f() { cout << "Base::f" << endl; }

            virtual void g() { cout << "Base::g" << endl; }

            virtual void h() { cout << "Base::h" << endl; }

 

};

 

按照上面的说法，我们可以通过Base的实例来得到虚函数表。 下面是实际例程：

 

          typedef void(*Fun)(void);

 

            Base b;

 

            Fun pFun = NULL;

 

            cout << "虚函数表地址：" << (int*)(&b) << endl;

            cout << "虚函数表 ― 第一个函数地址：" << (int*)*(int*)(&b) << endl;

 

            // Invoke the first virtual function  

            pFun = (Fun)*((int*)*(int*)(&b));

            pFun();

 

实际运行经果如下：(Windows XP+VS2003,  Linux 2.6.22 + GCC 4.1.3)

 

虚函数表地址：0012FED4

虚函数表 ― 第一个函数地址：0044F148

Base::f

 

 

通过这个示例，我们可以看到，我们可以通过强行把&b转成int *，取得虚函数表的地址，然后，再次取址就可以得到第一个虚函数的地址了，也就是Base::f()，这在上面的程序中得到了验证（把int* 强制转成了函数指针）。通过这个示例，我们就可以知道如果要调用Base::g()和Base::h()，其代码如下：

 

            (Fun)*((int*)*(int*)(&b)+0);  // Base::f()

            (Fun)*((int*)*(int*)(&b)+1);  // Base::g()

            (Fun)*((int*)*(int*)(&b)+2);  // Base::h()

 

这个时候你应该懂了吧。什么？还是有点晕。也是，这样的代码看着太乱了。没问题，让我画个图解释一下。如下所示：






注意：在上面这个图中，我在虚函数表的最后多加了一个结点，这是虚函数表的结束结点，就像字符串的结束符“\0”一样，其标志了虚函数表的结束。这个结束标志的值在不同的编译器下是不同的。在WinXP+VS2003下，这个值是NULL。而在Ubuntu 7.10 + Linux 2.6.22 + GCC 4.1.3下，这个值是如果1，表示还有下一个虚函数表，如果值是0，表示是最后一个虚函数表。

 

 

下面，我将分别说明“无覆盖”和“有覆盖”时的虚函数表的样子。没有覆盖父类的虚函数是毫无意义的。我之所以要讲述没有覆盖的情况，主要目的是为了给一个对比。在比较之下，我们可以更加清楚地知道其内部的具体实现。

 

一般继承（无虚函数覆盖）
 

下面，再让我们来看看继承时的虚函数表是什么样的。假设有如下所示的一个继承关系：

 




 

请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：



 

对于实例：Derive d; 的虚函数表如下：





 

我们可以看到下面几点：

1）虚函数按照其声明顺序放于表中。

2）父类的虚函数在子类的虚函数前面。

 

我相信聪明的你一定可以参考前面的那个程序，来编写一段程序来验证。

 

 

 

一般继承（有虚函数覆盖）
 

覆盖父类的虚函数是很显然的事情，不然，虚函数就变得毫无意义。下面，我们来看一下，如果子类中有虚函数重载了父类的虚函数，会是一个什么样子？假设，我们有下面这样的一个继承关系。

 

 


 

为了让大家看到被继承过后的效果，在这个类的设计中，我只覆盖了父类的一个函数：f()。那么，对于派生类的实例，其虚函数表会是下面的一个样子：

 




 


我们从表中可以看到下面几点，

1）覆盖的f()函数被放到了虚表中原来父类虚函数的位置。

2）没有被覆盖的函数依旧。

 

这样，我们就可以看到对于下面这样的程序，

 

            Base *b = new Derive();

 

            b->f();

 

由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。

 

 

 

多重继承（无虚函数覆盖）
 

下面，再让我们来看看多重继承中的情况，假设有下面这样一个类的继承关系。注意：子类并没有覆盖父类的函数。

 


 

 

对于子类实例中的虚函数表，是下面这个样子：




 


我们可以看到：

1）  每个父类都有自己的虚表。

2）  子类的成员函数被放到了第一个父类的表中。（所谓的第一个父类是按照声明顺序来判断的）

 

这样做就是为了解决不同的父类类型的指针指向同一个子类实例，而能够调用到实际的函数。

 

 

 

 

多重继承（有虚函数覆盖）
 

下面我们再来看看，如果发生虚函数覆盖的情况。

 

下图中，我们在子类中覆盖了父类的f()函数。

 


 

 

下面是对于子类实例中的虚函数表的图：

 




 

我们可以看见，三个父类虚函数表中的f()的位置被替换成了子类的函数指针。这样，我们就可以任一静态类型的父类来指向子类，并调用子类的f()了。如：

 

            Derive d;

            Base1 *b1 = &d;

            Base2 *b2 = &d;

            Base3 *b3 = &d;

            b1->f(); //Derive::f()

            b2->f(); //Derive::f()

            b3->f(); //Derive::f()

 

            b1->g(); //Base1::g()

            b2->g(); //Base2::g()

            b3->g(); //Base3::g()

 

 

安全性
 

每次写C++的文章，总免不了要批判一下C++。这篇文章也不例外。通过上面的讲述，相信我们对虚函数表有一个比较细致的了解了。水可载舟，亦可覆舟。下面，让我们来看看我们可以用虚函数表来干点什么坏事吧。

 

一、通过父类型的指针访问子类自己的虚函数

我们知道，子类没有重载父类的虚函数是一件毫无意义的事情。因为多态也是要基于函数重载的。虽然在上面的图中我们可以看到Base1的虚表中有Derive的虚函数，但我们根本不可能使用下面的语句来调用子类的自有虚函数：

 

          Base1 *b1 = new Derive();

            b1->f1();  //编译出错

 

任何妄图使用父类指针想调用子类中的未覆盖父类的成员函数的行为都会被编译器视为非法，所以，这样的程序根本无法编译通过。但在运行时，我们可以通过指针的方式访问虚函数表来达到违反C++语义的行为。（关于这方面的尝试，通过阅读后面附录的代码，相信你可以做到这一点）

 

 

二、访问non-public的虚函数

另外，如果父类的虚函数是private或是protected的，但这些非public的虚函数同样会存在于虚函数表中，所以，我们同样可以使用访问虚函数表的方式来访问这些non-public的虚函数，这是很容易做到的。

 

如：

 

class Base {

    private:

            virtual void f() { cout << "Base::f" << endl; }

 

};

 

class Derive : public Base{

 

};

 

typedef void(*Fun)(void);

 

void main() {

    Derive d;

    Fun  pFun = (Fun)*((int*)*(int*)(&d)+0);

    pFun();

}

 

 

结束语
C++这门语言是一门Magic的语言，对于程序员来说，我们似乎永远摸不清楚这门语言背着我们在干了什么。需要熟悉这门语言，我们就必需要了解C++里面的那些东西，需要去了解C++中那些危险的东西。不然，这是一种搬起石头砸自己脚的编程语言。

 

在文章束之前还是介绍一下自己吧。我从事软件研发有十个年头了，目前是软件开发技术主管，技术方面，主攻Unix/C/C++，比较喜欢网络上的技术，比如分布式计算，网格计算，P2P，Ajax等一切和互联网相关的东西。管理方面比较擅长于团队建设，技术趋势分析，项目管理。欢迎大家和我交流，我的MSN和Email是：haoel@hotmail.com  

 

附录一：VC中查看虚函数表
 

我们可以在VC的IDE环境中的Debug状态下展开类的实例就可以看到虚函数表了（并不是很完整的）





附录 二：例程
下面是一个关于多重继承的虚函数表访问的例程：

 

#include <iostream>

using namespace std;

 

class Base1 {

public:

            virtual void f() { cout << "Base1::f" << endl; }

            virtual void g() { cout << "Base1::g" << endl; }

            virtual void h() { cout << "Base1::h" << endl; }

 

};

 

class Base2 {

public:

            virtual void f() { cout << "Base2::f" << endl; }

            virtual void g() { cout << "Base2::g" << endl; }

            virtual void h() { cout << "Base2::h" << endl; }

};

 

class Base3 {

public:

            virtual void f() { cout << "Base3::f" << endl; }

            virtual void g() { cout << "Base3::g" << endl; }

            virtual void h() { cout << "Base3::h" << endl; }

};

 

 

class Derive : public Base1, public Base2, public Base3 {

public:

            virtual void f() { cout << "Derive::f" << endl; }

            virtual void g1() { cout << "Derive::g1" << endl; }

};

 

 

typedef void(*Fun)(void);

 

int main() 

{

            Fun pFun = NULL;

 

            Derive d;

            int** pVtab = (int**)&d;

 

            //Base1's vtable

            //pFun = (Fun)*((int*)*(int*)((int*)&d+0)+0);

            pFun = (Fun)pVtab[0][0];

            pFun();

 

            //pFun = (Fun)*((int*)*(int*)((int*)&d+0)+1);

            pFun = (Fun)pVtab[0][1];

            pFun();

 

            //pFun = (Fun)*((int*)*(int*)((int*)&d+0)+2);

            pFun = (Fun)pVtab[0][2];

            pFun();

 

            //Derive's vtable

            //pFun = (Fun)*((int*)*(int*)((int*)&d+0)+3);

            pFun = (Fun)pVtab[0][3];

            pFun();

 

            //The tail of the vtable

            pFun = (Fun)pVtab[0][4];

            cout<<pFun<<endl;

 

 

            //Base2's vtable

            //pFun = (Fun)*((int*)*(int*)((int*)&d+1)+0);

            pFun = (Fun)pVtab[1][0];

            pFun();

 

            //pFun = (Fun)*((int*)*(int*)((int*)&d+1)+1);

            pFun = (Fun)pVtab[1][1];

            pFun();

 

            pFun = (Fun)pVtab[1][2];

            pFun(); 

 

            //The tail of the vtable

            pFun = (Fun)pVtab[1][3];

            cout<<pFun<<endl;

 

 

 

            //Base3's vtable

            //pFun = (Fun)*((int*)*(int*)((int*)&d+1)+0);

            pFun = (Fun)pVtab[2][0];

            pFun();

 

            //pFun = (Fun)*((int*)*(int*)((int*)&d+1)+1);

            pFun = (Fun)pVtab[2][1];

            pFun();

 

            pFun = (Fun)pVtab[2][2];

            pFun(); 

 

            //The tail of the vtable

            pFun = (Fun)pVtab[2][3];

            cout<<pFun<<endl;

 

            return 0;

}

 

(转载时请注明作者和出处。未经许可，请勿用于商业用途)

 

更多文章请访问我的Blog: http://blog.csdn.net/haoel 

  
发表于 @ 2007年12月18日　22:07:00 | 评论( 92 ) | 编辑| 举报| 收藏 

旧一篇:GPLv3：大教堂和集市的新一轮对抗 | 新一篇:Java NIO类库Selector机制解析（上）
查看最新精华文章 请访问博客首页相关文章 
C++ 虚函数表解析详解C++虚函数表C++ 虚函数表解析(转自http://blog.csdn.net/haoel/archive/2007/12/18/1948051.aspx)C++ 虚函数表解析 (转载自陈皓专栏 http://blog.csdn.net/haoel)C++中的虚函数C++ 虚函数表解析C++ 虚函数内存布局学习笔记nevergone 发表于2007年12月19日 12:11:25  IP:举报回复删除
看反汇编代码
最能直接感受什么是虚函数表了pmunix 发表于2007年12月19日 12:50:45  IP:举报回复删除
其实虚表机制还带来一个问题，就是空间的浪费问题cxxer 发表于2007年12月19日 12:59:32  IP:举报回复删除
学习,不错,精彩,感谢.doyouwanna 发表于2007年12月19日 13:22:25  IP:举报回复删除
Driver::f
Driver......robotom 发表于2007年12月19日 14:09:28  IP:举报回复删除
好。
收藏一下。
lijgame 发表于2007年12月19日 15:41:59  IP:举报回复删除
似乎vc2005不是以NULL结尾的
如下的代码有问题，能正确获取前面两个虚函数，但是不能正确终止循环：
class CBase
{
public:
virtual void fun1()
{
cout<<"CBase::fun1"<<endl;
}
virtual void fun2()
{
cout<<"CBase::fun2"<<endl;
}
};
typedef void (*fun)();

int GetLengthofVTable()
{
int iLength = 0;
CBase b;
int* pAddr = (int*)*(int*)(&b);
while(*pAddr != NULL)
{
//fun f = (fun)*pAddr;
//f();
cout<<iLength<<endl;
++iLength;
pAddr++;
}
return iLength;
}haoel 发表于2007年12月20日 9:37:57  IP:举报回复删除
回复 lijgame：下面是对你程序的修改<br />int GetLengthofVTable()<br />{<br /> int iLength = 0;<br /> CBase b;<br /> fun* pAddr = (fun*)*(int*)(&amp;b);<br /> while(*pAddr != NULL)<br /> {<br /> (*pAddr)();<br /> cout&lt;&lt;iLength&lt;&lt;endl;<br /> ++iLength;<br /> pAddr++;<br /> }<br /> return iLength;<br />}
yeyuboy 发表于2007年12月19日 15:54:48  IP:举报回复删除
好文章。

不过用词不太准确。
重载（overload）：函数名相同，参数不同，同一层次下。

在这里应该是覆盖（overwrite）haoel 发表于2007年12月20日 9:35:08  IP:举报回复删除
回复 yeyuboy：非常感谢，已改正！
zhy2002 发表于2007年12月19日 16:18:22  IP:举报回复删除
聪明的读者很喜欢这篇文章。c++既然支持指针有可以随便转换类型，那么那些缺点是必然的，并不是虚函数表特有的缺陷。sunhuiyong 发表于2007年12月19日 16:52:29  IP:举报回复删除
不可否认，是一片好文章。帮助很大。newrain021011 发表于2007年12月19日 19:50:13  IP:举报回复删除
说的很详细，即使对于老手来说，也是一篇不错的文章。lishiyong110 发表于2007年12月19日 21:36:47  IP:举报回复删除
恩 学习一下 通过文章可以认识虚函数深刻些hada1234 发表于2007年12月20日 9:23:30  IP:举报回复删除
好！我顶你！haoel 发表于2007年12月20日 9:54:28  IP:10.35.12.*举报回复删除

看来，CSDN的BLOG系统还有些问题，
这里对lijgame所贴的程序回复如下：

下面是对你程序的修改

int GetLengthofVTable()
{
int iLength = 0;
CBase b;
fun* pAddr = (fun*)*(int*)(&b);
while(*pAddr != NULL)
{
(*pAddr)();
cout<<iLength<<endl;
++iLength;
pAddr++;
}
return iLength;
}jimmy_w 发表于2007年12月20日 11:44:11  IP:举报回复删除
挺好的分析，可以扔掉一些书了lovekatherine 发表于2007年12月20日 13:31:46  IP:举报回复删除
"在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。"

请问能给一下这句话在标准中的出处么？我印象中VPTR的位置是依赖于编译器实现的tssing 发表于2007年12月21日 11:04:22  IP:举报回复删除
太长了,懒得看LovelyCboy 发表于2007年12月21日 14:42:54  IP:举报回复删除
写的很清楚...很好..顶一下...安全都是由于指针引起的,它给我们很大的灵活性.但同时也是错误的根源.C++的访问权限检查只是在编译时进行,而不会在动行时在支看什么有没有访问权限之类的事,如果真那样做的话,我想那也慢的要死...呵呵....最后还是支持这样的好文章以后多出点...finlinden 发表于2007年12月24日 10:51:03  IP:举报回复删除
请允许我问一个弱的问题，因为我还是个C++的半入门者：）
问题如下：请先看我下面引用的作者的文章中的两句，

Base *b = new Derive();

b->f();
由b所指的内存中的虚函数表的f()的位置已经被Derive::f()函数地址所取代，于是在实际调用发生时，是Derive::f()被调用了。这就实现了多态。

【问题是这样的：】
我们为什么要刻意将一个Derive对象的地址付给一个【基类】的指针，来由这个基类指针操作呢？为什么不干脆直接生成一个Derive自己的指针，即：
Derive *b = new Derive();
想引用Derive的方法的话，这样岂不是来得更直接？？
――
【问题总结】：
在什么样的需求之下，使得我们：【一定要用：一个base类的指针，来操纵一个Derive类的对象】，才对我们的编程更有利？而用：一个derive类的指针，来直接操纵一个Derive类的对象，则变得索然无味？haoel 发表于2007年12月24日 21:45:15  IP:举报回复删除
回复 finlinden：对于这个问题，我想我还是不要回答的太过明白。还是给你留下一些思考的空间吧。给你一点提示：一个父类可以有多个子类。比如一个shape类可以有circle, rectangle, triangle... 子类，他们都要overwrite父类的纯虚函数draw()，而一个图上有若干个各种图形，在程序中我们用一个shape的指针数组来保存这些不同的图形，于是……， 明白了吗？
finlinden 发表于2007年12月26日 12:25:28  IP:举报回复删除
很好，很高的回答
受良师的教益，就像是在读好的宋词一样，在于不把所有东西都点破，而给你自己思想以遐想的空间。~！
――平安夜还在上网？，要多注意休息，多注意享受家庭生活啊：）cbk808 发表于2008年1月14日 22:54:10  IP:举报回复删除
狗屁啊,*(int*)(&b)才是虚函数表的地址
*(int*)*(int*)(&b)才是第一个函数的入口地址
你再用你的猪脑子想想是不是这样guogangj 发表于2008年1月28日 13:05:44  IP:举报回复删除
很好，现在能用心写纯粹意义上的技术文章的人不多了。

对于你所说的对象的内存结构，其实不一定是这样，尤其涉及到多层继承和多重继承同出现的情况，比较复杂，it depends... 编译器不同就有可能不同，另外就是虚函数表并不一定都以int(0)结束，也是it depends...

前阵子我遇到个题目提到private的virtual函数有什么用，你的文章也提到了，但我还是不知道作用，似乎不应该存在这种用法。liigo 发表于2008年4月29日 9:25:34  IP:举报回复删除
C++虚函数表严重依赖编译器xzk 发表于2008年4月30日 10:42:54  IP:举报回复删除
,*(int*)(&b)才是虚函数表的地址
*(int*)*(int*)(&b)才是第一个函数的入口地址
是正解，但是作者的讲解和精神都是可嘉的，小小错漏而已，读者自己还要消化的。zieckey 发表于2008年5月5日 21:34:32  IP:举报回复删除
xzk 发表于2008-04-30 10:42:54 IP: 58.62.113.*
,*(int*)(&b)才是虚函数表的地址
*(int*)*(int*)(&b)才是第一个函数的入口地址
是正解，但是作者的讲解和精神都是可嘉的，小小错漏而已，读者自己还要消化的。

确实是个小小错漏。楼上有兄弟不太客气，不应该阿！
小弟对陈皓先生很是景仰，从《 跟我一起写 Makefile》开始。
下面给出小弟理解后的程序，有错请跟帖。谢谢。

#include <stdio.h>

class Base {
public:
virtual void f() { printf("Base::f()\n"); }
virtual void g() { printf("Base::g()\n"); }
virtual void h() { printf("Base::h()\n"); }
virtual ~Base(){}
}; 

typedef void(*Fun)();

int main(int argc, char* argv[])
{
Base *b = new Base();
printf("Base对象b的地址：%p\n", b );//b为Base类的一个实例对象的首地址，此地址开始的四字节的内容存放的是虚函数表的地址

printf("虚函数表地址：%p\n", (int*)( *(int*)b) );

printf("虚函数表第一个地址(该地址内的 内容为第一个函数的地址)：%p\n", (int*)(*(int*)b) );//此处实际上就是虚函数表的首地址
printf("虚函数表第二个地址(该地址内的 内容为第二个函数的地址)：%p\n", (int*)(*(int*)b) +1 );
printf("虚函数表第三个地址(该地址内的 内容为第三个函数的地址)：%p\n", (int*)(*(int*)b) +2 );

printf("虚函数表 ――第一个函数地址：%p\n", (int*)*((int*)(*(int*)b)) );
printf("虚函数表 ――第二个函数地址：%p\n", (int*)*((int*)(*(int*)b) +1) );
printf("虚函数表 ――第三个函数地址：%p\n", (int*)*((int*)(*(int*)b) +2) );

Fun pFun = (Fun)*( (int*)(*(int*)b)+1 );
pFun();
((Fun)*( (int*)*(int*)b+2 )) ();
return 0;
}
bingo 发表于2008年5月8日 0:11:51  IP:举报回复删除
不错，楼主的认真精神值得学习，解析的非常清楚，收藏了。zkl 发表于2008年5月11日 11:41:32  IP:举报回复删除
问题是：Debug状态下的Derive object中的subobject Base1的虚函数表中为何没有g1（）函数呢？按道理应该是存在的呀lipingtababa 发表于2008年6月4日 13:01:32  IP:举报回复删除
楼主是好人,我爱楼主waterwalk 发表于2008年6月18日 15:58:19  IP:举报回复删除
关于这句：
“在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置（这是为了保证正确取到虚函数的偏移量）。”

ISO的c++标准里没有说虚表吧。好像连虚函数是不是使用虚表实现也没有说。我 发表于2008年6月20日 5:11:26  IP:举报回复删除
不知道作者是怎么理解安全性的定义的。。。
既然编译都通不过，还有什么所谓的安全问题呢？呵呵
就算你故意去让程序崩溃，去调用一个不存在的函数指针。。我也对这种变态的做法无语，因为这根本不是C++的缺陷，而是这个程序员大脑的问题（如果他要编病毒，总不能怪C++吧。。）

另外，保持底层的操作能力，正是C++的灵活魅力所在。这是那些成天把绝对的OO和一大堆Framework塞在脑子里面的书呆子永远无法享受的。

你说道，“永远不知道C++到底做什么”。。这只能说明你没有去了解，实际上C/C++才是最容易知道究竟做什么的语言。你知道一个JAVA的Hello World究竟做了什么吗？？ 你知道多少虚拟机的工作？多少指针垃圾收集的工作？呵呵，所以，实际上，C/C++正真保持了简洁与强大。。只要你反编译，调试一下，一切都一目了然了。。。

当年JAVA的那些广告语，现在看来都成了笑谈。。臃肿的框架，低下的性能，就为了所谓的安全。。所谓的移植性？？呵呵，我还不如装个VMware算了。。为了10%的改进，推翻剩下的90%..重定义语法，运行时，编译器，库，虚拟机。。。 我不敢说Ruby能取代JAVA,但是，我敢说Java肯定死在C++之前，哈哈^_^poet 发表于2008年6月20日 12:45:49  IP:举报回复删除
不喜欢C++总可以找出理由。虽然个人看法C++并不是一个很好的语言。但是：

1。C++本身是个不错的玩具，它具有所有编程语言中最复杂的语法和最复杂的编译器，对于语法狂人来说，具有其独特的魅力。

2。C++上面的特性，导致了，写出一份让90%的C++程序员都看不懂的程序非常容易。例如说多使用一些模板类，函数对象，函数适配器，bind2nd之类的。估计大多数普通C++程序员都看不懂了。――我认为世界上正常的趋势应该是使程序代码变成每个人都能懂的东西，而C++在这方面明显是劣势。

3。C++的大多数特性是在编译时间确定的，因此编译好的代码损失了许多信息，这使得C++对象很难以库的形式被其他语言复用。――被各种框架复用的代码大都用C语言写成，这就是一个例子。C++为什么要搞COM。是因为这是一个可行的复用办法，但是大家通过COM就明显可以看出，以二进制形式复用一个C++对象需要花多么大的代价。――而对于C语言，任何语言可以调用C语言动态库中的函数，而且接口无比简单，如果有libffi，甚至可以方便的获取函数的参数类型，并从其它语言中象C语言传递回调函数。――C++的许多特性把自己同其他语言之间通讯的大门紧紧关闭。个人觉得这才是最大的问题。

至于楼上那个说Java会死得快的，我只想说一个问题：
你知道Java现在的地位么？在欧美，你要是不会Java，想找个程序员的工作是非常困难的。因为其他程序员的需求量已经非常之小。――虽然本人也是非常不喜欢Java，但Java目前的强大是不争的事实。

hellocpp 发表于2008年6月28日 12:06:32  IP:举报回复删除
C++本身是门很简单的语言，干吗弄那么复杂呢。我就从来不用虚函数，C++不是写的很好么。ropert 发表于2008年7月6日 19:38:31  IP:举报回复删除
写得很啊,幸苦了.shelley_huhu 发表于2008年7月30日 13:41:25  IP:192.168.2.*举报回复删除
经典，学习收藏！！！！！！ljx0305 发表于2008年7月30日 23:14:53  IP:举报回复删除
但感觉上边讲的也不尽全对啊，上边的例子里边类是没有数据成员的，要是加上数据成员，好象就会发生错误啊snowwolf1987 发表于2008年8月5日 9:55:58  IP:举报回复删除
#include <iostream>
using namespace std;

class Base
{
private:
int a;
public:
Base(int x)
{
a = x;
}
virtual void print()
{
cout << a << endl;
}
};

class Drive : public Base
{
private:
int b;
public:
Drive(int y, int x) : Base(x)
{
b = y;
}
void print()
{
cout << b << endl;
}
};

void main()
{
Drive d(2,20);
Base *p = &d;
p->print();
p->Base::print();
}
您好，我是个初学者，楼主写的很清楚，但是有一点我不太明白。上面是我写的一个测试程序。在上面程序中，p->print();执行这个语句要在虚地址表中查找print()的那个地址，而这时那个内存区存放的是子类print()方法的地址，那下一句p->Base::print()调用的是符类的print()方法，那此时在哪里查找父类的print()的方法。还是在虚地址表里面吗，如果是，现在父类的print()方法的地址不是已经被覆盖了么？mykongkongarea 发表于2010年8月21日 21:06:24  IP:220.181.77.*举报回复删除
回复 snowwolf1987：我也想不明白这个问题 
sgzwiz 发表于2008年8月28日 18:26:43  IP:举报回复删除
请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：

-----------------------------------------

这一句还没改。

C++是天才写给天才用的。普通人就不要用了。精通C++的内存布局，适合反向C++程序，在编程时也会得心应手，看看MFC、ATL，大量运用了C++的各种特性。估计不懂C++内存分布的，应该对MFC、ATL非常感冒。认为MFC、ATL是垃圾的人，恰恰根本搞不清楚C++的内存布局。sgzwiz 发表于2008年8月28日 18:27:02  IP:举报回复删除
请注意，在这个继承关系中，子类没有重载任何父类的函数。那么，在派生类的实例中，其虚函数表如下所示：

-----------------------------------------

这一句还没改。

C++是天才写给天才用的。普通人就不要用了。精通C++的内存布局，适合反向C++程序，在编程时也会得心应手，看看MFC、ATL，大量运用了C++的各种特性。估计不懂C++内存分布的，应该对MFC、ATL非常感冒。认为MFC、ATL是垃圾的人，恰恰根本搞不清楚C++的内存布局。jzgnh 发表于2008年8月29日 10:09:07  IP:举报回复删除
typedef void(*Fun)(void);

这句有点问题,这里还有一个this指针的问题和调用方式的问题, 这个方法的定义是使用的 _cedcl 的方式调用的, 而如果参数固定的话其实是不需要调用者清理栈的,但是这里调用者肯定会清理栈的,所以很有可能破坏栈~还是换用成员函数指针吧~~jzgnh 发表于2008年8月29日 10:21:47  IP:举报回复删除
C++是天才写给天才用的 这个有点过了~
c++ 其实没你说的那么复杂,我感觉如果明白了C语言,那些C++的东西都一样的,只是有些工作本来是自己做,但是现在交给了编译器而已,如果你有兴趣的话可以通过n多种方法来分析到底编译器是如何做的,明白了其实C跟C++也就没什么区别了~~

至于怪异写法的问题我感觉C的怪异写法似乎更让人难以琢磨,呵呵~但是现在的"unix hack"好像不是很流行了吧,反正俺常用的那些库的代码感觉都没有太难以理解的代码ATL,openssl啥的,技巧不一定是写了别人看不懂的代码啊~~jzgnh 发表于2008年8月29日 10:23:19  IP:举报回复删除
C++是天才写给天才用的 这个有点过了~
c++ 其实没你说的那么复杂,我感觉如果明白了C语言,那些C++的东西都一样的,只是有些工作本来是自己做,但是现在交给了编译器而已,如果你有兴趣的话可以通过n多种方法来分析到底编译器是如何做的,明白了其实C跟C++也就没什么区别了~~

至于怪异写法的问题我感觉C的怪异写法似乎更让人难以琢磨,呵呵~但是现在的"unix hack"好像不是很流行了吧,反正俺常用的那些库的代码感觉都没有太难以理解的代码ATL,openssl啥的,技巧不一定是写了别人看不懂的代码啊~~babaoqi 发表于2008年9月3日 13:49:40  IP:举报回复删除
学习一下
顶一个ligand 发表于2008年9月18日 19:29:13  IP:举报回复删除
pFun = (Fun)*((int*)*(int*)(&b));

这行作者说得不清楚，它先做了一次取地址，然后又做了两次“间址”。说老实话，作者对这些问题研究得这么深，为什么总犯一些常识性错误呢？silvervi 发表于2008年9月30日 16:07:24  IP:举报回复删除
大哥，文章有错误

在VS 2005里面加了断点专门跑了一下，对照局部变量里面虚函数表的实际地址，错误跟我之前想的一样，少了一次解引用

正确的应该如下

cout << "虚函数表地址：" << (int *)*(int *)(&b) << endl;

cout << "虚函数表 ― 第一个函数地址：" << (int *)*(int *)*(int *)(&b) << end
l;
haoel 发表于2008年10月8日 11:50:35  IP:举报回复删除
回复 silvervi：其实都是一样的。函数指针的调用函数时，基本上是这个样子：(*pfun)();，先做了一次函数指针的取址操作。而我们正常调用的函数是fun()，我们可以把函数的名字直接复制赋值给函数指针：pfun = fun;那么，为什么用pfun调用函数时要做取址操作，而用fun调用函数时不用做取址操作了呢？呵呵，这点不妨留给你思考一下。
figoshen 发表于2008年10月5日 2:08:49  IP:举报回复删除
楼上的，楼主的程序我跑了没有问题，你说的的多加（int*）是问题我觉得加不加都一样了elovenana 发表于2008年10月14日 9:39:20  IP:举报回复删除
按照这样的写法，
(int *)*(int *)(&b)你的意思是说：类的首字节里面，写的是虚表的首地址；
(int *)*(int *)*(int *)(&b)，虚表的首地址里面，放的是首方法的地址？

这种类似于，二级指针似的，访问方法，只是茅塞顿开simpleease 发表于2008年10月16日 15:09:30  IP:举报回复删除
对博主的分享精神赞一个先。
其它的小问题就不说了，提两点吧：
1）“在C++的标准规格说明书中说到，编译器必需要保证虚函数表的指针存在于对象实例中最前面的位置”――请问是标准的那一条说的？我们讨论问题最好不要动不动就“标准说”，容易误导，是自己的理解就如是说呗，不要“挟标准以...”
2）对于通过偏移取虚函数地址并赋给一个普通函数的做法，是不是要做些补充说明？类的成员函数其实还是隐含有一个this作为第一个参数的。上面的例子是在没有成员变量的情况下跑起来，若是函数中用到了成员变量，你看看会不会出问题？
haoel 发表于2008年10月16日 16:03:40  IP:举报回复删除
回复 simpleease：非常感谢你的留言。对于第一个问题，你说的不错。C++的标准规格只关于C++语言的特性，而不关心实现。只是在ISO出的C++的性能报告中有说明，如果虚表放在实例的第一个位置，将会有性能上的优势，这应该是目前比较新的编译器都采取的实现。应该说是编译器的实现的实际标准。对不起，这是我的错误，我会把我的文章改过来。关于第二个问题，我想那已经超出我本篇文章的Scope了，不然，如果你再问我，为什么用我文章中函数指针调用虚的析构函数会导致程序crash，那么这些话题就超出“虚函数表”的讨论了，也偏离主题了。最后，谢谢你的留言。对我很有帮助。
liang 发表于2008年10月17日 13:41:47  IP:举报回复删除
你好， 我印象中虚函数表的第一项是留给RTTI用的
比如 typeid(CLASS).name() 用到了虚函数表的第一项的内容。这里的程序却说明虚函数表的第一项就是指向虚函数。 谁能解释一下？haoel 发表于2008年10月17日 14:43:52  IP:举报回复删除
回复 liang：没什么好解释的。这就是理论和实际的差别。
liang 发表于2008年10月17日 17:35:56  IP:举报回复删除
理论和实际是有差别， 但是留给RTTI用的类型信息被放到哪里了， 难道不需要了？haoel 发表于2008年10月18日 14:12:10  IP:举报回复删除
回复 liang：目前我还没有找到typeinfo的位置，我希望你能帮我看看是在哪里？第一个位置，还是最后一个位置？
agui1226 发表于2008年10月18日 16:13:35  IP:举报回复删除
不错，对理解虚表很有帮助，支持一下。smallCourser 发表于2008年10月19日 22:23:05  IP:举报回复删除
大哥，文章有错误

在VS 2005里面加了断点专门跑了一下，对照局部变量里面虚函数表的实际地址，错误跟我之前想的一样，少了一次解引用

正确的应该如下

cout << "虚函数表地址：" << (int *)*(int *)(&b) << endl;

cout << "虚函数表 ― 第一个函数地址：" << (int *)*(int *)*(int *)(&b) << end
l;

2008-10-08 11:50:34作者回复
其实都是一样的。函数指针的调用函数时，基本上是这个样子：(*pfun)();，先做了一次函数指针的取址操作。而我们正常调用的函数是fun()，我们可以把函数的名字直接复制赋值给函数指针：pfun = fun;那么，为什么用pfun调用函数时要做取址操作，而用fun调用函数时不用做取址操作了呢？呵呵，这点不妨留给你思考一下。


确实是搂住的笔误，少了次解析操作，为什莫不承认自己的错误，搂住的回复和主题无关阿。lsmdiao0812 发表于2008年10月20日 11:01:59  IP:举报回复删除
有一点疑问：
这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中
这句话有点不太明白？是为每个实例分配一个对应的虚函数表，还是一个类分配一个虚函数表，他的对象共用这个虚函数表？

lsmdiao0812 发表于2008年10月20日 11:04:50  IP:举报回复删除
有一点疑问：
这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中
这句话有点不太明白？是为每个实例分配一个对应的虚函数表，还是一个类分配一个虚函数表，他的对象共用这个虚函数表？

lsmdiao0812 发表于2008年10月20日 11:11:41  IP:举报回复删除
网速太慢，以为没发出去，结果发了两次qaz19870418 发表于2008年10月23日 12:27:15  IP:举报回复删除
写得好，学习了，支持一下，希望你能写出更多的好文章。zzcmx2008 发表于2008年10月27日 12:47:05  IP:举报回复删除
*(int*)(&b)才是虚函数表的地址
*(int*)*(int*)(&b)才是第一个函数的入口地址

文中应该有点小问题。mopyman 发表于2008年10月31日 15:01:05  IP:举报回复删除
"这样，在有虚函数的类的实例中这个表被分配在了这个实例的内存中"
这句话写的比较含糊，后面的描述没啥问题。
正确描述应该是这样的，“虚函数表(VTBL)是由类的所有实例共享的，在内存中只有一份，每个实例持有一个VPTR指向该类的虚函数表(VTBL)”fromfromto 发表于2008年10月31日 19:55:04  IP:举报回复删除
我对虚函数不是很懂，特别在早上累了一天之后脑子不够用

早上是去申请创新基金，创业基金fromfromto 发表于2008年11月4日 11:06:05  IP:举报回复删除
你说的是很ok啦 但是我做的一些个人项目中 基本不怎么用什么虚函数 也许只有企业级的产品用的才多一点
我大概成果转化考虑的多一点dexingchen 发表于2008年11月28日 17:42:26  IP:举报回复删除
这篇文章相当的好，就不多夸了，说一下问题：
1. 作者对于多继承的虚函数指针位置的理解是错误的，直接导致附录二的例程只是在特定情况下正确：比如，在Base1中增加一个成员变量int i，这个程序就错了；
2. 作者对Override、redefine没有做区分。个人认为用英文吧；fromfrom 发表于2008年12月12日 14:13:28  IP:举报回复删除
谢谢版主了
还有个问题不明白
在附录2例程里
//Base1's vtable

pFun = (Fun)*((int*)*(int*)((int*)&d+0)+0);

pFun = (Fun)pVtab[0][0];
在vs2005下查看
两种方法得到的虚函数表地址为什么不一样？
谢谢指点

fromfrom 发表于2008年12月12日 14:13:41  IP:举报回复删除
谢谢版主了
还有个问题不明白
在附录2例程里
//Base1's vtable

pFun = (Fun)*((int*)*(int*)((int*)&d+0)+0);

pFun = (Fun)pVtab[0][0];
在vs2005下查看
两种方法得到的虚函数表地址为什么不一样？
谢谢指点

askmjzl 发表于2008年12月12日 14:21:37  IP:举报回复删除
谢谢版主了
还有个问题不明白
在附录2例程里
//Base1's vtable

pFun = (Fun)*((int*)*(int*)((int*)&d+0)+0);

pFun = (Fun)pVtab[0][0];
在vs2005下查看两种方法得到的虚函数地址不同，为什么呢？flydream1980 发表于2008年12月27日 18:42:28  IP:举报回复删除
楼主的帖子写的真好， 不顶就不厚道了fjchenqian 发表于2009年2月3日 22:51:39  IP:举报回复删除
相当的好。谢谢。收藏了。~weixieming 发表于2009年4月10日 10:00:06  IP:举报回复删除
侯捷先生的《深入浅出MFC》关于虚函数讲解也相当详细而全面cnyu 发表于2009年6月12日 9:48:14  IP:举报回复删除
我想问一下， 既然在第一个虚拟函数表中存放了子类的非覆盖函数， 那么我为何在VC的Watch中看不到 &d Base1 __vptr [0] Derive:f() [1] Base1:g() [2] Base1:h() 按照道理， 这里应该有 [3] Derive:g1() 为何看不到呢? iotioa 发表于2009年10月22日 9:44:47  IP:举报回复删除
确实，楼主没有考虑到成员变量的问题，，如果有成员变量，虚指针则不是连续的，是在每个虚指针后有每个父类的成员变量。RTTI应该是在虚继承情况下有用的，我喜欢楼主的图文并貌，虽然并不完美iotioa 发表于2009年10月22日 9:52:45  IP:举报回复删除
应该用成员函数指针zbjxb 发表于2009年12月16日 1:29:04  IP:举报回复删除
代码的开始就有错误，并且是很严重的错误！害得我浪费了半天的时间思考这个问题。cout << "虚函数表地址：" << (int*)(&b) << endl;这里不是虚函数表地址，而是虚函数表指针的地址。wuxupeng999 发表于2010年1月31日 9:57:36  IP:举报回复删除
yxh860406 发表于2010年2月4日 13:33:58  IP:举报回复删除
lxqs_2343 发表于2010年2月4日 14:28:50  IP:举报回复删除
breezes2008 发表于2010年4月5日 10:44:41  IP:举报回复删除
shuyangxiaogou 发表于2010年4月22日 10:16:07  IP:举报回复删除
谢谢。lz应该再讲讲虚继承的内存分布。acka2009 发表于2010年5月6日 11:15:13  IP:举报回复删除
lz厉害，佩服！！acka2009 发表于2010年5月6日 11:21:57  IP:举报回复删除
那确实是 *(int *)(&b) 虚函数表的地址。 *(int *)(*(int *)(&b)+0) 第一个函数的地址 楼主辛苦了，图文并用很是哪个好！！！！~~~~s1418252 发表于2010年5月19日 17:08:12  IP:举报回复删除
匿名用户 发表于2010年6月8日 21:04:21  IP:举报回复删除
yinfuyong 发表于2010年6月12日 10:24:17  IP:举报回复删除
强！佩服iamtoful 发表于2010年7月22日 16:11:22  IP:举报回复删除
请问如何修改虚函数表？？？？？？CPPWorking 发表于2010年9月6日 13:37:26  IP:207.46.55.*举报回复删除
回复 iamtoful：
CPPWorking 发表于2010年9月6日 13:40:26  IP:207.46.55.*举报回复删除
回复 iamtoful： Sorry, 刚才直接发出去了。。。虚函数表一般是由编译器来维护的，但是你非要手动去修改，办法也是有的。比如： class Base { public: virtual void VirtualFunction(); }; class Derive : public Base { public: Derive() {memset(this, 0, sizeof(Derive));} ==>虚函数表的地址被置为0了。。 };
gavinwjin 发表于2010年8月7日 11:07:08  IP:举报回复删除
好强 我看的第一篇makefile原来也出此大牛之手 sudooo 发表于2010年8月7日 11:18:38  IP:举报回复删除
文章整体是不错的 不过就是有一些 小错误 大家注意辨别就ok了mykongkongarea 发表于2010年8月21日 21:08:33  IP:220.181.77.*举报回复删除
虚表中父类的函数指针被子类的覆盖之后，再调用父类函数的时候该怎么办啊，那就完全找不到了啊CPPWorking 发表于2010年9月6日 13:36:19  IP:207.46.55.*举报回复删除
回复 mykongkongarea：看不出来有什么问题哦。。 (假设有个Base父类，定义了VirtualFunction这个虚函数，子类Derive继承自Base并重写/"覆盖"了这个虚函数VirtualFunction) 请问你怎么调用父类的函数？ Base b; b.VirtualFunction(); 如果你说的是这种情况的话，根本不存在多态，并不会去虚函数表找，而是在程序编译的时候直接被嵌入父类的虚函数(Base::VirtualFunction)的地址。 如果是： Derive d; Base &b = d; b.VirtualFunction(); 那么这里本来就应该调用的子类覆盖之后的虚函数（通过虚函数表），这就是多态。
xiaoC_fantasy 发表于2010年9月7日 18:36:59  IP:125.67.146.*举报回复删除
博主还有可能回吗 小弟初学者 typedef void(*Fun)(void); 这句什么意思啊？ turkeyzhou 发表于2010年9月7日 22:53:24  IP:116.204.64.*举报回复删除
回复 xiaoC_fantasy：定义了一个函数指针的名称，这个就不必问博主了，随便找点入门资料就明白。
xiaoC_fantasy 发表于2010年9月10日 14:13:24  IP:125.67.147.*举报回复删除
回复 turkeyzhou：其实我大概知道作用是定义一个函数的指针，可是语法上怎么可以这样写 typedef 后面应该接两个参数啊
yeziqing 发表于2010年9月10日 9:24:27  IP:118.229.216.*举报回复删除
谢谢博主非常透彻的分享！不知博主能否进一步讲解下多重继承中含有虚基类情况下的虚函数表吗？ 比如下面的这样一种多重继承关系： class W { public: virtual void f() { cout << "W::f()" << endl; } virtual void g() { cout << "W::g()" << endl; } }; class AW : public virtual W { public: void g() { cout << "AW::g()" << endl; } }; class BW : public virtual W { public: void f() { cout << "BW::f()" << endl; } }; class CW : public AW, public BW, public virtual W {}; 其中CW类的对象的虚函数表是不是会有哪些地方的不同呢？ 谢谢！ haoel 发表于2010年9月10日 19:17:32  IP:167.206.189.*举报回复删除
回复 yeziqing：早写了，在这里：http://blog.csdn.net/haoel/archive/2008/10/15/3081328.aspx

本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/haoel/archive/2007/12/18/1948051.aspx