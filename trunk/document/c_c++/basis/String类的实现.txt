面试的时候被问及了String类的实现，结果没写好... 
就当是重新复习一下吧。 
下面的程序并没有把String类的所有成员方法实现，只参考教程写了大部分重要的成员函数。

 

view plaincopy to clipboardprint?#include<iostream>   
#include<iomanip>   
using namespace std;  
  
class String{  
    friend ostream& operator<< (ostream&,String&);//重载<<运算符   
    friend istream& operator>> (istream&,String&);//重载>>运算符   
public:  
    String(const char* str=NULL);                //赋值构造兼默认构造函数(char)   
    String(const String &other);                 //赋值构造函数(String)   
    String& operator=(const String& other);       //operator=   
    String operator+(const String &other)const;  //operator+   
    bool operator==(const String&);              //operator==   
    char& operator[](unsigned int);              //operator[]   
    size_t size(){return strlen(m_data);};  
    ~String(void) {delete[] m_data;}  
private:  
    char *m_data; // 用于保存字符串   
};  
  
inline String::String(const char* str)     
{  
    if(!str)m_data=0;      //声明为inline函数，则该函数在程序中被执行时是语句直接替换，而不是被调用   
    else {  
        m_data=new char[strlen(str)+1];  
        strcpy(m_data,str);  
    }  
}  
  
inline String::String(const String &other)  
{  
    if(!other.m_data)m_data=0;//在类的成员函数内可以访问同种对象的私有成员（同种类则是友元关系）   
    else   
    {  
        m_data=new char[strlen(other.m_data)+1];  
        strcpy(m_data,other.m_data);  
    }  
}  
  
inline String& String::operator=(const String& other)  
{  
    if (this!=&other)  
    {  
        delete[] m_data;  
        if(!other.m_data) m_data=0;  
        else  
        {  
            m_data = new char[strlen(other.m_data)+1];  
            strcpy(m_data,other.m_data);  
        }  
    }  
    return *this;  
}  
inline String String::operator+(const String &other)const  
{  
    String newString;  
    if(!other.m_data)  
        newString = *this;  
    else if(!m_data)  
        newString = other;  
    else  
    {  
        newString.m_data = new char[strlen(m_data)+strlen(other.m_data)+1];  
        strcpy(newString.m_data,m_data);  
        strcat(newString.m_data,other.m_data);  
    }  
    return newString;  
}  
  
inline bool String::operator==(const String &s)      
{  
    if ( strlen(s.m_data) != strlen(m_data) )  
        return false;  
    return strcmp(m_data,s.m_data)?false:true;  
}  
  
inline char& String::operator[](unsigned int e)  
{  
    if (e>=0&&e<=strlen(m_data))  
        return m_data[e];  
}  
  
ostream& operator<<(ostream& os,String& str)  
{  
    os << str.m_data;  
    return os;  
}  
  
istream &operator>>( istream &input, String &s )  
{  
   char temp[ 255 ]; //用于存储输入流   
   input>>setw(255)>>temp;  
   s = temp; //使用赋值运算符   
   return input; //使用return可以支持连续使用>>运算符   
}  
  
int main()  
{  
    String str1="Aha!";  
    String str2="My friend";  
    String str3 = str1+str2;  
    cout<<str3<<"/n"<<str3.size()<<endl;  
    return 0;  
}  
#include<iostream>
#include<iomanip>
using namespace std;

class String{
    friend ostream& operator<< (ostream&,String&);//重载<<运算符
	friend istream& operator>> (istream&,String&);//重载>>运算符
public:
    String(const char* str=NULL);                //赋值构造兼默认构造函数(char)
    String(const String &other);                 //赋值构造函数(String)
    String& operator=(const String& other);       //operator=
    String operator+(const String &other)const;  //operator+
    bool operator==(const String&);              //operator==
    char& operator[](unsigned int);              //operator[]
    size_t size(){return strlen(m_data);};
    ~String(void) {delete[] m_data;}
private:
    char *m_data; // 用于保存字符串
};

inline String::String(const char* str)   
{
	if(!str)m_data=0;      //声明为inline函数，则该函数在程序中被执行时是语句直接替换，而不是被调用
	else {
		m_data=new char[strlen(str)+1];
		strcpy(m_data,str);
	}
}

inline String::String(const String &other)
{
	if(!other.m_data)m_data=0;//在类的成员函数内可以访问同种对象的私有成员（同种类则是友元关系）
	else 
	{
		m_data=new char[strlen(other.m_data)+1];
		strcpy(m_data,other.m_data);
	}
}

inline String& String::operator=(const String& other)
{
    if (this!=&other)
    {
        delete[] m_data;
        if(!other.m_data) m_data=0;
        else
        {
            m_data = new char[strlen(other.m_data)+1];
            strcpy(m_data,other.m_data);
        }
    }
    return *this;
}
inline String String::operator+(const String &other)const
{
    String newString;
    if(!other.m_data)
        newString = *this;
    else if(!m_data)
        newString = other;
    else
    {
        newString.m_data = new char[strlen(m_data)+strlen(other.m_data)+1];
        strcpy(newString.m_data,m_data);
        strcat(newString.m_data,other.m_data);
    }
    return newString;
}

inline bool String::operator==(const String &s)    
{
    if ( strlen(s.m_data) != strlen(m_data) )
        return false;
    return strcmp(m_data,s.m_data)?false:true;
}

inline char& String::operator[](unsigned int e)
{
    if (e>=0&&e<=strlen(m_data))
        return m_data[e];
}

ostream& operator<<(ostream& os,String& str)
{
    os << str.m_data;
    return os;
}

istream &operator>>( istream &input, String &s )
{
   char temp[ 255 ]; //用于存储输入流
   input>>setw(255)>>temp;
   s = temp; //使用赋值运算符
   return input; //使用return可以支持连续使用>>运算符
}

int main()
{
    String str1="Aha!";
    String str2="My friend";
    String str3 = str1+str2;
    cout<<str3<<"/n"<<str3.size()<<endl;
	return 0;
}

 

 

http://blog.csdn.net/moxiaomomo/article/details/6411584