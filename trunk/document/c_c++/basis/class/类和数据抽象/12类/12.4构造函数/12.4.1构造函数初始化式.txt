与任何其他函数一样，构造函数具有名字、形参表和函数体。与其他函数不同的是，构造函数也可以包
含一个构造函数初始化列表：

     // recommended way to write constructors using a constructor initializer
     Sales_item::Sales_item(const string &book):
          isbn(book), units_sold(0), revenue(0.0) { }

构造函数初始化列表以一个冒号开始，接着是一个以逗号分隔的数据成员列表，每个数据成员后面跟一个
放在圆括号中的初始化式。这个构造函数将 isbn 成员初始化为 book 形参的值，将 units_sold 和 
revenue 初始化为 0。与任意的成员函数一样，构造函数可以定义在类的内部或外部。构造函数初始化
只在构造函数的定义中而不是声明中指定。
构造函数初始化列表是许多相当有经验的 C++ 程序员都没有掌握的一个特性。
【★】构造函数初始化列表只在构造函数的定义中而不是声明中指定

构造函数初始化列表难以理解的一个原因在于，省略初始化列表在构造函数的函数体内对数据成员赋值是
合法的。例如，可以将接受一个 string 的 Sales_item 构造函数编写为：

     // legal but sloppier way to write the constructor:
     // no constructor initializer
     Sales_item::Sales_item(const string &book)
     {
         isbn = book;
         units_sold = 0;
         revenue = 0.0;
     }
 这个构造函数给类 Sales_item 的成员赋值，但没有进行显式初始化。不管是否有显式的初始化式，在执
 行构造函数之前，要初始化 isbn 成员。这个构造函数隐式使用默认的 string 构造函数来初始化 isbn。
 执行构造函数的函数体时，isbn 成员已经有值了。该值被构造函数函数体中的赋值所覆盖。

     
从概念上讲，可以认为构造函数分两个阶段执行：（1）初始化阶段；（2）普通的计算阶段。计算阶段由
构造函数函数体中的所有语句组成。
【★】不管成员是否在构造函数初始化列表中显式初始化，类类型的数据成员总是在初始化阶段初始化。
初始化发生在计算阶段开始之前。

【★】在构造函数初始化列表中没有显式提及的每个成员，使用与初始化变量相同的规则来进行初始化。
运行该类型的默认构造函数，来初始化类类型的数据成员。内置或复合类型的成员的初始值依赖于对象的
作用域：在局部作用域中这些成员不被初始化，而在全局作用域中它们被初始化为 0。
【?】也就是对于int型在没有显式初始化时,初始化为0

在本节中编写的两个 Sales_item 构造函数版本具有同样的效果：无论是在构造函数初始化列表中初始化
成员，还是在构造函数函数体中对它们赋值，最终结果是相同的。构造函数执行结束后，三个数据成员保
存同样的值。不同之外在于，使用构造函数初始化列表的版本初始化数据成员，没有定义初始化列表的构
造函数版本在构造函数函数体中对数据成员赋值。这个区别的重要性取决于数据成员的类型。

【有时需要构造函数初始化列表】
【★】如果没有为类成员提供初始化式，则编译器会隐式地使用成员类型的默认构造函数。如果那个类没
有默认构造函数，则编译器尝试使用默认构造函数将会失败。在这种情况下，为了初始化数据成员，必须
提供初始化式。

有些成员必须在构造函数初始化列表中进行初始化。对于这样的成员，在构造函数函数体中对它们赋值不
起作用。没有默认构造函数的类类型的成员，以及 const 或引用类型的成员，不管是哪种类型，都必须
在构造函数初始化列表中进行初始化。
【?】没有默认构造函数的类类型的成员，以及 const 或引用类型的成员，不管是哪种类型，都必须
在构造函数初始化列表中进行初始化。什么意思?
【▲】看看下面的例子就知道了

因为内置类型的成员不进行隐式初始化，所以对这些成员是进行初始化还是赋值似乎都无关紧要。除了两
个例外，对非类类型的数据成员进行赋值或使用初始化式在结果和性能上都是等价的。

例如，下面的构造函数是错误的：
     class ConstRef {
     public:
         ConstRef(int ii);
     private:
         int i;
         const int ci;
         int &ri;
     };
     // no explicit constructor initializer: error ri is uninitialized
     ConstRef::ConstRef(int ii)
     {              // assignments:
          i = ii;   // ok
          ci = ii;  // error: cannot assign to a const
          ri = i;   // assigns to ri which was not bound to an object
     }

记住，可以初始化 const 对象或引用类型的对象，但不能对它们赋值。在开始执行构造函数的函数体之
前，要完成初始化。初始化 const 或引用类型数据成员的唯一机会是构造函数初始化列表中。编写该构
造函数的正确方式为
     // ok: explicitly initialize reference and const members
     ConstRef::ConstRef(int ii): i(ii), ci(i), ri(ii) { }

【建议：使用构造函数初始化列表】
在许多类中，初始化和赋值严格来讲都是低效率的：数据成员可能已经被直接初始化了，还要对它进行
初始化和赋值。比较率问题更重要的是，某些数据成员必须要初始化，这是一个事实。

必须对任何 const 或引用类型成员以及没有默认构造函数的类类型的任何成员使用初始化式。
 
当类成员需要使用初始化列表时，通过常规地使用构造函数初始化列表，就可以避免发生编译时错误。

【成员初始化的次序】
每个成员在构造函数初始化列表中只能指定一次，这不会令人惊讶。毕竟，给一个成员两个初始值意味
着什么？也许更令人惊讶的是，构造函数初始化列表仅指定用于初始化成员的值，并不指定这些初始化
执行的次序。成员被初始化的次序就是定义成员的次序。第一个成员首先被初始化，然后是第二个，依
次类推。
初始化的次序常常无关紧要。然而，如果一个成员是根据其他成员而初始化，则成员初始化的次序是至
关重要的。
【★】构造函数初始化列表执行的次序就是类定义成员的次序
考虑下面的类：

     class X {
         int i;
         int j;
     public:
         // run-time error: i is initialized before j
         X(int val): j(val), i(j) { }
     };
在这种情况下，构造函数初始化列表看起来似乎是用val 初始化 j，然后再用 j 来初始化 i。然而，i 
首先被初始化。这个初始化列表的效果是用尚未初始化的 j 值来初始化 i！
如果数据成员在构造函数初始化列表中的列出次序与成员被声明的次序不同，那么有的编译器非常友好，
会给出一个警告。
按照与成员声明一致的次序编写构造函数初始化列表是个好主意。此外，尽可能避免使用成员来初始化
其他成员。
【★】一般情况下，通过（重复）使用构造函数的形参而不是使用对象的数据成员，可以避免由初始化
式的执行次序而引起的任何问题。例如，下面这样为 X 编写构造函数可能更好：

     X(int val): i(val), j(val) { }
     
在这个版本中，i 和 j 初始化的次序就是无关紧要的。


【初始化式可以是任意表达式】
一个初始化式可以是任意复杂的表达式。例如，可以给 Sales_item 类一个新的构造函数，该构造函数
接受一个 string 表示 isbn，一个 usigned 表示售出书的数目，一个 double 表示每本书的售出价格：

     Sales_item(const std::string &book, int cnt, double price):
         isbn(book), units_sold(cnt), revenue(cnt * price) { }

revenue 的初始化式使用表示价格和售出数目的形参来计算对象的 revenue 成员。
【★】一个初始化式可以是任意复杂的表达式。


【类类型的数据成员的初始化式】
【★】初始化类类型的成员时，要指定实参并传递给成员类型的一个构造函数。可以使用该类型的任意构造函
数。例如，Sales_item 类可以使用任意一个 string 构造函数来初始化 isbn（第 9.6.1 节）。也可
以用 ISBN 取值的极限值来表示 isbn 的默认值，而不是用空字符串。可以将 isbn 初始化为由 10 个 
9 构成的串：

     // alternative definition for Sales_item default constructor
     Sales_item(): isbn(10, '9'), units_sold(0), revenue(0.0) {}

这个初始化式使用 string 构造函数，接受一个计数值和一个字符，并生成一个 string，来保存重复指定
次数的字符。















