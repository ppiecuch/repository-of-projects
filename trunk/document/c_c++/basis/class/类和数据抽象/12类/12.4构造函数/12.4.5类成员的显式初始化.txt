尽管大多数对象可以通过运行适当的构造函数进行初始化，但是直接初始化简单的非抽象类的数据成员
仍是可能的。
【★】对于没有定义构造函数并且其全体数据成员均为 public 的类，可以采用与初始化数组元素相同
的方式初始化其成员：

     struct Data {
         int ival;
         char *ptr;
     };
     // val1.ival = 0; val1.ptr = 0
     Data val1 = { 0, 0 };

     // val2.ival = 1024;
     // val2.ptr = "Anna Livia Plurabelle"
     Data val2 = { 1024, "Anna Livia Plurabelle" };

【★】根据数据成员的声明次序来使用初始化式。例如，因为 ival 在 ptr 之前声明，所以下面的用法
是错误的：

     // error: can't use "Anna Livia Plurabelle" to initialize the int ival
     Data val2 = { "Anna Livia Plurabelle" , 1024 };

这种形式的初始化从 C 继承而来，支持与 C 程序兼容。
【★】显式初始化类类型对象的成员有三个重大的缺点。
1、要求类的全体数据成员都是 public。
2、将初始化每个对象的每个成员的负担放在程序员身上。这样的初始化是乏味且易于出错的，因为容易
遗忘初始化式或提供不适当的初始化式。
3、如果增加或删除一个成员，必须找到所有的初始化并正确更新。
定义和使用构造函数几乎总是较好的。当我们为自己定义的类型提供一个默认构造函数时，允许编译器自
动运行那个构造函数，以保证每个类对象在初次使用之前正确地初始化。




