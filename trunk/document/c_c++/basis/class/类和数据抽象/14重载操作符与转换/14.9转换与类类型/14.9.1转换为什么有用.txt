假定想要定义一个名为 SmallInt 的类，该类实现安全小整数，这个类将使我们能够定义对象以保存
与 8 位 unsigned char 同样范围的值，即，0 到 255。这个类可以捕获下溢和上溢错误，因此使用
起来比内置 unsigned char 更安全。

我们希望这个类定义 unsigned char 支持的所有操作。具体而言，我们想定义 5 个算术操作符
（+、-、*、/、%）及其对应的复合赋值操作符，4 个关系操作符（<、<=、>、>=），以及相等
操作符（==、!=）。显然，需要定义 16 个操作符。

【支持混合类型表达式】
而且，我们希望可以在混合模式表达式中使用这些操作符。例如，应该可以将两个 SmallInt 对象相
加，也可以将任意算术类型加到 SmallInt。通过为每个操作符定义三个实例来达到目标：

     int operator+(int, const SmallInt&);
     int operator+(const SmallInt&, int);
     SmallInt operator+(const SmallInt&, const SmallInt&);


因为存在从任意算术类型到 int 的转换，这三个函数可以涵盖支持 SmallInt 对象的混合模式使用的
要求。但是，这个设计仅仅接近内置整数运算的行为，它不能适当处理浮点类型混合模式操作，也不
能适当支持 long 、unsigned int 或 unsigned long 的加运算。问题在于这个设计将所有算术类型
（甚至包括那些比 int 大的）转换为 int 并进行 int 加运算。

【转换减少所需操作符的数目】
即使忽略浮点或大整型操作数的问题，如果要实现这个设计，也必须定义 48 个操作符！幸好，C++ 
提供了一种机制，利用这种机制，一个类可以定义自己的转换，应用于其类类型对象。对 SmallInt 
而言，可以定义一个从 SmallInt 到 int 类型的转换。如果定义了该转换，则无须再定义任何算术、
关系或相等操作符。给定到 int 的转换，SmallInt 对象可以用在任何可用 int 值的地方。

如果存在一个到 int 的转换，则以下代码：

     SmallInt si(3);
     si + 3.14159;         // convert si to int, then convert to double


可这样确定：
1.将 si 转换为 int 值。
2.将所得 int 结果转换为 double 值并与双精度字面值常量 3.14159 相加，得到 double 值。



