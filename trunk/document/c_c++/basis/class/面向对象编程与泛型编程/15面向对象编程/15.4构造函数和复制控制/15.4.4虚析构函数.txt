自动调用基类部分的析构函数对基类的设计有重要影响。

删除指向动态分配对象的指针时，需要运行析构函数在释放对象的内存之前清除对象。处理继承层次中的对
象时，指针的静态类型可能与被删除对象的动态类型不同，可能会删除实际指向派生类对象的基类类型指针。

【★】如果删除基类指针，则需要运行基类析构函数并清除基类的成员，如果对象实际是派生类型的，则没
有定义该行为。要保证运行适当的析构函数，基类中的析构函数必须为虚函数：

     class Item_base {
     public:
         // no work, but virtual destructor needed
         // if base pointer that points to a derived object is ever deleted
         virtual ~Item_base() { }
     };


如果析构函数为虚函数，那么通过指针调用时，运行哪个析构函数将因指针所指对象类型的不同而不同：

     Item_base *itemP = new Item_base; // same static and dynamic type
     delete itemP;          // ok: destructor for Item_base called
     itemP = new Bulk_item; // ok: static and dynamic types differ
     delete itemP;          // ok: destructor for Bulk_item called


像其他虚函数一样，析构函数的虚函数性质都将继承。因此，如果层次中根类的析构函数为虚函数，则派生
类析构函数也将是虚函数，无论派生类显式定义析构函数还是使用合成析构函数，派生类析构函数都是虚函
数。

基类析构函数是三法则（第 13.3 节）的一个重要例外。三法则指出，如果类需要析构函数，则类几乎也确
实需要其他复制控制成员。基类几乎总是需要构造函数，从而可以将析构函数设为虚函数。如果基类为了将
析构函数设为虚函数则具有空析构函数，那么，类具有析构函数并不表示也需要赋值操作符或复制构造函数。

【★】如果基类为了将析构函数设为虚函数则具有空析构函数，那么，类具有析构函数并不表示也需要赋值
操作符或复制构造函数。

【★】即使析构函数没有工作要做，继承层次的根类也应该定义一个虚析构函数。

【构造函数和赋值操作符不是虚函数】
在复制控制成员中，只有析构函数应定义为虚函数，构造函数不能定义为虚函数。构造函数是在对象完全构
造之前运行的，在构造函数运行的时候，对象的动态类型还不完整。

【★】在复制控制成员中，只有析构函数应定义为虚函数，构造函数不能定义为虚函数。
【★】构造函数是在对象完全构造之前运行的，在构造函数运行的时候，对象的动态类型还不完整。

虽然可以在基类中将成员函数 operator= 定义为虚函数，但这样做并不影响派生类中使用的赋值操作符。
每个类有自己的赋值操作符，派生类中的赋值操作符有一个与类本身类型相同的形参，该类型必须不同于继
承层次中任意其他类的赋值操作符的形参类型。

将赋值操作符设为虚函数可能会令人混淆，因为虚函数必须在基类和派生类中具有同样的形参。基类赋值操
作符有一个形参是自身类类型的引用，如果该操作符为虚函数，则每个类都将得到一个虚函数成员，该成
员定义了参数为一个基类对象的 operator=。但是，对派生类而言，这个操作符与赋值操作符是不同的。

将类的赋值操作符设为虚函数很可能会令人混淆，而且不会有什么用处。







