我们希望使用容器（或内置数组）保存因继承而相关联的对象。但是，对象不是多态的（第 15.3.1 
节），这一事实对将容器用于继承层次中的类型有影响。

例如，书店应用程序中可能有购物篮，购物篮代表顾客正在购买的书。我们希望能够在 multiset（第
 10.5 节）中存储储购买物，要定义 multiset，必须指定容器将保存的对象的类型。将对象放进容
 器时，复制元素（第 9.3.3 节）。

如果定义 multiset 保存基类类型的对象：

     multiset<Item_base> basket;
     Item_base base;
     Bulk_item bulk;
     basket.insert(base);  // ok: add copy of base to basket
     basket.insert(bulk);  // ok: but bulk sliced down to its base part


则加入派生类型的对象时，只将对象的基类部分保存在容器中。记住，将派生类对象复制到基类对象
时，派生类对象将被切掉（第 15.3.1 节）。

容器中的元素是 Item_base 对象，无论元素是否作为 Bulk_item 对象的副本而建立，当计算元素的
 net_price 时，元素将按不打折定价。一旦对象放入了 multiset，它就不再是派生类对象了。
【★】窗口声明保存的是基类类型,则加入派生类型的对象时，只将对象的基类部分保存在容器中。
记住，将派生类对象复制到基类对象时，派生类对象将被切掉

因为派生类对象在赋值给基类对象时会被“切掉”，所以容器与通过继承相关的类型不能很好地融合。

不能通过定义容器保存派生类对象来解决这个问题。在这种情况下，不能将 Item_base 对象放入容
器――没有从基类类型到派生类型的标准转换。可以显式地将基类对象强制转换为派生类对象并将结果
对象加入容器，但是，如果这样做，当试图使用这样的元素时，会产生大问题：在这种情况下，元素
可以当作派生类对象对待，但派生类部分的成员将是未初始化的。

唯一可行的选择可能是使用容器保存对象的指针。这个策略可行，但代价是需要用户面对管理对象和
指针的问题，用户必须保证只要容器存在，被指向的对象就存在。如果对象是动态分配的，用户必须
保证在容器消失时适当地释放对象。下一节将介绍对这个问题更好更通用的解决方案。
【★】唯一可行的选择可能是使用容器保存对象的指针。

