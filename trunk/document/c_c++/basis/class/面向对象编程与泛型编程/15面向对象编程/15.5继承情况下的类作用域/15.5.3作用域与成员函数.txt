【★】在基类和派生类中使用同一名字的成员函数，其行为与数据成员一样：在派生类作用域中派生
类成员将屏蔽基类成员。即使函数原型不同，基类成员也会被屏蔽：
     struct Base {
         int memfcn();
     };
     struct Derived : Base {
         int memfcn(int); // hides memfcn in the base
     };
     Derived d; Base b;
     b.memfcn();        // calls Base::memfcn
     d.memfcn(10);      // calls Derived::memfcn
     d.memfcn();        // error: memfcn with no arguments is hidden
     d.Base::memfcn();  // ok: calls Base::memfcn

Derived 中的 memfcn 声明隐藏了 Base 中的声明。这并不奇怪，第一个调用通过 Base 对象 b 调用
基类中的版本，同样，第二个调用通过 d 调用 Derived 中的版本。可能比较奇怪的是第三个调用：

     d.memfcn(); // error: Derived has no memfcn that takes no arguments

要确定这个调用，编译器需要查找名字 memfcn，并在 Derived 类中找到。一旦找到了名字，编译器
就不再继续查找了。这个调用与 Derived 中的 memfcn 定义不匹配，该定义希望接受 int 实参，而
这个函数调用没有提供那样的实参，因此出错。

回忆一下，局部作用域中声明的函数不会重载全局作用域中定义的函数（第 7.8.1 节），同样，派生
类中定义的函数也不重载基类中定义的成员。通过派生类对象调用函数时，实参必须与派生类中定义
的版本相匹配，只有在派生类根本没有定义该函数时，才考虑基类函数。

【★】局部作用域中声明的函数不会重载全局作用域中定义的函数
【★】同样，派生类中定义的函数也不重载基类中定义的成员。
【★】通过派生类对象调用函数时，实参必须与派生类中定义的版本相匹配，只有在派生类根本没有
定义该函数时，才考虑基类函数。

【重载函数】
【★】像其他任意函数一样，成员函数（无论虚还是非虚）也可以重载。派生类可以重定义所继承的 
0 个或多个版本。

【★】如果派生类重定义了重载成员，则通过派生类型只能访问派生类中重定义的那些成员。
 
【★】如果派生类想通过自身类型使用的重载版本，则派生类必须要么重定义所有重载版本，要么一
个也不重定义。

有时类需要仅仅重定义一个重载集中某些版本的行为，并且想要继承其他版本的含义，在这种情况下，
为了重定义需要特化的某个版本而不得不重定义每一个基类版本，可能会令人厌烦。 

派生类不用重定义所继承的每一个基类版本，它可以为重载成员提供 using 声明（第 15.2.5 节）。
一个 using 声明只能指定一个名字，不能指定形参表，因此，为基类成员函数名称而作的 using 声
明将该函数的所有重载实例加到派生类的作用域。将所有名字加入作用域之后，派生类只需要重定义
本类型确实必须定义的那些函数，对其他版本可以使用继承的定义。

【★】派生类不用重定义所继承的每一个基类版本，它可以为重载成员提供 using 声明
【★】一个 using 声明只能指定一个名字，不能指定形参表，因此，为基类成员函数名称而作的 
using 声明将该函数的所有重载实例加到派生类的作用域。




