面向对象编程的关键思想是多态性（polymorphism）。多态性派生于一个希腊单词，意思是“许多形
态”。之所以称通过继承而相关联的类型为多态类型，是因为在许多情况下可以互换地使用派生类型
或基类型的“许多形态”。正如我们将看到的，在 C++ 中，多态性仅用于通过继承而相关联的类型的
引用或指针。
【★】在 C++ 中，多态性仅用于通过继承而相关联的类型的引用或指针。

【继承】
通过继承我们能够定义这样的类，它们对类型之间的关系建模，共享公共的东西，仅仅特化本质上不
同的东西。派生类（derived class）能够继承基类（base class）定义的成员，派生类可以无须改
变而使用那些与派生类型具体特性不相关的操作，派生类可以重定义那些与派生类型相关的成员函数，
将函数特化，考虑派生类型的特性。最后，除了从基类继承的成员之外，派生类还可以定义更多的成
员。

我们经常称因继承而相关联的类为构成了一个继承层次。其中有一个类称为根，所以其他类直接或间
接继承根类。在书店例子中，我们将定义一个基类，命名为 Item_base，命名为 Bulk_item，表示带
数量折扣销售的书。
这些类至少定义如下操作：
	名为 book 的操作，返回 ISBN。
	名为 net_price 的操作，返回购买指定数量的书的价格。
Item_base 的派生类将无须改变地继承 book 函数：派生类不需要重新定义获取 ISBN 的含义。另一
方面，每个派生类需要定义自己的 net_price 函数版本，以实现适当的折扣价格策略。

在 C++ 中，基类必须指出希望派生类重写哪些函数，定义为 virtual 的函数是基类期待派生类重新
定义的，基类希望派生类继承的函数不能定义为虚函数。
【★】定义为 virtual 的函数是基类期待派生类重新定义的，基类希望派生类继承的函数不能定义
为虚函数。

讨论过这些之后，可以看到我们的类将定义三个（const）成员函数：
非虚函数 std::string book()，返回 ISBN。由 Item_base 定义，Bulk_item 继承。
虚函数 double net_price(size_t) 的两个版本，返回给定数目的某书的总价。Item_base 类和
 Bulk_item 类将定义该函数自己的版本。
 
【动态绑定】
动态绑定我们能够编写程序使用继承层次中任意类型的对象，无须关心对象的具体类型。使用这些类
的程序无须区分函数是在基类还是在派生类中定义的。

例如，书店应用程序可以允许顾客在一次交易中选择几本书，当顾客购书时，应用程序可以计算总的
应付款，指出最终账单的一个部分将是为每本书打印一行，以显示总数和售价。

可以定义一个名为 print_total 的函数管理应用程序的这个部分。给定一个项目和数量，函数应打印
 ISBN 以及购买给定数量的某书的总价。这个函数的输出应该像这样：
     ISBN: 0-201-54848-8 number sold: 3 total price: 98
     ISBN: 0-201-82470-1 number sold: 5 total price: 202.5

可以这样编写 print_total 函数：

     // calculate and print price for given number of copies, applying any discounts
     void print_total(ostream &os,
                      const Item_base &item, size_t n)
     {
          os << "ISBN: " << item.book() // calls Item_base::book
             << "\tnumber sold: " << n << "\ttotal price: "
             // virtual call: which version of net_price to call is resolved at run time
             << item.net_price(n) << endl;
     }

该函数的工作很普通：调用其 item 形参的 book 和 net_price 函数，打印结果。关于这个函数，有
两点值得注意。

第一，虽然这个函数的第二形参是 Item_base 的引用但可以将 Item_base 对象或 Bulk_item 对象传
给它。
第二，因为形参是引用且 net_price 是虚函数，所以对 net_price 的调用将在运行时确定。调用哪
个版本的 net_price 将依赖于传给 print_total 的实参。如果传给 print_total 的实参是一个 
Bulk_item 对象，将运行 Bulk_item 中定义的应用折扣的 net_price；如果实参是一个 Item_base 
对象，则调用由 Item_base 定义的版本。

在 C++ 中，通过基类的引用（或指针）调用虚函数时，发生动态绑定。引用（或指针）既可以指向基
类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行
时确定，被调用的函数是引用（或指针）所指对象的实际类型所定义的。













	


