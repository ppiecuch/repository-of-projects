C++ 中面向对象编程的一个颇具讽刺意味的地方是，不能使用对象支持面向对象编程，相反，必须使
用指针或引用。例如，下面的代码段中：

     void get_prices(Item_base object,
                     const Item_base *pointer,
                     const Item_base &reference)
     {
         // which version of net_price is called is determined at run time
         cout << pointer->net_price(1) << endl;
         cout << reference.net_price(1) << endl;

         // always invokes Item_base::net_price
         cout << object.net_price(1) << endl;
     }

通过 pointer 和 reference 进行的调用在运行时根据它们所绑定对象的动态类型而确定。

但是，使用指针或引用会加重类用户的负担。在前一节中讨论继承类型对象与容器的相互作用时，
已经碰到了一种这样的负担。

C++ 中一个通用的技术是定义包装（cover）类或句柄类。句柄类存储和管理基类指针。指针所指对
象的类型可以变化，它既可以指向基类类型对象又可以指向派生类型对象。用户通过句柄类访问继承
层次的操作。因为句柄类使用指针执行操作，虚成员的行为将在运行时根据句柄实际绑定的对象的类
型而变化。因此，句柄的用户可以获得动态行为但无须操心指针的管理。
【★】C++ 中一个通用的技术是定义包装（cover）类或句柄类。句柄类存储和管理基类指针。

包装了继承层次的句柄有两个重要的设计考虑因素：
1.像对任何保存指针（第 13.5 节）的类一样，必须确定对复制控制做些什么。包装了继承层次的句
柄通常表现得像一个智能指针（第 13.5.1 节）或者像一个值（第 13.5.2 节）。
2.句柄类决定句柄接口屏蔽还是不屏蔽继承层次，如果不屏蔽继承层次，用户必须了解和使用基本层
次中的对象。

对于这些选项没有正确的选择，决定取决于继承层次的细节，以及类设计者希望程序员如何与那些类
相互作用。下面两节将实现两种不同的句柄，用不同的方式解决这些设计问题。





