如果有一个派生类型的对象，则可以使用它的地址对基类类型的指针进行赋值或初始化。同样，可以
使用派生类型的引用或对象初始化基类类型的引用。严格说来，对对象没有类似转换。编译器不会自
动将派生类型对象转换为基类类型对象。

【★】编译器不会自动将派生类型对象转换为基类类型对象。只是将指针或引用绑定而已

但是，一般可以使用派生类型对象对基类对象进行赋值或初始化。对对象进行初始化和／或赋值以及
可以自动转换引用或指针，这之间的区别是微妙的，必须好好理解。

引用转换不同于转换对象

我们已经看到，可以将派生类型的对象传给希望接受基类引用的函数。也许会因此认为对象进行转换，
但是，事实并非如此。将对象传给希望接受引用的函数时，引用直接绑定到该对象，虽然看起来在传
递对象，实际上实参是该对象的引用，对象本身未被复制，并且，转换不会在任何方面改变派生类型
对象，该对象仍是派生类型对象。

将派生类对象传给希望接受基类类型对象（而不是引用）的函数时，情况完全不同。在这种情况下，
形参的类型是固定的――在编译时和运行时形参都是基类类型对象。如果用派生类型对象调用这样的函
数，则该派生类对象的基类部分被复制到形参。

一个是派生类对象转换为基类类型引用，一个是用派生类对象对基类对象进行初始化或赋值，理解它
们之间的区别很重要。

【用派生类对象对基类对象进行初始化或赋值】
对基类对象进行初始化或赋值，实际上是在调用函数：初始化时调用构造函数，赋值时调用赋值操作
符。
【★】初始化时调用构造函数，赋值时调用赋值操作符。

用派生类对象对基类对象进行初始化或赋值时，有两种可能性。第一种（虽然不太可能的）可能性
是，基类可能显式定义了将派生类型对象复制或赋值给基类对象的含义，这可以通过定义适当的构造
函数或赋值操作符实现：

     class Derived;
     class Base {
     public:
         Base(const Derived&);  // create a new Base from a Derived
         Base &operator=(const Derived&);  // assign from a Derived
         // ...
     };
在这种情况下，这些成员的定义将控制用 Derived 对象对 Base 对象进行初始化或赋值时会发生什么。

然而，类显式定义怎样用派生类型对象对基类类型进行初始化或赋值并不常见，相反，基类一般（显
式或隐式地）定义自己的复制构造函数和赋值操作符（第十三章），这些成员接受一个形参，该形参
是基类类型的（const）引用。因为存在从派生类引用到基类引用的转换，这些复制控制成员可用于
从派生类对象对基类对象进行初始化或赋值：
	Item_base item; // object of base type
     Bulk_item bulk; // object of derived type
     // ok: uses Item_base::Item_base(const Item_base&) constructor
     Item_base item(bulk);  // bulk is "sliced down" to its Item_base portion
     // ok: calls Item_base::operator=(const Item_base&)
     item = bulk;           // bulk is "sliced down" to its Item_base portion

【★】从派生类对象对基类对象进行初始化或赋值,基类一般定义自己的复制构造函数和赋值操作符,这些
成员接受一个形参，该形参是基类类型的（const）引用。

用 Bulk_item 类型的对象调用 Item_base 类的复制构造函数或赋值操作符时，将发生下列步骤：
1.将 Bulk_item 对象转换为 Item_base 引用，这仅仅意味着将一个 Item_base 引用绑定到 
Bulk_item 对象。
2.将该引用作为实参传给复制构造函数或赋值操作符。
3.那些操作符使用 Bulk_item 的 Item_base 部分分别对调用构造函数或赋值的 Item_base 对象的
成员进行初始化或赋值。
4.一旦操作符执行完毕，对象即为 Item_base。它包含 Bulk_item 的 Item_base 部分的副本，但实
参的 Bulk_item 部分被忽略。

在这种情况下，我们说 bulk 的 Bulk_item 部分在对 item 进行初始化或赋值时被“切掉”了。
Item_base 对象只包含基类中定义的成员，不包含由任意派生类型定义的成员，Item_base 对象
中没有派生类成员的存储空间。

【派生类到基类转换的可访问性】
像继承的成员函数一样，从派生类到基类的转换可能是也可能不是可访问的。转换是否访问取决于在
派生类的派生列表中指定的访问标号。

【★】要确定到基类的转换是否可访问，可以考虑基类的 public 成员是否访问，如果可以，转换是
可访问的，否则，转换是不可访问的。

如果是 public 继承，则用户代码和后代类都可以使用派生类到基类的转换。如果类是使用 private 
或 protected 继承派生的，则用户代码不能将派生类型对象转换为基类对象。如果是 private 继
承，则从 private 继承类派生的类不能转换为基类。如果是 protected 继承，则后续派生类的成员
可以转换为基类类型。
【★】如果类是使用 private 或 protected 继承派生的，则用户代码不能将派生类型对象转换为
基类对象。
【★】如果是 private 继承，则从 private 继承类派生的类不能转换为基类。
【★】如果是 protected 继承，则后续派生类的成员可以转换为基类类型。

无论是什么派生访问标号，派生类本身都可以访问基类的 public 成员，因此，派生类本身的成员和
友元总是可以访问派生类到基类的转换。

【★】无论是什么派生访问标号，派生类本身都可以访问基类的 public 成员



















