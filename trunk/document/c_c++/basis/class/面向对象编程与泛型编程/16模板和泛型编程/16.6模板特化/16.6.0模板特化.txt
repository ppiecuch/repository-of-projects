本章其余部分将介绍一个比较高级的主题，在第一次阅读时可以跳过它。

我们并不总是能够写出对所有可能被实例化的类型都最合适的模板。某些情况下，通用模板定义对于
某个类型可能是完全错误的，通用模板定义也许不能编译或者做错误的事情；另外一些情况下，可以
利用关于类型的一些特殊知识，编写比从模板实例化来的函数更有效率的函数。

compare 函数和 Queue 类都是这一问题的好例子：与 C 风格字符串一起使用进，它们都不能正确工
作。让我们再来看看 compare 函数模板：

     template <typename T>
     int compare(const T &v1, const T &v2)
     {
        if (v1 < v2) return -1;
        if (v2 < v1) return 1;
        return 0;
     }


如果用两个 const char* 实参调用这个模板定义，函数将比较指针值。它将告诉我们这两个指针在内
存中的相对位置，但没有说明归纳法指针所指数组的内容有关的任何事情。

为了能够将 compare 函数用于字符串，必须提供一个知道怎样比较 C 风格字符串的特殊定义。这些
版本是特化的，这一事实对模板的用户透明。对用户而言，调用特化函数或使用特化类，与使用从
通用模板实例化的版本无法区别。


