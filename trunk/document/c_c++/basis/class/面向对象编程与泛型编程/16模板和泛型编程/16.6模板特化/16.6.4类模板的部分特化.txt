【★】如果类模板有一个以上的模板形参，我们也许想要特化某些模板形参而非全部。使用类模板的
部分特化可以做到这一点：

     template <class T1, class T2>
     class some_template {
         // ...
     };
     // partial specialization: fixes T2 as int and allows T1 to vary
     template <class T1>
     class some_template<T1, int> {
         // ...
     };

类模板的部分特化本身也是模板。部分特化的定义看来像模板定义，这种定义以关键字 template 开
头，接着是由尖括号（<>）括住的模板形参表。部分特化的模板形参表是对应的类模板定义形参表的
子集。some_template 的部分特化只有一个名为 T1 的模板类型形参，第二个模板形参 T2 的实参已
知为 int。部分特化的模板形参表只列出未知模板实参的那些形参。

【使用类模板的部分特化】
部分特化与对应类模板有相同名字，即这里的 some_template。类模板的名字后面必须接着模板实参
列表，前面例子中，模板实参列表是 <T1,int>。因为第一个模板形参的实参值未知，实参列表使用模
板形参名 T1 作为占位符，另一个实参是类型 int，为 int 而部分特化模板。

像任何其他类模板一样，部分特化是在程序中使用时隐式实例化：

     some_template<int, string> foo; // uses template
     some_template<string, int> bar; // uses partial specialization


注意第二个变量的类型，形参为 string 和 int 的 some_template，既可以从普通类模板定义实例
化，也可以从部分特化实例化。为什么选择部分特化来实例化该模板呢？当声明了部分特化的时候，
编译器将为实例化选择最特化的模板定义，当没有部分特化可以使用的时候，就使用通用模板定义。
foo 的实例化类型与提供的部分特化不匹配，因此，foo 的类型必然从通用类模板实例化，将 int 
绑定到 T1 并将 string 绑定到 T2。部分特化只用于实例化第二个类型为 int 的 some_template 类
型。

【★】部分特化的定义与通用模板的定义完全不会冲突。部分特化可以具有与通用类模板完全不同的成
员集合。类模板成员的通用定义永远不会用来实例化类模板部分特化的成员。




