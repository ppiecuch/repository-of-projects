到目前为止，我们只介绍了怎样声明 Queue 类模板的接口成员，本节将介绍怎样实现该类。

标准库将 queue 实现为其他容器之上的适配器（第 9.7 节）。为了强调在使用低级数据结构中涉及的
编程要点，我们将 Queue 实现为链表。实际上，在我们的实现中使用标准库容器可能是一个更好的决
定。

【Queue 的实现策略】
如图 16.1 所示，我们的实现使用两个类：
1、QueueItem 类表示 Queue 的链表中的节点，该类有两个数据成员 item 和 next：
item 保存 Queue 中元素的值，它的类型随 Queue 的每个实例而变化。
next 是队列中指向下一 QueueItem 对象的指针。
2、Queue 类将提供第 16.1.2 节描述的接口函数，Queue 类也有两个数据成员：head 和 tail，这些
成员是 QueueItem 指针。
像标准容器一样，Queue 类将复制指定给它的值。

【QueueItem 类】
首先编写 QueueItem 类：

     template <class Type> class QueueItem {
     // private class: no public section
         QueueItem(const Type &t): item(t), next(0) { }
         Type item;           // value stored in this element
         QueueItem *next;     // pointer to next element in the Queue
     };
这个类似乎已经差不多完整了：它保存由其构造函数初始化的两个数据成员。像 Queue 类一样，
QueueItem 是一个类模板，该类使用模板形参指定 item 成员的类型，Queue 中每个元素的值将保存
在 item 中。

每当实例化一个 Queue 类的时候，也将实例化 QueueItem 的相同版本。例如，如果创建 Queue<int>，
则将实例化一个伙伴类 QueueItem<int>。

QueueItem 类为私有类――它没有公用接口。我们这个类只是为实现 Queue，并不想用于一般目的，因
此，它没有公用成员。需要将 Queue 类设为 QueueItem 类的友元，以便 Queue 类成员能够访问
 QueueItem 的成员。第 16.4.4 节将介绍怎样做。
 
 在类模板的作用域内部，可以用它的非限定名字引用该类。
 【?】非限定名字是指?

 【Queue 类】
现在充实 Queue 类：

     template <class Type> class Queue {
     public:
         // empty Queue
         Queue(): head(0), tail(0) { }
         // copy control to manage pointers to QueueItems in the Queue
         Queue(const Queue &Q): head(0), tail(0)
                                       { copy_elems(Q); }
         Queue& operator=(const Queue&);
         ~Queue() { destroy(); }
              // return element from head of Queue
         // unchecked operation: front on an empty Queue is undefined
         Type& front()             { return head->item; }
         const Type &front() const { return head->item; }
         void push(const Type &);       // add element to back of Queue
         void pop ();                    // remove element from head of Queue
         bool empty () const {           // true if no elements in the Queue
             return head == 0;
         }
     private:
         QueueItem<Type> *head;         // pointer to first element in Queue
         QueueItem<Type> *tail;         // pointer to last element in Queue
         // utility functions used by copy constructor, assignment, and destructor
         void destroy();                // delete all the elements
         void copy_elems(const Queue&); // copy elements from parameter
     };

除了接口成员之外，还增加了三个复制控制成员（第十三章）以及那些成员所用的相关实用函数。
private 实用函数 destroy 和 copy_elems 将完成释放 Queue 中的元素以及从另一 Queue 复制元素
到这个 Queue 的任务。复制控制成员用于管理数据成员 head 和 tail，head 和 tail 是指向 Queue 
中首尾元素的指针，这些成员是 QueueItem<Type> 类型的值。

Queue 类实现了几个成员函数：
1.默认构造函数，将 head 和 tail 指针置 0,指明当前 Queue 为空。
2.复制构造函数，初始化 head 和 tail，并调用 copy_elems 从它的初始器复制元素。
3.几个 front 函数，返回头元素的值。这些函数不进行检查：像标准 queue 中的类似操作一样，用户不
能在空 Queue 上运行 front 函数。
empty 函数，返回 head 与 0 的比较结果。如果 head 为 0，Queue 为空；否则，Queue 是非空的。

 【模板作用域中模板类型的引用】
这个类的主要部分应该是我们熟悉的。它只与我们已经定义过的类有少许区别。新的内容是 Queue 类
型和 QueueItem 类型的引用中对模板类型形参的使用（或缺少）。

【★】通常，当使用类模板的名字的时候，必须指定模板形参。这一规则有个例外：在类本身的作用域内部，
可以使用类模板的非限定名。例如，在默认构造函数和复制构造函数的声明中，名字 Queue 是
 Queue<Type> 缩写表示。实质上，编译器推断，当我们引用类的名字时，引用的是同一版本。因此，
 复制构造函数定义其实等价于：

     Queue<Type>(const Queue<Type> &Q): head(0), tail(0)
                 { copy_elems(Q); }


编译器不会为类中使用的其他模板的模板形参进行这样的推断，因此，在声明伙伴类 QueueItem 的指
针时，必须指定类型形参：

     QueueItem<Type> *head;    // pointer to first element in Queue
     QueueItem<Type> *tail;    // pointer to last element in Queue

这些声明指出，对于 Queue 类的给定实例化，head 和 tail 指向为同一模板形参实例化的 QueueItem 
类型的对象，即，在 Queue<int> 实例化的内部，head 和 tail 的类型是 QueueItem<int>*。在 head 
和 tail 成员的定义中省略模板形参将是错误的：

     QueueItem *head;        // error: which version of QueueItem?
     QueueItem *tail;        // error: which version of QueueItem?

















