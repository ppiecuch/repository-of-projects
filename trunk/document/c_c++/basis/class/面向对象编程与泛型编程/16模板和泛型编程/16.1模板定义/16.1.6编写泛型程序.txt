编写模板时，代码不可能针对特定类型，但模板代码总是要对将使用的类型做一些假设。例如，虽然 compare 
函数从技术上说任意类型都是有效的，但实际上，实例化的版本可能是非法的。

产生的程序是否合法，取决于函数中使用的操作以及所用类型支持的操作。compare 函数有三条语句：

     if (v1 < v2) return -1; // < on two objects of type T
     if (v2 < v1) return 1;  // < on two objects of type T
     return 0;               // return int; not dependent on T


前两条语句包含隐式依赖于形参类型的代码，if 测试对形参使用 < 操作符，直到编译器看见 compare 调用并且 T
 绑定到一个实际类型时，才知道形参的类型，使用哪个 < 操作符完全取决于实参类型。

如果用不支持 < 操作符的对象调用 compare，则该调用将是无效的：

     Sales_item item1, item2;
     // error: no < on Sales_item
     cout << compare(item1, item2) << endl;


程序会出错。Sales_item 类型没有定义 < 操作符，所以该程序不能编译。

在函数模板内部完成的操作限制了可用于实例化该函数的类型。程序员的责任是，保证用作函数实参的类型实际上
支持所用的任意操作，以及保证在模板使用哪些操作的环境中那些操作运行正常。

【★】在函数模板内部完成的操作限制了可用于实例化该函数的类型。

【编写独立于类型的代码】
编写良好泛型代码的技巧超出了本书的范围，但是，有个一般原则值得注意。

编写模板代码时，对实参类型的要求尽可能少是很有益的。

虽然简单，但它说明了编写泛型代码的两个重要原则：
1.模板的形参是 const 引用。
2.函数体中的测试只用 < 比较。

通过将形参设为 const 引用，就可以允许使用不允许复制的类型。大多数类型（包括内置类型和我们已使用过的
除 IO 类型之外的所有标准库的类型）都允许复制。但是，也有不允许复制的类类型。将形参设为 const 引用，
保证这种类型可以用于 compare 函数，而且，如果有比较大的对象调用 compare，则这个设计还可以使函数运行
得更快。

一些读者可能认为使用 < 和 > 操作符两者进行比较会更加自然：

     // expected comparison
     if (v1 < v2) return -1;
     if (v1 > v2) return 1;
     return 0;

但是，将代码编写为

     // expected comparison
     if (v1 < v2) return -1;
     if (v2 < v1) return 1; // equivalent to v1 > v2
     return 0;

可以减少对可用于 compare 函数的类型的要求，这些类型必须支持 <，但不必支持 >。
(我认为一个类型既然支持<,那么从理论上讲,它支持>是合理的,也是应该的)

【警告：链接时的编译时错误】
一般而言，编译模板时，编译器可能会在三个阶段中标识错误：第一阶段是编译模板定义本身时。在这个阶段中
编译器一般不能发现许多错误，可以检测到诸如漏掉分号或变量名拼写错误一类的语法错误。

第二个错误检测时间是在编译器见到模板的使用时。在这个阶段，编译器仍没有很多检查可做。对于函数模板的调
用，许多编译器只检查实参的数目和类型是否恰当，编译器可以检测到实参太多或太少，也可以检测到假定类型
相同的两个实参是否真地类型相同。对于类模板，编译器可以检测提供的模板实参的正确数目。

产生错误的第三个时间是在实例化的时候，只有在这个时候可以发现类型相关的错误。根据编译器管理实例化的方
式（将在第 16.3 节讨论），有可能在链接时报告这些错误。

重要的是，要认识到编译模板定义的时候，对程序是否有效所知不多。类似地，甚至可能会在已经成功编译了使用
模板的每个文件之后出现编译错误。只在实例化期间检测错误的情况很少，错误检测可能发生在链接时。










