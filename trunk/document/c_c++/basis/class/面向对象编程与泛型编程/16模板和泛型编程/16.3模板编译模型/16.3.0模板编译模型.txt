当编译器看到模板定义的时候，它不立即产生代码。只有在看到用到模板时，如调用了函数模板或调
用了类模板的对象的时候，编译器才产生特定类型的模板实例。

一般而言，当调用函数的时候，编译器只需要看到函数的声明。类似地，定义类类型的对象时，类定
义必须可用，但成员函数的定义不是必须存在的。因此，应该将类定义和函数声明放在头文件中，而
普通函数和类成员函数的定义放在源文件中。
【★】定义类类型的对象时，类定义必须可用，但成员函数的定义不是必须存在的。类似地，编译器
只有在代码调用了函数模板或调用了类模板的对象的时候，才产生特定类型的模板实例。

模板则不同：要进行实例化，编译器必须能够访问定义模板的源代码。当调用函数模板或类模板的成
员函数的时候，编译器需要函数定义，需要那些通常放在源文件中的代码。

标准 C++ 为编译模板代码定义了两种模型。在两种模型中，构造程序的方式很大程度上是相同的：类
定义和函数声明放在头文件中，而函数定义和成员定义放在源文件中。两种模型的不同在于，编译器
怎样使用来自源文件的定义。如本书所述，所有编译器都支持第一种模型，称为“包含”模型，只有一
些编译器支持第二种模型，“分别编译”模型。
【?】“包含”模型与“分别编译”模型的区别
【▲】见下文

要编译使用自己的类模板和函数模板的代码，必须查阅编译器的用户指南，看看编译器怎样处理实例
化。

【包含编译模型】
在包含编译模型中，编译器必须看到用到的所有模板的定义。一般而言，可以通过在声明函数模板或类
模板的头文件中添加一条 #include 指示使定义可用，该 #include 引入了包含相关定义的源文件：

     // header file utlities.h
     #ifndef UTLITIES_H // header gaurd (Section 2.9.2, p. 69)
     #define UTLITIES_H
     template <class T> int compare(const T&, const T&);
     // other declarations

     #include "utilities.cc" // get the definitions for compare etc.
     #endif

     // implemenatation file utlities.cc
     template <class T> int compare(const T &v1, const T &v2)
     {
         if (v1 < v2) return -1;
         if (v2 < v1) return 1;
         return 0;
     }
     // other definitions

这一策略使我们能够保持头文件和实现文件的分享，但是需要保证编译器在编译使用模板的代码时能
看到两种文件。


某些使用包含模型的编译器，特别是较老的编译器，可以产生多个实例。如果两个或多个单独编译的
源文件使用同一模板，这些编译器将为每个文件中的模板产生一个实例。通常，这种方法意味着给定
模板将实例化超过一次。在链接的时候，或者在预链接阶段，编译器会选择一个实例化而丢弃其他的。
在这种情况下，如果有许多实例化同一模板的文件，编译时性能会显著降低。对许多应用程序而言，
这种编译时性能降低不大可能在现代计算机上成为问题，但是，在大系统环境中，编译时选择问题可
能变得非常重要。

这种编译器通常支持某些机制，避免同一模板的多个实例化中隐含的编译进开销。编译器优化编译时
性能的方法各不相同。如果使用模板的程序的编译时间难于承担，请查阅编译器的用户指南，看看你
的编译器能提供什么支持以避免多余的实例化。


【分别编译模型】
在分别编译模型中，编译器会为我们跟踪相关的模板定义。但是，我们必须让编译器知道要记住给定
的模板定义，可以使用 export 关键字来做这件事。

export 关键字能够指明给定的定义可能会需要在其他文件中产生实例化。在一个程序中，一个模板
只能定义为导出一次。编译器在需要产生这些实例化时计算出怎样定位模板定义。export 关键字不
必在模板声明中出现。
【★】export 关键字能够指明给定的定义可能会需要在其他文件中产生实例化。
【★】在一个程序中，一个模板只能定义为导出一次。
【★】export 关键字不必在模板声明中出现。

【★】一般我们在函数模板的定义中指明函数模板为导出的，这是通过在关键字 template 之前包含
 export关键字而实现的：

     // the template definition goes in a separately-compiled source file
     export template <typename Type>
     Type sum(Type t1, Type t2) /* ...*/

这个函数模板的声明像通常一样应放在头文件中，声明不必指定 export。

对类模板使用 export 更复杂一些。通常，类声明必须放在头文件中，头文件中的类定义体不应该使
用关键字 export，如果在头文件中使用了 export，则该头文件只能被程序中的一个源文件使用。

相反，应该在类的实现文件中使用 export：

     // class template header goes in shared header file
     template <class Type> class Queue { ... };
     // Queue.ccimplementation file declares Queue as exported
     export template <class Type> class Queue;
     #include "Queue.h"
     // Queue member definitions

导出类的成员将自动声明为导出的。也可以将类模板的个别成员声明为导出的，在这种情况下，关键
字 export 不在类模板本身指定，而是只在被导出的特定成员定义上指定。导出成员函数的定义不必
在使用成员时可见。任意非导出成员的定义必须像在包含模型中一样对待：定义应放在定义类模板的
头文件中。

【警告：类模板中的名字查找】
编译模板是异常困难的工作。幸好，它是由编译器作者处理的任务。不幸的是，某些复杂性被推到模
板用户的身上：模板包含两种名字：
1、独立于模板形参的那些名字
2、依赖于模板形参的那些名字
设计者的责任是，保证所有不依赖于模板形参的名字在模板本身的作用域中定义。
模板用户的责任是，保证与用来实例化模板的类型相关的所有函数、类型和操作符的声明可见。这个
责任意味着，在实例化类模板的成员或函数模板的时候，用户必须保证这些声明是可见的。
适当使用头文件的结构良好的程序都容易满足这两个要求。模板的作者应提供头文件，该头文件包含
在类模板或在其成员定义中使用的所有名字的声明。在用特定类型定义模板或者使用该模板的成员之
前，用户必须保证包含了模板类型的头文件，以及定义用作成员类型的类型的头文件。













