今天整理过去的学习笔记，无意中看到这个，自己写的，居然大部分都不记得，可能是很少用到吧。干脆帖出来，大家有什么补充的。。。

1、基础介绍
try
{
//程序中抛出异常
throw value;
}
catch(valuetype v)
{
//例外处理程序段
}
语法小结：throw抛出值，catch接受，当然，throw必须在“try语句块”中才有效。

2、深入throw：
(i)、程序接受到throw语句后就会自动调用析构器，把该域（try后的括号内）对象clean up，然后再进
入catch语句（如果在循环体中就退出循环）。

这种机制会引起一些致命的错误，比如，当“类”有指针成员变量时（又是指针！），在 “类的构建器
”中的throw语句引起的退出，会导致这个指针所指向的对象没有被析构。这里很基础，就不深入了，提
示一下，把指针改为类就行了，比如模板类来代替指针，在模板类的内部设置一个析构函数。

(ii)、语句“throw;”抛出一个无法被捕获的异常，即使是catch(...)也不能捕捉到，这时进入终止函数
，见下catch。

3、深入catch：
一般的catch出现的形式是：
try{}
catch(except1&){}
catch(except2&){}
catch(...){} //接受所有异常
一般都写成引用（except1&），原因很简单，效率。

问题a：抛出异常，但是catch不到异常怎么办？（注意没有java类似的finally语句）
在catch没有捕获到匹配的异常的时候，会调用默认的终止函数。可以调用set_terminate()来设置终止函数，参数是一个函数指针，类型是：void (*terminate)()。

到这里，可以题个问题：“没有try-catch,直接在程序中"throw;"，会怎么样？”


其他一些技巧：
4、try一个函数体，形式如下
void fun(type1,type2) try－－－－try放在函数体后
{
  函数定义
}
catch(typeX){}
这个用法的效果就相当于:
void fun() 
{
  try{函数定义}
}


5、throw一个函数体，形式如下：
void fun (); // 能抛出任何类型的异常
void fun () throw(except1,except2,except3) 
                   // 后面括号里面是一个异常参数表，本例中只能抛出这3中异常
void fun () throw()  // 参数表为空，不能抛出异常

问题b：假设fun()中抛出了一个不在“异常参数表”中的异常，会怎么样？

答：调用set_terminate()中设定的终止函数。然而，这只是表面现象，实际上是调用默认的unexpected()函数，然而这个默认的unexpected()调用了set_terminate()中设定的终止函数。可以用set_unexpected()来设置unexpected,就像set_terminate()一样的用法，但是在设定了新的“unexpected()”之后，就不会再调用set_terminater中设定的终止函数了。

这个语法是很有用的，因为在用别人的代码时，不知道哪个地方会调用什么函数又会抛出什么异常，用一个异常参数表在申明时限制一下，很实用。
