只在Linux下查看了malloc的使用情况：
GCC版本4.6.1
libc-dev 3.0.0-14.23
//============================================================
libc中有非线程安全/线程安全两个版本malloc函数
下面的链接对此有描述，几年前的版本可能是这样的：
通过 -pthreads 选项可以明确指定在链接时是链接非线程安全的版本还是线程安全的版本。
http://stackoverflow.com/questions/987444/about-thread-safety-in-malloc-and-free
//============================================================
我使用的版本中已经没有-pthreads这个选项了，但更智能些：
会智能选择使用非线程安全/线程安全的malloc函数
//====================
测试结果：
只要使用了线程相关的函数，在编译后的文件中使用的malloc函数就是线程安全的版本。
（链接器不会考虑你是否真的启动了线程，或是否真的使用了那个线程）
//====================
即：在文件中引用了头文件#include<pthread.h>，编译时使用-lpthread选项，文件中使用了pthread_t定义变量，
但没有使用pthread_attr_init或pthread_createh函数，编译后的malloc函数就是非线程安全的。
//====================
但如果使用了pthread_attr_init或pthread_createh函数，编译后的malloc函数就是线程安全的。
即使你只是使用了一次pthread_createh(NULL,NULL,NULL,NULL);
//============================================================
我以前从没考虑过malloc是否是线程安全的这回事，反正就直接用了。
使用glibc时可以在官网上下载手册，如果函数是非线程安全的，在函数下面会有一行说明（好像只有很少几个是非线程安全的）。
虽然malloc下面没有说明，但我还是观察了一下，算是解开自己的疑惑吧。
//============================================================