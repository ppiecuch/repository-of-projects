1.
深入Windowsr器
http://eric.netgenes.org/InsideWindowsTimer/InsideWindowsTimer.htm

2.
VCrg控制函
http://www.pcvc.net/category/content.asp?sendid=30
OQ泉 
　　S著硬件的w速l展，算C技g已V泛地用到自踊控制I域，榱Fr控制，控制程序必能蚓_地完成定r和r功能。VC提供了很多P於rg操作的函担下面根它精度的不同，分eM行f明。 

一般r控函 

　　VC程序T都利用Windows的WM_TIMER消息映射磉M行蔚rg控制：1.{用函SetTimer()O置定rg隔，如SetTimer(0,200,NULL)即樵O置200毫秒的rgg隔；2.在用程序中增加定r函OnTimer()，K在函抵刑砑禹的理Z句，用硗瓿rg到r的操作。@N定r方法是非常蔚模但其定r功能如同Sleep()函档难r功能一樱精度^低，只可以用FT如位D的B@示等Χr精度要求不高的情r，而在精度要求^高的l件下，@N方法避免裼谩 

精度r控函 

　　在要求`差不大於1毫秒的情r下，可以裼GetTickCount()函担函档姆祷刂凳DWORD型，表示以毫秒挝坏挠算C俞峤v的rgg隔。使用下面的程Z句，可以F50毫秒的精_定r，其`差小於1毫秒。 

　　DWORD dwStart, dwStop; 

　　// 起始值和K止值 

　　dwStop = GetTickCount(); 

　　while(TRUE) 
　　{ 
        dwStart = dwStop; 
　　// 上一次的K止值成新的起始值 
　　// 此添加相控制Z句
　　 do
　　 {
        dwStop = GetTickCount();
　　 }while(dwStop - 50 < dwStart);
　　} 

高精度r控函 

　　於一般的r控制，使用GetTickCount()函稻涂梢M足精度要求，但要M一步提高r精度，就要裼QueryPerformanceFrequency()函岛QueryPerformanceCounter()函怠＿@函凳VC提供的H供Windows 9X使用的高精度rg函担K要求算C挠布上支持高精度r器。QueryPerformanceFrequency()函岛QueryPerformanceCounter()函档脑型椋 

　　BOOL QueryPerformanceFrequency(LARGE_INTEGER *lpFrequency);

　　BOOL QueryPerformanceCounter(LARGE_INTEGER *lpCount);

　　型LARGE―INTEGER既可以是一作8字L的整型担也可以是作4字L的整型档穆合Y，其具w用法根g器是否支持64位而定。型的定x如下： 

　　typedef union _LARGE_INTEGER
　　{
　　 struct
　　 {
        DWORD LowPart; // 4字整型 
        LONG　　HighPart; // 4字整型 
    }; 
　　LONGLONG　　QuadPart; 

　　// 8字整型 
　　} LARGE_INTEGER; 

　　在M行r之前，先{用QueryPerformanceFrequency()函但@得C器炔坑r器的rl率]。P者在主l266、300、333的三NPentiumⅡC器上使用函担得到的rl率都是1193180Hz。接著，P者在需要栏裼r的事件l生之前和l生之後分e{用QueryPerformanceCounter()函担利用纱潍@得的抵差和rl率，就可以算出事件v的精_rg。以下程序是用y函Sleep(100)的精_持mrg。 

　　LARGE―INTEGER litmp; 
　　LONGLONG QPart1,QPart2; 
　　double dfMinus, dfFreq, dfTim; 

　　QueryPerformanceFrequency(&litmp); 
　　// @得灯鞯rl率 
　　dfFreq = (double)litmp.QuadPart; 
　　QueryPerformanceCounter(&litmp); 
　　// @得初始值 
　　QPart1 = litmp.QuadPart; 
　　Sleep(100) ; 
　　QueryPerformanceCounter(&litmp); 
　　// @得K止值 
　　QPart2 = litmp.QuadPart;
　　dfMinus = (double)(QPart2 － QPart1);
　　dfTim = dfMinus / dfFreq;
　　// @得的rg值

　　绦猩厦娉绦颍得到的Y果dfTim=0.097143767076216(秒)。心的x者lF，每次绦械慕Y果都不一樱存在一定的差e，@是由於Sleep()自身的`差所致。
　　本文介B了三N定r或r的F方法，x者可以根自己的H情rM行x瘢以_到程序的定r和r功能。以上程序均在VC 6.0、Windows 98h境下{通^。


http://delphi.ktop.com.tw/board.php?cid=168&fid=914&tid=30062