在前面已经提起过，在计算机中是采用二进制0和1来表示数据的，每一个0或者1占用1位（bit）存储空间，8位组成一个字节（byte），为计算机中数据类型的最小单位，如char在32bit系统中占用一个字节。但是正如我们知道的，有时候程序中的数据可能并不需要这么的字节，比如一个开关的状态，只有开和关，用1和0分别替代就可以表示。此时开关的状态只需要一位存储空间就可以满足要求。如果用一个字节来存储，显然浪费了另外的7位存储空间。所以在C语言中就有了位段（有的也叫位域，其实是一个东西）这个概念。具体的语法就是在变量名字后面，加上冒号(:)和指定的存储空间的位数。具体的定义语法如下：

   1:  struct 位段名称     2:  {       3:       位段数据类型   位段变量名称 : 位段长度,         4:        .......      5:   }   6:      7:  实例   8:      9:  struct Node  10:  {  11:     char a:2;  12:     double i;  13:     int c:4;  14:  }node;     其实定义很简单，上面示例的意义是，定义一个char变量a，占用2位存储空间，一个double变量i，以及一个占用4位存储的int变量c。请注意这里改变了变量本来占用字节的大小,并不是我们常规定义的一个int变量占用4个字节，一个char变量占用1一个字节。但是sizeof(node) = ?呢，在实际的运行环境中运行，得到sizeof(node) = 24；为什么呢？说起来其实也很简单，字节对齐，什么是字节对齐，待会下一个段落会具体讲解。先来看一个面试示例，代码如下：

   1:  #include <iostream>   2:      3:  using namespace std;   4:      5:  union   6:  {   7:      struct   8:      {   9:          char i:1;  10:          char j:2;  11:          char m:3;  12:      }s;  13:     14:      char ch;  15:  }r;  16:     17:  int _tmain(int argc, _TCHAR* argv[])  18:  {  19:      r.s.i = 1;  20:      r.s.j = 2;  21:      r.s.m = 3;  22:     23:      cout<<" r.ch = "<<(int)r.ch<<" = 0x"<<hex<<(int)r.ch<<endl  24:          <<" sizeof(r) = "<<sizeof(r)<<endl;  25:     26:      return 0;  27:  }           好了，具体结果是怎么样的呢？

     r.ch = 29 = 0x1d 
     sizeof(r) = 1  
           为什么是这个结果？说起来其实也很简单，结合前面的大小端，可以具体来分析下，先看下表：

 
 
       m:3
 j:2
 i:1

 
7
 6
 5
 4
 3
 2
 1
 0
 
0
 0
 0
 1
 1
 1
 0
 1
 
1
 D
 
http://www.cnblogs.com/leezhm/archive/2011/07/19/2110864.html
          上面的表格，解释了为什么这里等于29=0x1D。首先i、j、m分别占用1、2、3位，分布在一个字节中。故根据赋值语句可知，在内存的相应的字节上首先存储i=1,然后存储j=2，也即10，而后是m=3，也即011。可看上表的不同颜色所示，然后不足的位，补0来填充。所以整个字节就是0x1D=29，顾r.ch = 29 = 0x1D。

         关于位段，补充以下规则：

