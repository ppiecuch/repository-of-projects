在C++编程语言中，还有很多比较高深的内容值得我们在学习和实践中不断的学习。在这篇文章中，我们将会为大家详细介绍有关C++ const变量的相关内容，希望能帮助大家轻松了解这方面知识。

一、对于基本声明

view sourceprint?const int r=100; 

标准C++ const变量声明加初始化，因为默认内部连接所以必须被初始化，其作用域为此文件，编译器经过类型检查后直接用100在编译时替换。

view sourceprint?extend const int r=100; 

将const改为外部连接，作用于扩大至全局，编译时会分配内存，并且可以不进行初始化，仅仅作为声明，编译器认为在程序其他地方进行了定义。

view sourceprint?const int r[ ]={1,2,3,4};  

struct S {int a,b;};  

const S s[ ]={(1,2),(3.4)}; 

以上两种都是常量集合，编译器会为其分配内存，所以不能在编译期间使用其中的值，例如：int temp[r[2]];这样的编译器会报告不能找到常量表达式

二、对于指针

view sourceprint?const int *r=&x; 

声明r为一个指向常量的x的指针，r指向的对象不能被修改，但他可以指向任何地址的常量。

与用法1完全等价，没有任何区别。

view sourceprint?int * const r=&x; 

声明r为一个常量指针，他指向x，r这个指针的指向不能被修改，但他指向的地址的内容可以修改。

view sourceprint?const int * const r=&x; 

综合1、3用法，r是一个指向常量的常量型指针。

三、对于类型检查

可以把一个非const对象赋给一个指向const的指针，因为有时候我们不想从这个指针来修改其对象的值；但是不可以把一个C++ const变量对象赋值给一个非 const指针，因为这样可能会通过这个指针改变指向对象的值，但也存在使这种操作通过的合法化写法，使用类型强制转换可以通过指针改变const对象：

view sourceprint?const int r=100;  

int * ptr = const_cast(&r);  

//C++标准，C语言使用：int * ptr =(int*)&r; 

四、对于字符数组

如char * name = “china”; 这样的语句，在编译时是能够通过的，但是”china”是常量字符数组，任何想修改他的操作也能通过编译但会引起运行时错误，如果我们想修改字符数组的话就要使用char name[ ] = “china”; 这种形式。

五、对于函数

view sourceprint?void Fuction1 ( const int r ); 

此处为参数传递C++ const变量值，意义是变量初值不能被函数改变

view sourceprint?const int Fuction1 (int); 

此处返回const值，意思指返回的原函数里的变量的初值不能被修改，但是函数按值返回的这个变量被制成副本，能不能被修改就没有了意义，它可以被赋给任何的const或非const类型变量，完全不需要加上这个const关键字。但这只对于内部类型而言（因为内部类型返回的肯定是一个值，而不会返回一个变量，不会作为左值使用），对于用户自定义类型，返回值是常量是非常重要的，见下面条款。

view sourceprint?Class CX; //内部有构造函数，声明如CX(int r =0)  

CX Fuction1 () { return CX(); }  

const CX Fuction2 () { return CX(); } 

如有上面的自定义类CX，和函数Fuction1()和Fuction2(),我们进行如下操作时：

view sourceprint?Fuction1() = CX(1); //没有问题，可以作为左值调用    

Fuction2() = CX(1); //编译错误，const返回值禁止作为左值调用。 

因为左值把返回值作为变量会修改其返回值，const声明禁止这种修改。 

4.函数中指针的C++ const变量传递和返回：

view sourceprint?int F1 (const char * pstr); 

作为传递的时候使用const修饰可以保证不会通过这个指针来修改传递参数的初值，这里在函数内部任何修改*pstr的企图都会引起编译错误。

view sourceprint?const char * F2 (); 

意义是函数返回的指针指向的对象是一个const对象，它必须赋给一个同样是指向const对象的指针。

view sourceprint?const char * const F3(); 

比上面多了一个const，这个const的意义只是在他被用作左值时有效，它表明了这个指针除了指向const对象外，它本身也不能被修改，所以就不能当作左值来处理。

5.函数中引用的const传递：

view sourceprint?void F1 ( const X& px); 

这样的一个C++ const变量引用传递和最普通的函数按值传递的效果是一模一样的，他禁止对引用的对象的一切修改，唯一不同的是按值传递会先建立一个类对象的副本，然后传递过去，而它直接传递地址，所以这种传递比按值传递更有效。

另外只有引用的const传递可以传递一个临时对象，因为临时对象都是const属性，且是不可见的，他短时间存在一个局部域中，所以不能使用指针，只有引用的const传递能够捕捉到这个家伙。

六、对于类

1.首先，对于C++ const变量的成员变量，只能在构造函数里使用初始化成员列表来初始化，试图在构造函数体内进行初始化const成员变量会引起编译错误。初始化成员列表形如：

view sourceprint?X:: X ( int ir ): r(ir) {} 

假设r是类X的C++ const变量

2.const 成员函数。提到这个概念首先要谈到const对象，正象内置类型能够定义const对象一样（const int r=10;），用户自定义类型也可以定义const对象(const X px(10);)，编译器要保证这个对象在其生命周期内不能够被改变。如果你定义了这样的一个const对象，那么对于这个对象的一切非const成员函数的调用，编译器为了保证对象的const特性，都会禁止并在编译期间报错。所以如果你想让你的成员函数能够在const对象上进行操作的话，就要把这个函数声明为const成员函数。假如f( )是类中的成员函数的话，它的声明形如：

view sourceprint?int f( ) const; 

C++ const变量放在函数的最后，编译器会对这个函数进行检查，在这个函数中的任何试图改变成员变量和调用非const成员函数的操作都被视为非法

注意：类的构造和析构函数都不能是const函数。

3. 建立了一个const成员函数，但仍然想用这个函数改变对象内部的数据。这样的一个要求也会经常遇到，尤其是在一个苛刻的面试考官那里。首先我们要弄清楚考官的要求，因为有两种方法可以实现，如果这位考官要求不改变原来类的任何东西，只让你从当前这个const成员函数入手，那么你只有使用前面提到的类型强制转换方法。

实例如下：假如有一个叫做X的类，它有一个int成员变量r，我们需要通过一个C++ const变量成员函数f( )来对这个r进行++r操作，代码如下

view sourceprint?void X::f( ) const 

{ (const_cast(this)) -> ++r; } //通过this指针进行类型强制转换实现 

另外一种方法就是使用关键字：mutable。如果你的成员变量在定义时是这个样子的：

view sourceprint?mutable int r ; 

那么它就告诉编译器这个成员变量可以通过C++ const变量成员函数改变。编译器就不会再理会对他的检查了。

http://www.cnblogs.com/wxxweb/archive/2011/04/28/2031674.html