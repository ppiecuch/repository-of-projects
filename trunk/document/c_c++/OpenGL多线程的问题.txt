准备给游戏加入一个Loading画面，采用多线程，前面很顺利，但是就是载入后精灵无法正常显示，看不见纹理，开始以为是使用DevIL库出问题，单步调试发现DevIL载入图片正常，而opengl的glGenTextures出错了，返回的索引总是0。

　　后来google在gamedev上找到答案，原来opengl不是线程安全的(不知道正确不？)，找到了关键方向：wglCreateContext.

　　后来在msdn上找到API解释，以及代码实例：

　　view sourceprint?01 HDC hdc;

　　02 HGLRC hglrc;

　　03

　　04 // create a rendering context

　　05 hglrc = wglCreateContext (hdc);

　　06

　　07 // make it the calling thread's current rendering context

　　08 wglMakeCurrent (hdc, hglrc);

　　09

　　10 // call OpenGL APIs as desired ...

　　11

　　12 // when the rendering context is no longer needed ...

　　13

　　14 // make the rendering context not current

　　15 wglMakeCurrent (NULL, NULL) ;

　　16

　　17 // delete the rendering context

　　18 wglDeleteContext (hglrc);

　　只要hdc一样，创建的context都会渲染到相同的设备上面

　　但是实验很久，都没成功，最后发现是少了一个函数：wglShareLists(HGLRC hglrc1, HGLRC hglrc2)

　　注：hglrc1分享hglrc2的资源

　　view sourceprint?01 // 创建多线程

　　02 // 获取当前hdc

　　03 HDC hDC = GetDC(hWnd);

　　04 // 创建渲染context

　　05 HGLRC hrc1 = wglCreateContext(hDC);

　　06 // 分享资源

　　07 wglShareLists(wglGetCurrentContext(), hrc1);

　　08 ...

　　09 ...

　　10 // 载入资源的时候

　　11 wglMakeCurrent(hDC, hrc1);

　　12 ...

　　13 ...

　　14 // 使用后

　　15 wglMakeCurrent(NULL, NULL);

　　16 wglDeleteContext(hrc1);

http://www.chinadogame.com.cn/201101/90030072892.html