1.资源对象没关闭造成的内存泄漏
描述：

资源性对象比如（Cursor，File文件等）往往都用了一些缓冲，我们在不使用的时候，应该及时关闭它们，以便它们的缓冲及时回收内存。它们的缓冲不仅存在于java虚拟机内，还存在于java虚拟机外。如果我们仅仅是把它的引用设置为null,而不关闭它们，往往会造成内存泄漏。因为有些资源性对象，比如SQLiteCursor（在析构函数finalize(),如果我们没有关闭它，它自己会调close()关闭），如果我们没有关闭它，系统在回收它时也会关闭它，但是这样的效率太低了。因此对于资源性对象在不使用的时候，应该调用它的close()函数，将其关闭掉，然后才置为null.在我们的程序退出时一定要确保我们的资源性对象已经关闭。

程序中经常会进行查询数据库的操作，但是经常会有使用完毕Cursor后没有关闭的情况。如果我们的查询结果集比较小，对内存的消耗不容易被发现，只有在常时间大量操作的情况下才会复现内存问题，这样就会给以后的测试和问题排查带来困难和风险。
 示例代码：


[java] view plaincopyprint?Cursor cursor = getContentResolver().query(uri...);  
if (cursor.moveToNext()) {  
  ... ...    
}  
Cursor cursor = getContentResolver().query(uri...);
if (cursor.moveToNext()) {
  ... ...  
}修正示例代码：
[java] view plaincopyprint?Cursor cursor = null;  
try {  
  cursor = getContentResolver().query(uri...);  
  if (cursor != null &&cursor.moveToNext()) {  
      ... ...    
  }  
} finally {  
  if (cursor != null) {  
      try {    
          cursor.close();  
      } catch (Exception e) {  
          //ignore this   
      }  
   }  
}  
Cursor cursor = null;
try {
  cursor = getContentResolver().query(uri...);
  if (cursor != null &&cursor.moveToNext()) {
      ... ...  
  }
} finally {
  if (cursor != null) {
      try {  
          cursor.close();
      } catch (Exception e) {
          //ignore this
      }
   }
} 

2.构造Adapter时，没有使用缓存的convertView
描述：

以构造ListView的BaseAdapter为例，在BaseAdapter中提供了方法：
public View getView(int position, ViewconvertView, ViewGroup parent)
来向ListView提供每一个item所需要的view对象。初始时ListView会从BaseAdapter中根据当前的屏幕布局实例化一定数量的view对象，同时ListView会将这些view对象缓存起来。当向上滚动ListView时，原先位于最上面的list item的view对象会被回收，然后被用来构造新出现的最下面的list item。这个构造过程就是由getView()方法完成的，getView()的第二个形参View convertView就是被缓存起来的list item的view对象(初始化时缓存中没有view对象则convertView是null)。由此可以看出，如果我们不去使用convertView，而是每次都在getView()中重新实例化一个View对象的话，即浪费资源也浪费时间，也会使得内存占用越来越大。ListView回收list item的view对象的过程可以查看:
android.widget.AbsListView.java --> voidaddScrapView(View scrap) 方法。
示例代码：


[java] view plaincopyprint?public View getView(int position, ViewconvertView, ViewGroup parent) {  
  View view = new Xxx(...);  
  ... ...  
  return view;  
}  
public View getView(int position, ViewconvertView, ViewGroup parent) {
  View view = new Xxx(...);
  ... ...
  return view;
}修正示例代码：
[java] view plaincopyprint?public View getView(int position, ViewconvertView, ViewGroup parent) {  
  View view = null;  
  if (convertView != null) {  
  view = convertView;  
  populate(view, getItem(position));  
  ...  
  } else {  
  view = new Xxx(...);  
  ...  
  }  
  return view;  
}  
public View getView(int position, ViewconvertView, ViewGroup parent) {
  View view = null;
  if (convertView != null) {
  view = convertView;
  populate(view, getItem(position));
  ...
  } else {
  view = new Xxx(...);
  ...
  }
  return view;
} 

3.Bitmap对象不在使用时调用recycle()释放内存
描述：

有时我们会手工的操作Bitmap对象，如果一个Bitmap对象比较占内存，当它不在被使用的时候，可以调用Bitmap.recycle()方法回收此对象的像素所占用的内存，但这不是必须的，视情况而定。可以看一下代码中的注释：


[java] view plaincopyprint?/** 
 * Free up the memory associated with thisbitmap's pixels, and mark the 
 * bitmap as "dead", meaning itwill throw an exception if getPixels() or 
 * setPixels() is called, and will drawnothing. This operation cannot be 
 * reversed, so it should only be called ifyou are sure there are no 
 * further uses for the bitmap. This is anadvanced call, and normally need 
 * not be called, since the normal GCprocess will free up this memory when 
 * there are no more references to thisbitmap. 
 */  
 /**
  * Free up the memory associated with thisbitmap's pixels, and mark the
  * bitmap as "dead", meaning itwill throw an exception if getPixels() or
  * setPixels() is called, and will drawnothing. This operation cannot be
  * reversed, so it should only be called ifyou are sure there are no
  * further uses for the bitmap. This is anadvanced call, and normally need
  * not be called, since the normal GCprocess will free up this memory when
  * there are no more references to thisbitmap.
  */ 

4.试着使用关于application的context来替代和activity相关的context
这是一个很隐晦的内存泄漏的情况。有一种简单的方法来避免context相关的内存泄漏。最显著地一个是避免context逃出他自己的范围之外。使用Application context。这个context的生存周期和你的应用的生存周期一样长，而不是取决于activity的生存周期。如果你想保持一个长期生存的对象，并且这个对象需要一个context,记得使用application对象。你可以通过调用Context.getApplicationContext() or Activity.getApplication()来获得。更多的请看这篇文章如何避免Android内存泄漏。

5.注册没取消造成的内存泄漏
一些Android程序可能引用我们的Anroid程序的对象（比如注册机制）。即使我们的Android程序已经结束了，但是别的引用程序仍然还有对我们的Android程序的某个对象的引用，泄漏的内存依然不能被垃圾回收。调用registerReceiver后未调用unregisterReceiver。

比如:假设我们希望在锁屏界面(LockScreen)中，监听系统中的电话服务以获取一些信息(如信号强度等)，则可以在LockScreen中定义一个PhoneStateListener的对象，同时将它注册到TelephonyManager服务中。对于LockScreen对象，当需要显示锁屏界面的时候就会创建一个LockScreen对象，而当锁屏界面消失的时候LockScreen对象就会被释放掉。

但是如果在释放LockScreen对象的时候忘记取消我们之前注册的PhoneStateListener对象，则会导致LockScreen无法被垃圾回收。如果不断的使锁屏界面显示和消失，则最终会由于大量的LockScreen对象没有办法被回收而引起OutOfMemory,使得system_process进程挂掉。

虽然有些系统程序，它本身好像是可以自动取消注册的（当然不及时），但是我们还是应该在我们的程序中明确的取消注册，程序结束时应该把所有的注册都取消掉。

6.集合中对象没清理造成的内存泄漏
我们通常把一些对象的引用加入到了集合中，当我们不需要该对象时，并没有把它的引用从集合中清理掉，这样这个集合就会越来越大。如果这个集合是static的话，那情况就更严重了。

7.其他
http://blog.csdn.net/sunchaoenter/article/details/7224926