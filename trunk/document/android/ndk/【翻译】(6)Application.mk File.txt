

-----------------

英文文档见android-ndk-r5b的documentation.html

属于Android Native Development Kit (NDK)的一部分

见http://developer.android.com/sdk/ndk/（需要代理）

翻译仅个人见解

-----------------

Application.mk file syntax specification

 

Application.mk文件语法规范

 

Introduction:

 

介绍：

-------------

 

This document describes the syntax of Application.mk build files written to describe the native modules required by your Android application. To understand what follows, it is assumed that you have read the docs/OVERVIEW.html file that explains their role and usage.

 

这个文档描述Application.mk构建文件的语法，书写它的目的是描述你的Android应用程序需要的原生模块。为了理解下面所说的东西，假设你已经读过docs/OVERVIEW.html文件，它解释这些文件的角色和用法。

 

Readers of this document should have read docs/OVERVIEW.html and docs/ANDROID-MK.html

 

这个文档的读者应该读过docs/OVERVIEW.html和docs/ANDROID-MK.html

 

Overview:

 

概述：

---------

 

The purpose of Application.mk is to describe which native 'modules' (i.e. static/shared libraries) are needed by your application.

 

Application.mk的目的是描述哪个原生“模块”（即静态或动态库）是你的应用程序所需要的。

 

An Application.mk file is usually placed under $PROJECT/jni/Application.mk, where $PROJECT points to your application's project directory.

 

一个Application.mk文件通常放置在$PROJECT/jni/Application.mk，这里$PROJECT指向你的应用程序的工程目录。

 

Another alternative is to place it under a sub-directory of the top-level $NDK/apps directory, e.g.:

 

另一个选择是放在顶级$NDK/apps目录的子目录下，例如：

 

   $NDK/apps/<myapp>/Application.mk

 

Where <myapp> is a short name used to describe your 'application' to the NDK build system (this name doesn't go into your generated shared libraries or your final packages).

 

这里<myapp>是一个短名称，用于向NDK构建系统描述你的“应用程序”（这个名称不会被带入你生成的动态库或你的最终程序包）。

 

The Application.mk is really a tiny GNU Makefile fragment that must define a few variables:

 

Application.mk其实是一个小型GNU Makefile片段，它必须定义一些这样的变量：

 

APP_PROJECT_PATH

    This variable should give the *absolute* path to your Application's project root directory. This is used to copy/install stripped versions of the generated JNI shared libraries to a specific location known to the APK-generating tools.

 

APP_PROJECT_PATH

	这个变量应该给定为你的应用程序工程根目录的绝对路径。用于复制/安装剪裁版的JNI动态生成库到APK生成工具知道的特定位置。

 

    Note that it is optional for $PROJECT/jni/Application.mk, but *mandatory* for $NDK/apps/<myapp>/Application.mk

 

	注意这个变量对于$PROJECT/jni/Application.mk是可选的，但对于$NDK/apps/<myapp>/Application.mk是强制需要的。

 

APP_MODULES

    This variable is optional. If not defined, the NDK will build by default _all_ the modules declared by your Android.mk, and any sub-makefile it may include.

 

APP_MODULES

	这个变量是可选的。如果不定义它，NDK将默认构建你的Android.mk，以及它可能包含的所有子makefile中声明的所有模块。

 

    If APP_MODULES is defined, it must be a space-separated list of module names as they appear in the LOCAL_MODULE definitions of Android.mk files. Note that the NDK will compute module dependencies automatically.

 

	如果定义了APP_MODULES，它必须是用空格分隔的模块名称列表，正如它们在Android.mk文件中LOCAL_MODULE变量里出现那样。注意NDK将自动计算模块依赖。

 

    NOTE: This variable's behaviour changed in NDK r4. Before that:

 

    注意：这个变量的行为在NDK r4中发生改变。在此之前：

 

      - the variable was mandatory in your Application.mk

 

      - 这个变量在你的Application.mk中是强制的

 

      - all required modules had to be listed explicitly.

 

      - 所有所需的模块必须显式地列出。

 

APP_OPTIM

    This optional variable can be defined to either 'release' or 'debug'. This is used to alter the optimization level when building your application's modules.

 

APP_OPTIM

	这个可选变量可以定义为release或者debug，它在构建你的应用程序模块时用于改变优化级别。

 

    A 'release' mode is the default, and will generate highly optimized binaries. The 'debug' mode will generate un-optimized binaries which are much easier to debug.

 

    默认是release模式，它将生成高度优化的二进制。debug模式将生成非优化的二进制文件，它更易于调试。

 

    Note that if your application is debuggable (i.e. if your manifest sets the android:debuggable attribute to "true" in its <application> tag), the default will be 'debug' instead of 'release'. This can be overridden by setting APP_OPTIM to 'release'.

 

    注意如果你的应用程序是可调试的（即，如果你的清单文件在它的<application>标签中把android:debuggable属性设为true），默认将是debug而非release。把APP_OPTIM设置为release可以覆写它。

 

    Note that it is possible to debug both 'release' and 'debug' binaries, but the 'release' builds tend to provide less information during debugging sessions: some variables are optimized out and can't be inspected, code re-ordering can make stepping through the code difficult, stack traces may not be reliable, etc...

 

	注意可以调试release和debug版二进制，但release版构建倾向于在调试会话中提供较少信息：一些变量被优化并且不能被检测，代码重新排序可能致使代码步进变得困难，堆栈跟踪可能不可靠，等等。

 

APP_CFLAGS

    A set of C compiler flags passed when compiling any C or C++ source code of any of the modules. This can be used to change the build of a given module depending on the application that needs it, instead of modifying the Android.mk file itself.

 

APP_CFLAGS

	一个C编译器开关集合，在编译任意模块的任意C或C++源代码时传递。它可以用于改变一个给定的应用程序需要依赖的模块的构建，而不是修改它自身的Android.mk文件

 

    IMPORTANT WARNING: +++++++++++++++++++++++++++++++++++++++++++++++++++

 

    重要警告：

 

     All paths in these flags should be relative to the top-level NDK directory. For example, if you have the following setup:

 

     这些开关的所有路径应该是相对于顶级NDK目录。例如，如果你拥有以下配置：

 

        sources/foo/Android.mk

        sources/bar/Android.mk

 

      To specify in foo/Android.mk that you want to add the path to the 'bar' sources during compilation, you should use:

 

      为了在foo/Android.mk中表明你想在构建期间添加路径（注：这里应该指头文件搜索路径）到bar的源代码，你应该使用

 

       APP_CFLAGS += -Isources/bar

 

     Or alternatively:

 

     或者选择这样：

 

       APP_CFLAGS += -I$(LOCAL_PATH)/../bar

 

     Using '-I../bar' will *NOT* work since it will be equivalent to '-I$NDK_ROOT/../bar' instead.

 

	使用-I../bar将不能工作，因为它将改为等效于-I$NDK_ROOT/../bar。

 

    +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

 

    NOTE: In android-ndk-1.5_r1, this only applied to C sources, not C++ ones. This has been corrected to match the full Android build system.

 

    注意：在android-ndk-1.5_r1里，它仅应用于C源文件，而非C++源文件。它已经被更正为匹配完全Android构建系统。

 

APP_CXXFLAGS

    An alias for APP_CPPFLAGS, to be considered obsolete as it may disappear in a future release of the NDK.

 

APP_CXXFLAGS

	APP_CPPFLAGS的别名，将考虑为过时，因为它可能在未来的NDK发布版中消失。

 

APP_CPPFLAGS

    A set of C++ compiler flags passed when building C++ sources *only*.

 

APP_CPPFLAGS

	一个C++编译器开关集合，仅当构建C++源码时传递。

 

    NOTE: In android-ndk-1.5_r1, this applied to both C and C++ sources. This has been corrected to match the full Android build system. You can now use APP_CFLAGS for flags that shall apply to C and C++ sources.

 

    注意：在android-ndk-1.5_r1中，它应用于C和C++源码。它被更正为匹配完全Android构建系统。你现在可以使用APP_CFLAGS设置应用于C和C++源码的开关。

 

APP_BUILD_SCRIPT

    By default, the NDK build system will look for a file named Android.mk under $(APP_PROJECT_PATH)/jni, i.e. for the file:

 

APP_BUILD_SCRIPT

	默认，NDK构建系统将在$(APP_PROJECT_PATH)/jni下寻找一个名为Android.mk的文件。即，对于这个文件

 

       $(APP_PROJECT_PATH)/jni/Android.mk

 

    If you want to override this behaviour, you can define APP_BUILD_SCRIPT to point to an alternate build script. A non-absolute path will always be interpreted as relative to the NDK's top-level directory.

 

	如果你想重载这个行为，你可以定义APP_BUILD_SCRIPT指向一个不同的构建脚本。一个非绝对路径将总是被解析为相对于NDK顶级目录的路径。

 

APP_ABI

    By default, the NDK build system will generate machine code for the 'armeabi' ABI. This corresponds to an ARMv5TE based CPU with software floating point operations. You can use APP_ABI to select a different ABI.

 

APP_ABI

	默认，NDK构建系统将生成使用armeabi ABI的机器代码。它对应于一个带有软件浮点操作的基于ARMv5TE的CPU。你可以使用APP_ABI选择一个不同的ABI

 

    For example, to support hardware FPU instructions on ARMv7 based devices, use:

 

    例如，为了支持基于ARMv7的设备的软件浮点单元指令，使用：

 

        APP_ABI := armeabi-v7a

 

    Or to support both ARMv5TE and ARMv7 based devices, use:

 

    或者为了支持基于ARMv5TE和ARMv7的设备，使用

 

        APP_ABI := armeabi armeabi-v7a

 

    For the list of all supported ABIs and details about their usage and limitations, please read docs/CPU-ARCH-ABIS.html

 

    想获得所有支持的ABI列表和关于它们用法和限制的细节，请阅读docs/CPU-ARCH-ABIS.html。

 

APP_STL

    By default, the NDK build system provides C++ headers for the minimal C++ runtime library (/system/lib/libstdc++.so) provided by the Android system.

 

APP_STL

	默认，NDK构建系统提供由Android系统给出的最小C++运行时库（/system/lib/libstdc++.so）的C++头文件。

 

    However, the NDK comes with alternative C++ implementations that you can use or link to in your own applications. Define APP_STL to select one of them. Examples are:

 

    然而，NDK带有另一个C++实现，你可以在你自己的应用程序中使用或链接它。定义APP_STL以选择它们其中的一个。例子如下：

 

       APP_STL := stlport_static    --> static STLport library

 

       APP_STL := stlport_static    --> 静态STLport库

 

       APP_STL := stlport_shared    --> shared STLport library

 

       APP_STL := stlport_shared    --> 动态STLport库

 

       APP_STL := system            --> default C++ runtime library

 

       APP_STL := system            --> 默认的C++运行时库

 

    For more information on the subject, please read docs/CPLUSPLUS-SUPPORT.html

 

	关于这个主题的详细信息，请阅读docs/CPLUSPLUS-SUPPORT.html

 

A trivial Application.mk file would be:

 

一个细小的Application.mk文件将是：

 

-------------- cut here -------------------------

APP_PROJECT_PATH := <path to project>

-------------- cut here -------------------------

 

