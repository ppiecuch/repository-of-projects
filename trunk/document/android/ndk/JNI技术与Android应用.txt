本文转自http://www.cnblogs.com/yc_sunniw ... /07/05/1771149.html
1. 什么是 JNI 
    JNI是Java Native Interface的缩写。从Java 1.1开始，JNI标准成为java平台的一部分，它允许Java和其他语言进行交互。JNI一开始为C和C++而设计的，但是它并不妨碍你使用其他语 言，只要调用约定受支持就可以了。使用java与本地已编译的代码交互，通常会丧失平台可移植性。但是，有些情况下这样做是可以接受的，甚至是必须的，比 如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。关于 JNI 的用法很简单，有点像 java 里的 reflect 的工作机制，有兴趣的朋友可以参看Java 本地接口规范 http://linux.computersci.net/art ... pec/jniTOC.doc.html
2.  Jni程序开发的一般操作步骤如下：
(1) 编写带有native声明的方法的java类
(2) 使用javac 或 IDE(JBuilder,eclipse等)编译所编写的java类
(3) 使用javah -jni java类名生成扩展名为h的头文件
(4) 使用C++ 实现本地方法,对调用签名可用 javap Cs Cp [类全名] 查看（开发 C++ 动态链接库本例是用的 VC6）
注意要从 JDK下面的 include 文件夹中把 jni.h和 jni_md.h 两个文件 copy 到你的 VC 工程里
(5) 在 Java 中 load 动态链接库文件，调用 native 方法.
或者说将项目依赖的所有原生库和资源加入到java项目的java.library.path，生成java程序
3. 开发实例
(1). 编写 Java 类:
package org.jm.jni;
import java.util.ArrayList;
public class BackgroundProcess {
static {
System.loadLibrary("org_jm_jni_BackgroundProcess");
}
// 三个 native 方法和一个 int 变量
public native boolean checkValid();
public native void processData(BackgroundProcess bg);
public native void processGarbage(String[] bg);
public int num = 5;
// C++ 中可以调用的方法
public String backProcess(ArrayList<String> p) {
System.out.println("这是 Java 里的方法，在 C++ 中调用。");
System.out.println("这个方法，是 java 中 native checkValid 方法调用的。");
return "look up process ->" + p;
}
public static void main(String[] args) {
String[] array = new String[4];
array[0] = "jack";
array[1] = "maggie";
array[2] = "rocket";
array[3] = "tom";
BackgroundProcess bgP = new BackgroundProcess();
// 调用 C++ DLL 中定义的方法。
bgP.checkValid();// 该方法回调 java 中的 backProcess 方法,即java::checkValid->c++::checkValid->java::backProcess
bgP.processData(bgP);
bgP.processGarbage(array);
// C++ DLL 改变了该变量
System.out.println("number 现在的值是: " + bgP.num);
}
}
2. 生成 C++ 的头文件（javah 命令生成，用javap Cs Cp [类全名] 命令查看java 方法签名）
/* DO NOT EDIT THIS FILE - it is machine generated */
#include "jni.h"
/* Header for class org_jm_jni_BackgroundProcess */
#ifndef _Included_org_jm_jni_BackgroundProcess
#define _Included_org_jm_jni_BackgroundProcess
#ifdef __cplusplus
extern "C" {
#endif
/*
* Class: org_jm_jni_BackgroundProcess
* Method: checkValid
* Signature: ()Z
*/
JNIEXPORT jboolean JNICALL Java_org_jm_jni_BackgroundProcess_checkValid
(JNIEnv *, jobject);
/*
* Class: org_jm_jni_BackgroundProcess
* Method: processData
* Signature: (Lorg/jm/jni/BackgroundProcess;)V
*/
JNIEXPORT void JNICALL Java_org_jm_jni_BackgroundProcess_processData
(JNIEnv *, jobject, jobject);
/*
* Class: org_jm_jni_BackgroundProcess
* Method: processGarbage
* Signature: ([Ljava/lang/String;)V
*/
JNIEXPORT void JNICALL Java_org_jm_jni_BackgroundProcess_processGarbage
(JNIEnv *, jobject, jobjectArray);
#ifdef __cplusplus
}
#endif
#endif
    这里JNIEXPORT和JNICALL都是JNI的关键字，表示此函数是要被JNI调用的。例如jint是以JNI为中介使JAVA的int类型与本地 的int沟通的一种类型，我们可以视而不见，就当做int使用。函数的名称是JAVA_再加上java程序的package路径再加函数名组成的。参数 中，我们也只需要关心在JAVA程序中存在的参数，至于JNIEnv*和jclass我们一般没有必要去碰它。
3. 开发 C++ DLL 的原文件 (记得要加入 jni.h 和 jni_md.h 两个文件)
发布 DLL 文件, 我是配置了 path 环境变量
#include "org_jm_jni_BackgroundProcess.h"
#include <iostream.h>
#include <windows.h>
#include "string.h"
char* jstringTostring(JNIEnv* env, jstring jstr)
{
char* rtn = NULL;
jclass clsstring = env->FindClass("java/lang/String");
jstring strencode = env->NewStringUTF("utf-8");
jmethodID mid = env->GetMethodID(clsstring, "getBytes", "(Ljava/lang/String;)[B");
jbyteArray barr= (jbyteArray)env->CallObjectMethod(jstr, mid, strencode);
jsize alen = env->GetArrayLength(barr);
jbyte* ba = env->GetByteArrayElements(barr, JNI_FALSE);
if (alen > 0)
{
rtn = (char*)malloc(alen + 1);
memcpy(rtn, ba, alen);
rtn[alen] = 0;
}
env->ReleaseByteArrayElements(barr, ba, 0);
return rtn;
}
//char* to jstring
jstring stoJstring(JNIEnv* env, const char* pat)
{
jclass strClass = env->FindClass("Ljava/lang/String;");
jmethodID ctorID = env->GetMethodID(strClass, "<init>", "([BLjava/lang/String;)V");
jbyteArray bytes = env->NewByteArray(strlen(pat));
env->SetByteArrayRegion(bytes, 0, strlen(pat), (jbyte*)pat);
jstring encoding = env->NewStringUTF("utf-8");
return (jstring)env->NewObject(strClass, ctorID, bytes, encoding);
}
/*
* Class: org_jm_jni_BackgroundProcess
* Method: checkValid
* Signature: ()Z
*/
JNIEXPORT jboolean JNICALL Java_org_jm_jni_BackgroundProcess_checkValid
(JNIEnv *env, jobject obj){
jclass bgpClass=env->GetObjectClass(obj);
jmethodID methodId=env->GetMethodID(bgpClass,"backProcess","(Ljava/util/ArrayList;)Ljava/lang/String;");
jobject str=env->CallObjectMethod(obj,methodId,NULL);
jfieldID fieldId=env->GetFieldID(bgpClass,"num","I");
jint number=env->GetIntField(obj,fieldId);
cout << "number 值是: " <<number << endl;
env->SetIntField(obj,fieldId,100L);
return 1;
}
/*
* Class: org_jm_jni_BackgroundProcess
* Method: processData
* Signature: (Lorg/jm/jni/BackgroundProcess;)V
*/
JNIEXPORT void JNICALL Java_org_jm_jni_BackgroundProcess_processData
(JNIEnv *env, jobject, jobject){
cout<< "this function do nothing " << endl;
}
/*
* Class: org_jm_jni_BackgroundProcess
* Method: processGarbage
* Signature: ([Ljava/lang/String;)V
*/
JNIEXPORT void JNICALL Java_org_jm_jni_BackgroundProcess_processGarbage
(JNIEnv *env, jobject, jobjectArray array){
jint size=env->GetArrayLength(array);
cout << "数组大小是: " << size << endl;
jstring tempObj=NULL;
char *pszSTR1 = NULL;
for(int i=0;i<size;i++){
cout << "current value is : " << i << endl;
tempObj=(jstring)env->GetObjectArrayElement(array,i);
const char * chars =env->GetStringUTFChars(tempObj, 0);
cout << chars << endl;
}
}
在此，针对andorid中c++与java中的方法互调，引用参考说明如下：
(1).andorid CPP调用java函数和访问其成员:原理 => CPP代码找到java的那个class里面的函数的入口地址,然后在CPP代码中调用java代码
步骤1) 用FindClass()函数找到该java类(如android.os.Binder)的实例对象的引用:
　　jclass clazz = env->FindClass(kBinderPathName) = env->FindClass("android.os.Binder")
步骤2) 用GetFieldID()函数获取到要访问的域(field: 实际上就是该java class中的某个成员变量的名字)的ID:
　　gBinderOffsets.mObject = env->GetFieldID(clazz, "mObject", "I") // mObject为java class "Binder"里的一个成员变量
　　-> 注意,这里将要访问的那个java对象的成员mObject的ID保存到了全局变量gBinderOffsets.mObject中,这样做的前提和优点如下:
　　前提: android里面,每个java进程中只允许有一个java虚拟机(sun公司原始的java架构中,一个进程中可以有多个java虚拟机)
　　优点: 除了第一次,以后每次要访问该java对象的成员mObject就非常快了(不用再去FindClass()和GetFieldID())
步骤3) 用GetMethodID()函数获取到要访问的方法(Method: 实际上就是该java class中的某个成员函数的名字)的ID:
　　gBinderOffsets.mExecTransact = env->GetMethodID(clazz, "execTransact", "(IIII)Z") // execTransact为java class "Binder"里的一个成员函数
步骤4) 用类似于GetIntField()的函数获取到该java对象的那个域(即成员)的值:
　　IBinder* target = (IBinder*)env->GetIntField(obj,gBinderProxyOffsets.mObject)
     // 获取java android.os.Binder类型对象里面的成员mObject的值 
步骤5) 用类似于CallBooleanMethod()的函数调用到该java对象的那个成员函数:
　　jboolean res = env->CallBooleanMethod(mObject, gBinderOffsets.mExecTransact, code, (int32_t)&data, (int32_t)reply, flags)
(2).android java调用CPP函数: 原理 => 相当于java的那个class里面有的函数使用CPP代码来实现了
1)通过结构JNINativeMethod描述java代码调用函数和CPP函数的对应关系:
　　typedef struct {
　　const char* name; // java代码调用CPP函数的入口
　　const char* signature; // CPP函数的返回值
　　void* fnPtr; // CPP的函数名
　　} JNINativeMethod;
　　=> 例如: java代码通过IBinder.transact()来调用CPP的函数android_os_BinderProxy_transact()
　　{"transact", "(ILandroid/os/Parcel;Landroid/os/Parcel;I)Z", (void*)android_os_BinderProxy_transact},
2)将CPP函数注册到java的某个class中: 使用函数AndroidRuntime::registerNativeMethods()来注册
　　=> 这之后,java代码就可以调用CPP函数了
3)java代码调用CPP函数方法:
　　IBinder.transact()
总结其原理：C/C++要调用JAVA程序，必须先加载JAVA虚拟机，由JAVA虚拟机解释执行class文件。为了初始化JAVA虚拟机，JNI提供了一系列的接口函数，通过这些函数方便地加载虚拟机到内存中。
1). 加载虚拟机：
函数：jint JNI_CreateJavaVM(JavaVM **pvm, void **penv, void args);
参数说明：JavaVM **pvm JAVA虚拟机指针,第二个参数JNIEnv *env是贯穿整个调用过程的一个参数,因为后面的所有函数都需要这个参数,需注意的是第三个参数,在jdk1.1与1.2版本有些不同,在JDK 1.1中第三个参数总是指向一个结构JDK1_ 1InitArgs，这个结构无法完全在所有版本的虚拟机中进行无缝移植。所以为了保证可移植性,建议使用jdk1.2的方法加载虚拟机。
2). 获取指定对象的类定义:
有两种方法可获得类定义,一是在已知类名的情况使用FindClass来获取；二是通过对象直接得到类定义GetObjectClass
3). 获取要调用的方法：
获得非静态方法：
jmethodID (JNICALL *GetMethodID)(JNIEnv *env, jclass clazz, const char *name, const char *sig);
获得静态方法：
jmethodID (JNICALL *GetStaticMethodID)(JNIEnv *env, jclass class, const char *name, const char *sig);
参数说明：JNIEnv *env初始化是得到的JNI环境；jclass class前面已获取到的类定义；const char *name方法名；const char *sig方法参数定义
4). 调用JAVA类方法：
函数：CallObjectMethod（JNIEnv *env， jobject obj, jmethodID mid）；
函数：CallStaticObjectMethod（（JNIEnv *env， jobject obj, jmethodID mid）；
5). 获得类属性的定义：
jfieldID (JNICALL *GetFieldID) (JNIEnv *env, jclass clazz, const char *name, const char *sig);
静态属性：
jfieldID (JNICALL *GetStaticFieldID) (JNIEnv *env, jclass clazz, const char *name, const char *sig);
6). 数组处理：
要创建数组首先要知道类型及长度，JNI提供了一系列的数组类型及操作的函数如：
NewIntArray、NewLongArray、NewShortArray、NewFloatArray、NewDoubleArray、 NewBooleanArray、NewStringUTF、NewCharArray、NewByteArray、NewString，访问通过 GetBooleanArrayElements、GetIntArrayElements等函数。
7). 异常：
由于调用了Java的方法，会产生异常。这些异常在C/C++中无法通过本身的异常处理机制来捕捉到，但可以通过JNI一些函数来获取Java中抛出的异常信息。
8).多线程调用
我们知道JAVA是非常消耗内存的，我们希望在多线程中能共享一个JVM虚拟机，真正消耗大量系统资源的是JAVA虚拟机jvm而不是虚拟机环境 env，jvm是允许多个线程访问的，但是虚拟机环境只能被创建它本身的线程所访问，而且每个线程必须创建自己的虚拟机环境env。JNI提供了两个函 数：AttachCurrentThread和DetachCurrentThread。便于子线程创建自己的虚拟机环境。
4.  java与dll交互的技术
    目前java与dll交互的技术主要有3种：jni，jawin和jacob。Jni（Java Native Interface）是sun提供的java与系统中的原生方法交互的技术（在windows\linux系统中，实现java与native method互调）。目前只能由c/c++实现。后两个都是sourceforge上的开源项目，同时也都是基于jni技术的windows系统上的一个 应用库。Jacob（Java-Com Bridge）提供了java程序调用microsoft的com对象中的方法的能力。而除了com对象外，jawin（Java/Win32 integration project）还可以win32-dll动态链接库中的方法。就功能而言：jni >> jawin>jacob，其大致的结构如下图：

就易用性而言，正好相反：jacob>jawin>>jni。
    Jvm封装了各种操作系统实际的差异性的同时，提供了jni技术，使得开发者可以通过java程序（代码）调用到操作系统相关的技术实现的库函数，从而与 其他技术和系统交互，使用其他技术实现的系统的功能；同时其他技术和系统也可以通过jni提供的相应原生接口开调用java应用系统内部实现的功能。在 windows系统上，一般可执行的应用程序都是基于native的PE结构，windows上的jvm也是基于native结构实现的。Java应用体 系都是构建于jvm之上。

    Jni对于应用本身来说，可以看做一个代理模式。对于开发者来说，需要使用c/c++来实现一个代理程序（jni程序）来实际操作目标原生函数，java程序中则是jvm通过加载并调用此jni程序来间接地调用目标原生函数。

5. Android中jni的现有应用
(1).从如何载入.so档案谈起
由于Android的应用层的类都是以Java写的，这些Java类编译为Dex型式的Bytecode之后，必须靠Dalvik虚拟机(VM: Virtual Machine)来执行。VM在Android平台里，扮演很重要的角色。此外，在执行Java类的过程中，如果Java类需要与C组件沟通时，VM就会 去载入C组件，然后让Java的函数顺利地调用到C组件的函数。此时，VM扮演着桥梁的角色，让Java与C组件能通过标准的JNI介面而相互沟通。应用 层的Java类是在虚拟机(VM: Vitual Machine)上执行的，而C件不是在VM上执行，那么Java程式又如何要求VM去载入(Load)所指定的C组件呢? 可使用下述指令：
System.loadLibrary(*.so的档案名);
例如，Android框架里所提供的MediaPlayer.java类，含指令：
public class MediaPlayer{
static {
System.loadLibrary("media_jni");
}
}
  这要求VM去载入Android的/system/lib/libmedia_jni.so档案。载入*.so之后，Java类与*.so档案就汇合起来，一起执行了。
(2).如何撰写*.so的入口函数
    ---- JNI_OnLoad()与JNI_OnUnload()函数的用途
    当Android的VM(Virtual Machine)执行到System.loadLibrary()函数时，首先会去执行C组件里的JNI_OnLoad()函数。它的用途有二：
    1)告诉VM此C组件使用那一个JNI版本。如果你的*.so档没有提供JNI_OnLoad()函数，VM会默认该*.so档是使用最老的JNI 1.1版本。由于新版的JNI做了许多扩充，如果需要使用JNI的新版功能，例如JNI 1.4的java.nio.ByteBuffer,就必须藉由JNI_OnLoad()函数来告知VM。
    2)由于VM执行到System.loadLibrary()函数时，就会立即先呼叫JNI_OnLoad()，所以C组件的开发者可以藉由JNI_OnLoad()来进行C组件内的初期值之设定(Initialization) 。
    例如，在Android的/system/lib/libmedia_jni.so档案里，就提供了JNI_OnLoad()函数，其程式码片段为：
//#define LOG_NDEBUG 0
#define LOG_TAG "MediaPlayer-JNI"
jint JNI_OnLoad(JavaVM* vm, void* reserved)
{
JNIEnv* env = NULL;
jint result = -1;
if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) {
LOGE("ERROR: GetEnv failed\n");
goto bail;
}
assert(env != NULL);
if (register_android_media_MediaPlayer(env) < 0) {
LOGE("ERROR: MediaPlayer native registration failed\n");
goto bail;
}
if (register_android_media_MediaRecorder(env) < 0) {
LOGE("ERROR: MediaRecorder native registration failed\n");
goto bail;
}
if (register_android_media_MediaScanner(env) < 0) {
LOGE("ERROR: MediaScanner native registration failed\n");
goto bail;
}
if (register_android_media_MediaMetadataRetriever(env) < 0) {
LOGE("ERROR: MediaMetadataRetriever native registration failed\n");
goto bail;
}
/* success -- return valid version number */
result = JNI_VERSION_1_4;
bail:
return result;
}
此函数回传JNI_VERSION_1_4值给VM，于是VM知道了其所使用的JNI版本了。此外，它也做了一些初期的动作(可呼叫任何本地函数)，例如指令：
if (register_android_media_MediaPlayer(env) < 0) {
LOGE("ERROR: MediaPlayer native registration failed\n");
goto bail;
}
    就将此组件提供的各个本地函数(Native Function)登记到VM里，以便能加快后续呼叫本地函数的效率。
    JNI_OnUnload()函数与JNI_OnLoad()相对应的。在载入C组件时会立即呼叫JNI_OnLoad()来进行组件内的初期动作；而当 VM释放该C组件时，则会呼叫JNI_OnUnload()函数来进行善后清除动作。当VM呼叫JNI_OnLoad()或JNI_Unload()函数 时，都会将VM的指针(Pointer)传递给它们，其参数如下：
jint JNI_OnLoad(JavaVM* vm, void* reserved) { }
jint JNI_OnUnload(JavaVM* vm, void* reserved){ }
    在JNI_OnLoad()函数里，就透过VM之指标而取得JNIEnv之指标值，并存入env指标变数里，如下述指令：
jint JNI_OnLoad(JavaVM* vm, void* reserved){
JNIEnv* env = NULL;
jint result = -1;
if (vm->GetEnv((void**) &env, JNI_VERSION_1_4) != JNI_OK) {
LOGE("ERROR: GetEnv failed\n");
goto bail;
}
}
   由于VM通常是多执行绪(Multi-threading)的执行环境。每一个执行绪在呼叫JNI_OnLoad()时，所传递进来的JNIEnv指标 值都是不同的。为了配合这种多执行绪的环境，C组件开发者在撰写本地函数时，可藉由JNIEnv指标值之不同而避免执行绪的资料冲突问题，才能确保所写的 本地函数能安全地在Android的多执行绪VM里安全地执行。基于这个理由，当在呼叫C组件的函数时，都会将JNIEnv指标值传递给它，如下：
jint JNI_OnLoad(JavaVM* vm, void* reserved)
{
JNIEnv* env = NULL;
if (register_android_media_MediaPlayer(env) < 0) {
}
}
    这JNI_OnLoad()呼叫register_android_media_MediaPlayer(env)函数时，就将env指标值传递过去。如 此，在register_android_media_MediaPlayer()函数就能藉由该指标值而区别不同的执行绪，以便化解资料冲突的问题。
　 例如，在register_android_media_MediaPlayer()函数里，可撰写下述指令：
if ((*env)->MonitorEnter(env, obj) != JNI_OK) {
}
   查看是否已经有其他执行绪进入此物件，如果没有，此执行绪就进入该物件里执行了。还有，也可撰写下述指令：
if ((*env)->MonitorExit(env, obj) != JNI_OK) {
  }
    查看是否此执行绪正在此物件内执行，如果是，此执行绪就会立即离开。
(3). registerNativeMethods()函数的用途
    应用层级的Java类别透过VM而呼叫到本地函数。一般是仰赖VM去寻找*.so里的本地函数。如果需要连续呼叫很多次，每次都需要寻找一遍，会多花许多时间。此时，组件开发者可以自行将本地函数向VM进行登记。例如，在Android的/system/lib/libmedia_jni.so档案里的代码段如下：
//#define LOG_NDEBUG 0
#define LOG_TAG "MediaPlayer-JNI"
static JNINativeMethod gMethods[] = {
{"setDataSource", "(Ljava/lang/String;)V",
(void *)android_media_MediaPlayer_setDataSource},
{"setDataSource", "(Ljava/io/FileDescriptor;JJ)V",
(void *)android_media_MediaPlayer_setDataSourceFD},
{"prepare", "()V", (void *)android_media_MediaPlayer_prepare},
{"prepareAsync", "()V", (void *)android_media_MediaPlayer_prepareAsync},
{"_start", "()V", (void *)android_media_MediaPlayer_start},
{"_stop", "()V", (void *)android_media_MediaPlayer_stop},
{"getVideoWidth", "()I", (void *)android_media_MediaPlayer_getVideoWidth},
{"getVideoHeight", "()I", (void *)android_media_MediaPlayer_getVideoHeight},
{"seekTo", "(I)V", (void *)android_media_MediaPlayer_seekTo},
{"_pause", "()V", (void *)android_media_MediaPlayer_pause},
{"isPlaying", "()Z", (void *)android_media_MediaPlayer_isPlaying},
{"getCurrentPosition", "()I", (void *)android_media_MediaPlayer_getCurrentPosition},
{"getDuration", "()I", (void *)android_media_MediaPlayer_getDuration},
{"_release", "()V", (void *)android_media_MediaPlayer_release},
{"_reset", "()V", (void *)android_media_MediaPlayer_reset},
{"setAudioStreamType","(I)V", (void *)android_media_MediaPlayer_setAudioStreamType},
{"setLooping", "(Z)V", (void *)android_media_MediaPlayer_setLooping},
{"setVolume", "(FF)V", (void *)android_media_MediaPlayer_setVolume},
{"getFrameAt", "(I)Landroid/graphics/Bitmap;",
(void *)android_media_MediaPlayer_getFrameAt},
{"native_setup", "(Ljava/lang/Object;)V",
(void *)android_media_MediaPlayer_native_setup},
{"native_finalize", "()V", (void *)android_media_MediaPlayer_native_finalize},
};
static int register_android_media_MediaPlayer(JNIEnv *env){
return AndroidRuntime::registerNativeMethods(env,
"android/media/MediaPlayer", gMethods, NELEM(gMethods));
}
jint JNI_OnLoad(JavaVM* vm, void* reserved){
if (register_android_media_MediaPlayer(env) < 0) {
LOGE("ERROR: MediaPlayer native registration failed\n");
goto bail;
}
}
   当VM载入libmedia_jni.so档案时，就呼叫JNI_OnLoad()函数。接着，JNI_OnLoad()呼叫 register_android_media_MediaPlayer()函数。此时，就呼叫到 AndroidRuntime::registerNativeMethods()函数，向VM(即AndroidRuntime)登记gMethods[]表格所含的本地函数了。简而言之，registerNativeMethods()函数的用途有二：
1) 更有效率去找到函数。
2) 可在执行期间进行抽换。由于gMethods[]是一个<名称，函数指针>对照表，在程序执行时，可多次呼叫registerNativeMethods()函数来更换本地函数之指针，而达到弹性抽换本地函数之目的。
(4). Andoird 中使用了一种不同传统Java JNI的方式来定义其native的函数。其中很重要的区别是Andorid使用了一种Java 和 C 函数的映射表数组，并在其中描述了函数的参数和返回值。这个数组的类型是JNINativeMethod，定义如下：
typedef struct {
const char* name; /*Java中函数的名字*/
const char* signature; /*描述了函数的参数和返回值*/
void* fnPtr; /*函数指针，指向C函数*/
} JNINativeMethod;
其中比较难以理解的是第二个参数，例如 "()V" ,"(II)V", "(Ljava/lang/String;Ljava/lang/String;)V". 实际上这些字符是与函数的参数类型一一对应的。"()" 中的字符表示参数，后面的则代表返回值。例如"()V" 就表示void Func(); "(II)V" 表示 void Func(int, int);
具体的每一个字符的对应关系如下:
字符 Java类型 C类型
V void void
Z jboolean boolean
I jint int
J jlong long
D jdouble double
F jfloat float
B jbyte byte
C jchar char
S jshort short
数组则以"["开始，用两个字符表示
[I jintArray int[]
[F jfloatArray float[]
[B jbyteArray byte[]
[C jcharArray char[]
[S jshortArray short[]
[D jdoubleArray double[]
[J jlongArray long[]
[Z jbooleanArray boolean[]
上面的都是基本类型。如果Java函数的参数是class，则以"L"开头，以";"结尾，中间是用"/" 隔开的包及类名。而其对应的C函数名的参数则为jobject. 一个例外是String类，其对应的类为jstring
Ljava/lang/String; String jstring
Ljava/net/Socket; Socket jobject
如果JAVA函数位于一个嵌入类，则用$作为类名间的分隔符。
例如 "(Ljava/lang/String;Landroid/os/FileUtils$FileStatus;)Z"
6. Android JNI编程实践
(1) 直接使用java本身jni接口（windows/ubuntu）
1). 在Eclipsh中新建一个android应用程序。两个类：一个继承于Activity，UI显示用。另一个包含native方法。编译生成所有类。
jnitest.java文件：
package com.hello.jnitest;
import android.app.Activity;
import android.os.Bundle;
public class jnitest extends Activity {
/** Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState) {
  super.onCreate(savedInstanceState);
setContentView(R.layout.main);
Nadd cal = new Nadd();
setTitle("The Native Add Result is " + String.valueOf(cal.nadd(10, 19)));
}
}
Nadd.java文件：
package com.hello.jnitest;
public class Nadd {
static {
System.loadLibrary("Nadd");
}
public native int nadd(int a, int b);
}
以上在windows中完成。
2). 使用javah命令生成C/C++的.h文件。注意类要包含包名，路径文件夹下要包含所有包中的类，否则会报找不到类的错误。classpath参数指定到包名前一级文件夹，文件夹层次结构要符合java类的组织层次结构。
javah -classpath ../jnitest/bin com.hello.jnitest.Nadd
com_hello_jnitest_Nadd .h文件：
/* DO NOT EDIT THIS FILE - it is machine generated */
#include <jni.h>
/* Header for class com_hello_jnitest_Nadd */
#ifndef _Included_com_hello_jnitest_Nadd
#define _Included_com_hello_jnitest_Nadd
#ifdef __cplusplus
extern "C" {
#endif
/*
* Class: com_hello_jnitest_Nadd
* Method: nadd
* Signature: (II)I
*/
JNIEXPORT jint JNICALL Java_com_hello_jnitest_Nadd_nadd
(JNIEnv *, jobject, jint, jint);
#ifdef __cplusplus
}
#endif
#endif
3).编辑.c文件实现native方法。
com_hello_jnitest_Nadd.c文件：
#include <stdlib.h>
#include "com_hello_jnitest_Nadd.h"
JNIEXPORT jint JNICALL Java_com_hello_jnitest_Nadd_nadd(JNIEnv * env, jobject c, jint a, jint b)
{
return (a+b);
}
4).编译.c文件生存动态库。
arm-none-linux-gnueabi-gcc -I/home/a/work/android/jdk1.6.0_17/include -I/home/a/work/android/jdk1.6.0_17/include/linux -fpic -c com_hello_jnitest_Nadd.c
arm-none-linux-gnueabi-ld -T/home/a/CodeSourcery/Sourcery_G++_Lite/arm-none-linux-gnueabi/lib/ldscripts/armelf_linux_eabi.xsc -share -o libNadd.so com_hello_jnitest_Nadd.o
得到libNadd.so文件。
以上在ubuntu中完成。
5).将相应的动态库文件push到avd的system/lib中:adb push libNadd.so /system/lib。若提示Read-only file system错误，运行adb remount命令，即可。
Adb push libNadd.so /system/lib
6).在eclipsh中运行原应用程序即可。
以上在windows中完成。
对于一中生成的so文件也可采用二中的方法编译进apk包中。只需在工程文件夹中建libs\armeabi文件夹（其他文件夹名无效，只建立libs文件夹也无效），然后将so文件拷入，编译工程即可。
(2).使用NDK生成本地方法（ubuntu and windows）
1).安装NDK：解压，然后进入NDK解压后的目录，运行build/host-setup.sh（需要Make 3.81和awk）。若有错，修改host-setup.sh文件：将#!/bin/sh修改为#!/bin/bash，再次运行即可。
2).在apps文件夹下建立自己的工程文件夹，然后在该文件夹下建一文件Application.mk和项project文件夹。
Application.mk文件：
APP_PROJECT_PATH := $(call my-dir)/project
APP_MODULES := myjni
3).在project文件夹下建一jni文件夹，然后新建Android.mk和myjni.c。这里不需要用javah生成相应的.h文件，但函数名要包含相应的完整的包、类名。
4).编辑相应文件内容。
Android.mk文件：
# Copyright (C) 2009 The Android Open Source Project
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
LOCAL_PATH := $(call my-dir)
include $(CLEAR_VARS)
LOCAL_MODULE := myjni
LOCAL_SRC_FILES := myjni.c
include $(BUILD_SHARED_LIBRARY)
myjni.c文件：
#include <string.h>
#include <jni.h>
jstring
Java_com_hello_NdkTest_NdkTest_stringFromJNI( JNIEnv* env,
jobject thiz )
{
return (*env)->NewStringUTF(env, "Hello from My-JNI !");
}
myjni文件组织：
a@ubuntu:~/work/android/ndk-1.6_r1/apps$ tree myjni
myjni
|-- Application.mk
`-- project
|-- jni
| |-- Android.mk
| `-- myjni.c
`-- libs
`-- armeabi
`-- libmyjni.so
4) directories, 4 files
5) 编译：make APP=myjni.
以上内容在ubuntu完成。以下内容在windows中完成。当然也可以在ubuntu中完成。
6) 在eclipsh中创建android application。将myjni中自动生成的libs文件夹拷贝到当前工程文件夹中，编译运行即可。
NdkTest.java文件：
package com.hello.NdkTest;
import android.app.Activity;
import android.os.Bundle;
import android.widget.TextView;
public class NdkTest extends Activity {
/** Called when the activity is first created. */
@Override
public void onCreate(Bundle savedInstanceState) {
super.onCreate(savedInstanceState);
TextView tv = new TextView(this);
tv.setText( stringFromJNI() );
setContentView(tv);
}
public native String stringFromJNI();
static {
System.loadLibrary("myjni");
}
}
对于二中生成的so文件也可采用一中的方法push到avd中运行。
