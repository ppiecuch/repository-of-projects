在Java 的异常处理机制中：
如果抛出的是Exception异常的话，必须有try..catch..进行处理，属于checked exception。
如果抛出的是RuntimeException异常的话，则不是必须进行try..catch..异常处理，发生异常之后将由JVM进行处理，属于unchecked exception。
注意：为了保证程序的健壮性，建议抛出RunntimeException异常，也使用try..catch..进行处理。

这两者最本质的区别在于设计者认为使用者是否能够并且应该处理这个异常。

Java 异常的分类：
基类为：Throwable
Error 和 Exception 继承于Throwable
RuntimeException和IOException等继承Exception
其中，Error和RuntimeException及其子类属于unchecked exception, 而其他异常为checked exception。


Error类描述了Java运行系统中的内部错误以及资源耗尽的情形，应用程序不应该抛出这种类型的对象（一般是由Java虚拟机抛出）。如果出现这种错误，除了尽力使程序安全退出外，在其他方面是无能为力的。所以，在我们在程序设计时，应该更关注Exception体系。

RuntimeExcption体系，包括错误的类型转换，数组越界访问和试图访问空指针等等。如果出现RuntimeException，那么一定是你自己的错误。

其他非RuntimeExcetpion（IOException等等），这类异常一般是外部错误，例如试图从文件尾后读取数据等，这并不是程序本身的错误，而是在应用环境中出现的外部错误。

在Android开发中，常常会出现uncheched Exception 导致程序的crash，为了提供良好的用户体验，并对出错的信息进行收集，以便对程序进行改进，提高程序的健壮性。因此，常使用Thread.UncaughtExceptionHandler来进行处理。

首先需要继承Thread.UncaughtExceptionHandler类
[java] view plaincopyprint?
public class CrashHandler implements Thread.UncaughtExceptionHandler {  
    public static final String TAG = CrashHandler.class.getSimpleName();  
    private static CrashHandler INSTANCE = new CrashHandler();  
    private Context mContext;  
    private Thread.UncaughtExceptionHandler mDefaultHandler;  
  
  
    private CrashHandler() {  
    }  
  
  
    public static CrashHandler getInstance() {  
        return INSTANCE;  
    }  
  
  
    public void init(Context ctx) {  
        mContext = ctx;  
        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();  
        Thread.setDefaultUncaughtExceptionHandler(this);  
    }  
  
  
    @Override  
    public void uncaughtException(Thread thread, Throwable ex) {  
        // if (!handleException(ex) && mDefaultHandler != null) {   
        // mDefaultHandler.uncaughtException(thread, ex);   
        // } else {   
        // android.os.Process.killProcess(android.os.Process.myPid());   
        // System.exit(10);   
        // }   
        System.out.println("uncaughtException");  
  
  
        new Thread() {  
            @Override  
            public void run() {  
                Looper.prepare();  
                new AlertDialog.Builder(mContext).setTitle("提示").setCancelable(false)  
                        .setMessage("程序崩溃了...").setNeutralButton("我知道了", new OnClickListener() {  
                            @Override  
                            public void onClick(DialogInterface dialog, int which) {  
                                System.exit(0);  
                            }  
                        })  
                        .create().show();  
                Looper.loop();  
            }  
        }.start();  
    }  
  
  
    /** 
     * 自定义错误处理,收集错误信息 发送错误报告等操作均在此完成. 开发者可以根据自己的情况来自定义异常处理逻辑 
     *  
     * @param ex 
     * @return true:如果处理了该异常信息;否则返回false 
     */  
    private boolean handleException(Throwable ex) {  
        if (ex == null) {  
            return true;  
        }  
        // new Handler(Looper.getMainLooper()).post(new Runnable() {   
        // @Override   
        // public void run() {   
        // new AlertDialog.Builder(mContext).setTitle("提示")   
        // .setMessage("程序崩溃了...").setNeutralButton("我知道了", null)   
        // .create().show();   
        // }   
        // });   
  
  
        return true;  
    }  
}  

public class CrashHandler implements Thread.UncaughtExceptionHandler {
    public static final String TAG = CrashHandler.class.getSimpleName();
    private static CrashHandler INSTANCE = new CrashHandler();
    private Context mContext;
    private Thread.UncaughtExceptionHandler mDefaultHandler;


    private CrashHandler() {
    }


    public static CrashHandler getInstance() {
        return INSTANCE;
    }


    public void init(Context ctx) {
        mContext = ctx;
        mDefaultHandler = Thread.getDefaultUncaughtExceptionHandler();
        Thread.setDefaultUncaughtExceptionHandler(this);
    }


    @Override
    public void uncaughtException(Thread thread, Throwable ex) {
        // if (!handleException(ex) && mDefaultHandler != null) {
        // mDefaultHandler.uncaughtException(thread, ex);
        // } else {
        // android.os.Process.killProcess(android.os.Process.myPid());
        // System.exit(10);
        // }
        System.out.println("uncaughtException");


        new Thread() {
            @Override
            public void run() {
                Looper.prepare();
                new AlertDialog.Builder(mContext).setTitle("提示").setCancelable(false)
                        .setMessage("程序崩溃了...").setNeutralButton("我知道了", new OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog, int which) {
                                System.exit(0);
                            }
                        })
                        .create().show();
                Looper.loop();
            }
        }.start();
    }


    /**
     * 自定义错误处理,收集错误信息 发送错误报告等操作均在此完成. 开发者可以根据自己的情况来自定义异常处理逻辑
     * 
     * @param ex
     * @return true:如果处理了该异常信息;否则返回false
     */
    private boolean handleException(Throwable ex) {
        if (ex == null) {
            return true;
        }
        // new Handler(Looper.getMainLooper()).post(new Runnable() {
        // @Override
        // public void run() {
        // new AlertDialog.Builder(mContext).setTitle("提示")
        // .setMessage("程序崩溃了...").setNeutralButton("我知道了", null)
        // .create().show();
        // }
        // });


        return true;
    }
}

然后在Application类中进行注册 

[java] view plaincopyprint?
public class MyApplication extends Application{  
  
  
    @Override  
    public void onCreate(){  
    super.onCreate();  
        initErrorHandler();  
    }  
  
  
   private void initErrorHandler(){  
    CrashHandler handler = CrashHandler.getInstance();  
    handler.init(this);  
   }  
