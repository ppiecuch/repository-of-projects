在计算机发展初期，人们就开始从事计算机图形的开发，但直到20世纪80年代末、90年代初，三维图形才开始迅速发展。于是各种三维图形工具软件包相继推出，如GL，RenderMan等。随着计算机技术的迅速发展，GL已经进一步发展成为OpenGL，现在OpenGL被认为是高性能图形和交互式视景处理的标准。这些三维图形工具软件包有些侧重于使用方便，有些侧重于绘制效果或与应用软件的连接，但没有一种软件包能在交互式三维图形建模能力和编程方便程度上与OpenGL相比拟。

    OpenGL（即开放性图形库Open Graphics Library），是一个三维的计算机图形和模型库，最初是美国SGI公司为图形工作站开发的一种功能强大的三维图形机制（或者说是一种图形标准）。它源于SGI公司为其图形工作站开发的IRIS GL，在跨平台移植过程中发展成为OpenGL。SGI在1992年7月发布1.0版，后成为工业标准，由成立于1992年的独立财团OpenGL Architecture Review Board (ARB)控制。SGI等ARB成员以投票方式产生标准，并制成规范文档(Specification)公布，各软硬件厂商据此开发自己系统上的实现。只有通过了ARB规范全部测试的实现才能称为OpenGL。1995年12月ARB批准了1.1版本，最新版规范是2006年8月2日通过的opengl2.1，是自1.0版本后的第七次版本。新版本适应以往早期的版本，也就是2.0, 1.5, 1.4, 1.3, 1.2, 1.1, or 1.0 GL不要任何改变就能在新版本下运行。

    OpenGL被设计成独立于硬件，独立于窗口系统，在运行各种操作系统的各种计算机上都可用，并能在网络环境下以客户/服务器模式工作，是专业图形处理、科学计算等高端应用领域的标准图形库。它低端应用上的主要竞争对手是MS-Direct3D，该图形库是以COM接口形式提供的，所以极为复杂，稳定性差，另外微软公司拥有该库版权，目前只在Windows平台上可用。Direct3D的优势在速度上，但现在低价显卡都能提供很好的OpenGL硬件加速，所以做3D图形开发使用Direct3D已没有特别的必要，在专业图形处理特别是高端应用方面目前还没有出现以Direct3D技术为基础的例子，而游戏等低端应用也有转向OpenGL的趋势。

     微软在Windows NT对OpenGL的支持始于3.51，在Windows9x中的支持始于Win95 OEM Service Release 2。Windows下常用的OpenGL库有两种，MS实现的和SGI实现的，MS-OpenGL调用会自动检测是否存在显示卡制造商提供的ICD(Installable Client DeviceDriver)驱动程序，有则调用ICD中的例程，否则使用CPU进行计算，所以能利用显示卡的OpenGL加速能力。对开发者来说使用方法并没有区别，只是有ICD驱动时更快些。SGI的版本是纯软件实现，不能利用硬件加速并且SGI已经在1999年宣布停止支持，但这套图形库便于调试程序，仍有不少开发者使用。

    1999年SGI宣布与MS合作开发Ferihant，即Windows的下一代图形处理体系，包括DirectX与OpenGL的低级图形处理接口和以场景图支持为特点的高级接口，并且就此停止对其在Windows下的OpenGL实现的支持以示决心。此举令世人瞩目，大家都以为Windows图形处理快要过上幸福生活了，然而，不久，SGI宣布中止合作，并撤回派出的科学家，Ferihant基本上夭折。SGI 称终止合作的原因是MS不肯积极合作，光想把SGI 的技术合并进DirectX，但是真正内幕不详。不过以SGI在图形处理界的老大地位来说，还是有几分可信度的，因为MS最初支持OpenGL就不积极。

    OpenGL可以运行在当前各种流行操作系统之上，如Mac OS、Unix、Windows 95/98、Windows NT/2000、Linux、OPENStep、Python、BeOS等。各种流行的编程语言都可以调用OpenGL中的库函数，如C、C++、Fortran、Ada、Java。OpenGL完全独立于各种网络协议和网络拓扑结构。目前，Microsoft公司、SGI公司、ATT公司的Unix软件实验室、IBM公司、DEC公司、SUN公司、HP公司等几家在计算机市场占主导地位的大公司都采用了OpenGL图形标准。值得一提的是，由于Microsoft公司在Windows NT和Windows 95/98中提供OpenGL标准，使得OpenGL在微机中得到了广泛应用。尤其是在OpenGL三维图形加速卡和微机图形工作站推出后，人们可以在微机上实现CAD设计、仿真模拟、三维游戏等，从而使得应用OpenGL及其应用软件来创建三维图形变得更有机会、更为方便。

    OpenGL作为一个性能优越的图形应用程序设计界面（API），适用于广泛的计算机环境。从个人计算机到工作站和超级计算机，OpenGL都能实现高性能的三维图形功能。由于许多在计算机界具有领导地位的计算机公司纷纷采用OpenGL作为三维图形应用程序设计界面，所以OpenGL应用程序具有广泛的移植性。因此，OpenGL已成为目前的三维图形开发标准，是从事三维图形开发工作的技术人员所必须掌握的开发工具。OpenGL应用领域十分宽广，如军事、电视广播、CAD/CAM/CAE、娱乐、艺术造型、医疗影像、虚拟世界等。

1.1 opengl1.1

1995年，SGI推出了更为完善的OpenGL 1.1版本。OpenGL 1.1的性能比1.0版提高甚多。其中包括改进打印机支持，在增强元文件中包含OpenGL的调用，顶点数组的新特性，提高顶点位置、法线、颜色、色彩指数、纹理坐标、多边形边缘标识的传输速度，引入了新的纹理特性等等。

1.2 opengl1.3

2001年8月，ARB发布OpenGL 1.3规范，它增加了立方纹理贴图、纹理环境、多重采样、纹理框架压缩等扩展指令，但是改进程度非常有限。

1.3 opengl1.4

2002年7月，ARB正式发布OpenGL 1.4，它也只加入了深度纹理／阴影纹理、顶点设计框架、自动纹理贴图等简单的功能。

1.3 opengl1.5

2003年的7月，ARB公布OpenGL 1.5规范。OpenGL 1.5内包含ARB制定的“正式扩展规格绘制语言”（OpenGL Shading Language v1.0），该语言用于着色对象、顶点着色、片断着色等扩展功能，同时也将作为下一代OpenGL 2.0版本的内核。OpenGL 1.5的变化还增加了顶点缓冲对象（可提高透视性能）、非乘方纹理(可提高纹理内存的使用效率)以及阴影功能、隐蔽查询功能等等。其主要内容包括

l 顶点Buffer Object：进行顶点配列方式可以提高透视性能
l Shadow功能：增加用来比较Shadow映射的函数
l 隐蔽查询(QUERY)：为提高Curling性能采用非同步隐蔽测试
l 非乘方纹理(Texture)：提高mipmap等纹理内存的使用效率
l OpenGL Shading Language v.1.0：用于着色(shader)对象、顶点着色以及片断着色技术(fragment shader )的扩展功能

1.4 opengl2.0

       OpenGL 1.0推出后的相当长的一段时间里，OpenGL唯一做的只是增加了一些扩展指令集，这些扩展指令是一些绘图功能，像是ClearCoat、Multisample、视频及绘图的整合工具(某些是通过OpenML的努力而开发出来的，它本身属于OpenGL ARB扩展指令之一。
    OpenGL 2.0将在OpenGL 1.3基础上进行修改扩充、但它将有下面五个方面的重大改进：①复杂的核心被彻底精简；②完全的硬件可编程能力；③改进的内存管理机制、支持高级像素处理；④扩展至数字媒体领域，使之跨越高端图形和多媒体范畴；⑤支持嵌入式图形应用。
    为了在获得强大功能的同时保持理想的兼容性，OpenGL 2.0经历以下两个发展阶段：第一个阶段注重兼容能力和平滑过渡，为此，OpenGL 2.0核心将在精简后的OpenGL 1.3功能模块的基础上加上可完全兼容的新功能共同组成，这种做法在满足兼容性的同时，还可将原有OpenGL中数量众多、且相互纠缠不清的扩展指令进行彻底精简。 第一阶段的任务只是为了过渡，而第二阶段才是OpenGL 2.0的真正成熟期。此时，ARB将合成出一个“纯OpenGL 2.0”内核，纯内核将包含更多新增加的“精简型API函数”，这些函数具有完全的可编程特性、结构简单高效、功能强大且应用灵活。除了完成这项任务外，ARB组织还得指导开发商抛弃繁琐的OpenGL 1.X、转用更具弹性的“纯OpenGL 2.0”。

1.5 opengl2.1

       OpenGL version 2.1在2006年8月2日发布，是最初版本1.0后的第七个版本。尽管增加了版本的层析，支持高层析的编程shaders,但版本能够适于早期的版本，意味着运行2.0, 1.5, 1.4, 1.3, 1.2, 1.1, or 1.0 GL的程序不用任何改变就可运行。

    OpenGL2.1与当前的2.0版本相比，虽然版本号变更不如DX9到DX10那么巨大，但它却增加了多项实用的技术和功能，例如向后兼容增强型OpenGL的先进管道规划，其中包括：
优化GPU和显存之间并行工作时间，提高象素缓冲和对象的象素和质感快速缓冲利用率；
增加标准彩色图像质感sRGB色彩空间应用促进管理的灵活性；
并增加了许多新的shader弹性调配，包括非平方矩阵支持，支持阵列流对象和碎块点位置时,干扰和shaders属性不变的变量shader代码提高可靠性。
1. GLSL升级至1.2版；
2. 支持非正方形的矩阵. UniformMatrix {2x3,3x2,2x4,4x2,3x4,4x3}fv ；
3. 象素缓冲对象(Pixel Buffer Object).  它扩充了缓冲对象的接口.现在缓冲区对象可以支持顶点数组和象素数据了.象素缓冲对象能加速在GPU内存中进行的缓冲区之间的数据拷贝及其他象素操作.；4. sRGB纹理. 遵循IEC 61966-2-1.标准的sRGB颜色空间的纹理格式(包括压缩和非压缩格式).（OpenGL 2.1 adds backwards compatible enhancements to OpenGL's advanced programmable pipeline including: Pixel Buffer Objects for fast texture and pixel copies between frame buffer and buffer objects in GPU memory; texture images specified in standard sRGB color space for enhanced application color management flexibility; and numerous additions to increase the flexibility of shader programming including non-square matrix support, support for arrays as first-class objects, a fragment position query in shaders using Point Sprites and an invariant attribute for variables to enhance shader code reliability.）

2 OpenGL扩展（OpenGL Extensions）

    OpenGL和Direct3D比较起来，最大的一个长处就是其扩展机制。硬件厂商开发出一个新功能，可以针对新功能开发OpenGL扩展，软件开发人员通过这个扩展就可以使用新的硬件功能。所以虽然显卡的发展速度比OpenGL版本更新速度快得多，但程序员仍然可以通过OpenGL使用最新的硬件功能。而Direct3D则没有扩展机制，硬件的新功能要等到微软发布新版DirectX后才可能支持。 
OpenGL扩展也不是没有缺点，正因为各个硬件厂商都可以开发自己的扩展，所以扩展的数目比较大，而且有点混乱，有些扩展实现的相同的功能，可因为是不同厂商开发的，接口却不一样，所以程序中为了实现这个功能，往往要为不同的显卡写不同的程序。这个问题在OpenGL 2.0出来后可能会得到解决，OpenGL 2.0的一个目标就是统一扩展，减少扩展数目。 

2.1 扩展名
每个扩展都有一个扩展名，扩展名类似如下形式： 

GL_ARB_multitexture 

第一段GL，用来表示针对OpenGL哪部分开发的扩展，有以下几个值： 

GL C 针对OpenGL核心的扩展 
WGL C 针对Windows平台的扩展 
GLX C 针对Unix / Linux平台的扩展 
GLU C 针对OpenGL Utility Library的扩展 

第二段ARB，用来表示是谁开发的这个扩展，常见以下几个值：

ARB C 经OpenGL Architecture Review Board（OpenGL管理机构）正式核准的扩展，往往由厂商开发的扩展发展而来，如果同时存在厂商开发的扩展和ARB扩展，应该优先使用ARB扩展 

EXT C 被多个硬件厂商支持的扩展 
NV C nVIDIA 公司开发的扩展 
ATI C ATI公司开发的扩展 
ATIXC ATI公司开发的实验性扩展 
SGI C Silicon Graphics（SGI）公司开发的扩展 
SGIXC Silicon Graphics（SGI）公司开发的实验性扩展 

第三段multitexture就是真正的扩展名了，如multitexture就是多重纹理扩展。

2.2使用OpenGL扩展

要使用一个OpenGL扩展，首先必须检查显卡是否支持这个扩展，以下代码可以获取一个显卡支持的的OpenGL扩展：
const char *str = glGetString( GL_EXTENSIONS );
函数返回一个字符串指针，这个字符串就是显卡所支持的所有扩展的扩展名，不同的扩展名之间用空格隔开，形如：

"GL_ARB_imaging GL_ARB_multitexture GL_ARB_point_parameters ……"

OpenGL扩展往往都会新增一些函数，在Windows平台上，这些函数不是通过.lib库连接到程序里的，而要在运行时动态获得函数的指针。我们以GL_ARB_point_parameters扩展为例看看怎么获得函数指针。

首先要定义函数指针类型，

typedef void (APIENTRY * PFNGLPOINTPARAMETERFARBPROC)(GLenum pname,
GLfloat param);
typedef void (APIENTRY * PFNGLPOINTPARAMETERFVARBPROC)(GLenum pname,
const GLfloat *params);

这个工作SGI已经为我们做好，它提供了一个头文件 glext.h ，里面有目前绝大多数扩展的常量和函数指针定义，下载下来放到编译器的include/GL文件夹下面，然后在程序里面加上：

#include <GL/glext.h>

就可以在程序中使用常量和函数指针类型了。

然后要定义函数指针：

PFNGLPOINTPARAMETERFARBPROC glPointParameterfARB;
PFNGLPOINTPARAMETERFVARBPROC glPointParameterfvARB;

再检查显卡是否支持GL_ARB_point_parameters扩展，其中isExtensionSupported是自定义的一个函数，就是在glGetString( GL_EXTENSIONS )返回的字符串里查找是否存在指定的扩展名：

int hasPointParams = isExtensionSupported("GL_ARB_point_parameters");

如果支持，就可以用wglGetProcAddress函数获取扩展函数的指针：
if (hasPointParams) 
{
glPointParameterfARB = (PFNGLPOINTPARAMETERFARBPROC）\
wglGetProcAddress( "glPointParameterfEXT" );
glPointParameterfvARB = (PFNGLPOINTPARAMETERFVARBPROC) \
wglGetProcAddress( "glPointParameterfvEXT" );
}

最后就可以在程序里使用扩展函数：

if (hasPointParams)
{
static GLfloat quadratic[3] = { 0.25, 0.0, 1/60.0 };
glPointParameterfvARB(GL_DISTANCE_ATTENUATION_ARB, quadratic);
glPointParameterfARB(GL_POINT_FADE_THRESHOLD_SIZE_ARB, 1.0);
}

另外，下面代码说明如何访问扩展函数：（资料来源于csdn知识库）

调用wglGetProcAddress函数访问一个不在标准OpenGL库中的扩展函数。如果该扩展函数存在当前的执行(implementation)中，那么wglGetProcAddress返回一个用来访问该函数的函数指针。否则，wglGetProcAddress返回NULL.

例如，要访问glAddSwapHintRectWIN扩展函数，如下调用wglGetProcAddress:

// Get a pointer to the extension function.
typedef void (WINAPI *FNSWAPHINT)(GLint, GLint, GLsizei, GLsizei);
fnSwapHint = (FNSWAPHINT)wglGetProcAddress("glAddSwapHintRectWIN");

// Actual call to glAddSwapHintRectWIN.
if (fnSwapHint != NULL)
(*fnSwapHint)(0, 0, 100, 100);

2.3 WGL扩展

glGetString( GL_EXTENSIONS )取得的扩展字符串中并不包括针对Windows平台的WGL扩展，WGL扩展串要通过WGL_ARB_extensions_string扩展来获得，以下代码演示了如何获得WGL扩展串：

定义WGL_ARB_extensions_string扩展新增函数wglGetExtensionsStringARB的函数指针类型，同样这个工作SGI已经为我们做好，只不过不在glext.h中，而在它提供的另外一个头文件 wglext.h 中：

typedef const char *(APIENTRY * PFNWGLGETEXTENSIONSSTRINGARBPROC)(
HDC hdc);

定义函数指针：

PFNWGLGETEXTENSIONSSTRINGARBPROC wglGetExtensionsStringARB;

检查是否支持WGL_ARB_extensions_string扩展，如果不支持，表示这个显卡不支持WGL扩展，如果支持，则得到wglGetExtensionsStringARB函数的指针，并调用它得到WGL扩展串：

int hasWGLext = isExtensionSupported("WGL_ARB_extensions_string");
if (hasWGLext)
{
wglGetExtensionsStringARB = (PFNWGLGETEXTENSIONSSTRINGARBPROC) \
wglGetProcAddress( "wglGetExtensionsStringARB" );
const char *wglExt = wglGetExtensionsStringARB( hdc );
……
}

2.4 OpenGL版本

一些常用的OpenGL扩展会在新版的OpenGL中加到OpenGL核心中去，成为OpenGL标准的一部分，可以简化程序开发，程序员使用这些功能时不必做繁琐的扩展初始化工作。比如多重纹理功能，在OpenGL1.2.1加入到OpenGL核心中，以前要使用多重纹理，要先检查是否支持GL_ARB_multitexture扩展，然后初始化glActiveTextureARB等函数，很麻烦，而OpenGL1.2后，则可以直接使用glActiveTexture函数。 
不过，这种简化只有Mac/Unix/Linux程序员才能享受到，在Windows平台上没有这么简单。微软为了维护Direct3D，对OpenGL的支持很消极，其OpenGL实现仍然是1.1。由于Windows上的OpenGL程序最终都会动态链接到微软的OpenGL32.dll，可OpenGL32.dll只支持OpenGL 1.1，使我们不能直接使用新版OpenGL，仍然要用扩展访问OpenGL1.1以来新增的功能。

2.5 OpenGL扩展资料

All About OpenGL Extensions ：必读。
讨论OpenGL扩展机制，讲述了如何阅读扩展官方说明书，并举了一些扩展的例子。
OpenGL Extension Registry ：
由SGI维护，列出了目前公开的所有扩展及其官方说明书。

OpenGL Hardware Registry ： 由Delphi3D.net维护，列出了目前几乎所有3D加速卡的OpenGL硬件信息，包括其支持的扩展。当然，这里面列的扩展不能作为程序的依据，程序中要使用某个扩展，还是要先检查显卡是否支持。因为同样的显卡，如果驱动程序不同，支持的扩展也不相同，往往新的驱动程序会加入新的扩展，丢掉一些废弃的扩展。

2.6 OpenGL硬件加速 

在Windows平台上，OpenGL驱动可能有三种模式：纯软件、MCD和ICD： 

纯软件模式：微软提供一个OpenGL的软件实现，所有渲染操作均由CPU完成，速度很慢。如果安装系统时使用Windows自带的显卡驱动程序，那么OpenGL程序就会运行在软件模式下。而且由于微软有自己的Direct3D，所以对OpenGL的支持很消极，它的OpenGL纯软件实现只支持OpenGL1.1，而目前OpenGL的最新版本为1.4

MCD（Mini Client Driver）：MCD是早期微软在Windows NT上支持OpenGL时，为了简化驱动开发时使用的一个模型。在这个模型中，OpenGL渲染管线的变换、光照部分仍然由软件实现，而光栅化部分则由硬件厂商实现，因此只要硬件支持，MCD可以硬件加速光栅化部分。MCD虽然可以简化驱动开发，但是功能限制太大，现在市面上的3D加速卡均支持硬件变换和光照，MCD却不能利用这一特性，看上去MCD已经没有存在的价值

ICD（Installable Client Driver）：ICD是一个完整的OpenGL驱动模型，比MCD复杂得多。硬件厂商要实现完整的OpenGL渲染管线，如变换、光照、光栅化等，因此只要硬件支持，ICD可以硬件加速整个OpenGL渲染管线。我们通常说的OpenGL硬件加速就是指的通过ICD模型获得的硬件加速，而现在硬件厂商提供的OpenGL驱动程序也都是依照ICD模型开发的。主要硬件厂商的ICD已经可以支持OpenGL的最新版1.4

Windows怎么实现OpenGL硬件加速呢？OpenGL32.dll是微软的OpenGL 1.1纯软件实现，我们的程序都要动态链接到这个dll。如果安装3D芯片厂商的驱动程序，会将一个不同名字的dll放到Windows系统目录下，比如在Windows 2000下安装nVIDIA GeForce2 MX的驱动程序，会在系统目录下放一个nvoglnt.dll（这就是nVIDIA的OpenGL驱动），并在注册表中登记nvoglnt.dll，让Windows知道硬件加速OpenGL驱动的名字，以后运行OpenGL程序，OpenGL32.dll就会把OpenGL调用直接转到nvoglnt.dll。 

Windows平台上，一个OpenGL程序是否使用硬件加速由三个因素决定，这三个因素缺一不可，否则程序都会运行于纯软件模式： 

是否有一块3D加速卡 

是否安装了显卡厂商提供的最新的驱动程序，Windows自带的显卡驱动程序并不会提供OpenGL硬件加速能力 

指定的像素格式是否被显卡硬件所支持 

判断一种像素格式是否被显卡硬件所支持，可以用函数DescribePixelFormat取得该像素格式的数据，然后看结构体PIXELFORMATDESCRIPTOR中的dwFlags的值，如果

PFD_GENERIC_FORMAT被置1，并且PFD_GENERIC_ACCELERATED被置0，即
(pfd.dwFlags & PFD_GENERIC_FORMAT) && 
!(pfd.dwFlags & PFD_GENERIC_ACCELERATED)
表明该像素格式不被显卡硬件支持，使用该像素格式的OpenGL程序将使用纯软件模式渲染 

PFD_GENERIC_FORMAT被置1，并且PFD_GENERIC_ACCELERATED被置1，即
(pfd.dwFlags & PFD_GENERIC_FORMAT) && 
(pfd.dwFlags & PFD_GENERIC_ACCELERATED)
表明该像素格式被显卡硬件支持，并且程序使用MCD模式渲染 

PFD_GENERIC_FORMAT被置0，并且PFD_GENERIC_ACCELERATED被置0，
!(pfd.dwFlags & PFD_GENERIC_FORMAT) && 
!(pfd.dwFlags & PFD_GENERIC_ACCELERATED)
表明该像素格式被显卡硬件支持，并且程序使用ICD模式渲染 

3 OpenGL Extension 

这个软件可以自动测试显卡对OpenGL的版本支持和扩展命令。

4、如何使用扩展

    如果你在Windows平台下开发OpenGL程序，那么系统中自带的OpenGL库就是1.1的，如果想使用1.2或者更高版本的OpenGL库，那么只能使用OpenGL扩展。
    很多参考书上都会提到OpenGL2.0、OpenGL2.1，但是微软对OpenGL的支持只到1.1，1.1以后微软就不再支持了，为什么，因为微软更想发展自家的DirectX。
    所以如果想使用OpenGL1.1以上的功能或者函数，只能使用OpenGL扩展，这些扩展是一些OpenGL团体或个人开发出来的能Windows上使用的OpenGL1.1以后的一些功能及函数。所以，在Windows上根本就没有什么OpenGL2.0的头文件或库文件了，OpenGL1.1以后的东西都已经以扩展的形式存在了，而且，并没有一个统一的标准，你可以使用glex，glew，glee等等。

是否能用扩展和显卡的功能有关，const     GLubyte   * glGetString( GLenum name )我们以GL_EXTENSIONS为参数调用该函数，就能获得当前显卡所支持的所有扩展，像下面这样：const GLubyte *str = glGetString(GL_EXTENSIONS) ; cout << str << endl ;输出的各个扩展之间以空格分隔，如果这些扩展中包含GL_ARB_imaging，那么你就可以使用glBlendEquation这个函数了。当然，这样查询的只是gl扩展，还可以用gluGetString获得glu扩展。在判断了显卡所支持的扩展以后，就可以使用该扩展中所包含的函数了。

4．1 使用glext

这里下载：(http://graphics.ethz.ch/pointsho ... lext_8h-source.html)

a)头文件的包含 这个文件并不是Windows系统中原有的，需要到网上下载。使用的时候有一点要注意，如果程序中还用到了glut.h文件，那么一定要把glext.h放在glut.h的后面，因为glext.h要用到gl.h，而glut.h中包含了gl.h，如果顺序搞错了，编译的时候会有一大堆错误，正确的顺序如下：

#include <iostream>

#include <windows.h>

#include <GL/glut.h>

#include <GL/glext.h>

b)获取函数指针

先定义函数指针，PFNGLBLENDEQUATIONPROC  glBlendEquation = NULL;

再获取函数地址, 使用wglGetProcAddress函数，注意这一句要加在使用glBlendEquation函数的语句之前才有效，最后后面紧跟着使用glBlendEquation的函数语句，切记不要加在所有子程序的外面，否则获取的指针是无效的

glBlendEquation = (PFNGLBLENDEQUATIONPROC)wglGetProcAddress("glBlendEquation");

例如可以这样加：

PFNGLBLENDEQUATIONPROC glBlendEquation = (PFNGLBLENDEQUATIONPROC)wglGetProcAddress("glBlendEquation");

switch(key)

{ case 'a':

case 'A':  //Note: glBlendEquation is a subset of GL_ARB_imaging, please call glGetString

//first to confirm whether your video card support this extension.
                   glBlendEquation(GL_FUNC_ADD) ;

 break ;

         case 's':

         case 'S':

                   glBlendEquation(GL_FUNC_SUBTRACT) ;

                   break ;

4.2 使用glew

glew也是一个扩展库，包含了OpenGL中许多核心及扩展函数，现在的版本是1.3.5，支持OpenGL2.1，可以到这里下载：

http://glew.sourceforge.net/

上面的方法可能有些麻烦，如果已经下载了glew库的话，那么可以直接使用该扩展，但是使用之前首先要确定你的显卡是否支持该扩展。方法如下：首先还是要判断显卡是否支持该扩展，我们这里假定已经支持，

1)．包含头文件glew.h，注意这里和上面不同，这回glut.h要放在glew.h的后面了
像下面这样
#include <GL/glew.h>

#include <GL/glut.h>
然后就可以在程序中直接使用glBlendEquation了，其他扩展的判断和使用方法与此类似。
最后还有一点切记！那就是还要调用glewInit() ;来初始化一下方可使用扩展，如下：
GLenum err = glewInit() ;

         if (GLEW_OK != err)
         {
                   MessageBoxA(NULL, "error", "My Window", 1) ;
         }

   你现在可以使用扩展了！

http://www.sciencenet.cn/blog/Print.aspx?id=23999