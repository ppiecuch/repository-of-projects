opengl镜面反射 收藏 
其实镜面效果在很多地方都有应用，比如光滑的物品表面，或是水面的倒影等。
但做镜面的反射不是让opengl自己去计算一个镜面的反射画面，而是把物件和反射面画出来后，再在反射面的那块区域把物件的倒影画出来。
听起来不算简单，但难点却不是怎么画倒影，而是怎么把倒影限定在某块区域。
要实现这个效果，就要使用opengl的模板测试。关于模板，这里转载一段关于模板的教程，我觉得这段教程对于新手来说很容易理解。


--------------------------------------------------------------------------------

3、模板测试
模板测试是所有OpenGL测试中比较复杂的一种。

首先，模板测试需要一个模板缓冲区，这个缓冲区是在初始化OpenGL时指定的。
如果使用GLUT工具包，可以在调用glutInitDisplayMode函数时在参数中加上GLUT_STENCIL，例如：

glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGBA | GLUT_STENCIL);

在Windows操作系统中，即使没有明确要求使用模板缓冲区，有时候也会分配模板缓冲区。
但为了保证程序的通用性，最好还是明确指定使用模板缓冲区。如果确实没有分配模板缓冲区，则所有进行模板测试的像素全部都会通过测试。

通过glEnable/glDisable可以启用或禁用模板测试。

glEnable(GL_STENCIL_TEST);  // 启用模板测试
glDisable(GL_STENCIL_TEST); // 禁用模板测试


OpenGL在模板缓冲区中为每个像素保存了一个“模板值”，当像素需要进行模板测试时，将设定的模板参考值与该像素的“模板值”进行比较，
符合条件的通过测试，不符合条件的则被丢弃，不进行绘制。
条件的设置与Alpha测试中的条件设置相似。但注意Alpha测试中是用浮点数来进行比较，而模板测试则是用整数来进行比较。
比较也有八种情况：始终通过、始终不通过、大于则通过、小于则通过、大于等于则通过、小于等于则通过、等于则通过、不等于则通过。

glStencilFunc(GL_LESS, 3, mask);

这段代码设置模板测试的条件为：“小于3则通过”。
glStencilFunc的前两个参数意义与glAlphaFunc的两个参数类似，第三个参数的意义为：如果进行比较，则只比较mask中二进制为1的位。
例如，某个像素模板值为5（二进制101），而mask的二进制值为00000011，因为只比较最后两位，5的最后两位为01，其实是小于3的，因此会通过测试。

如何设置像素的“模板值”呢？glClear函数可以将所有像素的模板值复位。代码如下：

glClear(GL_STENCIL_BUFFER_BIT);

可以同时复位颜色值和模板值：

glClear(GL_COLOR_BUFFER_BIT | GL_STENCIL_BUFFER_BIT);

正如可以使用glClearColor函数来指定清空屏幕后的颜色那样，也可以使用glClearStencil函数来指定复位后的“模板值”。

每个像素的“模板值”会根据模板测试的结果和深度测试的结果而进行改变。

glStencilOp(fail, zfail, zpass);

该函数指定了三种情况下“模板值”该如何变化。
第一个参数表示模板测试未通过时该如何变化；第二个参数表示模板测试通过，但深度测试未通过时该如何变化；第三个参数表示模板测试和深度测试均通过时该如何变化。
如果没有起用模板测试，则认为模板测试总是通过；如果没有启用深度测试，则认为深度测试总是通过）
变化可以是：
GL_KEEP（不改变，这也是默认值），
GL_ZERO（回零），
GL_REPLACE（使用测试条件中的设定值来代替当前模板值），
GL_INCR（增加1，但如果已经是最大值，则保持不变），
GL_INCR_WRAP（增加1，但如果已经是最大值，则从零重新开始），
GL_DECR（减少1，但如果已经是零，则保持不变），
GL_DECR_WRAP（减少1，但如果已经是零，则重新设置为最大值），
GL_INVERT（按位取反）。

在新版本的OpenGL中，允许为多边形的正面和背面使用不同的模板测试条件和模板值改变方式，于是就有了glStencilFuncSeparate函数和glStencilOpSeparate函数。
这两个函数分别与glStencilFunc和glStencilOp类似，只在最前面多了一个参数face，用于指定当前设置的是哪个面。可以选择GL_FRONT, GL_BACK, GL_FRONT_AND_BACK。

注意：模板缓冲区与深度缓冲区有一点不同。
无论是否启用深度测试，当有像素被绘制时，总会重新设置该像素的深度值（除非设置glDepthMask(GL_FALSE);）。
而模板测试如果不启用，则像素的模板值会保持不变，只有启用模板测试时才有可能修改像素的模板值。
（这一结论是我自己的实验得出的，暂时没发现什么资料上是这样写。如果有不正确的地方，欢迎指正）
另外，模板测试虽然是从OpenGL 1.0就开始提供的功能，但是对于个人计算机而言，硬件实现模板测试的似乎并不多，很多计算机系统直接使用CPU运算来完成模板测试。
因此在一些老的显卡，或者是多数集成显卡上，大量而频繁的使用模板测试可能造成程序运行效率低下。
即使是当前配置比较高端的个人计算机，也尽量不要使用glStencilFuncSeparate和glStencilOpSeparate函数。

从前面所讲可以知道，使用剪裁测试可以把绘制区域限制在一个矩形的区域内。
但如果需要把绘制区域限制在一个不规则的区域内，则需要使用模板测试。
例如：绘制一个湖泊，以及周围的树木，然后绘制树木在湖泊中的倒影。为了保证倒影被正确的限制在湖泊表面，可以使用模板测试。具体的步骤如下：
(1) 关闭模板测试，绘制地面和树木。
(2) 开启模板测试，使用glClear设置所有像素的模板值为0。
(3) 设置glStencilFunc(GL_ALWAYS, 1, 1); glStencilOp(GL_KEEP, GL_KEEP, GL_REPLACE);绘制湖泊水面。这样一来，湖泊水面的像素的“模板值”为1，而其它地方像素的“模板值”为0。
(4) 设置glStencilFunc(GL_EQUAL, 1, 1); glStencilOp(GL_KEEP, GL_KEEP, GL_KEEP);绘制倒影。这样一来，只有“模板值”为1的像素才会被绘制，因此只有“水面”的像素才有可能被倒影的像素替换，而其它像素则保持不变。


--------------------------------------------------------------------------------

整理下代码思路

先把场景中的物件画上去，然后画镜面的形状。这里不一定是要画一个镜子上去，只是类似设置一个镜面的范围，不在此范围内看不到物件的反射图案。
比如我画一个湖面，可以先把湖面的范围的模板值计算好，然后把倒影画在湖中后再把水面的贴图贴上去。
按照NEHE的教程，如果不把图案的实际颜色画出来，只要用glColorMask()函数把各颜色分量的掩码设置为0即可。

下面是我的程序的关键代码：

view plaincopy to clipboardprint?
void Mirror::Render()   
{   
    //启用深度测试，并把场景的东西都画好   
    glEnable(GL_DEPTH_TEST);   
    glutSolidTeapot(1);   
  
    //设置模板，当画镜面时把镜面范围的模板值换成1&0xff   
    glEnable(GL_STENCIL_TEST);   
    glStencilFunc(GL_ALWAYS,1,0xff);   
    glStencilOp(GL_KEEP,GL_KEEP,GL_REPLACE);   
  
    //画镜面时必须设置深度值为只读，否则会更新深度值导致倒影画不上去   
    glDepthMask(GL_FALSE);   
    //如果只希望画反射范围就要设置不把镜面的实际颜色画上去   
    //glColorMask(0,0,0,0);   
    DrawMirror();   
    //glColorMask(1,1,1,1);   
    glDepthMask(GL_TRUE);   
  
    //继续设置模板测试，不等于镜面模板值的则不会显示   
    glStencilFunc(GL_EQUAL,1,0xff);   
    glStencilFunc(GL_KEEP,GL_KEEP,GL_KEEP);   
  
    //这里为画水壶的倒影   
    glPushMatrix();   
    glTranslatef(0.0f,-3.0f,0.0f);   
    glScalef(1.0,-1.0,1.0);   
    glutSolidTeapot(1);   
    glPopMatrix();   
    glDisable(GL_STENCIL_TEST);   
}  

程序最终运行的效果图：


本文来自CSDN博客，转载请标明出处：http://blog.csdn.net/hacson/archive/2010/07/25/5764778.aspx