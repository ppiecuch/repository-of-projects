先自我介绍……你要是说这是自我炒作我也认了。首先说明，FXCarl是一个对3D美术一窍不同的家伙。虽然很想往技术美工方向发展了。因为是学程序出身，眼下能做的也就是写写Shaders。等到手上的项目做完，会公开始用的实时光照模型……不过那是后话了。现在只是想配合一下这两天大家讨论的热火朝天的Normal Map，在这里和占大多数的美术人员从另外一个角度来谈谈“凹凸贴图技术”

首先我想说，对于凹凸贴图在计算机图形领域中的研究，最早开始于70年代末，至今已经有接近30年历史了。Normal Map只是一种目前很流行的凹凸贴图技术，而这里将会介绍一些目前游戏和在XBOX360和PlayStation3这种新世代主机上将会运用的凹凸贴图技术。

1.Bump Mapping

做过CG的朋友一定比FXCarl还要更早的认识Bump Map。这种贴图是一种灰度图，用表面上灰度的变化来描述目标表面的凹凸，因此这种贴图是黑白的，如果节省空间的画，甚至可以把贴图的Alpha通道征用来用作Bump。值得注意的是，这种贴图表面上存储的东西是高度域－－即每个点和原始表面的高度差，记住，每个点的颜色不是色彩，是高度，一个数值！因此，对这个贴图做任何的操作都会影响到这个物体3D的外观质感。不能凭感觉用事。

在游戏中，所使用的算法确切的说应该叫做fake bump mapping ，假凹凸贴图。因为在游戏中Bump Map并没有改变物体的表面而只是影响光照的结果，欺骗眼睛而已。最简单的做法是，直接把Bump Map叠加在已经渲染好的表面上，造成亮度上的扰动，从而让人以为是凹凸的－－这个很容易理解，把一面白色的墙面有技巧的部分划成灰色就会变成蚀痕，这些诸位会比小的更擅长。而计算复杂度是基本加减法。这个所谓的 Fake Bump Mapping 从Geforce2就开始硬件支持，但是从来没有大范围的应用过。

不过有趣的是，Bump Map这个东西却从未过时，在后来的渲染算法中，其储存表面高度域的特性仍然发挥着巨大的作用。我们后文再提Normal Mapping.




2.Normal Mapping

Normal Mapping在游戏领域中的实践是一个非常值得记住的时期－－Geforce3上市，GPU概念出现，硬件可编程流水线的出现（Shaders），Normal Mapping是一种凹凸贴图技术，它的另外一个名字叫做Dot3 bump mapping。

用于实现它的控制纹理是一张叫做Normal Map的纹理，也是目前大家在讨论如何制作的那种。我们先说说这张叫做Normal Map的图。这张图中存储的东西是每个原始表面法线的迭代，说起来有点复杂，但是不难理解。举例说我们的说面，一般在游戏的3D模型上，表面法线就像是一根站立于桌面的钢笔，垂直向上。而Normal Map中存储的东西就是我们这支表示表面法线方向的钢笔所“应该”指向的方向－－比如说朝左边倾斜15度。

Normal Map有两种主要形式，一种叫做世界空间的Normal Map，一种叫做切空间的Normal Map。第一种在游戏中没有实用价值，我们说第二种，也就是大家最常见的一种。

那么，为什么我们看到的Normal Map会有这么奇怪的颜色呢？其实Normal Map和Bump Map一样，即它显示出来的颜色和它所起的作用是没有直接联系的。大家一定对空间坐标的概念非常熟悉了。在Normal Map的定义中，有一个事先的约定，这个约定就是－－原本表面的垂直方向，我们称为Z轴；而表面的UV坐标两个方向，分别对应X轴和Y轴。（确切的说，应该是称作切线和负法线，但是这两个东西和大家熟悉的UV坐标刚好重叠，所以就用大家更习惯的说法了）然后我们知道如果我们在XYZ轴上各取一个点，这个点的取值位置在-1到1之间，那么我们就可以得到一个指向任何方向的法线方向（不用多解释，大家知道法线是一个向量，向量有方向和长度两个概念，但是对法线来说，长度是不需要的）。但是，请大家注意，我们在描述色彩的时候，RGB三个通道的取值范围都是从零开始的。可是当我们尝试把一个任意的法线保存在一张纹理中的时候，会面临取负值的问题。因此我们要把法线做压缩。方法很简单，把XYZ每个轴上的法线投影长度进行N＋1/2的运算。这样就把所有的法线压缩到了0和1的范围里。然后我们把XYZ的方向分别存储在RGB三个通道中。似乎我们还没有说到关于为什么Normal Map会是蓝兮兮的原因是吧。那么现在就是公布结果的时候了！首先，我们知道如果在一个物体表面，法线垂直向上，那么它的XYZ坐标是多少？是0,0,1对不对?然后我们把这个数字按照我们前面所说的压缩方法进行压缩，每个数字加1然后再除以2，那么我们得到的是0.5,0.5,1对不对？好我们把它代入到RGB中，那么我们会得到128,128,255对不对？好了，试试看在调色板里的颜色吧！

P.S.现在FXCarl和你猜个谜，看看FXCarl说的对不对。现在我们在Normal Map上看见一个颜色，这个颜色是219,128,219。那么这个表面的法线方向是垂直向右偏45度。大家用MAX做一个Normal Map看看FXCarl说的对不对？

如果你还没有理解Normal Map的意思，或者说你有兴趣再深入了解一些，那么FXCarl再和你说的深入一些。不知道大家对于切空间的理解是什么？我们来个实验，找三支笔。然后其中两只笔在桌面放成互相成90度，笔尾接笔尾。最后我们把第三支笔，笔尖向上，笔尾和那两只桌面上的笔的笔尾叠在一个点上。注意看我们的三支笔！这三支笔就是这张桌面上这个点的切空间坐标了！大家一定想到了原来我们的Normal Map中存储的表面法线方向原来就是一个切空间向量啊，恩没错，就是切空间向量。但是似乎看起来切空间没什么作用是不是？呵呵，我们不妨把桌面换成一个篮球。记住，保持三支笔的互相关系，然后用三支笔并在一起的笔尾去接触篮球的表面。呵呵，发现了没有？切空间的优势在于，在任意表面上，切空间中的坐标都是有效的！也就是说始用切空间中的数据就可以做到和3D模型的复杂度无关！你可以用在任意的表面，甚至这个表面一直在动也不会影响到Normal Map发挥作用，你说这个切空间是不是很有用呢？

让我们回到开头，大家就会发现，如果使用世界空间的Normal Map会有什么样的结果呢？嘿嘿那样会造成一个很尴尬的结果，比如说我们做了一个人物身上的Normal Map，可是我们的场景中有两个一样的人物，但是他们的姿势和面对的角度都不一样。那么……My God ～肯定有一个人物的Normal Map是没法适用的！而用切空间的Normal Map就没有问题了。恩，不过这个大家可以放心，MAX或者Maya做出来的Normal Map都是切空间的Normal Map，证明的方法很简单……看看这张贴图是不是主要由蓝色构成的……

OK，下面是重头戏，告诉大家Normal Map是如何发生作用的。

使用Normal Map的先决条件－－逐像素著色。先来说一下传统著色，传统游戏使用的是一个Phong光照模型的简化版，甚至有游戏使用Ground模型。这两种算法的方式都是只对物体3D模型的顶点计算光照，而3D表面上的大面积区域则使用差值填充。逐像素著色是到了Shaders出现之后才有的，因此Normal Mapping也是一个Shaders必须的算法。计算一个物体表面漫反射光照的公式是很简单的NdotL－－什么是NdotL，就是物体表面的法线和光照方向的点积。点积是一个线性代数的问题，美术朋友们可以不用深究，写成程序也很容易：Diffuse = saturate(Mul(Normal,Light));。想要简单的理解就是－－光线的方向矢量在法线矢量上的投影，然后这个投影的结果变成黑白中间的一个值。我们同样举个简单的例子，用两支笔放在桌面上，然后一支笔不动，令一支笔笔尾和第一支笔的笔尾相连，不动，然后以共同的笔尾做为圆心，移动笔。这时如果我们从一支笔尖往另外一支笔的笔杆上垂直拉一条线（一条垂线）就会看到这时移动后的一支笔在原本的笔杆所投影的长度（就是一支笔的笔尖连垂线到另一支笔的笔杆上的位置，这个位置沿着笔杆到共同笔尾的长度）会越来越短，当两支笔垂直的时候，投影的结果就是零－－没有光照贡献了。这个容易理解，当光线的方向和一个表面绝对平行的时候，这个表面就会再也接受不到光线了。现在我们引入NormalMap。这时我们的光照计算和以往有点不同，我们把表面的法线用NormalMap中存储的法线来替代。这样当我们在计算表面光照情况的时候，就会因为法线不断的变化而产生比原来丰富的多的明暗变化。

至于为什么会感觉出凹凸来这个就是人的眼睛自己骗自己了……其实那里本没有凹凸的，但是我们人眼睛太多管闲事了。就像Windows的按钮哪个纯平面的东西我们还以为是凸出来的呢。

Normal Map看来可以增加细节，但是它的缺点也很明显。不过在说缺点之前，要提前说一句－－Normal Map带来的优势是远远大于它的缺点的。因此仍然是个极好的东西，不要对它有偏见，特别是在我们后面介绍的更牛的技术前面，千万不要。最大的也是最明显的缺点应该就是它的视角问题。因为Normal Map只是改变的表面上的光照结果，并没有改变表面上的形状。因此，表面上看来，似乎只要是不接近水平，NormalMap就不会有视角问题。其实不然，NormalMap因为不能实现自身内部的遮挡，因此不能表现平面上凹凸起伏比较大的场合。比如说我们一个桌面上突出一块，然后在突出的这块东西边上放一支牙签。如果用Normal Map表现，会发现。根据经验，这个凸起会很轻易的挡住我们的视线，让我们看不见那支牙签。可是Normal Map却不会这么做。因此我们一直能看见障碍物背后的东西，这一点是个问题－－也就是说只有在垂直于平面的时候NormalMap才会发挥最好的作用。这样一来，Normal Map只能用在大家对遮挡关系不敏感的场合，比如场景等，不是不能用于人物，而是用Normal Map的人物不太经得起特写，放大了，角度刁钻了都容易穿帮。

虽然Normal Map有个不能平视的巨大问题，但是依然是好处远大于小障碍，因此还是非常值得推广的。后面的几种新兴算法其实都是由Normal Mapping发展起来的，因此做为基础的东西，也还是最有理解价值的。

P.S.关于Normal Map的一点秘籍。注意理解……Normal Map其实并不是从低模的表面凸出高模的细节的，而是把高模中比最高点的位置低的地方凹进去的！因此低模要比高模大一点点才会很准。大家可以想像成我们是用一个比高模稍微大一点点尺寸的低模石膏模型来把高模雕刻出来的。
P.S.2.关于Normal Map的做法，其实早期发明Normal Map的时候还没有MAX这种这么方便生成Normal Map的方法，Normal Map都是从Bump Map计算得到的，因此其实通过很简单的算法就可以从Bump Map算出Normal Map的，甚至可以On The Fly（就是让游戏引擎直接读BumpMap然后转换成NormalMap）。因此对于一些建起模来效率很低，但是又能明显增加表面细节的东西，例如水泥表面的颗粒，用画Bump的方式来做是个更好的主意，然后交给技术美工去搞定好了－－当然你会用Z－Bursh那就当我什么都没说了，呵呵。说来FXCarl估计MAX生成法线图的方式也是比较高低模上每个点的高度偏移，然后生成每个UV图素上的高度差来得到一个BumpMap，然后再从BumpMap变成NormalMap。

3.Parallax mapping 视差贴图

（因为后面的算法都是基于NormalMap的应用，可能看上去没有NormalMapping那么长了，但内容肯定一样精彩的！）

视差贴图是一种NormalMapping算法的增强算法，其本质上和NormalMapping没有区别。优势是只需要增加3个HLSL语句和一个控制纹理通道（只需要几个GPU指令，代价小到可以忽略）就可以显著的增加物体表面的深度感。但是NormalMap中出现的问题，Parallax mapping基本上都有－－特别是视角接近平行的时候，凹凸感消失的问题，并没有明显改善－－其实这个使用NormalMap带来的问题就像是液晶屏的可视角度问题一样令人挥之不去。或者按照FXCarl个人的说法－－Parallax mapping才是真正具有实用价值的NormalMapping。

目前实践证明，这种技术非常适合XBOX360和PS3这样的新世代游戏主机（都上市一年了还用次世代……我真受不了现在有些人）。例如360游戏SEGA死刑犯就是使用的和PC游戏FEAR一样的Monolith引擎－－使用Parallax mapping。

Parallax mapping使用的还是单张的控制纹理。一张NormalMap。如果我们用AcdSee来看这张NormalMap，我们会发觉似乎和NormalMapping用的控制纹理是一样的。而如果我们打开这张NormalMap的Alpha通道，就会发现其中的玄机所在。原来Alpha通道里存储的是对应这张NormalMap的BumpMap！（就是HeightMap，就是用饱和度记录表面高度）

现在插入一点理论课程。大家留心读上面的文字，会看见一个控制纹理的词汇。这个词汇是这里要重点解释的。因为理解控制纹理，在成为新世代美工的需求中是相当重要的。按照大家这么多年美术做下来的经验，对于图素(Texel,纹理上的一点)的理解肯定是RBG3个色彩带一个表示透明度的Alpha通道。但是在我们的渲染器和程序员的眼里，它可不是我们美术朋友们看见的东西。他们看见的是一个4通道的矢量（其实可以理解成四个数的组合）。这4个数字的取值范围分别是0到255。通过这个空间，其实可以用来做更多别的事情－－最常用的就是记录表面的物理细节。至于为什么要用控制纹理呢？FXCarl前两天听一个朋友有这么个说法：我觉得NormalMap的效果也没什么，直接画也画的出来的。其实这个说法一点都没错，但是要知道，这个想法是过时的。因为NormalMap并非用于著色，而是用于更真实的生成色彩。重所周知，用画的方式，做静帧固然可以做到无限好。可是动起来怎么办？如何才能保证在不同的光照关系下依然保证最终著色的结果正确？唯一的做法，就是每帧重画一遍。如何才能做到最有效的重画？那就要把重画的参考告诉我们的渲染器，让它来帮你做一些简单的工作，这就是控制纹理的作用－－把你想要实时改变的东西告诉渲染器。其实控制纹理的范围很大，除了NormalMap还有很多，比如说Nvidia的DEMO曾经用纹理存储物体表面在阳光下的色彩变化规律。把艺术家想要实时改变的东西压缩在纹理中告诉渲染器是一件相当有挑战性的工作，当然也会获得更令人赞叹的画面。请接受控制纹理，那是让艺术家把一个瞬间的精确著色变成一个普遍适用的著色的利器！

Parallax mapping是如何达到增加NormalMap的效果的呢。我们要从NormalMap的特性说起。我们假设在NormalMap表面制作一个凸起。然后我们转转角度看看。我们会发现，其实这个凸起的背对我们视线的面～并不会因为我们视角的逐渐放平而消失－－这显然是不正确的，要知道背后的东西应该是看不见的才对。因此Parallax mapping就是来缓解这个问题的，具体的代码这里不提。我来试着白话解释一下原理。其实为了不让我们看见“不该看的东西”应该试着挪动纹理坐标……把那个不该给玩家看见的图素（Texel）跳过去。也就是说根据高度图提供的数据，把那个位置较低那个纹理的后面的纹理向前拉。相当于在图素采样的时候刻意的把那个图素跳过去。这样那个不该被玩家看见的像素就会因为图素的消失而不见了－－很明显，这个算法是不太站得住脚的，虽然计算的时候会参考玩家视线的角度。但仍然是一种来自于经验的估算。值得欣慰的是，对于本身NormalMap所需要表现的微小细节来说，这样的改进已经看上去不错。因此开始有大量的游戏决定采用。特别是它的优点是所消耗的代价极为有限，而需要增加的工作量只是让美工把高度图保存到Alpha通道里而已。很划算。

但是对于技术研究者来说，这样的表现显然还是不够令人满意的。因此，顺着视差贴图的思路向下发展，借助ShaderModel3.0的出现。出现了一个真正从物理上改变物体表面的算法，这就是我们下一篇文章需要介绍的Displacement Mapping


 

4.Displacement mapping 位移贴图

和前面说的几种方式不同，DisplacementMapping是一种真正改变物体表面的方式。通过一种称为micropolygons（微多边形）tessellate（镶嵌）的技巧来实现真正的改变物体表面的细节。

具体流程是这样的。首先，根据屏幕的分辨率，在模型的可见面上镶嵌和最终象素尺寸相同的微多边形。这个过程叫做镶嵌。然后读取一张Bump贴图。根据表面的灰度确定高度。然后根据镶嵌所得到的多边形，沿着原先的表面法线方向移动微多边形。接着再为新的多边形确定好新的法线方向。此时，物体的表面确实已经真的增加出了细节。

其实这种技巧，我们在使用ZBrush的时候就可以看见了。大家用过Zbrush的时候会知道，在表面刷过的细节，只有在画面静止下来之后才会越来越清晰。而微多边形镶嵌起到的就是类似的作用。只增强面对屏幕的多边形的表面粗糙细节，而不是整个模型。因此性能代价并不会像直接上高模那么大。相比来说位移贴图在效果上是没有任何瑕疵的，但是也未必没有缺点。

首先就是，对硬件的要求很高，必须支持ShaderMode3.0才可以，因为只有支持SM3才可以在顶点阶段进行纹理操作。同时镶嵌对于性能的消耗也不小。不过其实就对于GPU的压力而言，反而似乎要更合理一些（因为对顶点的运算要求提高，对象素级别的运算要求反而没有影响）想必在将来的DX10统一渲染构架中会更有价值。

和我们介绍的所有凹凸贴图技术相比，位移贴图是唯一真正改变多边形表面几何形状的方法。相比之后将要介绍的切空间光线追踪算法，这种算法的性能消耗虽然并不占优，但其实要更为合理。给予画面更多特效的机会，同时更有趣的是，其实他和其他基于象素着色的凹凸贴图并没有什么冲突。其实这种位移贴图在新世代主机的游戏中大家都有可能见到。只是可能不是大家想得到的地方。

它可以用来实时生成大面积的户外地形！这是其他任何凹凸贴图方式所不能比拟的！


ReliefMapping 和 ParallaxOcclusionMapping 和 ConeMapping 浮雕纹理贴图和视差阻塞贴图和圆锥跟踪贴图

三种利用切空间光线追踪先进算法的技术，三种方法分别是光线跟踪，光束跟踪和圆锥跟踪算法。当然可以说后面的都是第一种的改进。这些都是面向未来的技术，很有前途。ReliefMapping甚至现在可以实现扣环这样的复杂几何表面，并且可以处理不能平视的问题！



http://blog.csdn.net/weiqubo/article/details/7043087
