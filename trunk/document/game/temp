#include <jni.h>
#include <stdio.h>
#include <GLES/gl.h>
#include <zipint.h>
#include <zip.h>
#include <ft2build.h>
#include <freetype/freetype.h>
#include <freetype/ftglyph.h>
#include <freetype/ftoutln.h>
#include <freetype/fttrigon.h>
#include <freetype/ftmodapi.h>
#include "log.h"
#include "math/rectangle.h"
#include "androidgl.h"
#include "util.h"
#include <wchar.h>


/***************************************/
/*           FreeType中文显示           */
/***************************************/

float cameraPosition[]={0,10,40};
static float cameraAngle=0;
static float cameraSin;
static float cameraCos;
static void rotateCamera()
{
	cameraAngle-=1;
	if(cameraAngle<=0)
		cameraAngle+=360;
	cameraSin=sinf(cameraAngle*M_PI/180.0);
	cameraCos=cosf(cameraAngle*M_PI/180.0);
	float _x= cameraCos - 40*cameraSin;
	float _z= cameraSin + 40*cameraCos;
	cameraPosition[0]=_x;
	cameraPosition[2]=_z;
}

static GLfloat axeVertexArray[][3] = {
	{0,0,0},
	{10,0,0},
	{0,0,0},
	{0,10,0},
	{0,0,0},
	{0,0,10}
};
static GLubyte axeColorArray[][3] = {
  255, 0, 0, 255,
  255, 0, 0, 255,
  0, 255, 0, 255,
  0, 255, 0, 255,
  0, 0, 255, 255,
  0, 0, 255, 255
};

#define CUBOID_LENGTH 8
#define CUBOID_WIDTH 8
#define CUBOID_HEIGHT 8

Rectangle* rectangle;
zip* APKArchive;
GLuint textures[1];
GLfloat* vertex;
short* texCoord;
const unsigned char vertexIndices[4]={0,1,2,3};
const static char* fontPath="assets/font/ygyxs2.ttf";
const unsigned char g_UnicodeString[]="aaa VB文件格式：";




static int  sWindowWidth  = 320;
static int  sWindowHeight = 480;
static float angle=0;


// 这个函数返回比a大的，并且是最接近a的2的次方的数
inline int next_p2 (int a ){
	int rval=1;	// rval<<=1 Is A Prettier Way Of Writing
	rval*=2;
	while(rval<a)
		rval<<=1;
	return rval;
}

//auxiliary function
void* alloc(FT_Memory p1, long p2){
    return malloc(p2);
}

//auxiliary function
void free_1(FT_Memory p1, void* p2){
    free(p2);
}

//auxiliary function
void* realloc_1(FT_Memory p1,long p2,long p3,void* p4){
    return realloc(p4, p3);
}

static unsigned short s_font_utf8_to_unicode (const unsigned char *utf8)
{
	unsigned short unicode;
	unicode = utf8[0];
	if (unicode >= 0xF0) {
		unicode  =  (unsigned short) (utf8[0] & 0x07) << 18;
		unicode |=  (unsigned short) (utf8[1] & 0x3F) << 12;
		unicode |=  (unsigned short) (utf8[2] & 0x3F) << 6;
		unicode |=  (unsigned short) (utf8[3] & 0x3F);
	} else if (unicode >= 0xE0) {
		unicode  =  (unsigned short) (utf8[0] & 0x0F) << 12;
		unicode |=  (unsigned short) (utf8[1] & 0x3F) << 6;
		unicode |=  (unsigned short) (utf8[2] & 0x3F);
	} else if (unicode >= 0xC0) {
		unicode  =  (unsigned short) (utf8[0] & 0x1F) << 6;
		unicode |=  (unsigned short) (utf8[1] & 0x3F);
	}
	return unicode;
}

int WinLatinToUnicode_[32] = {
	/*0x80*/    0x20AC, //EURO SIGN
	/*0x81*/       0x0, //UNDEFINED
	/*0x82*/    0x201A, //SINGLE LOW-9 QUOTATION MARK
	/*0x83*/    0x0192, //LATIN SMALL LETTER F WITH HOOK
	/*0x84*/    0x201E, //DOUBLE LOW-9 QUOTATION MARK
	/*0x85*/    0x2026, //HORIZONTAL ELLIPSIS
	/*0x86*/    0x2020, //DAGGER
	/*0x87*/    0x2021, //DOUBLE DAGGER
	/*0x88*/    0x02C6, //MODIFIER LETTER CIRCUMFLEX ACCENT
	/*0x89*/    0x2030, //PER MILLE SIGN
	/*0x8A*/    0x0160, //LATIN CAPITAL LETTER S WITH CARON
	/*0x8B*/    0x2039, //SINGLE LEFT-POINTING ANGLE QUOTATION MARK
	/*0x8C*/    0x0152, //LATIN CAPITAL LIGATURE OE
	/*0x8D*/       0x0, //UNDEFINED
	/*0x8E*/    0x017D, //LATIN CAPITAL LETTER Z WITH CARON
	/*0x8F*/       0x0, //UNDEFINED
	/*0x90*/       0x0, //UNDEFINED
	/*0x91*/    0x2018, //LEFT SINGLE QUOTATION MARK
	/*0x92*/    0x2019, //RIGHT SINGLE QUOTATION MARK
	/*0x93*/    0x201C, //LEFT DOUBLE QUOTATION MARK
	/*0x94*/    0x201D, //RIGHT DOUBLE QUOTATION MARK
	/*0x95*/    0x2022, //BULLET
	/*0x96*/    0x2013, //EN DASH
	/*0x97*/    0x2014, //EM DASH
	/*0x98*/    0x02DC, //SMALL TILDE
	/*0x99*/    0x2122, //TRADE MARK SIGN
	/*0x9A*/    0x0161, //LATIN SMALL LETTER S WITH CARON
	/*0x9B*/    0x203A, //SINGLE RIGHT-POINTING ANGLE QUOTATION MARK
	/*0x9C*/    0x0153, //LATIN SMALL LIGATURE OE
	/*0x9D*/       0x0, //UNDEFINED
	/*0x9E*/    0x017E, //LATIN SMALL LETTER Z WITH CARON
	/*0x9F*/    0x0178  //LATIN CAPITAL LETTER Y WITH DIAERESIS
};



inline static int winLatinToUnicode(int c)
{
     if (c>=0x80 && c<=0x9F) {
         return WinLatinToUnicode_[ c - 0x80 ];
     }
     return c;
}

struct xCharTexture
{
 GLuint  m_texID;
 wchar_t m_chaID;
 int     m_Width;
 int     m_Height;

    int     m_adv_x;
    int     m_adv_y;
    int     m_delta_x;
    int     m_delta_y;
public:
 xCharTexture()
 {
  m_texID  = 0;
  m_chaID  = 0;
  m_Width  = 0;
  m_Height = 0;
 }
}g_TexID[65536];

class xFreeTypeLib
{
 FT_Library m_FT2Lib;
 FT_Face    m_FT_Face;

public:
 int   m_w;
 int   m_h;
 //void load(const char* font_file , int _w , int _h);
 void load(zip_file* fontFile,int _w,int _h);
 GLuint loadChar(wchar_t ch);
};

wchar_t AnsiToUnicode(const unsigned char* lpcstr)   //参数lpcstr类型也可是char*
{
 /*wchar_t Pwstr;
 int  i;
 i=MultiByteToWideChar(CP_ACP,0,lpcstr,-1,NULL,0);
 Pwstr=new wchar_t[i];
 MultiByteToWideChar(CP_ACP,0,lpcstr,-1,Pwstr,i);

 return (Pwstr);*/
	return s_font_utf8_to_unicode(lpcstr);
}

void xFreeTypeLib::load(zip_file* fontFile , int _w , int _h)
{
	int error;
	unsigned long file_size=fontFile->bytes_left;
	LOGI("AndroidGL","file_size:%ld",file_size);
	FT_Byte* file_base=new FT_Byte[file_size];
	zip_fread(fontFile, file_base, file_size);
	LOGI("AndroidGL","zip_fread",NULL);
  FT_Library library;
  if (FT_Init_FreeType( &library) )
   exit(0);
  //加载一个字体,取默认的Face,一般为Regualer
  //if (FT_New_Face( library, font_file, 0, &m_FT_Face ))
  if(error=FT_New_Memory_Face(library,file_base,file_size,0,&m_FT_Face))
   {
	  LOGI("AndroidGL","FT_New_Memory_Face ERROR:%d",error);
	  return;
   }
  FT_Select_Charmap(m_FT_Face, FT_ENCODING_UNICODE);
  m_w = _w ; m_h = _h;
  m_FT_Face->num_fixed_sizes;
  //大小要乘64.这是规定。照做就可以了。
  //FT_Set_Char_Size( m_FT_Face , 0 , m_w << 6, 96, 96);
  FT_Set_Pixel_Sizes(m_FT_Face,m_w, m_h);
 }

GLuint xFreeTypeLib::loadChar(wchar_t ch)
{
 if(g_TexID[ch].m_texID)
  return g_TexID[ch].m_texID;

 if(FT_Load_Char(m_FT_Face, ch, /*FT_LOAD_RENDER|*/FT_LOAD_FORCE_AUTOHINT|
  (true ? FT_LOAD_TARGET_NORMAL : FT_LOAD_MONOCHROME | FT_LOAD_TARGET_MONO) )   )
 {
  return 0;
 }

 /*if(FT_Load_Glyph( m_FT_Face, FT_Get_Char_Index( m_FT_Face, ch ), FT_LOAD_FORCE_AUTOHINT ))
  throw std::runtime_error("FT_Load_Glyph failed");*/

    xCharTexture& charTex = g_TexID[ch];

 //得到字模
 FT_Glyph glyph;
 if(FT_Get_Glyph( m_FT_Face->glyph, &glyph ))
  return 0;

 //转化成位图
 FT_Render_Glyph( m_FT_Face->glyph,   FT_RENDER_MODE_LCD );//FT_RENDER_MODE_NORMAL  );
 FT_Glyph_To_Bitmap( &glyph, ft_render_mode_normal, 0, 1 );
 FT_BitmapGlyph bitmap_glyph = (FT_BitmapGlyph)glyph;

 //取道位图数据
 FT_Bitmap& bitmap=bitmap_glyph->bitmap;

 //把位图数据拷贝自己定义的数据区里.这样旧可以画到需要的东西上面了。
 int width  =  bitmap.width;
 int height =  bitmap.rows;

 m_FT_Face->size->metrics.y_ppem;
 m_FT_Face->glyph->metrics.horiAdvance;

 width = next_p2( bitmap.width );
  height = next_p2( bitmap.rows );
 charTex.m_Width = width;
 charTex.m_Height = height;
 charTex.m_adv_x = m_FT_Face->glyph->advance.x / 64.0f;
 charTex.m_adv_y = m_FT_Face->size->metrics.y_ppem; //m_FT_Face->glyph->metrics.horiBearingY / 64.0f;
 charTex.m_delta_x = (float)bitmap_glyph->left;
 charTex.m_delta_y = (float)bitmap_glyph->top - height;
 glGenTextures(1,&charTex.m_texID);
    glBindTexture(GL_TEXTURE_2D,charTex.m_texID);
 /*char* pBuf = new char[width * height * 4];
 for(int j=0; j  < height ; j++)
 {
  for(int i=0; i < width; i++)
  {
   unsigned char _vl =  (i>=bitmap.width || j>=bitmap.rows) ? 0 : bitmap.buffer[i + bitmap.width*j];
   pBuf[(4*i + (height - j - 1) * width * 4)  ] = 0xFF;
   pBuf[(4*i + (height - j - 1) * width * 4)+1] = 0xFF;
   pBuf[(4*i + (height - j - 1) * width * 4)+2] = 0xFF;
   pBuf[(4*i + (height - j - 1) * width * 4)+3] = _vl;
  }
 }
 glTexImage2D( GL_TEXTURE_2D,0,GL_RGBA,width, height,0,GL_RGBA,GL_UNSIGNED_BYTE,pBuf);
 */
char* pBuf = new char[width * height];
 for(int j=0; j  < height ; j++)
 {
  for(int i=0; i < width; i++)
  {
   unsigned char _vl =  (i>=bitmap.width || j>=bitmap.rows) ? 0 : bitmap.buffer[i + bitmap.width*j];
   pBuf[i + (height - j - 1) * width] = _vl;
  }
 }
 glTexImage2D( GL_TEXTURE_2D,0,GL_LUMINANCE,width, height,0,GL_LUMINANCE,GL_UNSIGNED_BYTE,pBuf);

 glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
 glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);
 glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
 glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
 glTexEnvi(GL_TEXTURE_2D,GL_TEXTURE_ENV_MODE,GL_REPLACE);

 /*gluBuild2DMipmaps(GL_TEXTURE_2D, GL_RGBA, width, height, GL_RGBA, GL_UNSIGNED_BYTE, pBuf);
 glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_S, GL_CLAMP);
 glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_WRAP_T, GL_CLAMP);
 glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
 glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
 glTexEnvi(GL_TEXTURE_2D,GL_TEXTURE_ENV_MODE,GL_REPLACE);*/
 delete[] pBuf;
 return charTex.m_chaID;
}

xFreeTypeLib g_FreeTypeLib;
float ratio;

xCharTexture* getTextChar(wchar_t ch)
{
  g_FreeTypeLib.loadChar(ch);
  return &g_TexID[ch];
}

void drawText(wchar_t* _strText,int x , int y, int maxW , int h)
{
 int sx = x;
 int sy = y;
 int maxH = h;
 size_t nLen = wcslen(_strText);

 for(int i = 0 ; i <nLen ; i ++)
 {
  if(_strText[i] =='\n')
  {
   sx = x ; sy += maxH + 12;
   continue;
  }
  xCharTexture* pCharTex = getTextChar(_strText[i]);
  glBindTexture(GL_TEXTURE_2D,pCharTex->m_texID);
  glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST );
  glTexParameteri ( GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST );
  glEnable(GL_BLEND);
  glBlendFunc(GL_SRC_ALPHA,GL_ONE_MINUS_SRC_ALPHA);
  //glDisable(GL_TEXTURE_2D);
  int w = pCharTex->m_Width;
  int h = pCharTex->m_Height;

  int ch_x = sx + pCharTex->m_delta_x;
  int ch_y = sy - h - pCharTex->m_delta_y;

  if(maxH < h) maxH = h;
  /*glBegin ( GL_QUADS );
  {
   glTexCoord2f(0.0f, 1.0f); glVertex3f(ch_x      , ch_y    ,  1.0f);
   glTexCoord2f(1.0f, 1.0f); glVertex3f(ch_x +  w, ch_y    ,  1.0f);
   glTexCoord2f(1.0f, 0.0f); glVertex3f(ch_x +  w, ch_y + h,  1.0f);
   glTexCoord2f(0.0f, 0.0f); glVertex3f(ch_x     , ch_y + h,  1.0f);
  }
  glEnd();*/
    //glEnable(GL_TEXTURE_2D);
  	glEnableClientState(GL_VERTEX_ARRAY);
  	glEnableClientState(GL_TEXTURE_COORD_ARRAY);

  	vertex[0]=ch_x;
  	vertex[1]=ch_y;
  	vertex[2]=ch_x +  w;
  	vertex[3]=ch_y;
  	vertex[4]=ch_x;
  	vertex[5]=ch_y + h;
  	vertex[6]=ch_x +  w;
  	vertex[7]=ch_y + h;


  	glVertexPointer(2,GL_FLOAT,0,vertex);
  	glTexCoordPointer(2, GL_SHORT, 0, texCoord);
  	glBindTexture(GL_TEXTURE_2D,pCharTex->m_texID);
  	glDrawElements(GL_TRIANGLE_STRIP,4,GL_UNSIGNED_BYTE,vertexIndices);

  	glDisableClientState(GL_VERTEX_ARRAY);
  	glDisableClientState(GL_TEXTURE_COORD_ARRAY);
  	//glDisable(GL_TEXTURE_2D);
  sx += pCharTex->m_adv_x;
  if(sx > x + maxW)
  {
   sx = x ; sy += maxH + 12;
  }
 }
}

void appInit(JNIEnv*  env, jobject thiz, jstring apkPath)
{
	LOGI("AndroidGL","apkPath:s%",apkPath);
	glClearColorx((GLfixed)(0.1f * 65536),(GLfixed)(0.2f * 65536),(GLfixed)(0.3f * 65536), 0x10000);

	//创建长方形
	rectangle=new Rectangle(20,10);

	const char* str;
	jboolean isCopy;
	str = env->GetStringUTFChars(apkPath, &isCopy);
	LOGI("AndroidGL","str:s%",*str);
	APKArchive=loadAPK(str);

	int width,height,colorType;
	//glGenTextures(sizeof(textures)/sizeof(textures[0]), textures);


	zip_file* fontFile=zip_fopen(APKArchive, fontPath, 0);
	if(!fontFile)
	{
		LOGE("AndroidGL","Error opening %s from APK",fontPath);
		return;
	}

	vertex=new GLfloat[8];
	texCoord=new short[8];
	texCoord[0]=0;
	texCoord[1]=1;
	texCoord[2]=1;
	texCoord[3]=1;
	texCoord[4]=0;
	texCoord[5]=0;
	texCoord[6]=1;
	texCoord[7]=0;


	g_FreeTypeLib.load(fontFile,12,12);

	zip_fclose(fontFile);



	unsigned char ch='Q';

//	// 释放分配的内存
//	delete[] data;
//
//	// 释放face类
//	FT_Done_Face(face);
//
//	// 释放FreeType库
//	FT_Done_FreeType(library);



	LOGI("AndroidGL","Init",NULL);
}

void appResize(int width,int height)
{
	/*视口变换*/
	glViewport(0, 0, width, height);
	/*投影变换*/
	glMatrixMode(GL_PROJECTION);
	glLoadIdentity();
	//gluPerspective(60.0,(float)width/(float)height,0.1f,200);
	glOrthof(-16,16,-21,21,100,-100);
	/*模型矩阵*/
	glMatrixMode(GL_MODELVIEW);
	/*启用剔除功能*/
	glEnable(GL_CULL_FACE);
	glFrontFace(GL_CCW);

	LOGI("AndroidGL","Resize",NULL);
}

void appRender(long tick, int width, int height)
{

	glClear(GL_DEPTH_BUFFER_BIT | GL_COLOR_BUFFER_BIT);
	glLoadIdentity();
	gluLookAt(cameraPosition[0],cameraPosition[1],cameraPosition[2],0,0,0,0,1,0);

	glEnable ( GL_TEXTURE_2D );
	wchar_t wstr = AnsiToUnicode(g_UnicodeString);
	drawText(&wstr, 0, 0, 320,400);
	glDisable(GL_TEXTURE_2D);
//	angle+=1.5f;
	//rotateCamera();
}


/* Call to initialize the graphics state */
void
Java_org_tinder_studio_gl_AndroidGLView_nativeInit( JNIEnv*  env, jobject thiz, jstring apkPath )
{
    appInit(env,thiz,apkPath);
}


/* Call to finalize the graphics state */
void
Java_org_tinder_studio_gl_AndroidGLView_nativeDone( JNIEnv*  env, jobject thiz )
{
}

/* Call to render the next GL frame */
void
Java_org_tinder_studio_gl_AndroidGLView_nativeRender( JNIEnv*  env, jobject thiz )
{
    appRender(0, sWindowWidth, sWindowHeight);
}

void
Java_org_tinder_studio_gl_AndroidGLView_nativeResize( JNIEnv*  env, jobject  thiz, jint w, jint h )
{
    sWindowWidth  = w;
    sWindowHeight = h;
    appResize(w,h);
    LOGI("AndroidGL","resize w=%d h=%d", w, h);
}
void
Java_org_tinder_studio_gl_AndroidGLView_nativePause(JNIEnv *env, jobject thiz)
{
	LOGI("AndroidGL","Pause",0);
}

static JNINativeMethod methods[] = {

  {"nativeInit", "()", (void*)Java_org_tinder_studio_gl_AndroidGLView_nativeInit },
  {"nativeDone", "()", (void*)Java_org_tinder_studio_gl_AndroidGLView_nativeDone },
  {"nativeRender", "()", (void*)Java_org_tinder_studio_gl_AndroidGLView_nativeRender },
  {"nativeResize", "()", (void*)Java_org_tinder_studio_gl_AndroidGLView_nativeResize }

};

static const char *classPathName = "org/tinder/studio/gl/AndroidGLView";

/*
 * Register native methods for all classes we know about.
 *
 * returns JNI_TRUE on success.
 */
static int registerNatives(JNIEnv* env)
{
  if (!registerNativeMethods(env, classPathName,
                 methods, sizeof(methods) / sizeof(methods[0]))) {
    return JNI_FALSE;
  }
  return JNI_TRUE;
}

