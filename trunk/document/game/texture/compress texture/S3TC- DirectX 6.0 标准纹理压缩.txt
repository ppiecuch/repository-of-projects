简介：

    纹理贴图是贴在3D对象上的位图，它可以在不增加3D场景中几何体复杂性的前提下得到逼真的表面细节。纹理贴图可以从木纹、大理石一直到复杂图形如人物、建筑、树木等等。为了模拟现实生活中的场景，必须利用大量详细的纹理贴图来实现。这些纹理贴图会占用大量系统或显示存储器（基于纹理贴图存放的位置），从而强迫软件开发者使用较少的纹理贴图以适应现有的存储器容量和带宽。

    AGP（Accelerated Graphics Port 图形加速端口）允许程序直接在系统存储器中操作纹理贴图，加大了整体可用的存储器容量。但是，AGP和系统存储器都是被共享使用的资源，除了纹理贴图，AGP还要用来传送几何体数据，系统内存则被操作系统和应用程序使用。所以不能认为所有系统存储器及带宽都可以用来读取纹理贴图。而且在为AGP纹理贴图优化过的图形子系统中，存储器带宽将十分紧张。

    S3TC纹理压缩技术对解决这两个问题很有帮助。它可以在同样的空间下存储更多、更大、更详细的纹理贴图，同时减少了读取它们所需的带宽。

图1：纹理贴图（左）与屏幕上的3D物体（右）对应关系

 

    纹理压缩的明显优势就是可以把纹理贴图存储在更少的存储器中，当纹理贴图容量超出帧缓冲区时这一点尤其重要。同样重要的事实是读取纹理贴图所需的带宽大大减少，从而带来AGP总线上性能的增强。系统内存和AGP带宽都是紧张的资源，压缩后，图形加速器可以得到更多的可利用资源。


纹理压缩的优势：

减少存储器容量/带宽的需求 = 增加性能和纹理品质

更大和更多的纹理贴图

MIP-Maps



S3TC总览

    S3TC是为纹理贴图开发的纹理压缩算法。纹理被压缩到每单元4点（不透明纹理或简单透明纹理）或每单元8点（复杂透明纹理），压缩后的纹理品质保持良好。

S3TC简要描述

    S3TC把纹理按4x4个单元大小划分为块。对于不透明纹理贴图，每个单元代表位图中的2个点，总共32bits。除了这些单元之外，每个块还存有两个标准RGB565格式表示的16位颜色。这两个颜色值，加上使用标准插入算法在其中插入两个新的颜色值，构成了四色查找表。四色查找表决定了块中每个单元实际的颜色值。总共，每个块被编码为64个bit，平均每个单元4bits。简单透明纹理（单色透明）保留四色查找表中的第四个颜色来表示该单元透明，第三个颜色是给出的两个颜色的平均值。区分不透明纹理和简单透明纹理的方法是看给出两个颜色的存放次序。

    图3中显示了原始块、查找表和压缩结果。块中每一个单元的两个bits代表四色查找表中的一个颜色。可以看出，这个颜色与原始颜色最为接近。

    S3TC也可以压缩更复杂的透明纹理贴图，每块需使用总计128bits来表示。这个算法与上述算法的区别这里不再详述。（可参考微软DirectX 6.0文档）

图3：S3TC编码示意图



简单的解码器

    对用S3TC压缩的块解码是非常容易的。每个单元有自己的2bits索引，使用这个索引在四色查找表中找到对应该单元的颜色。解码器所需的逻辑电路非常少，并且可以使用并行解码器以获得更高的速度。实现方案之简单决定了它可以在图形硬件工业中得到普及。

图像品质和其他算法比较

    虽然压缩算法多种多样，大多数使用廉价解码器的简单算法或者效果不佳，或者压缩率不高，或者两者兼备。基于VQ（矢量量子化）的压缩技术图形质量不良，而且因为这种算法基于电码本，解码一个单元需要操作内存两次，第一次读取块中的单元内容，第二次根据单元内容读取电码本。理论上将电码本存储于芯片上可以节省一次内存操作，但是这将大大增加成本，并且装载这些电码本也将花费一定时间。基于这些原因，VQ算法比S3TC慢，何况其图形品质也不够理想。

    色调化技术是另一种形态的矢量量子化算法。当纹理贴图使用大量各种颜色时这种算法效果不佳，所以色调化算法限于整图颜色数为256色或更少，而S3TC并不限制整图颜色数多少。色调化技术解压缩时也需要一个新的映射调色板（即电码本）。

    另一种标准的压缩技术如JPEG压缩效果优于S3TC，但算法代价昂贵。不仅需要大量的逻辑电路来实现算法，而且解码器会造成大的数据延迟，也就意味着必须有庞大的缓冲区来补偿这些延迟数据，进一步增加了逻辑电路数量和解码器复杂性。同时，离散余弦变换算法会造成少量噪音（如块状噪音），这种噪音很难用如三线性滤波器的标准滤波器来消除。S3TC所压缩的纹理贴图在这方面表现较好，某些色阶过渡平滑的纹理贴图压缩后效果甚至好于标准的16bit RGB565格式。

DirectX 标准

    S3TC是用于DirectX 6.0的标准纹理压缩算法。微软公司已经从S3公司取得S3TC的授权并将其加入DirectX 6.0，提供给ISV（独立软件开发商）和IHV（独立硬件开发商）使用。软件开发者可以把这种压缩算法作为通用标准来使用，因为遵从微软的标准已是既成事实，而且这种算法很容易被整合在图形硬件中，所以这种算法普及指日可待。即使用户的图形硬件不能支持S3TC，DirectX API会自动解码压缩后的纹理贴图。压缩纹理贴图可以使用高品质的离线压缩器，不会造成加载程序时任何延时。压缩后的纹理贴图也会减少软件容量，给软件发布带来一些方便。

　

相对纹理贴图数量

    为了显示S3TC对3D应用程序提高品质的帮助，下表显示了在有限的存储空间内纹理贴图的存放情况。其中数据已经包含了Mip-Maps，色调化方式为24bits-8bits。

　

纹理贴图大小
 未压缩
 色调化
 S3TC
 
64x64
 512
 1536
 3072
 
256x256
 32
 96
 192
 
1024x1024
 2
 6
 12
 

　

    换种说法，如果有8M图形存储器，在800x600x16图形模式下使用双缓冲的16bit Z-Buffer，还剩5.25M存储器给纹理贴图使用。使用S3TC后，这5.25M会变得相当于31.5M纹理贴图的存储空间。或者，你可以使用第三缓冲区，还剩26M的纹理贴图存储空间。或者把所有现有纹理贴图扩大四倍，转换为Mip-Maps格式，这样还能存储3.5M的纹理贴图。

    利用S3TC压缩纹理贴图，应用程序可以使用更多的纹理，使用更高的分辨率，增加程序的性能，使用第三缓冲区和Mip-Maps纹理贴图，或者兼顾以上。这将大大增加计算机中3D场景的真实性。

结论

    S3TC节约了存储器空间，减低了系统带宽需求。S3TC提供的压缩方案用简单的解码器实现了高质量的图形，并易于用硬件实现。以下是优点总览：

被微软的DirectX 6.0采用，容易为软件开发者采用。 
减少存储器使用，从而可以使用更多更大的纹理贴图。 
减少纹理贴图使用的系统带宽，增加系统整体性能。 
平均压缩比6:1 
基于块结构，压缩率固定，易于用硬件实现。 
硬件解码简单且高速。 
品质优于色调化技术，JPEG，媲美未压缩的RGB565图形。 
直接编码简单透明纹理，不需要额外负担。 
支持复杂透明纹理和平滑Alpha位图。 
有易用的、高品质的离线压缩程序。 
    通过纹理压缩节约下的存储器可以用来使用比普通纹理贴图占用更多空间（30%）的MIP-Maps纹理贴图。MIP-Maps可以减少不同距离下的纹理映射问题。没有MIP-Maps，远处物体的一个点也许都将对应纹理贴图上的几个单元。低通滤波器可以处理这些信息，但不能防止噪音点（亮点，突发点）的出现；而实时滤波器则代价高昂。所以使用MIP-Maps来预处理过滤前的图形，可以大大减少滤波器的复杂性。图2显示了简单的四级MIP-Maps模式，每级的大小是前级的1/4。除最下层的普通纹理贴图外，MIP-Maps纹理贴图还需保存上三层信息以处理远处物体，因此其容量比普通纹理贴图要大。

    使用MIP-Maps纹理贴图也可以增加性能。MIP-Maps保持顺序读取内存，并造成较长的猝发流。否则，当物体向远处移动时，像素的跳跃式采样造成存储器操作更加随机，增加快取命中失败的可能。更多的关于MIP-Maps纹理贴图的信息，可以参考关于三线性过滤的白皮书。

图2：四级MIP-Maps纹理贴图示意图。

    纹理压缩技术可以使用更大的纹理贴图。当纹理较小时，物体的表面会显得模糊或呈马赛克状，较大的纹理可以让物体表面表现出更多细节。纹理压缩也可以让更多的纹理贴图同时使用，使场景更加丰富多彩。当纹理的容量超出本地帧缓冲区时，压缩省下的空间可以用来增加显示分辨率或用作第三缓冲区。更高分辨率的显示可以使图像看起来更加平滑和细致，第三缓冲区可以大幅度提高性能，因为渲染引擎可以更早开始处理数据而不必等待下一次显示卡的垂直回扫周期。典型情况下第三缓冲区可以提高性能30%左右。

http://blog.csdn.net/guo_wangwei/article/details/638333