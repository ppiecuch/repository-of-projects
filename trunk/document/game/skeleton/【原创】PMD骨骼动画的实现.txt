捣鼓了整整俩天，终于把骨骼变换实现出来了……只可惜明天就丫的期末考了，求春哥保佑啊……

好了，废话不说，下面写一下经验和教训吧。

关于骨骼动画是什么，相关的资料网上很多，不过关于其中的具体实现多半是基于D3D的SkinnedMesh，而且对于关键的骨骼变换以及顶点混合都没有过多的涉及（太简单了？）。

唯一几篇值得看的有：

《骨骼运动变换的数学计算过程详解》

http://thatax.blog.163.com/blog/static/20892680200872945049507/

《骨骼动画 一、二、三》

http://dev.gameres.com/Program/Visual/3D/BoneAni1.htm

http://dev.gameres.com/Program/Visual/3D/BoneAni2.htm

http://dev.gameres.com/Program/Visual/3D/BoneAni3.htm

 

由于我所用的模型是MMD的PMD模型，因此D3D的SkinnedMesh对我没有太多的启发。那么首先我介绍一下PMD格式中蒙皮的定义。

PMD每一个文件都是一个模型，其中的每个顶点受到两个骨骼影响，所有的骨骼（包括IK节点）组织成了一个庞大的网络（鉴于其最大骨骼数目理论上可以达到32768(signed short)根，因此可能无法使用固定渲染管线进行渲染，所以我直接用代码来计算顶点）

每根骨骼包含了父节点、子节点、IK影响节点、名字以及骨骼坐标（具体定义参加本空间中《MikuMikuDance PMD模型格式结构》一文）

原本以为骨骼构成了单链，并且只有一个根骨骼（父节点标号为-1），但是实际编写过程中却发现其模型中一根骨骼会被多个骨骼引用，而且不止一个根骨骼……于是我只好在读取的时候将骨骼构造成了一个树（链表描述），倒是和D3D中的Frame结构很相似。

    struct _PMDBoneNode
    {
        unsigned int index;        // PMD中原始的骨骼编号

        CMatrix4 mat;    // 存放当前的变换矩阵
        CMatrix4 final;    // 存放当前的最终变换矩阵

        struct _PMDBoneNode* parent;    // 指向父亲节点
        struct _PMDBoneNode* sibling;    // 指向兄弟节点
        struct _PMDBoneNode* son;        // 指向子代节点
    };

然后在Update中对整个骨骼树进行遍历（使用深度优先搜索，既减少内存占用，又保证了每个骨骼的父骨骼都已经被计算完毕）

PS：在遍历的时候由于算法写错了，导致了整整两天都没想出为什么……

遍历的同时对骨骼进行矩阵的运算，等骨骼运算完毕了，再遍历顶点表，计算顶点混合。

下面，我简单说一下核心的两个部分：矩阵的计算和顶点混合。

一、顶点混合

顶点混合主要是为了防止骨骼运动时导致的蒙皮撕裂，基本思想用的是一个顶点受到多个骨骼的影响，再用权重分配这种影响。

公式很简单：V‘（变换后顶点） = V（变换前） * （M1（影响的骨骼1的矩阵） * W1（权重） + M2（影响的骨骼1的矩阵） * W2（权重）……）

其实也等效于：V' = V*M1*W1 + V*M2*W2 + ……

唯一要注意的是，对于顶点的位置要用TransformCoord，而顶点的法向量要用TransformNormal

二、骨骼矩阵的运算

这里稍微复杂了一点，建议先看会儿《骨骼运动变换的数学计算过程详解》

下面这张图很好的描述了算法：



但是要注意区分矩阵相乘的顺序（此处为世界坐标系而不是局部坐标系）

遍历完成后矩阵的计算就完成了。

http://hi.baidu.com/%C4%A6%F4%C9%D1%DB%C0%E1/blog/item/87644093191cfc7454fb960e.html