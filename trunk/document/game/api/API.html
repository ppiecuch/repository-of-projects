<!DOCTYPE HTML>
<html>
	<head>
		<title>API</title>
		<link type="text/css"  href="resources/css.css" rel="stylesheet" media="all" />
		<script type="text/javascript" src="resources/shCore.js"></script>
		<script type="text/javascript" src="resources/shBrushGL.js"></script>
		<link type="text/css" rel="stylesheet" href="resources/shCoreMidnight.css"/>
		<script type="text/javascript">SyntaxHighlighter.all();</script>
		<style type="text/css">
			#report div.arrow {
				background: transparent url(resources/arrows.png) no-repeat scroll 0px -16px;
				width: 16px;
				height: 16px;
				display: block;
			}
			#report div.up {
				background-position: 0px 0px;
			}
		</style>
		<script src="resources/jquery-1.4.2.min.js" type="text/javascript"></script>
		<script type="text/javascript">
			$(document).ready(function() {
				$("#report tr:odd").addClass("odd");
				$("#report tr:even td").addClass("alt");
				$("#report tr:not(.odd)").hide();
				$("#report tr:first-child").show();
				
				$("#report tr th:first-child").addClass("first");
				$("#report tr td:first-child").addClass("first");

				$("#report tr.odd").click(function() {
					$(this).next("tr").toggle();
					$(this).find(".arrow").toggleClass("up");
				});
			});

		</script>
	</head>
	<body>
		<table id="report" cellspacing="0" class="groovy_table" width="90%">
			<thead>
				<tr>
				<th>函数</th>
				<th>ES1</th>
				<th>ES2</th>
				<th>GL</th>
				<th>&nbsp;</th>
			</tr>
			</thead>
			<tbody>
			<tr>
				<td>void glActiveTexture(GLenum texture)</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
select server-side active texture unit
glActiveTexture selects which texture unit subsequent texture state calls will affect. 
The number of texture units an implementation supports is implementation dependent, it must be at least 2.
【参数】
texture
Specifies which texture unit to make active. 
The number of texture units is implementation dependent, but must be at least two. 
texture must be one of GL_TEXTUREi, where 0 <= i < GL_MAX_TEXTURE_UNITS , which is an implementation-dependent value. 
The intial value is GL_TEXTURE0.
【返回值】
【备注】
</pre>
<pre>
参考文档：
http://www.khronos.org/opengles/sdk/1.1/docs/man/
</pre>
				</td>
			</tr>
			<tr>
				<td>void glAlphaFunc(GLenum func,GLclampf ref)<br>
				void glAlphaFuncx(	GLenum func,GLclampx ref)
				</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
The alpha test discards fragments depending on the outcome of a comparison between an incoming fragment's alpha value and a constant reference value. 
glAlphaFunc specifies the reference value and the comparison function. The comparison is performed only if alpha testing is enabled. 
To enable and disable alpha testing, call glEnable and glDisable with argument GL_ALPHA_TEST. Alpha testing is initially disabled. 
When disabled, it is as if the comparison always passes.

func and ref specify the conditions under which the pixel is drawn. The incoming alpha value is compared to ref using the function specified by func. 
If the value passes the comparison, the incoming fragment is drawn if it also passes subsequent stencil and depth buffer tests. 
If the value fails the comparison, no change is made to the frame buffer at that pixel location. The comparison functions are as follows:

GL_NEVER
Never passes.

GL_LESS
Passes if the incoming alpha value is less than the reference value.

GL_EQUAL
Passes if the incoming alpha value is equal to the reference value.

GL_LEQUAL
Passes if the incoming alpha value is less than or equal to the reference value.

GL_GREATER
Passes if the incoming alpha value is greater than the reference value.

GL_NOTEQUAL
Passes if the incoming alpha value is not equal to the reference value.

GL_GEQUAL
Passes if the incoming alpha value is greater than or equal to the reference value.

GL_ALWAYS
Always passes (initial value).

glAlphaFunc operates on all pixel write operations, including those resulting from the scan conversion of points, lines, and polygons. 
glAlphaFunc does not affect glClear.
【参数】
func
Specifies the alpha comparison function. Symbolic constants GL_NEVER, GL_LESS, GL_EQUAL, GL_LEQUAL, GL_GREATER, GL_NOTEQUAL, GL_GEQUAL, 
and GL_ALWAYS are accepted. The initial value is GL_ALWAYS.

ref
Specifies the reference value that incoming alpha values are compared to. This value is clamped to the range [0, 1], where 0 represents the 
lowest possible alpha value and 1 the highest possible value. The initial reference value is 0.
【返回值】
【备注】
</pre>
<pre>
参考文档：
http://www.khronos.org/opengles/sdk/1.1/docs/man/
</pre>
				</td>
			</tr>
			<tr>
				<td>void glAttachShader( GLuint program, GLuint shader)</td>
				<td>支持</td>
				<td>不支持</td>
				<td>支持</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
In order to create an executable, there must be a way to specify the list of things that will be linked together. 
Program objects provide this mechanism. Shaders that are to be linked together in a program object must first be attached to that program object. 
glAttachShader attaches the shader object specified by shader to the program object specified by program. 
This indicates that shader will be included in link operations that will be performed on program.

All operations that can be performed on a shader object are valid whether or not the shader object is attached to a program object. 
It is permissible to attach a shader object to a program object before source code has been loaded into the shader object or before the shader object has been compiled. 
Multiple shader objects of the same type may not be attached to a single program object. 
However, a single shader object may be attached to more than one program object. 
If a shader object is deleted while it is attached to a program object, it will be flagged for deletion, 
and deletion will not occur until glDetachShader is called to detach it from all program objects to which it is attached.


【参数】
program 
Specifies the program object to which a shader object will be attached.

shader 
Specifies the shader object that is to be attached.

【返回值】
【备注】
</pre>
<pre>
参考文档：

</pre>
				</td>
			</tr>
			<tr>
				<td>void glBindBuffer(GLenum target,GLuint buffer)</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
glBindBuffer lets you create or use a named buffer object. 
Calling glBindBuffer with target set to GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER and buffer set to the name of the new buffer object binds the buffer object name to the target. 
When a buffer object is bound to a target, the previous binding for that target is automatically broken.

Buffer object names are unsigned integers. The value zero is reserved, but there is no default buffer object for each buffer object target. 
Instead, buffer set to zero effectively unbinds any buffer object previously bound, and restores client memory usage for that buffer object target. 
Buffer object names and the corresponding buffer object contents are local to the shared buffer-object space (see eglCreateContext) of the current GL rendering context.

You may use glGenBuffers to generate a set of new buffer object names.

The state of a buffer object immediately after it is first bound is an unmapped zero-sized memory buffer with GL_READ_WRITE access and GL_STATIC_DRAW usage.

While a non-zero buffer object name is bound, GL operations on the target to which it is bound affect the bound buffer object, and queries of the target to 
which it is bound return state from the bound buffer object. While buffer object name zero is bound, as in the initial state, attempts to modify or query 
state on the target to which it is bound generates an GL_INVALID_OPERATION error.

When vertex array pointer state is changed, for example by a call to glNormalPointer, the current buffer object binding (GL_ARRAY_BUFFER_BINDING) is copied 
into the corresponding client state for the vertex array type being changed, for example GL_NORMAL_ARRAY_BUFFER_BINDING. 
While a non-zero buffer object is bound to the GL_ARRAY_BUFFER target, the vertex array pointer parameter that is traditionally interpreted as a pointer to 
client-side memory is instead interpreted as an offset within the buffer object measured in basic machine units.

While a non-zero buffer object is bound to the GL_ELEMENT_ARRAY_BUFFER target, the indices parameter of glDrawElements that is traditionally interpreted as 
a pointer to client-side memory is instead interpreted as an offset within the buffer object measured in basic machine units.

A buffer object binding created with glBindBuffer remains active until a different buffer object name is bound to the same target, or until the bound buffer 
object is deleted with glDeleteBuffers.

Once created, a named buffer object may be re-bound to any target as often as needed. However, the GL implementation may make choices about how to optimize 
the storage of a buffer object based on its initial binding target.
【参数】
target
Specifies the target to which the buffer is bound. The symbolic constant must be GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.

buffer
Specifies the name of a buffer object.
【返回值】
【备注】
</pre>
<pre>
参考文档：
http://www.khronos.org/opengles/sdk/1.1/docs/man/
</pre>
				</td>
			</tr>
			<tr>
				<td>void glBlendFunc(GLenum sfactor,GLenum dfactor);</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
【参数】
sfactor
Specifies how the red, green, blue, and alpha source blending factors are computed. The following symbolic constants are accepted: 
GL_ZERO, GL_ONE, GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, and GL_SRC_ALPHA_SATURATE. 
The initial value is GL_ONE.

dfactor
Specifies how the red, green, blue, and alpha destination blending factors are computed. Eight symbolic constants are accepted: 
GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, and GL_ONE_MINUS_DST_ALPHA. 
The initial value is GL_ZERO.
【返回值】
【备注】
</pre>
<pre>
参考文档：

</pre>
				</td>
			</tr>
			<tr>
				<td>void glBlendFuncSeparate( GLenum srcRGB,  GLenum dstRGB,  GLenum srcAlpha,  GLenum dstAlpha)</td>
				<td>不支持</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
Pixels can be drawn using a function that blends the incoming (source) RGBA values with the RGBA values that are already in the frame buffer (the destination values). 
Blending is initially disabled. Use glEnable and glDisable with argument GL_BLEND to enable and disable blending. 

glBlendFuncSeparate defines the operation of blending when it is enabled. 
srcRGB specifies which method is used to scale the source RGB-color components. 
dstRGB specifies which method is used to scale the destination RGB-color components. 
Likewise, srcAlpha specifies which method is used to scale the source alpha color component, and dstAlpha specifies which method is used to scale the destination alpha component. 
The possible methods are described in the following table. Each method defines four scale factors, one each for red, green, blue, and alpha. 

In the table and in subsequent equations, source and destination color components are referred to as (Rs,Gs,Bs,As) and (Rd,Gd,Bd,Ad). 
The color specified by glBlendColor is referred to as (Rc,Gc,Bc,Ac). They are understood to have integer values between 0 and (kR,kG,kB,kA), where 


kc=2mc-1


and (mR,mG,mB,mA) is the number of red, green, blue, and alpha bitplanes. 

Source and destination scale factors are referred to as (sR,sG,sB,sA) and (dR,dG,dB,dA). 
All scale factors have range [0,1]. 

.....

【参数】
srcRGB 
Specifies how the red, green, and blue blending factors are computed. 
The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, 
GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA, 
GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, GL_ONE_MINUS_CONSTANT_ALPHA, and GL_SRC_ALPHA_SATURATE. 
The initial value is GL_ONE. 

dstRGB 
Specifies how the red, green, and blue destination blending factors are computed. 
The following symbolic constants are accepted: GL_ZERO, GL_ONE, GL_SRC_COLOR, GL_ONE_MINUS_SRC_COLOR, 
GL_DST_COLOR, GL_ONE_MINUS_DST_COLOR, GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA, GL_DST_ALPHA, GL_ONE_MINUS_DST_ALPHA.
GL_CONSTANT_COLOR, GL_ONE_MINUS_CONSTANT_COLOR, GL_CONSTANT_ALPHA, and GL_ONE_MINUS_CONSTANT_ALPHA. 
The initial value is GL_ZERO. 

srcAlpha 
Specified how the alpha source blending factor is computed. The same symbolic constants are accepted as for srcRGB. 
The initial value is GL_ONE. 

dstAlpha 
Specified how the alpha destination blending factor is computed. 
The same symbolic constants are accepted as for dstRGB. The initial value is GL_ZERO. 

【返回值】
【备注】
Incoming (source) alpha is correctly thought of as a material opacity, ranging from 1.0 (KA), 
representing complete opacity, to 0.0 (0), representing complete transparency. 
</pre>
<pre>
参考文档：
http://www.khronos.org/opengles/sdk/docs/man/
</pre>
				</td>
			</tr>
			<tr>
				<td>void glBufferData(GLenum target,GLsizeiptr size,const GLvoid * data,GLenum usage)</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
glBufferData creates a new data store for the buffer object currently bound to target. Any pre-existing data store is deleted. 
The new data store is created with the specified size in bytes and usage. If data is not NULL, the data store is initialized with data from this pointer.

usage is a hint to the GL implementation as to how a buffer object's data store will be accessed. 
This enables the GL implementation to make more intelligent decisions that may significantly impact buffer object performance. 
It does not, however, constrain the actual usage of the data store.

usage may be one of these:

GL_STATIC_DRAW
The data store contents will be modified once and used many times as the source for GL drawing commands.

GL_DYNAMIC_DRAW
The data store contents will be modified repeatedly and used many times as the source for GL drawing commands.
【参数】
target
Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.

size
Specifies the size in bytes of the buffer object's new data store.

data
Specifies a pointer to data that will be copied into the data store for initialization, or NULL if no data is to be copied.

usage
Specifies the expected usage pattern of the data store. The symbolic constant must be GL_STATIC_DRAW or GL_DYNAMIC_DRAW.
【返回值】
【备注】
为了把顶点数据复制到图形硬件，首先绑定需要使用的缓冲区对象，然后调用glBufferData函数。
void glBufferData(GLenum target,GLsizeiptr size,const GLvoid * data,GLenum usage)

其中，target必须是 GL_ARRAY_BUFFER 或 GL_ELEMENT_ARRAY_BUFFER，size表示顶点数组的长度（以字节为单位）。最后一个参数说明如下：

GL_DYNAMIC_DRAW
存储在缓冲区对象的数据可能会经常变化，并且很可能多次作为绘图的来源。这个提示告诉OpenGL实现把数据放在更新开销不太大的地方。
GL_STATIC_DRAW
存储在缓冲区对象的数据可能不太会变化，并且可能多次作为绘图的来源。这个提示告诉OpenGL实现把数据放在可以快速读取但不必快速更新的地方。
GL_STREAM_DRAW(ES1不支持，ES2支持)
存储在缓冲区对象的数据可能不太会变化，并且只有一次作为绘图的来源（或次数非常少）。这个提示OpenGL实现有一些时间敏感的数据（例如动画几何图形）将只使用
一次，然后被替换。关键是数据要放在可以快速更新的地方，即使需要付出更快渲染的代价。
</pre>
<pre>
参考文档：
http://www.khronos.org/opengles/sdk/1.1/docs/man/
《OpenGL超级宝典》p294
</pre>
				</td>
			</tr>
			<tr>
				<td>void glBufferSubData(GLenum target,GLintptr offset,GLsizeiptr size,const GLvoid * data)</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
glBufferSubData redefines some or all of the data store for the buffer object currently bound to target. 
Data starting at byte offset offset and extending for size bytes is copied to the data store from the memory pointed to by data. 
An error is thrown if offset and size together define a range beyond the bounds of the buffer object's data store.
【参数】
target
Specifies the target buffer object. The symbolic constant must be GL_ARRAY_BUFFER or GL_ELEMENT_ARRAY_BUFFER.

offset
Specifies the offset into the buffer object's data store where data replacement will begin, measured in bytes.

size
Specifies the size in bytes of the data store region being replaced.

data
Specifies a pointer to the new data that will be copied into the data store.
【返回值】
【备注】
</pre>
<pre>
参考文档：
http://www.khronos.org/opengles/sdk/1.1/docs/man/
</pre>
				</td>
			</tr>
			<tr>
				<td>void glClientActiveTexture(	GLenum  texture)</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
select active texture unit
【参数】
texture
Specifies which texture unit to make active. 
The number of texture units is implementation dependent, but must be at least two. 
texture must be one of GL_TEXTUREi, where i ranges from 0 to the value of GL_MAX_TEXTURE_COORDS - 1, 
which is an implementation-dependent value. The initial value is GL_TEXTURE0.

glClientActiveTexture selects the vertex array client state parameters to be modified by glTexCoordPointer, 
and enabled or disabled with glEnableClientState or glDisableClientState, respectively, 
when called with a parameter of GL_TEXTURE_COORD_ARRAY.
【返回值】
【备注】
</pre>
<pre>
参考文档：
http://www.khronos.org/opengles/sdk/1.1/docs/man/
</pre>
				</td>
			</tr>
			<tr>
				<td>void glCopyTexImage2D(GLenum target,GLint level,GLenum internalformat,GLint x,GLint y,GLsizei width,GLsizei height,GLint border)</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
glCopyTexImage2D defines a two-dimensional texture image with pixels from the color buffer.
The screen-aligned pixel rectangle with lower left corner at (x, y) and with a width of width and a height of height 
defines the texture array at the mipmap level specified by level. internalformat specifies the color components of the texture.
The red, green, blue, and alpha components of each pixel that is read are converted to an internal fixed-point or floating-point 
format with unspecified precision. The conversion maps the largest representable component value to 1.0, and component value 0 to 0.0. 
The values are then converted to the texture's internal format for storage in the texel array.
internalformat must be chosen such that color buffer components can be dropped during conversion to the internal format, but new 
components cannot be added. For example, an GL_RGB color buffer can be used to create GL_LUMINANCE or GL_RGB textures, 
but not GL_ALPHA, GL_LUMINANCE_ALPHA or GL_RGBA textures.
Pixel ordering is such that lower x and y screen coordinates correspond to lower s and t texture coordinates.
If any of the pixels within the specified rectangle of the color buffer are outside the window associated with the current rendering 
context, then the values obtained for those pixels are undefined.
【参数】
target
Specifies the target texture. Must be GL_TEXTURE_2D.
level
Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
internalformat
Specifies the color components of the texture. Must be one of the following symbolic constants: GL_ALPHA, GL_LUMINANCE, GL_LUMINANCE_ALPHA, GL_RGB, or GL_RGBA.
x, y
Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
width
Specifies the width of the texture image. Must be 0 or 2n for some integer n.
height
Specifies the height of the texture image. Must be 0 or 2m for some integer m.
border
Specifies the width of the border. Must be 0.
【返回值】
【备注】
</pre>
<pre>
参考文档：

</pre>
				</td>
			</tr>
			<tr>
				<td>void glCopyTexSubImage2D(GLenum target,GLint level,GLint xoffset,GLint yoffset,GLint x,GLint y,GLsizei width,GLsizei height)</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
glCopyTexSubImage2D replaces a rectangular portion of a two-dimensional texture image with pixels from the color buffer.
The screen-aligned pixel rectangle with lower left corner at ( x, y) and with width width and height height replaces the portion of the texture array with x indices xoffset through xoffset+width-1 , 
inclusive, and y indices yoffset through yoffset+height-1 , inclusive, at the mipmap level specified by level.
The pixels in the rectangle are processed the same way as with glCopyTexImage2D.
glCopyTexSubImage2D requires that the internal format of the currently bound texture is such that color buffer components can be dropped during conversion to the internal format, 
but new components cannot be added. For example, an GL_RGB color buffer can be used to create GL_LUMINANCE or GL_RGB textures, but not GL_ALPHA, GL_LUMINANCE_ALPHA or GL_RGBA textures.
The destination rectangle in the texture array may not include any texels outside the texture array as it was originally specified. It is not an error to specify a subtexture with zero width or height, 
but such a specification has no effect.
If any of the pixels within the specified rectangle of the current color buffer are outside the read window associated with the current rendering context, then the values obtained for those pixels are undefined.
No change is made to the internalformat, width, height, or border parameters of the specified texture array or to texel values outside the specified subregion.
【参数】
target
Specifies the target texture. Must be GL_TEXTURE_2D.
level
Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image.
xoffset
Specifies a texel offset in the x direction within the texture array.
yoffset
Specifies a texel offset in the y direction within the texture array.
x, y
Specify the window coordinates of the lower left corner of the rectangular region of pixels to be copied.
width
Specifies the width of the texture subimage.
height
Specifies the height of the texture subimage.
【返回值】
【备注】
</pre>
<pre>
参考文档：

</pre>
				</td>
			</tr>
			<tr>
				<td>void glDeleteBuffers(GLsizei n,const GLuint * buffers)</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
glDeleteBuffers deletes n buffer objects named by the elements of the array buffers. After a buffer object is deleted, it has no contents, and its name is free for reuse.

glDeleteBuffers silently ignores zero and names that do not correspond to existing buffer objects.
【参数】
n
Specifies the number of buffer objects to be deleted.

buffers
Specifies an array of buffer object names to be deleted.
【返回值】
【备注】
</pre>
<pre>
参考文档：
http://www.khronos.org/opengles/sdk/1.1/docs/man/
</pre>
				</td>
			</tr>
			<tr>
				<td>void glGenBuffers(GLsizei n,GLuint * buffers)</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
glGenBuffers returns n buffer object names in buffers. There is no guarantee that the names form a contiguous set of integers; 
however, it is guaranteed that none of the names was in use immediately before the call to glGenBuffers.

Buffer object names returned by a call to glGenBuffers are not returned by subsequent calls, 
unless they are first deleted with glDeleteBuffers.

No buffer objects are associated with the returned buffer object names until they are first bound by calling glBindBuffer.

OpenGL提供一个特性：对几何图形吞吐量提供了终极控制。当我们使用顶点数组时，可以把单个数组从客户内存（CPU可以访问）传输到图形硬件。
这个特性称为顶点缓冲区对象，我们按照与加载和管理纹理相似的方式使用和管理顶点数组数据。但是，顶点缓冲区对象比纹理对象灵活得多。
【参数】
n
Specifies the number of buffer object names to be generated.

buffers
Specifies an array in which the generated buffer object names are stored.
【返回值】
【备注】
</pre>
<pre>
参考文档：
http://www.khronos.org/opengles/sdk/1.1/docs/man/
《OpenGL超级宝典》p294
</pre>
				</td>
			</tr>
			<tr>
				<td>void glLoadMatrixf(const GLfloat * m);<br>void glLoadMatrixx(const GLfixed * m);</td>
				<td>支持</td>
				<td>不支持</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
glLoadMatrix replaces the current matrix with the one whose elements are specified by m. 
The current matrix is the projection matrix, modelview matrix, or texture matrix, depending on the current matrix mode (see glMatrixMode).

The current matrix, M, defines a transformation of coordinates. 
For instance, assume M refers to the modelview matrix. 
If v= v[0] v[1] v[2] v[3] is the set of object coordinates of a vertex, and m points to an array of 16 fixed-point or single-precision floating-point values m[0], m[1], ... m[15] , 
then the modelview transformation Mv does the following:
Mv= ( m[0] m[4] m[8] m[12] m[1] m[5] m[9] m[13] m[2] m[6] m[10] m[14] m[3] m[7] m[11] m[15] ) x ( v[0] v[1] v[2] v[3] )
Where ``x'' denotes matrix multiplication.

Projection and texture transformations are similarly defined.
【参数】
m
Specifies a pointer to 16 consecutive values, which are used as the elements of a 4x4 column-major matrix.
【返回值】
【备注】
</pre>
<pre>
参考文档：

</pre>
				</td>
			</tr>
			<tr>
				<td>void glPixelStorei(GLenum pname,GLint param);</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【参数】
pname
Specifies the symbolic name of the parameter to be set. 
GL_PACK_ALIGNMENT affects the packing of pixel data into memory. 
GL_UNPACK_ALIGNMENT affects the unpacking of pixel data from memory.
指定所要被设置参数的符号名。这里，参数的符号名有两种：
一种是GL_PACK_ALIGNMENT，它影响将像素数据写回到主存的打包形式，对glReadPixels的调用产生影响；
还有一种是GL_UNPACK_ALIGNMENT，它影响从主存读到的像素数据的解包形式，对glTexImage2D以及glTexSubImage2D产生影响。
param
Specifies the value that pname is set to.
指定相应的pname设置为什么值。这个数值一般是1、2、4或8，用于指定存储器中每个像素行有多少个字节对齐。对齐的字节数越高，系统就越能优化。

【描述】
glPixelStorei sets pixel storage modes that affect the operation of subsequent glReadPixels 
as well as the unpacking of glTexImage2D, and glTexSubImage2D.

pname is a symbolic constant indicating the parameter to be set, and param is the new value. 
The following storage parameter affects how pixel data is returned to client memory. 
This value is significant for glReadPixels:

GL_PACK_ALIGNMENT
Specifies the alignment requirements for the start of each pixel row in memory.
 The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 
4 (word-alignment), and 8 (rows start on double-word boundaries). The initial value is 4.

The following storage parameter affects how pixel data is read from client memory. 
This value is significant for glTexImage2D and glTexSubImage2D:

GL_UNPACK_ALIGNMENT
Specifies the alignment requirements for the start of each pixel row in memory. 
The allowable values are 1 (byte-alignment), 2 (rows aligned to even-numbered bytes), 
4 (word-alignment), and 8 (rows start on double-word boundaries). The initial value is 4.

【注意】
Pixel storage modes are client states.
glCompressedTexImage2D and glCompressedTexSubImage2D are not affected by glPixelStorei.

【消除BMP文件中“对齐”带来的影响】
实际上OpenGL也支持使用了这种“对齐”方式的像素数据。只要通过glPixelStore修改“像素保存时对齐的方式”就可以了。像这样：
int alignment = 4;
glPixelStorei(GL_UNPACK_ALIGNMENT, alignment);
第一个参数表示“设置像素的对齐值”，第二个参数表示实际设置为多少。
这里像素可以单字节对齐（实际上就是不使用对齐）、双字节对齐（如果长度为奇数，则再补一个字节）、
四字节对齐（如果长度不是四的倍数，则补为四的倍数）、八字节对齐。分别对应alignment的值为1, 2, 4, 8。
实际上，默认的值是4，正好与BMP文件的对齐方式相吻合。

【纹理图的创建】
在提取图像数据并将放入纹理内存之前，OpenGL需要知道这些数据在处理器内存中的格式，可能需要通过函数glPixelStore*()来设置像素存储模式（在glTexImage2D之前调用）：
glPixelStorei(GL_UNPACK_ALIGNMENT,1);
指定内存中每行像素起始地址的对齐要求，第二个参数可以为1，2，4，8。例如为4的话则每行像素占用地址空间为4字节整数倍。
</pre>
<pre>
http://www.khronos.org/opengles/sdk/1.1/docs/man/
http://www.cnblogs.com/yxnchinahlj/archive/2010/11/19.html
http://wenku.baidu.com/view/bb1b57d97f1922791688e804.html
http://www.cocoachina.com/bbs/read.php?tid=38052
</pre>

				</td>
			</tr>
			<tr>
				<td>
				void glPointSize(GLfloat size) <br>
				void glPointSizex(GLfixed size) 
				</td>
				<td>支持</td>
				<td>不支持</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
specify the diameter of rasterized points
glPointSize specifies the rasterized diameter of both aliased and antialiased points. 
Using a point size other than 1 has different effects, depending on whether point antialiasing is enabled. 
To enable and disable point antialiasing, call glEnable and glDisable with argument GL_POINT_SMOOTH. 
Point antialiasing is initially disabled.

If point antialiasing is disabled, the actual size is determined by rounding the supplied size to the nearest integer. 
(If the rounding results in the value 0, it is as if the point size were 1.) 
If the rounded size is odd, then the center point (x,y) of the pixel fragment that represents the point is computed as
{[Xw]+1/2,[Yw]+1/2}
where w subscripts indicate window coordinates. 
All pixels that lie within the square grid of the rounded size centered at (x,y) make up the fragment. 
If the size is even, the center point is
{[Xw+1/2],[Yw+1/2]}
and the rasterized fragment's centers are the half-integer window coordinates within the square of the rounded size centered at (x,y). 
All pixel fragments produced in rasterizing a nonantialiased point are assigned the same associated data, 
that of the vertex corresponding to the point.

If antialiasing is enabled, then point rasterization produces a fragment for each pixel square that intersects the region lying within 
the circle having diameter equal to the current point size and centered at the point's (xw,yw). 
The coverage value for each fragment is the window coordinate area of the intersection of the circular region with the corresponding pixel square. 
This value is saved and used in the final rasterization step. The data associated with each fragment is the data associated with the point being rasterized.

Not all sizes are supported when point antialiasing is enabled. 
If an unsupported size is requested, the nearest supported size is used. 
Only size 1 is guaranteed to be supported; others depend on the implementation. 
To query the range of supported sizes, call glGet with the argument GL_SMOOTH_POINT_SIZE_RANGE. 
For aliased points, query the supported ranges glGet with the argument GL_ALIASED_POINT_SIZE_RANGE.


【参数】
size 
Specifies the diameter of rasterized points. The initial value is 1.

【返回值】
【备注】
A non-antialiased point size may be clamped to an implementation-dependent maximum. 
Although this maximum cannot be queried, it must be no less than the maximum value for antialiased points, rounded to the nearest integer value.


ES1.1 supports both points and point sprites. Use glPointSize() to set a constant size, or GL_OES_point_size_array to set a per-point size.
ES2.0 supports only point sprites. You must write gl_PointSize in the vertex shader, per point.
</pre>
<pre>
参考文档：
http://www.khronos.org/opengles/sdk/1.1/docs/man/
http://www.idevgames.com/forums/thread-3.html
</pre>
				</td>
			</tr>
			<tr>
				<td>void glPolygonMode(	GLenum face,GLenum mode)</td>
				<td>不支持</td>
				<td>不支持</td>
				<td>支持</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
【参数】
face
Specifies the polygons that mode applies to. Must be GL_FRONT for front-facing polygons, GL_BACK for back-facing polygons, 
or GL_FRONT_AND_BACK for front- and back-facing polygons.
mode
Specifies how polygons will be rasterized. Accepted values are GL_POINT, GL_LINE, and GL_FILL. 
The initial value is GL_FILL for both front- and back-facing polygons.
【返回值】
【备注】
</pre>
<pre>
参考文档：
http://www.opengl.org/sdk/docs/man/xhtml/glPolygonMode.xml
</pre>
				</td>
			</tr>
			<tr>
				<td>void glScissor(	GLint x,GLint y,GLsizei width,GLsizei height)</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
glScissor defines a rectangle, called the scissor box, in window coordinates.
The first two arguments, x and y, specify the lower left corner of the box. 
width and height specify the width and height of the box.

To enable and disable the scissor test, call glEnable and glDisable with argument GL_SCISSOR_TEST. 
The scissor test is initially disabled. While scissor test is enabled, only pixels that lie within the scissor box 
can be modified by drawing commands. Window coordinates have integer values at the shared corners of frame buffer pixels. 
glScissor(0, 0, 1, 1) allows modification of only the lower left pixel in the window, and glScissor(0, 0, 0, 0) doesn't 
allow modification of any pixels in the window.

★When the scissor test is disabled, it is as though the scissor box includes the entire window.
【参数】
x, y
Specify the lower left corner of the scissor box, in pixels. The initial value is (0, 0).
width, height
Specify the width and height of the scissor box. When a GL context is first attached to a surface (e.g. window), 
width and height are set to the dimensions of that surface.

【返回值】
无
【备注】
设置剪裁区域，如果启用了GL_SCISSOR_TEST，只有在剪裁区域的绘制的内容才显示。
</pre>
<pre>
参考文档：
http://www.khronos.org/opengles/sdk/1.1/docs/man/
</pre>
				</td>
			</tr>
			<tr>
				<td>void glTexImage2D(GLenum target,GLint level,GLint internalformat,GLsizei width,GLsizei height,GLint border,GLenum format,GLenum type,const GLvoid * pixels)</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
【参数】
target
Specifies the target texture. Must be GL_TEXTURE_2D.

level
Specifies the level-of-detail number. Level 0 is the base image level. Level n is the nth mipmap reduction image. Must be greater or equal 0.

internalformat
Specifies the color components in the texture. Must be same as format. The following symbolic values are accepted: GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, or GL_LUMINANCE_ALPHA.

width
Specifies the width of the texture image. Must be 2n for some integer n. All implementations support texture images that are at least 64 texels wide.

height
Specifies the height of the texture image. Must be 2m for some integer m. All implementations support texture images that are at least 64 texels high.

border
Specifies the width of the border. Must be 0.

format
Specifies the format of the pixel data. Must be same as internalformat. The following symbolic values are accepted: GL_ALPHA, GL_RGB, GL_RGBA, GL_LUMINANCE, and GL_LUMINANCE_ALPHA.

type
Specifies the data type of the pixel data. The following symbolic values are accepted: GL_UNSIGNED_BYTE, GL_UNSIGNED_SHORT_5_6_5, GL_UNSIGNED_SHORT_4_4_4_4, and GL_UNSIGNED_SHORT_5_5_5_1.

pixels
Specifies a pointer to the image data in memory.
【返回值】
【备注】
</pre>
<pre>
参考文档：

</pre>
				</td>
			</tr>
			<tr>
				<td>void glTexParameterf(GLenum target,GLenum pname,GLfloat param);<br>
					void glTexParameteri(GLenum target,GLenum pname,GLint param);<br>
					void glTexParameterx(GLenum target,GLenum pname,GLfixed param);</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
Texture mapping is a technique that applies an image onto an object's surface as if the image were a decal or cellophane shrink-wrap. The image is created in texture space, with an s t coordinate system. A texture is a one- or two-dimensional image and a set of parameters that determine how samples are derived from the image.

glTexParameter assigns the value in param or params to the texture parameter specified as pname. target defines the target texture, which must be GL_TEXTURE_2D.

The following symbols are accepted in pname:

GL_TEXTURE_MIN_FILTER
The texture minifying function is used whenever the pixel being textured maps to an area greater than one texture element. There are six defined minifying functions. Two of them use the nearest one or nearest four texture elements to compute the texture value. The other four use mipmaps.

A mipmap is an ordered set of arrays representing the same image at progressively lower resolutions. If the texture has dimensions 2 n x 2 m , there are max n m + 1 mipmaps. The first mipmap is the original texture, with dimensions 2 n x 2 m . Each subsequent mipmap has dimensions 2 k - 1 x 2 l - 1 , where 2 k x 2 l are the dimensions of the previous mipmap, until either k = 0 or l = 0 . At that point, subsequent mipmaps have dimension 1 x 2 l - 1 or 2 k - 1 x 1 until the final mipmap, which has dimension 1 x 1 . To define the mipmaps, call glTexImage2D or glCopyTexImage2D with the level argument indicating the order of the mipmaps. Level 0 is the original texture. Level max n m is the final 1 x 1 mipmap.

param supplies a function for minifying the texture as one of the following:

GL_NEAREST
Returns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured.

GL_LINEAR
Returns the weighted average of the four texture elements that are closest to the center of the pixel being textured. These can include repeated or wrapped elements, depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T, and on the exact mapping.

GL_NEAREST_MIPMAP_NEAREST
Chooses the mipmap that most closely matches the size of the pixel being textured and uses the GL_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value.

GL_LINEAR_MIPMAP_NEAREST
Chooses the mipmap that most closely matches the size of the pixel being textured and uses the GL_LINEAR criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value.

GL_NEAREST_MIPMAP_LINEAR
Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the GL_NEAREST criterion (the texture element nearest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.

GL_LINEAR_MIPMAP_LINEAR
Chooses the two mipmaps that most closely match the size of the pixel being textured and uses the GL_LINEAR criterion (a weighted average of the four texture elements that are closest to the center of the pixel) to produce a texture value from each mipmap. The final texture value is a weighted average of those two values.

As more texture elements are sampled in the minification process, fewer aliasing artifacts will be apparent. While the GL_NEAREST and GL_LINEAR minification functions can be faster than the other four, they sample only one or four texture elements to determine the texture value of the pixel being rendered and can produce moire patterns or ragged transitions.

The initial value of GL_TEXTURE_MIN_FILTER is GL_NEAREST_MIPMAP_LINEAR.

GL_TEXTURE_MAG_FILTER
The texture magnification function is used when the pixel being textured maps to an area less than or equal to one texture element. It sets the texture magnification function to either GL_NEAREST or GL_LINEAR (see below). GL_NEAREST is generally faster than GL_LINEAR, but it can produce textured images with sharper edges because the transition between texture elements is not as smooth.

GL_NEAREST
Returns the value of the texture element that is nearest (in Manhattan distance) to the center of the pixel being textured.

GL_LINEAR
Returns the weighted average of the four texture elements that are closest to the center of the pixel being textured. These can include repeated or wrapped elements, depending on the values of GL_TEXTURE_WRAP_S and GL_TEXTURE_WRAP_T, and on the exact mapping.

The initial value of GL_TEXTURE_MAG_FILTER is GL_LINEAR.

GL_TEXTURE_WRAP_S
Sets the wrap parameter for texture coordinate s to either GL_CLAMP_TO_EDGE or GL_REPEAT.

GL_CLAMP_TO_EDGE
causes s coordinates to be clamped to the range [ 1 2 N , 1 - 1 2 N ] , where N is the size of the texture in the direction of clamping.

GL_REPEAT
causes the integer part of the s coordinate to be ignored; the GL uses only the fractional part, thereby creating a repeating pattern.

The initial value of GL_TEXTURE_WRAP_S is GL_REPEAT.

GL_TEXTURE_WRAP_T
Sets the wrap parameter for texture coordinate t to either GL_CLAMP_TO_EDGE or GL_REPEAT. See the discussion under GL_TEXTURE_WRAP_S.

The initial value of GL_TEXTURE_WRAP_T is GL_REPEAT.

GL_GENERATE_MIPMAP
Sets the automatic mipmap generation parameter. If set to GL_TRUE, making any change to the interior texels of the level base array of a mipmap will also compute a complete set of mipmap arrays derived from the modified level base array. Array levels level base +1 through p are replaced with the derived arrays, regardless of their previous contents. All other mipmap arrays, including the level base array, are left unchanged by this computation.

The initial value of GL_GENERATE_MIPMAP is GL_FALSE.
【参数】
target
Specifies the target texture, which must be GL_TEXTURE_2D.

pname
Specifies the symbolic name of a single-valued texture parameter. Which can be one of the following: GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_GENERATE_MIPMAP.

param
Specifies the value of pname.

【返回值】
【备注】
Suppose that a program has enabled texturing (by calling glEnable with argument GL_TEXTURE_2D and has set GL_TEXTURE_MIN_FILTER to one of the functions that requires a mipmap. If either the dimensions of the texture images currently defined (with previous calls to glTexImage2D, or glCopyTexImage2D) do not follow the proper sequence for mipmaps (described above), or there are fewer texture images defined than are needed, or the set of texture images have differing numbers of texture components, then it is as if texture mapping were disabled.

Linear filtering accesses the four nearest texture elements.

glTexParameter specifies the texture parameters for the texture bound to the active texture unit, specified by calling glActiveTexture.
</pre>
<pre>
参考文档：

</pre>
				</td>
			</tr>
			<tr>
				<td>void glTexParameterfv(GLenum target,GLenum pname,GLfloat * params);<br>
					void glTexParameteriv(GLenum target,GLenum pname,GLint * params);<br>
					void glTexParameterxv(GLenum target,GLenum pname,GLfixed * params);
				</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
见上API
【参数】
target
Specifies the target texture, which must be GL_TEXTURE_2D.

pname
Specifies the symbolic name of a texture parameter. Which can be one of the following: GL_TEXTURE_MIN_FILTER, GL_TEXTURE_MAG_FILTER, GL_TEXTURE_WRAP_S, GL_TEXTURE_WRAP_T, or GL_GENERATE_MIPMAP.

params
Specifies a pointer to an array where the value or values of pname are stored.

【返回值】
【备注】
见上API
</pre>
<pre>
参考文档：

</pre>
				</td>
			</tr>
			<tr>
				<td>void glTexSubImage2D(GLenum target,GLint level,GLint xoffset,GLint yoffset,GLsizei width,GLsizei height,GLenum format,GLenum type,const GLvoid * pixels);</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【描述】
如果有多个使用周期较短且大小相同的纹理, 可以调用函数glTexSubImage2D()将不同的图像加载到已有的纹理对象中.与删除并重新创建纹理对象相比, 这样做的效率可能更高
</pre>
<pre>
http://apps.hi.baidu.com/share/detail/48145190
</pre>
				</td>
			</tr>
			<tr>
				<td>template</td>
				<td>支持</td>
				<td>&nbsp;</td>
				<td>&nbsp;</td>
				<td>
				<div class="arrow">
					&nbsp;
				</div></td>
			</tr>
			<tr>
				<td colspan="5" >
<pre class="brush: gl;auto-links:true;">
【功能描述】
【参数】
【返回值】
【备注】
</pre>
<pre>
参考文档：

</pre>
				</td>
			</tr>
			</tbody>
		</table>
	</body>
</html>