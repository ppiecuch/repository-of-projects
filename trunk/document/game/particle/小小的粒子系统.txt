#include <stdio.h>
#include <stdlib.h>
#include <glut.h>
#include <glaux.h>


#define MAX_PARTICLES 1000
bool rainbow = true;

float slowdown = 2.0f;
float xspeed;
float yspeed;
float zoom=-40.0f;

GLuint loop;
GLuint col;
GLuint delay;

GLuint texture[1];


typedef struct 
{
bool active;
float life;
float fade;

float r; //color
float g;
float b;

float x; //postion
float y;
float z;

float xi; //deirection
float yi;
float zi;

float xg; //gravity
float yg;
float zg;
} particles;

particles particle[MAX_PARTICLES];

static GLfloat colors[12][3]=   // Rainbow Of Colors
{
{1.0f,0.5f,0.5f},{1.0f,0.75f,0.5f},{1.0f,1.0f,0.5f},{0.75f,1.0f,0.5f},
{0.5f,1.0f,0.5f},{0.5f,1.0f,0.75f},{0.5f,1.0f,1.0f},{0.5f,0.75f,1.0f},
{0.5f,0.5f,1.0f},{0.75f,0.5f,1.0f},{1.0f,0.5f,1.0f},{1.0f,0.5f,0.75f}
};

AUX_RGBImageRec *LoadBMP(char *Filename)     // Loads A Bitmap Image
{
FILE *File=NULL;         // File Handle
if (!Filename)          // Make Sure A Filename Was Given
{
   return NULL;        // If Not Return NULL
}
File=fopen(Filename,"r");       // Check To See If The File Exists
if (File)           // Does The File Exist?
{
   fclose(File);         // Close The Handle
   return auxDIBImageLoad(Filename);    // Load The Bitmap And Return A Pointer
}
return NULL;          // If Load Failed Return NULL
}

int LoadGLTextures()          // Load Bitmap And Convert To A Texture
{
int Status=FALSE;         // Status Indicator
AUX_RGBImageRec *TextureImage[1];     // Create Storage Space For The Textures
memset(TextureImage,0,sizeof(void *)*1);   // Set The Pointer To NULL

if (TextureImage[0]=LoadBMP("Particle.bmp")) // Load Particle Texture
{
   Status=TRUE;         // Set The Status To TRUE
   glGenTextures(1, &texture[0]);     // Create One Texture
  
   glBindTexture(GL_TEXTURE_2D, texture[0]);
   glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR);
   glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR);
   glTexImage2D(GL_TEXTURE_2D, 0, 3, TextureImage[0]->sizeX, TextureImage[0]->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, TextureImage[0]->data);
}

if (TextureImage[0])        // If Texture Exists
{
   if (TextureImage[0]->data)      // If Texture Image Exists
   {
    free(TextureImage[0]->data);    // Free The Texture Image Memory
   }
   free(TextureImage[0]);       // Free The Image Structure
}
return Status;          // Return The Status
}

void reshape(int w, int h)
{
if (h == 0)
{
   h = 1;
}

glViewport(0,0,w,h);
glMatrixMode(GL_PROJECTION);
glLoadIdentity();

gluPerspective(45.0f, (GLfloat)w/(GLfloat)h, 0.1f, 200.0f);
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();

}

int init()
{
if (!LoadGLTextures())
{
   return FALSE;
}

glShadeModel(GL_SMOOTH);
glClearColor(0.0f, 0.0f, 0.0f, 0.0f);
glClearDepth(1.0f);
glDisable(GL_DEPTH_TEST);
glEnable(GL_BLEND);
glBlendFunc(GL_SRC_ALPHA, GL_ONE);
glHint(GL_PERSPECTIVE_CORRECTION_HINT,GL_NICEST);
glHint(GL_POINT_SMOOTH_HINT, GL_NICEST);
glEnable(GL_TEXTURE_2D);
glBindTexture(GL_TEXTURE_2D, texture[0]);

for (loop=0; loop<MAX_PARTICLES; loop++)
{
   particle[loop].active = true;
   particle[loop].life = 1.0f;
   particle[loop].fade = float(rand()%100)/1000.0 + 0.003f;
   particle[loop].r = colors[loop*(12/MAX_PARTICLES)][0];
   particle[loop].g = colors[loop*(12/MAX_PARTICLES)][1];
   particle[loop].b = colors[loop*(12/MAX_PARTICLES)][2];
   particle[loop].xi = float((rand()%50)-26.0f)*10.0f;
   particle[loop].yi = float((rand()%50)-25.0f)*10.0f;
   particle[loop].zi = float((rand()%50)-25.0f)*10.0f;
   particle[loop].xg = 0.0f;
   particle[loop].yg = -0.8f;
   particle[loop].zg = 0.0f;
}

return TRUE;
}

int number = MAX_PARTICLES;

void display()
{
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
glLoadIdentity();

for (loop=0; loop<MAX_PARTICLES; loop++) 
{
   if (particle[loop].active)
   {
    float x = particle[loop].x;
    float y = particle[loop].y;
    float z = particle[loop].z + zoom;

    glColor4f(particle[loop].r, particle[loop].g, 
     particle[loop].b, particle[loop].life);

    glBegin(GL_TRIANGLE_STRIP);
     glTexCoord2d(1,1);
     glVertex3f(x+0.5f, y+0.5f, z);

     glTexCoord2d(0,1);
     glVertex3f(x-0.5f, y+0.5f, z);

     glTexCoord2d(1,0);
     glVertex3f(x+0.5f, y-0.5f, z);

     glTexCoord2d(0,0);
     glVertex3f(x-0.5f, y-0.5f, z);
    glEnd();

    particle[loop].x += particle[loop].xi/(slowdown*1000);
    particle[loop].y += particle[loop].yi/(slowdown*1000);
    particle[loop].z += particle[loop].zi/(slowdown*1000);

    particle[loop].xi += particle[loop].xg;
    particle[loop].yi += particle[loop].yg;
    particle[loop].zi += particle[loop].zg;
    particle[loop].life -= particle[loop].fade;

    if (particle[loop].life < 0.0f)
    {
    
     particle[loop].life = 1.0f;
     particle[loop].fade = float(rand()%100)/1000.0 + 0.003f;
     particle[loop].r = colors[loop*(12/MAX_PARTICLES)][0];
     particle[loop].g = colors[loop*(12/MAX_PARTICLES)][1];
     particle[loop].b = colors[loop*(12/MAX_PARTICLES)][2];
     particle[loop].xi = float((rand()%50)-26.0f)*10.0f;
     particle[loop].yi = float((rand()%50)-25.0f)*10.0f;
     particle[loop].zi = float((rand()%50)-25.0f)*10.0f;
     particle[loop].xg = 0.0f;
     particle[loop].yg = -0.8f;
     particle[loop].zg = 0.0f;

     particle[loop].x = 0.0f;
     particle[loop].y = 0.0f;
     particle[loop].z = 0.0f;
    }

   }
}

glutSwapBuffers();
}

int main(int argc, char** argv)
{
glutInit(&argc, argv);
glutInitDisplayMode(GLUT_DOUBLE | GLUT_DEPTH | GLUT_RGB);
glutInitWindowPosition(10,10);
glutInitWindowSize(500,500);
glutCreateWindow("lizi");

init();

glutReshapeFunc(reshape);
glutDisplayFunc(display);
glutIdleFunc(display);

glutMainLoop();

return 0;
}

http://hi.baidu.com/%CB%E3%B7%A8%C8%CB%C9%FA/blog/item/1883cede189b9c1b4954033b.html