MD5防穷举变换算法的研究与实现

 

摘要：分析了MD5加密算法和碰撞的原理，对目前常规MD5算法加密结果容易被破解的问题，利用JDK的java.security包中的MD5算法给出了JavaBeans形式的变换算法，以期进一步减小破解时碰撞的概率，增强系统加密的安全性。

关键词:MD5碰撞;变换算法;

一、MD5加密算法

1、单项散列函数及加密应用

单向函数（one-way function）是公钥密码学的核心,单向函数正向计算容易，但求逆却非常困难。因而单向函数具有很好的保密性。然而单向函数不能直接用于加密，因为用单向函数加密的信息很难解密。散列函数是把不定长输入转换成定长输出的一种函数，单向函数与散列函数形成的单向散列函数兼有二者的特点，在现代密码学中得到了广泛的应用。单向散列函数H(x)作用于一个任意长度的消息M上，返回一个固定长度散列值h，即:

h=H(M)

单向散列函数的特性如下

给定M，计算h很容易；

给定h,根据H(M)=h计算M很困难；

给定M，要寻找M’使得H(M’)=h也很难。

单向散列函数能够赋予消息M唯一的“指纹”h，故又称为“指纹函数”。单向散列函数在加密应用中按如下方式进行：

待加密消息M被分为M1,M2,…Mk共K个子分组，单向散列函数的输入是消息分组Mi和前一消息分组Mi-1的散列值hi-1 输出散列值hi=f(Mi,hi-1),该散列值hi和下一轮的消息分组Mi+1一起 作为单向散列函数的下一轮输入,如此反复,最后一组的输出就是整个待加密消息的散列值。

2、MD5加密算法

MD5加密算法是Ron Rivest设计的一种单向散列函数,它以512位分组为单位处理输入明文(Plaintext) 每个512位分组又分为16个32位子分组。算法的输出为4个级联的32位分组组成128 位的散列值。MD5算法的初始化、主循环和尾部处理三个步骤如下：

（1）初始化。算法初始化分为原始明文初始化和链接变量初始化两个部分。明文初始化首先将长度为L的待加密明文P后面级联一个字节0x80，再级联若干个0x00作为填充，使其长度为（516*K-64）位(K为正整数)，接着再级联64位以字节计的明文长度。此时明文长度被填充为512 位的整数倍，同时确保不同明文填充后不会相同。四个32位链接变量初始化为：A=0x1234567，B=0x789ABCDEF，C=0xFEDCBA98，D=0x76543210。这四个链接变量对于整个算法至关重要，其取值直接关系到配套设备软件的编写，务必将这四个链接变量写正确。

（2）算法主循环。主循环次数为经过填充的明文数据位数除以512位所得的商K。将链接变量A、B、C、D分别赋给a、b、c、d四个变量。每次主循环都有四轮，每轮进行16次操作。每次操作先对a、b、c、d中的三个进行一次非线性函数运算，然后将所得结果依次加上第四个变量Mj(文本中的一个子分组)和一个Ci(常数)，将所得结果循环左移一个不定的常数S，然后再加上a、b、c、d其中之一，最后用该结果取代a、b、c、d其中之一。

（3）尾部处理

每一次主循环全部完成之后，将A、B、C、D分别加上a、b、c、d，接着用下一个分组继续运行算法，最后的输出散列值是A、B、C、D的级联。

定义非线性函数FF(a,b,c,d,S,Ci)：

a=b+[F(b,c,d)+Mj+Ci]<<<S

其中S为循环左移的位数,为一常数，常数Ci为第i步中232*|sin(i)|的整数部分(i单位为弧度),四轮一共为64次，每一次的非线性函数都不相同。

3、MD5碰撞

目前在密码学领域应用最为广泛的hash函数是SHA-1和MD5，大多是128位和更长。hash函数在现实生活中应用十分广泛。很多下载网站都提供下载文件的MD5码校验，可以用来判别文件是否完整。如WordPress的数据库，所有密码都是保存的MD5码，这样即使数据库的管理员也无法知道用户的原始密码，避免隐私泄露。

如果两个输入串的hash函数的值一样，则称这两个串是一个碰撞(Collision)。既然是把任意长度的字符串变成固定长度的字符串，所以必有一个输出串对应无穷多个输入串，碰撞是必然存在的。

一个优良的hash函数 f 应当满足以下三个条件：

（1）对于任意y，寻找x，使得f(x)=y，在计算上是不可行的。

（2）给定x1∈A,找x2∈B，，使得f(x1)=f(x2)，在计算上是不可能的，这也就是弱无碰撞性。

（3）寻找x1，x2，使得f(x1)=f(x2)，在计算上也是不可行的，这也就是强无碰撞性。

这样就称为安全保密的Hash函数，除了枚举外不可能有别的更快的方法。如第3条，根据生日定理，要想找到这样的x1，x2，理论上需要大约2^(n/2)的枚举次数。

因为前两条都能被破坏的hash函数太弱而被抛弃，几乎所有的hash函数的破解，都是指的破坏上面的第3条性质，即找到一个碰撞。在密码学上还有一个概念是理论破解，指的是提出一个算法，使得可以用低于理论值得枚举次数找到碰撞。

山大教授王小云的主要工作是给出了MD5、SHA-0的碰撞，以及SHA-1的理论破解，她证明了160位SHA-1，只需要大约2^69次计算就能找出来，而理论值是2^80次。她的寻找MD5碰撞的方法是极端高效的。

目前流行的软件都提供了MD5算法，可以直接调用，因此我们要研究的是如何在原有算法的基础上使用变换算法来增加碰撞的难度。

MD5的全称是Message-Digest Algorithm 5（信息-摘要算法），MD5的典型应用是对一段信息（Message）产生128位的信息摘要（Message-Digest），以防止被篡改。

MD5广泛应用于数字签名和加密技术。如在设计用户登录时，系统把用户所输密码计算成MD5值，然后和保存在文件系统中的MD5值进行比较，进而确定输入的密码是否正确。这样系统在不知道密码明码的情况下，可验证用户身份的合法性，在一定程度上增加了密码被破解的难度。

基于此，目前黑客使用最多的破译密码方法是被称为“跑字典”的方法。有两种方法得到字典，一种是日常搜集的用做密码的字符串表，另一种是用排列组合方法生成的。先用MD5程序计算出这些字典项的MD5值，然后再用目标的MD5值在这个字典中检索。攻击者不但拥有数据量巨大的密码字典，而且建立了很多MD5原文/密文对照数据库，往往能快速找到常用密码的MD5密文，是破译MD5密文的高效途径。由于MD5密文数据库所使用的是最常规的MD5加密算法：原文-->MD5-->密文，因此对现有的常规MD5算法加以变换，对照数据库就无能为力了。

二、MD5变换算法

研究发现，破解时采用的MD5密文数据库使用的是常规的MD5加密算法，如果使用变换了的MD5算法，就能够进一步增强破解难度，减小碰撞的概率。虽然MD5算法本身已经公诸于众，但实际应用中一般不需要程序员亲自写。如在Java中，由SUN公司提供的软件包java.security提供了用于安全框架的类和接口，实现了可方便配置的、精细访问控制安全架构的类。另外，还支持加密公钥对的生成和存储以及消息摘要（message digest）和数字签名的生成等加密操作。

笔者将java.security提供的消息摘要算法，在单纯的MD5算法的基础上变换出好几种算法，写成了JavaBeans的形式，以供开发者直接引用。注意在代码的开头要引入包java.security.*;。

1、单纯的MD5算法生成消息摘要

该算法是未经变换的MD5算法，能够实现对消息进行消息摘要产生32位的16进制字符串。后面的几种变换算法是在该算法基础上进一步变换而成的。

public String MD5Purity(String plainText ) {

      try {

         MessageDigest md = MessageDigest.getInstance("MD5");

         md.update(plainText.getBytes());

         byte b[] = md.digest();

         int i;

         StringBuffer buf = new StringBuffer("");

         for (int offset = 0; offset < b.length; offset++) {

           i = b[offset];

           if(i<0) i+= 256;

           if(i<16)  buf.append("0");

           buf.append(Integer.toHexString(i));

         }

         plainText=buf.toString();

      } catch (NoSuchAlgorithmException e){e.printStackTrace();}

        return plainText.toUpperCase();

    }

2、循环进行指定多次的MD5运算

最好理解的变换就是对消息进行多次MD5运算。以下方法接受plainText和n两个形参，第一个是要加密的消息，第二个是重复加密的次数。

public String MD5Times(String plainText,int n){

       for(int i=0;i<n;i++){

       plainText=MD5Purity(plainText);     

   }

      return plainText.toUpperCase();

    }

3、附加字符串干涉

在进行MD5运算的某一个步骤中，附加一个内容确定的字符串，如用户名，以干涉被加密的数据。注意不能使用随机字串，这样会使原算法无法重现。该算法在某些情况下是很具有优势的，如对大量的用户密码加密时，可以把用户名作为附加干涉字串，这样攻击者就算知道算法，也很难从字典中一下子生成海量的对照表，然后大量地破译用户密码，而只能有针对性地穷举为数不多的用户。下面的方法是实现在原文plainText后连接append后再计算其MD5

public String MD5Append(String plainText,String append){

  return MD5Purity(plainText+append).toUpperCase();

}

4、字符串次序干涉

　　首先把MD5运算后的密文字符串的顺序调转，然后再进行一次MD5运算。

    public String MD5Reverse(String plainText){

          StringBuffer s=new StringBuffer(MD5Purity(plainText));

          s=s.reverse();

          plainText=s.toString();

      return MD5Purity(plainText).toUpperCase();

}

5、密文分割MD5算法

尽管用户的密码是不确定的字符串，但是只要经过一次MD5运算后，就会得到一个由32个字符组成的字符串，这时可以再针对这个定长字符串变换。首先把这段密文分割成若干段，对每段都进行一次MD5运算，然后把这写密文连成一个超长的字符串，最后再进行一次MD5运算，得到仍然是长度为32位的密文。

//把密文分割成两段，每段16个字符

public String MD5X2(String plainText){

{

　　//先把密码加密成长度为32字符的密文

　　    String s = new StringBuffer(MD5Purity(plainText));

　　//把密码分割成两段

　　String left = s.substring( 0, 16);

　　String right = s.substring(16, 16);

　　//分别加密后再合并

　　s = MD5Purity(left)+ MD5Purity(right);

　　//最后把长字串再加密一次，成为32字符密文

　　return MD5Purity(s);

}

//把密文分割成32段，每段1个字符

public String MD5X32(String plainText){

　　{

　　String s = MD5Purity(s);

　　//循环地截取密文中的每个字符并进行加密、连接

　　for (int i = 0; i < 32;i++) {

　　  s= MD5Purity(s.substring(i,1));

　　}

　　//这时$data长度为1024个字符，再进行一次MD5运算

　　return MD5Purity(s);

}

当然，这种密文分割的具体算法是取之不尽的，如可以把原密文分割成16段每段两字符，或8段每段4字符，或者每一段的字符数不相等。

三、引入JavaBeans包的程序运行结果

只要在程序的开头部分加入import MD5.MD5Beans.*;即可引入类MD5Beans。下面是调用MD5Beans中不同的MD5变换算法对同一字符串计算报文摘要的结果，如图1所示。

 

import MD5.MD5Beans.*;

  class MD5Test

    {public static void main(String args[])

      {MD5.MD5Beans MB;

      MB = new MD5.MD5Beans();

      System.out.println("字符串prettygirl的MD5消息摘要:");  

      System.out.println("单纯:"+MB.MD5Purity("prettygirl"));

      System.out.println("重复:"+MB.MD5Times("prettygirl",20));

      System.out.println("加串:"+MB.MD5Append("prettygirl","dutifulboy"));

      System.out.println("逆序:"+MB.MD5Reverse("prettygirl"));

  }

}

图1  MD5不同变换算法的运行结果

四、总结

MD5变换算法取之不尽，用上面几个算法互相组合就可以完成更复杂的算法。这样即使系统数据库被下载而导致用户密码数据暴露，MD5变换算法也能大大增加破译出密码原文的难度。要进行这些复杂的变换运算，当然要花费更多的系统开销，然而对于安全性要求很严格的系统来说，是完全值得的。

 

参考文献

[1]基于MD5的迭代冗余加密算法,王津涛,计算机工程与设计,2007.01

[2]基于穷举策略的缩水算法,刘旭,计算机工程与设计,2007.02

[3]基于随机数和Hash函数的认证方案,张利华,微电子学与计算机, 2007.06