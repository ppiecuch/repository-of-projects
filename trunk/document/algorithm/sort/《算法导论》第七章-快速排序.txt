quick_sort(the idea of the book of Introduction to Algorithms)


view plaincopy to clipboardprint?/*    Name: quciksort with recursive  
*     Author: coder  
*     Time: 2011-8-17           
*/  
  
/* ----- including files ----- */  
#include <stdio.h>   
  
/* -----  macro and ect ------ */  
#define MAX 256   
  
/* ------- declaration ------- */  
void quicksort();  
int partition();  
  
/* -------  functions -------- */  
// ---- function of main -----   
int main()  
{  
    int i;  
    int A[MAX] = {16,4,10,14,7,9,3,2,8,1};  
  
    quicksort(A,0,9);  //here the position is from 0 to 9   
      
    for(i = 0; i < 10; ++i)  
    {  
      printf("%4d",A[i]);  
    }  
    return 0;  
}  
// ---- function of quicksort ----   
void quicksort(int A[],int left,int right)  
{  
     int q;    //init the position of return   
       
     if(left < right)  
     {  
       /* Firt of all,partition all one time,here get the last position 
        * of A[right],then quicksort the front ones and the after ones. 
        */  
       q = partition(A,left,right);  
       quicksort(A,left,q-1);  
       quicksort(A,q+1,right);  
     }  
}  
// ---- function of partition ----   
int partition(int A[],int left,int right)  
{  
     int x;    //save the middle value   
     int i,j;    //mark   
     int temp;    //init middle save   
       
     j = left-1;  
     x = A[right];    //save the value of A[left]   
       
     /* Here,we have the idea that we dont't sort the last one,it just 
      * be used to compare with the front ones.Smaller exchange,or will not. 
      * We should always have the idea that the last one should be the biggest. 
      */  
     for(i = left; i < right; ++i)  //run left to right   
     {  
       if(A[i] <= x)  /* here,j is like a handler,remember the number of smallers. 
                       * If smaller,j++,then exchange the A[j] and A[i],here is just 
                       * to get the smaller to the left. 
                       */  
       {  
         ++j;  
         temp = A[j];  
         A[j] = A[i];  
         A[i] = temp;  
       }  
     }  
     /* At last,we must get the A[right] to the right position. 
      */  
     temp = A[right];     
     A[right] = A[j+1];  
     A[j+1] = temp;  
       
     return j+1;  
}  
/*    Name: quciksort with recursive 
*     Author: coder 
*     Time: 2011-8-17          
*/

/* ----- including files ----- */
#include <stdio.h>

/* -----  macro and ect ------ */
#define MAX 256

/* ------- declaration ------- */
void quicksort();
int partition();

/* -------  functions -------- */
// ---- function of main -----
int main()
{
    int i;
	int A[MAX] = {16,4,10,14,7,9,3,2,8,1};

    quicksort(A,0,9);  //here the position is from 0 to 9
    
    for(i = 0; i < 10; ++i)
    {
      printf("%4d",A[i]);
    }
    return 0;
}
// ---- function of quicksort ----
void quicksort(int A[],int left,int right)
{
     int q;    //init the position of return
     
     if(left < right)
     {
       /* Firt of all,partition all one time,here get the last position
        * of A[right],then quicksort the front ones and the after ones.
        */
       q = partition(A,left,right);
       quicksort(A,left,q-1);
       quicksort(A,q+1,right);
     }
}
// ---- function of partition ----
int partition(int A[],int left,int right)
{
     int x;    //save the middle value
     int i,j;    //mark
     int temp;    //init middle save
     
     j = left-1;
     x = A[right];    //save the value of A[left]
     
     /* Here,we have the idea that we dont't sort the last one,it just
      * be used to compare with the front ones.Smaller exchange,or will not.
      * We should always have the idea that the last one should be the biggest.
      */
     for(i = left; i < right; ++i)  //run left to right
     {
       if(A[i] <= x)  /* here,j is like a handler,remember the number of smallers.
                       * If smaller,j++,then exchange the A[j] and A[i],here is just
                       * to get the smaller to the left.
                       */
       {
         ++j;
         temp = A[j];
         A[j] = A[i];
         A[i] = temp;
       }
     }
     /* At last,we must get the A[right] to the right position.
      */
     temp = A[right];   
     A[right] = A[j+1];
     A[j+1] = temp;
     
     return j+1;
}
 


Here,we set the last one as handler.
http://blog.csdn.net/coder_song/article/details/6694825