合并深度：
一、工作副本：即你当前的工作目录，一般默认为这个选项；
二、全递归：即你选择的目录的版本库，包括了其下面的子文件，子文件夹，包括子文件夹里面的内容；
三、直接子节点，包括文件夹：即你选择的目录下面的文件，文件夹，但是不包括文件夹里面的子文件，子文件夹。
四、仅文件子节点：即你选择的目录下面的文件，但不包括文件夹，当然不包括的文件夹下面的所有内容也都不纳入合并范围。
五、仅此项：没有任何合并内容。
实例：
1、主干test文件夹下面有text.txt文件,把test文件夹创建分支test2
2、在test2文件夹下面增加test21文件夹，在test21文件夹下面增加文件夹test211，在test211文件夹下面增加文件test211.txt；修改test2文件夹下面的文件test.txt，增加文件test2.txt。提交
3、右键test文件夹合并test2文件夹，选择工作副本。则test文件夹中原先的test.txt文件则显示修改状态，test2.txt文件显示新增状态，文件夹test21和test211以及里面的test211.txt文件都显示为新增状态。选择将test文件夹svn还原，则新增状态下的文件夹或者文件显示为无版本控制状态，原先的test.txt还原为常规常态。
4、右键test文件夹合并test2文件夹，选择全递归，结果和3一样。但是我们之前的test文件夹和仓库上的test的内容是一致的，如果不一致，那么选全递归，是已仓库版本为标准。选工作副本，顾名思义，则以你本地的工作副本文件为主，分支上有而工作副本中没有的文件夹或文件则不进行比较合并。
5、右键test文件夹合并test2文件夹，选择直接子节点，包含文件夹。则test文件夹中原先的test.txt文件显示为修改状态，test2.txt文件显示为新增状态，test21文件夹显示为新增状态，但是其里面内容则为空，那么就证明了分支中test21文件夹以下的内容并没有合并到主干test中来，合并行为只是选取了当前目录。选择将test文件夹svn还原，则新增状态下的文件夹或者文件显示为无版本控制状态，原先的test.txt还原为常规状态。
6、右键test文件夹合并test2文件夹，选择仅文件子节点。则test文件夹中原先的test.txt文件显示为修改状态，test2.txt文件显示为新增状态，分支test2中的test21文件夹没有合并到test中来。选择将test文件夹svn还原，则新增状态下的文件显示为无版本控制状态，原先的test.txt还原为常规状态。
7、右键test文件夹合并test2文件夹，选择仅此项。则test文件夹显示为修改状态，但是内容没有任何改动。将test文件夹svn还原，则该文件夹显示为常规状态。
只记录合并（阻止这些版本将来被合并）
选择此项意味着并没有实际的合并动作，只是在将来的合并过程中，svn将过滤掉此版本的修改动作。例如，我在合并的过程中，选择对分支的23版本只记录合并（阻止这个版本将来被合并），那么23版本并不会合并到主干中。在以后的合并中，如果选择合并分支的22到24版本，那么23版本将被忽略，我们也可以看到，在选择版本的对话框上，23版本的字体是灰色的。所以要慎重使用这个选项，一旦使用了，那么表示这个版本在以后的合并中就不能再使用了。
忽略祖先：如果在分支上有一个文件曾经被删除过，后来又加了一个同文件名的文件，那么在merge的时候svn会识别到这两个文件不是同一个祖先而直接覆盖旧文件增加新文件。而实际上我是要对这两个不同祖先的文件进行合并的，这个时候就需要使用svn merge --ignore-ancestry 忽略祖先来进行合并才能保证正确。
实例：
1、 将主干test创建分支test1；
2、 将test1文件夹下的test.txt文件删除，提交；
3、 在test1下创建文件test.txt，提交；
4、 将test1合并到主干test，如果默认选择，则提示将test1中的test.txt文件替换test文件夹中的test.txt文件；如果选择了忽略祖先，那么系统将把两个test.txt作比较，必要时提示冲突。
carriage return是一个符号（指回车符号CR），而一般在代码文件或文体文件里（WINDOWS下）里换行是CR和LF（即\r\n或十六进制码0D 0A)，而你行中只有CR，所以将要加一个LF（即OA）。说得很明确了，其实LF就是line feed的简写。whitespace包括line feeds, tabs, spaces, and carriage returns。

http://hi.baidu.com/200770842223/item/ddd556578360e59008be17ee