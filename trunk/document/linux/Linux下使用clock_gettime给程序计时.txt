哦，clock_gettime( ) 提供了纳秒的精确度，给程序计时可是不错哦；

 

函数的原型如下：

int clock_gettime(clockid_t clk_id, struct timespect *tp);
clockid_t clk_id用于指定计时时钟的类型，对于我们Programmr以下三种比较常用：

CLOCK_REALTIME, a system-wide realtime clock.CLOCK_PROCESS_CPUTIME_ID, high-resolution timer provided by the CPU for each process.CLOCK_THREAD_CPUTIME_ID, high-resolution timer provided by the CPU for each of the threads. CLOCK_REALTIME, a system-wide realtime clock.
CLOCK_PROCESS_CPUTIME_ID, high-resolution timer provided by the CPU for each process.
CLOCK_THREAD_CPUTIME_ID, high-resolution timer provided by the CPU for each of the threads.
struct timespect *tp用来存储当前的时间，其结构如下：



1 struct timespec {
2     time_t tv_sec; /* seconds */
3     long tv_nsec; /* nanoseconds */
4 };



呵呵，好啦！该讲的都刚清楚了，下面我们就上代码把；




代码

 1 #include <iostream>
 2 #include <time.h>
 3  using namespace std;
 4  
 5 timespec diff(timespec start, timespec end);
 6  
 7  int main()
 8 {
 9     timespec time1, time2;
10     int temp;
11     clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &time1);
12     for (int i = 0; i< 242000000; i++)
13         temp+=temp;
14     clock_gettime(CLOCK_PROCESS_CPUTIME_ID, &time2);
15     cout<<diff(time1,time2).tv_sec<<":"<<diff(time1,time2).tv_nsec<<endl;
16     return 0;
17 }
18  
19 timespec diff(timespec start, timespec end)
20 {
21     timespec temp;
22     if ((end.tv_nsec-start.tv_nsec)<0) {
23         temp.tv_sec = end.tv_sec-start.tv_sec-1;
24         temp.tv_nsec = 1000000000+end.tv_nsec-start.tv_nsec;
25     } else {
26         temp.tv_sec = end.tv_sec-start.tv_sec;
27         temp.tv_nsec = end.tv_nsec-start.tv_nsec;
28     }
29     return temp;
30 }