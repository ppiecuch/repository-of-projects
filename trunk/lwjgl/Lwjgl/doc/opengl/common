在OpenGL对窗口渲染之前，必须根据渲染需要对窗口进行配置。
需要硬件渲染还是软件渲染？
渲染使用单缓冲还是双缓冲？
是否需要深度缓冲区？
是否需要模板、目标Alpha或积累缓冲区？
当为窗口设置这些参数之后，就无法对它们进行修改。
为了从一个只有深度缓冲和颜色缓冲区的窗口切换到一个带有模板缓冲区的窗口，必须首先销毁第一个窗口，然后根据需要重新创建一个窗口。 


void glMatrixMode(GLenum mode) 
指定哪一个矩阵是当前矩阵 
参数 
mode指定哪一个矩阵堆栈是下一个矩阵操作的目标，可选值:GL_MODELVIEW、GL_PROJECTION、GL_TEXTURE. 
说明 
glMatrixMode设置当前矩阵模式： 
GL_MODEVIEW，对模型视景矩阵堆栈应用随后的矩阵操作。 
GL_PROJECTION，对投影矩阵应用随后的矩阵操作。 
GLTEXTURE，对纹理矩阵堆栈应用随后的矩阵操作。 


void glShadeModel ( GLenum mode)
设置着色模式。
参数
mode可以是GL_SMOOTH（默认值）或GL_FLAT。采用恒定着色时（即GL_FLAT），使用图元中某个顶点的颜色来渲染整个图元。
在使用光滑着色时（即GL_SMOOTH），独立的处理图元中各个顶点的颜色。对于线段图元，线段上各点的颜色将根据两个顶点的颜色通过插值得到。
对于多边形图元，多边形内部区域的颜色将根据所有顶点的颜色插值得到。


gl.glEnable(GL10.GL_DEPTH_TEST)
告诉opengl要检查depth，为什么哪。
在三维空间里一个物体A在另一个物体B后面，那么这个A被B挡住里，所以你是看不见的。
我们要告诉opengl，我们不想看见被挡住的东西。这个GL_DEPTH_TEST 就是这个功能。

glDepthFunc(GL_LEQUAL) 最准确的解释是什么？
答案：深度小或相等的时候也渲染。

glDepthFunc(GL_LESS)？
答案：深度小的时候才渲染。




glLoadIdentity()
该函数的功能是重置当前指定的矩阵为单位矩阵。 
注意，使用glLoadIdentity()函数的目的是隔离各个模型变换的效果。对矩阵值进行初始化能够防
止连续变换产生的累积效果。尽管反复使用glLoadIdentity()能够实现预想的效果，但是它的效率可能
较低，因为可能必须重新指定视图或模型变换（关于隔离各个变换操作的更好方法，参见第3.6节）。
注意：有时候，为了实现连续的旋转，我们可能会想到重复应用一个值很小的旋转矩阵。
这个技巧存在的问题是：由于四舍五入的误差，经过数千次微小的旋转之后，物体的最终位置
可能和预想的不一样。因此，应该摒弃这种做法，而是在每次更新时发布一条新的命令，并使
用一个新的角度作为参数。



变换顺序
现在我们讨论这些变换的发生顺序。所有的视图和模型变换都是用一个4×4的矩阵表示的。每个后
续的glMultMatrix*()函数或变换函数把一个新的4×4矩阵M与当前的模型视图矩阵C相乘，产生结果矩
阵CM。最后，每个顶点v与当前的模型视图矩阵相乘。这个过程意味着程序所调用的最后一个变换函数
实际上是首先应用于顶点的：CMv。因此，另一种说法就是我们以相反的顺序指定了这些矩阵。但是，
和许多其他事情一样，一旦我们已经习以为常（并认为它是正确的），后退和前进其实是一样的。
考虑下面的代码序列，它使用3个变换绘制了1个点：
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
glMultMatrixf(N); /* apply transformation N */
glMultMatrixf(M); /* apply transformation M */
glMultMatrixf(L); /* apply transformation L */
glBegin(GL_POINTS);
glVertex3f(v); /* draw transformed vertex v */
glEnd();
在这段代码中，模型视图矩阵按顺序分别包含了I、N、NM，最后是NML，其中I表示单位矩阵。
经过变换的顶点是NMLv。因此，顶点变换就是N(M(Lv))，也就是说，v首先与L相乘，Lv再与M相乘，
MLv再与N相乘。注意，顶点v的变换是按照相反的顺序发生，而不是按照它们的指定顺序出现的
（实际上，一个顶点与模型视图矩阵的乘法只出现一次。在这个例子中，N、M和L在应用于v之前已
经与一个矩阵相乘）。

全局固定坐标系统
因此，如果想根据一个全局固定的坐标系统来考虑问题（在这种坐标系统中，矩阵乘法将影响模
型的位置、方向和缩放），就必须注意乘法的出现顺序与它们在代码中出现的顺序相反。我们简单地
以图3-4左侧的那个变换（沿原点旋转，然后再沿x轴下移）为例，如果想让物体在经过变换之后出现
在轴上，必须首先进行旋转，然后再进行移动。为此，需要反转操作的顺序，因此它的代码大概像下
面这样（其中R是旋转矩阵，T是移动矩阵）：
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();
glMultMatrixf(T); /* translation */
glMultMatrixf(R); /* rotation */
draw_the_object();


局部移动坐标系统
考虑矩阵乘法的另一种思路是抛弃在变换模型时所使用的全局固定坐标系统，而是想象一个固定
到所绘制物体的局部坐标系统。所有的操作都相对于这个不断发生变化的坐标系统进行。按照这种方
法，矩阵乘法很自然地按照它们在代码中出现的顺序进行。（这和我们所使用的比喻无关，代码是一
样的，但思考它的方式可以不同。）现在，让我们在这个移动-旋转例子中使用这种局部坐标系统。
首先，想象这个物体具有一个固定的坐标系统。移动操作使这个物体沿x轴下移，因此这个局部坐标
系统也随之沿x轴下移。然后，这个物体沿原点（经过移动之后的原点）进行旋转，因此这个物体是
在轴上的位置进行旋转的。
在诸如带关节的机器人手臂（肩、肘、腕以及手指等部位均存在关节）这样的应用程序中，应该
使用这种方法。为了判断指尖相对于身体的位置，首先要从肩开始，然后是肘、腕，接着才是手指，
在每个关节应用适当的旋转和移动。如果以相反的顺序考虑这些变换，显然会复杂无比。
但是，如果变换包含了缩放，尤其是当缩放为非规则缩放的时候（在不同的轴上以不同的数量进
行缩放），第二种方法就会出现问题。在规则缩放之后，如果再对一个顶点进行移动，它的实际移动
量就是原先移动量乘以缩放倍数，因为坐标系统也随之进行了缩放。如果混合了非规则缩放和旋转，
在变换之后，这个局部坐标系统的各个轴可能不再互相垂直。
如前所述，我们一般是在进行任何模型变换之前调用视图变换命令。这样，模型中的顶点首先变
换到所需要的方向，然后根据视图操作进行变换。由于矩阵乘法必须以相反的顺序出现，因此视图命
令需要首先出现。但是，如果满足于默认的条件，就不需要指定视图或模型变换。如果不进行视图变
换，照相机就位于默认的原点位置，指向z轴的负方向。如果不进行模型变换，模型就不会移动，它
仍然保持原先指定的位置、方向和大小。
由于执行模型变换的函数也可以用于执行视图变换，所以我们首先讨论模型变换，尽管实际上首
先进行的是视图变换。这种讨论顺序和许多程序员在设计代码时所考虑的方式相同。他们常常编写所
有必要的代码来组成场景，这就涉及对物体的位置和方向进行正确的变换。接着，决定在什么地方设
置观察点（相对于这些物体所构成的场景），然后编写相应的视图变换代码。
3.2.2 模型变换
在OpenGL中，有3个函数用于执行模型变换，它们是glTranslate*()、glRotate*()和glScale*()。正
如我们预想的那样，这些函数通过移动、旋转、拉伸、收缩或反射，对物体（或坐标系统，取决于思考方式）进行变换。
这3个函数都相当于产生一个适当的移动、旋转或缩放矩阵，然后以这个矩阵作
为参数调用glMultMatrix*()。但是，使用这3个函数可能比使用glMultMatrix*()速度更快。OpenGL会
自动计算矩阵（关于这方面的细节，请参阅附录F）。



