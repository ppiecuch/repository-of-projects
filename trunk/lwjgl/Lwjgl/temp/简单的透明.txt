NeHe的opengl教程delphi版(8)----简单的透明[5]


呵呵，这两课早就翻译好了，一直没贴，大家久等了（有人再等吗？）

简单的透明
opengl中的绝大多数特效都与某些类型的(色彩)混合有关。
混色的定义为，将某个象素的颜色和已绘制在屏幕上与其对应的象素颜色相互结合。
至于如何结合这两个颜色则依赖于颜色的alpha通道的分量值，以及/或者所使用的混色函数。
alpha通常是位于颜色值末尾的第4个颜色组成分量。
前面这些课我们都是用gl_rgb来指定颜色的三个分量。
相应的gl_rgba可以指定alpha分量的值。
更进一步，我们可以使用glcolor4f()来代替glcolor3f()。

绝大多数人都认为alpha分量代表材料的透明度。
这就是说，alpha值为0.0时所代表的材料是完全透明的。
alpha值为1.0时所代表的材料则是完全不透明的。

混色的公式
若您对数学不感冒，而只想看看如何实现透明，请跳过这一节。
若您想深入理解(色彩)混合的工作原理，这一节应该适合您吧。
『cker的补充:其实并不难^-^。原文中的公式如下，cker再唠叨一下吧。
其实混合的基本原理是就将要分色的图像各象素的颜色以及背景颜色均按照rgb规则各自分离之后，
根据－图像的rgb颜色分量*alpha值+背景的rgb颜色分量*(1-alpha值)
－这样一个简单公式来混合之后，最后将混合得到的rgb分量重新合并。』

公式如下：
(rs sr + rd dr, gs sg + gd dg, bs sb + bd db, as sa + ad da)
opengl按照上面的公式计算这两个象素的混色结果。
小写的s和r分别代表源象素和目标象素。大写的s和d则是相应的混色因子。
这些决定了您如何对这些象素混色。
绝大多数情况下，各颜色通道的alpha混色值大小相同，
这样对源象素就有 (as, as, as, as)，
目标象素则有1, 1, 1, 1) - (as, as, as, as)。
上面的公式就成了下面的模样:
(rs as + rd (1 - as), gs as + gd (1 - as), bs as + bs (1 - as), as as + ad (1 - as))
这个公式会生成透明/半透明的效果。

opengl中的混色
在opengl中实现混色的步骤类似于我们以前提到的opengl过程。
接着设置公式，并在绘制透明对象时关闭写深度缓存。
因为我们想在半透明的图形背后绘制 对象。
这不是正确的混色方法，但绝大多数时候这种做法在简单的项目中都工作的很好。

rui martins 的补充： 正确的混色过程应该是先绘制全部的场景之后再绘制透明的图形。
并且要按照与深度缓存相反的次序来绘制(先画最远的物体)。
考虑对两个多边形(1和2)进行alpha混合，不同的绘制次序会得到不同的结果。
(这里假定多边形1离观察者最近，那么正确的过程应该先画多边形2，再画多边形1。
正如您再现实中所见到的那样，
从这两个<透明的>多边形背后照射来的光线总是先穿过多边形2，
再穿过多边形1，最后才到达观察者的眼睛。)
在深度缓存启用时，您应该将透明图形按照深度进行排序，
并在全部场景绘制完毕之后再绘制这些透明物体。否则您将得到不正确的结果。
我知道某些时候这样做是很令人痛苦的，但这是正确的方法。

我们将使用第七课的代码。
一开始先在代码开始处增加两个新的变量。出于清晰起见，我重写了整段代码。

}
var
   h_rc             : hglrc;            // rendering context(着色描述表)。
   h_dc             : hdc;              // device context(设备描述表)
   h_wnd            : hwnd;             // 窗口句柄
   h_instance       : hinst;            // 程序instance(实例)。
   keys             : array[0..255] of boolean; // 用于键盘例程的数组

   light            : boolean;          // 光源的开/关

   blend            : boolean;          // blending off/on? ( 新增 )

   lp               : boolean;          // l键按下了么?
   fp               : boolean;          // f键按下了么?

   bp               : boolean;          // b 键按下了么? ( 新增 )

   xrot             : glfloat;          // x 旋转
   yrot             : glfloat;          // y 旋转
   xspeed           : glfloat;          // x 旋转速度
   yspeed           : glfloat;          // y 旋转速度

   z                : glfloat = -5.0 f; // 深入屏幕的距离
   lightambient     : array[0..3] of glfloat = (0.5, 0.5, 0.5, 1.0);  //环境光参数 ( 新增 )
   lightdiffuse     : array[0..3] of glfloat = (1.0, 1.0, 1.0, 1.0);  // 漫射光参数 ( 新增 )
   lightposition    : array[0..3] of glfloat = (0.0, 0.0, 2.0, 1.0);  // 光源位置 ( 新增 )
   filter           : gluint;           // 滤波类型
   texture          : array[0..2] of gluint; // 3种纹理的储存空间

procedure glgentextures(n: glsizei; var textures: gluint); stdcall; external



   opengl32;

procedure glbindtexture(target: glenum; texture: gluint); stdcall; external
   opengl32;

function glubuild2dmipmaps(target: glenum; components, width, height: glint;
   format, atype: glenum; data: pointer): integer; stdcall; external glu32 name
   'glubuild2dmipmaps';

{
然后往下移动到 loadgltextures() 这里。
找到 if (textureimage[0]=loadbmp('data/crate.bmp'))
这一行。我们现在使用有色玻璃纹理来代替上一课中的木箱纹理。
if (textureimage[0]=loadbmp("data/glass.bmp")); // 载入玻璃位图 ( 已修改 )
}

function loadtexture: boolean;          // 载入位图并转换成纹理
var
   status           : boolean;          // status 指示器
   textureimage     : array[0..1] of ptaux_rgbimagerec; // 创建纹理的存储空间
begin
   status := false;
   zeromemory(@textureimage, sizeof(textureimage)); // 将指针设为 null
   textureimage[0] := loadbmp('walls.bmp');
   if textureimage[0] <> nil then
      begin
         status := true;                // 将 status 设为 true
         glgentextures(1, texture[0]);  // 创建纹理
         // 创建 nearest 滤波贴图
         glbindtexture(gl_texture_2d, texture[0]);
         // 生成纹理
         gltexparameteri(gl_texture_2d, gl_texture_mag_filter, gl_nearest);  // ( 新增 )
         gltexparameteri(gl_texture_2d, gl_texture_min_filter, gl_nearest);  // ( 新增 )

         glteximage2d(gl_texture_2d, 0, 3, textureimage[0].sizex,
            textureimage[0].sizey, 0, gl_rgb, gl_unsigned_byte,
            textureimage[0].data);
         glbindtexture(gl_texture_2d, texture[1]);  // 使用来自位图数据生成 的典型纹理
         // 生成纹理
         glteximage2d(gl_texture_2d, 0, 3, textureimage[0].sizex,
            textureimage[0].sizey, 0, gl_rgb, gl_unsigned_byte,
            textureimage[0].data);
         gltexparameteri(gl_texture_2d, gl_texture_min_filter, gl_linear);  // 线形滤波
         gltexparameteri(gl_texture_2d, gl_texture_mag_filter, gl_linear);  // 线形滤波
         // 创建 mipmapped 纹理
         glbindtexture(gl_texture_2d, texture[2]);
         gltexparameteri(gl_texture_2d, gl_texture_mag_filter, gl_linear);
         gltexparameteri(gl_texture_2d, gl_texture_min_filter,
            gl_linear_mipmap_nearest);  // ( 新增 )
         glubuild2dmipmaps(gl_texture_2d, 3, textureimage[0].sizex,
            textureimage[0].sizey, gl_rgb, gl_unsigned_byte,
            textureimage[0].data);      //(新增)  }
      end;
   if assigned(textureimage[0]) then    // 纹理是否存在
      if assigned(textureimage[0].data) then // 纹理图像是否存在
         textureimage[0].data := nil;   // 释放纹理图像占用的内存
   textureimage[0] := nil;              // 释放图像结构
   result := status;                    // 返回 status
end;

{
在glinit()代码段加入以下两行。
第一行以全亮度绘制此物体，并对其进行50%的alpha混合(半透明)。
当混合选项打开时，此物体将会产生50%的透明效果。
第二行设置所采用的混合类型。

rui martins 的补充:
alpha通道的值为 0.0意味着物体材质是完全透明的。
1.0 则意味着完全不透明。
}

procedure glinit();                     // 此处开始对opengl进行所有设置
begin


if (not loadtexture) then            // 调用纹理载入子例程
      exit;                             // 如果未能载入，退出

   glenable(gl_texture_2d);             // 启用纹理映射
   glshademodel(gl_smooth);             // 启用阴影平滑
   glclearcolor(0.0, 0.0, 0.0, 0.0);    // 黑色背景
   glcleardepth(1.0);                   // 设置深度缓存
   glenable(gl_depth_test);             // 启用深度测试
   gldepthfunc(gl_less);                // 所作深度测试的类型
   glhint(gl_perspective_correction_hint, gl_nicest); //高度优化的透视投影计算
   gllightfv(gl_light1, gl_ambient, @lightambient[0]); // 设置环境光
   gllightfv(gl_light1, gl_diffuse, @lightdiffuse[0]); // 设置漫射光
   gllightfv(gl_light1, gl_position, @lightposition); // 光源位置
   glenable(gl_light1);                 // 启用一号光源

   glcolor4f(1.0, 1.0, 1.0, 0.5);       // 全亮度， 50% alpha 混合( 新增 )
   glblendfunc(gl_src_alpha, gl_one); // 基于源象素alpha通道值的半透明混合函数 ( 新增 )

end;

 {在接近第七课结尾处的地方找到下面的代码段。
                  if keys[vk_left] then    //left方向键按下了么?
                  yspeed := yspeed - 0.01; //若是, 减少yspeed
                接着上面的代码，我们增加如下的代码。
                这几行监视b键是否按下。
                如果是的话，计算机检查混合选项是否已经打开。
                然后将其置为相反的状态。
                }
               if (keys[ord('b')] and not bp) then //b 健按下且bp为 false么?
                  begin
                     bp := true;        // 若是， bp 设为 true
                     blend := not blend; // 切换混合选项的 true / false
                     if (blend) then    // 混合打开了么?
                        begin
                           glenable(gl_blend); // 打开混合
                           gldisable(gl_depth_test); // 关闭深度测试
                        end
                     else               // 否则
                        begin
                           gldisable(gl_blend); // 关闭混合
                           glenable(gl_depth_test); // 打开深度测试
                        end;


end;
               if (not keys[ord('b')]) then //  b 键松开了么?
                  begin
                     bp := false;       // 若是， bp设为 false
                  end;
               {
               但是怎样才能在使用纹理贴图的时候指定混合时的颜色呢?很简单，
               在调整贴图模式时，文理贴图的每个象素点的颜色都是由alpha通道参数
               与当前地象素颜色相乘所得到的。
               比如，绘制的颜色是 (0.5, 0.6, 0.4),
               我们会把颜色相乘得到(0.5, 0.6, 0.4, 0.2)
                (alpha参数在没有指定时，缺省为零)。
               就是如此！opengl实现alpha混合的确很简单！
               }
               {
                原文注 (11/13/99)
                我(nehe)混色代码进行了修改，以使显示的物体看起来更逼真。
                同时对源象素和目的象素使用alpha参数来混合，会导致物体的人造痕迹看起来很明显。
                会使得物体的背面沿着侧面的地方显得更暗。
                基本上物体会看起来很怪异。
                我所用的混色方法也许不是最好的，但的确能够工作。
                启用光源之后，物体看起来很逼真。
                感谢tom提供的原始代码，他采用的混色方法是正确的，
                但物体看起来并不象所期望的那样吸引人:)
                代码所作的再次修改是因为在某些显卡上gldepthmask()函数存在寻址问题。
                这条命令在某些卡上启用或关闭深度缓冲测试时似乎不是很有效，
                所以我已经将启用或关闭深度缓冲测试的代码转成老式的glenable和gldisable。

                纹理贴图的alpha混合
                用于纹理贴图的alpha参数可以象颜色一样从问题贴图中读取。
                方法如下，您需要在载入所需的材质同时取得其的alpha参数。
                然后在调用glteximage2d()时使用gl_rgba的颜色格式。


